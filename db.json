{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/guestbook/index.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639319394649},{"_id":"source/GithubPages/index.md","hash":"7ac012dac84e158f62b0a1b9c7ec25155d845748","modified":1635181808306},{"_id":"source/_posts/Software&Tool.md","hash":"ccaff31fc4720b0485670ec3f459c863a28bc459","modified":1638892497831},{"_id":"source/_posts/WSL.md","hash":"ce222c470679d2f6a1f7b05f02ab391b1857fe8e","modified":1639406264297},{"_id":"source/_posts/hello-world.md","hash":"2557e0b9ce1179b4e2a7e7c0c5d44099069b9aee","modified":1635258853311},{"_id":"source/_posts/书单.md","hash":"07ca751a61b6e51962d88cbf2c67cd1cd4688faf","modified":1646841233826},{"_id":"source/tags/index.md","hash":"05263d4b30ffeffa6ab06a99679b3ca160cca2c0","modified":1635262584034},{"_id":"source/about/index.md","hash":"3f945fcdbdee9baedf2f5b87601553f6efdc8505","modified":1635260167912},{"_id":"source/categories/index.md","hash":"3e84de4d4d88b363553433992dc8be79d1ca52e7","modified":1635262679021},{"_id":"source/_posts/2022/c语言.md","hash":"a7aa4e720dd90dad5deda9418a6ceef501f5323c","modified":1643728399234},{"_id":"source/_posts/2022/读书随记.md","hash":"bf89f0bf61a1880921d15e861d77be86571477d9","modified":1647158885453},{"_id":"source/_posts/2022/leetcode刷题笔记.md","hash":"7cfe81d6d0f526a10f7784cda87916e3078a832e","modified":1646841315508},{"_id":"source/_posts/2022/leetcode未分类题目.md","hash":"2fdd655bf4a62140d82b4af0202918bdac70e2cd","modified":1647876112945},{"_id":"source/_posts/2022/剑指offer.md","hash":"7e1fdcc4214b449b3335db330b348d5782682deb","modified":1642518313248},{"_id":"source/_posts/2021/11/leetcode题解算法.md","hash":"3e31523d0cc3d61379e9aa9127775bd22b26bc66","modified":1645951251134},{"_id":"source/_posts/2021/12/C++.md","hash":"98c8b3284187958b15d3c5c1995ca3e42fd6a9c0","modified":1639321722046},{"_id":"source/_posts/2021/11/内存.md","hash":"cce95fbec070b0552812be3ea9c281e94529df5a","modified":1638460083166},{"_id":"source/_posts/2021/12/cmake.md","hash":"dca4c812e06a1b046e8e210e157dd9a9b16dbc68","modified":1639235753086},{"_id":"source/_posts/2021/12/英语语法一.md","hash":"a2799e3d67c6eb68fd0ffde7be9902f050ede515","modified":1638811611134},{"_id":"source/_posts/数据结构与算法基础.md","hash":"eb1132019de61d5257ea0e537108559f823ed6be","modified":1645946139530},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1635177260128},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1635177260129},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1635177260133},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1635177260133},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1635177260128},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1635177260132},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1635177260133},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1635177260134},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1635177260134},{"_id":"themes/next/_config.yml","hash":"0b65a8423d8f991eab2e01cb475a7812b52e24b6","modified":1639319436915},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1635177260141},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1635177260164},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1635177260129},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1635177260129},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1635177260130},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1635177260131},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1635177260131},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1635177260131},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1635177260132},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1635177260131},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1635177260132},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1635177260135},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1635177260135},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1635177260132},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1635177260132},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1635177260135},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1635177260136},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1635177260136},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1635177260136},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1635177260137},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1635177260136},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1635177260137},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1635177260141},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1635177260141},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1635177260141},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1635177260142},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1635177260142},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1635177260142},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1635177260142},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1635177260143},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1635177260143},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1635177260143},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1635177260143},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1635177260143},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1635177260144},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1635177260144},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1635177260144},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1635177260144},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1635177260145},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1635177260145},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1635177260145},{"_id":"themes/next/languages/zh-CN.yml","hash":"0d6c0380e255ba29c16d8027805821653fe68bd8","modified":1638082642941},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1635177260145},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1635177260146},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1635177260146},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1635177260163},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1635177260163},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1635262331795},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1635177260163},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1635177260164},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1635177260164},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1635177260170},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1635177260130},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1635177260130},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1635177260130},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1635177260138},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1635177260130},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1635177260139},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1635177260139},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1635177260139},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1635177260139},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1635177260140},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1635177260140},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1635177260137},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1635177260140},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1635177260140},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1635177260137},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1635177260138},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1635177260138},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1635177260146},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1635177260147},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1635262330087},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1635177260147},{"_id":"themes/next/layout/_partials/footer.swig","hash":"5669a475fa232f5d08c14261fe1c2614cd9b998e","modified":1638377330495},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1635177260150},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1635177260150},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1635177260153},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1635177260153},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1635177260153},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1635177260154},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1635177260155},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1635177260155},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1635177260157},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1635177260159},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1635177260160},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1635177260160},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1635177260164},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1635177260168},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1635177260168},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1635177260168},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1635177260168},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1635177260169},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1635177260168},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1635177260169},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1635177260169},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1635177260169},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1635177260189},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1635177260172},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1635177260195},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1635177260170},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1635177260170},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1635177260170},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1635177260170},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1635177260171},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1635177260171},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1635177260171},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1635177260172},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1635177260171},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1635177260172},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1635177260195},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1635177260196},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1635177260196},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1635177260196},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1635177260196},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1635177260197},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1635177260197},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1635177260198},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1635177260197},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1635177260198},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1635177260198},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1635177260201},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1635177260198},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1635177260198},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1635177260199},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1635177260199},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1635177260199},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1635177260200},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1635177260200},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1635177260201},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1635177260148},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1635177260148},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1635177260149},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1635177260149},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1635177260149},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1635177260149},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1635177260149},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1635177260150},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1635177260150},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1635177260151},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1635177260151},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1635177260151},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1635177260152},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1635177260152},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1635177260151},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1635177260152},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1635177260152},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1635177260153},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1635177260154},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1635177260154},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1635177260155},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1635177260155},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1635177260156},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1635177260155},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1635177260156},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1635177260156},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1635177260156},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1635177260157},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1635177260157},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1635177260157},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1635177260158},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1635177260158},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1635177260158},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1635177260158},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1635177260158},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1635177260159},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1635177260159},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1635177260160},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1635177260159},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1635177260161},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1635177260160},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1635177260161},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1635177260161},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"09571d4d61ba3bc570ef49834c2f7b223edbd5b8","modified":1638295777923},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1635177260162},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1635177260162},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1635177260162},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1635177260162},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1635177260165},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1635177260165},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1635177260165},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1635177260166},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1635177260166},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1635177260166},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1635177260166},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1635177260167},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1635177260166},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1635177260167},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1635177260167},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1635177260193},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1635177260194},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1635177260194},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1635177260194},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1635177260194},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1635177260204},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1635177260204},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1635177260200},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1635177260200},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1635177260181},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1635177260181},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1635177260173},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1635177260173},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1635177260173},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1635177260177},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1635177260184},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1635177260184},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1635177260185},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1635177260186},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1635177260186},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1635177260187},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1635177260187},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1635177260189},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1635177260189},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1635177260192},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1635177260192},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1635177260192},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1635177260193},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1635177260193},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1635177260193},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1635177260191},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1635177260191},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1635177260191},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1635177260191},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1635177260192},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1635177260192},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1635177260190},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1635177260190},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1635177260190},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1635177260190},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1635177260190},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1635177260202},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1635177260203},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1635177260179},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1635177260179},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1635177260179},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1635177260180},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1635177260180},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1635177260182},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1635177260181},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1635177260181},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1635177260181},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1635177260182},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1635177260182},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1635177260182},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1635177260183},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1635177260183},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1635177260183},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1635177260175},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1635177260183},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1635177260184},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1635177260184},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1635177260175},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1635177260175},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1635177260176},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1635177260175},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1635177260175},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1635177260176},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1635177260176},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1635177260176},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1635177260176},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1635177260177},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1635177260177},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcb25180e69715f17cbf4cdc8e971a0212287623","modified":1635261704773},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1635177260174},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1635177260173},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1635177260174},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1635177260174},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1635177260174},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1635177260178},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1635177260178},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1635177260178},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1635177260178},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1635177260178},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1635177260185},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1635177260185},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1635177260185},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1635177260187},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1635177260186},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1635177260187},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1635177260187},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1635177260188},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1635177260188},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1635177260188},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1635177260188},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1635177260202},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1635177260203},{"_id":"public/baidusitemap.xml","hash":"4a8bac4a554a38eaa56be70171de651a5bad488e","modified":1647876117341},{"_id":"public/atom.xml","hash":"3fa74f5af3ae50f8ff077a94262c9d23e4197277","modified":1647876117341},{"_id":"public/search.xml","hash":"e7185048cb8114d0a1ae0197581e8cdc46e45f63","modified":1647876117341},{"_id":"public/sitemap.xml","hash":"e46fbe7efdbca743c542b01fd0ad2106b8456b64","modified":1647876117341},{"_id":"public/GithubPages/index.html","hash":"3c17bad19a9fcdebdd07aacc54f2d09febc7c75d","modified":1647876117341},{"_id":"public/tags/index.html","hash":"a7e017e503646113e38ded51a07b5dc1806882c7","modified":1647876117341},{"_id":"public/categories/index.html","hash":"7d91ffd1b190f071370b40248155cd1fd29b7c6d","modified":1647876117341},{"_id":"public/about/index.html","hash":"a089a1423307745c8f2fb5e1e8b8720b2632d65e","modified":1647876117341},{"_id":"public/guestbook/index.html","hash":"63c6ef21d9391b1c01636720e4a2eae98ca4ec6a","modified":1647876117341},{"_id":"public/archives/page/2/index.html","hash":"e8ac8c2408e07e89da63d1997b1f6ca4478a2866","modified":1647876117341},{"_id":"public/archives/2021/10/index.html","hash":"48a68a74a19d2e9aac37ad55c91f7f272f7eded7","modified":1647876117341},{"_id":"public/archives/2021/12/index.html","hash":"8a27c07152c84ba7b121f90c5b20d00140b6ab8a","modified":1647876117341},{"_id":"public/archives/2022/index.html","hash":"2bd58d366fdb660a0b07aad42f813a1570b2c0ac","modified":1647876117341},{"_id":"public/archives/2022/01/index.html","hash":"4f478a74330d403a560392fcb889dd79a20ec517","modified":1647876117341},{"_id":"public/archives/2022/02/index.html","hash":"2b219577016dc71ce54949af3e3e12da6f469833","modified":1647876117341},{"_id":"public/categories/tool/page/2/index.html","hash":"92f9b475fa9377960dc460271e436b856ffbd437","modified":1647876117341},{"_id":"public/categories/study/index.html","hash":"ac988994c092c9c899ea60358ae8ea29e9aa120c","modified":1647876117341},{"_id":"public/categories/tool/2022/index.html","hash":"136c8d533e18255e3dbc0da07d7de4c6ac4205dc","modified":1647876117341},{"_id":"public/categories/tool/2021/index.html","hash":"c1335b640e1769db7e2f523c129c3921d0f97110","modified":1647876117341},{"_id":"public/categories/study/2021/index.html","hash":"1f157d6f99fa4e378780aa7f9efe7b7fc572c7a0","modified":1647876117341},{"_id":"public/categories/tool/2021/12/index.html","hash":"96a1501427916e0d5f7293bbe5f6b4a074c05093","modified":1647876117341},{"_id":"public/categories/tool/2021/11/index.html","hash":"c170e1ccb3de47bd350d9ab9c9b981c319eb2718","modified":1647876117341},{"_id":"public/categories/study/2021/12/index.html","hash":"38eb92ec3cf54ac548203e0d1cc4c34c16fffc1a","modified":1647876117341},{"_id":"public/tags/Another-Tag/page/2/index.html","hash":"852f5c1cad4caf293ef8ea0948658d2a997354ff","modified":1647876117341},{"_id":"public/tags/Computer-Science/index.html","hash":"c2be0cbdb153e78b7e7eb9cdf60916f90b009e4a","modified":1647876117341},{"_id":"public/tags/c-c/index.html","hash":"ba427c2b06b17555cf6e054ecca014869195bd5c","modified":1647876117341},{"_id":"public/tags/cs/index.html","hash":"195a04f691c2aa8ee800a2ae3b2d94f4d5a1ece2","modified":1647876117341},{"_id":"public/tags/complier/index.html","hash":"5a7254a90d9f78c25b3b2b57b2d18f4253417d76","modified":1647876117341},{"_id":"public/tags/cmake/index.html","hash":"7f88650ad581be65af7e8ac4f55d61b2d4de4ea1","modified":1647876117341},{"_id":"public/tags/English/index.html","hash":"5c1598826ed91375bb8d861565ef0e8b206ba180","modified":1647876117341},{"_id":"public/2022/02/01/2022/leetcode刷题笔记/index.html","hash":"9b0abda913eddeecdcd7f47d24ba4e07343afd26","modified":1647876117341},{"_id":"public/2022/01/27/2022/读书随记/index.html","hash":"84e5bd74146aedcc5e1a5ebb40a50b9f6880387e","modified":1647876117341},{"_id":"public/2022/01/20/2022/c语言/index.html","hash":"a3d0560633df112ae57a90a57d16c784a573d57b","modified":1647876117341},{"_id":"public/2022/02/01/2022/leetcode未分类题目/index.html","hash":"21cc1c74de4e28c6d0483933ab0c824e46790b54","modified":1647876117341},{"_id":"public/2022/01/17/2022/剑指offer/index.html","hash":"379391c63805db89db09fe2c4c6a0e5cb9f07c44","modified":1647876117341},{"_id":"public/2021/12/07/2021/12/C++/index.html","hash":"cbf228c11fa22a673bcdb698cb0b3d4693b24afb","modified":1647876117341},{"_id":"public/2021/12/07/2021/12/cmake/index.html","hash":"7025eab9164344d1526fd259ba43b44eac48ff1d","modified":1647876117341},{"_id":"public/2021/12/02/2021/12/英语语法一/index.html","hash":"6a21711313d3c1f1e39f4e185a893c074bb5b189","modified":1647876117341},{"_id":"public/2021/10/27/WSL/index.html","hash":"05e1fa0720b4000711f292706dfb8a6f1a0bba78","modified":1647876117341},{"_id":"public/2021/10/27/书单/index.html","hash":"73f40fedeaa641b15bd7eb019189160a8b0eec25","modified":1647876117341},{"_id":"public/2021/10/27/数据结构与算法基础/index.html","hash":"1094f65c10899f02ebc15e65d618648ad686800b","modified":1647876117341},{"_id":"public/2021/10/27/2021/11/leetcode题解算法/index.html","hash":"a1fe0a2bac7c9b60d7b5553e595974832405fc50","modified":1647876117341},{"_id":"public/2021/10/26/Software&Tool/index.html","hash":"71c46264ee4fc5151d4e2028d08b90bed92c3013","modified":1647876117341},{"_id":"public/2021/10/25/hello-world/index.html","hash":"688afc012c9d1d991bd6b3aea821917447222bff","modified":1647876117341},{"_id":"public/2021/10/07/2021/11/内存/index.html","hash":"8a8bd83b728bbcda3490f1cde4ed134170836104","modified":1647876117341},{"_id":"public/archives/index.html","hash":"8386302c1e59628c36bc20a616c3d8b9f876b20b","modified":1647876117341},{"_id":"public/archives/2021/index.html","hash":"45bba5422fe1b538af11b8f63953a02d508a961c","modified":1647876117341},{"_id":"public/categories/tool/index.html","hash":"07a33caa71618b015a3937901e6eac010577e69f","modified":1647876117341},{"_id":"public/index.html","hash":"96099474615b99a839c5e53db7f0fc1e27046dcd","modified":1647876117341},{"_id":"public/page/2/index.html","hash":"fe2ca55604ca4a62163b9598b40b99c596d9878b","modified":1647876117341},{"_id":"public/tags/实用教程/index.html","hash":"f395a6a3f5b3077f6e285b23f37f6025d6d369d0","modified":1647876117341},{"_id":"public/tags/Another-Tag/index.html","hash":"b6e678e48585f3e02f7315a80c22adfe0370df6f","modified":1647876117341},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1647876117341},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1647876117341},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1647876117341},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1647876117341},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1647876117341},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1647876117341},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1647876117341},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1647876117341},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1647876117341},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1647876117341},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1647876117341},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1647876117341},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1647876117341},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1647876117341},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1647876117341},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1647876117341},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1647876117341},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1647876117341},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1647876117341},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1647876117341},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1647876117341},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1647876117341},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1647876117341},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1647876117341},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1647876117341},{"_id":"public/css/main.css","hash":"dade97180c1835e5d910aec75e0372ce5aedc54a","modified":1647876117341},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1647876117341},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1647876117341},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1647876117341},{"_id":"public/js/crypto-js.js","hash":"3dd73b6f13dc818a3a9c5c7424c1c4a9649b00a2","modified":1647876117341}],"Category":[{"name":"tool","_id":"cl10uw8uz00040guubnp0a87i"},{"name":"study","_id":"cl10uw8x400260guuamts1l2k"},{"name":"2022","parent":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw9ae002b0guu08c99vas"},{"name":"2021","parent":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw9gp002j0guuc7nlgz3a"},{"name":"2021","parent":"cl10uw8x400260guuamts1l2k","_id":"cl10uw9gr002p0guu2gb4hxnd"},{"name":"12","parent":"cl10uw9gp002j0guuc7nlgz3a","_id":"cl10uw9gs002q0guu0p3y6ltx"},{"name":"11","parent":"cl10uw9gp002j0guuc7nlgz3a","_id":"cl10uw9gs002r0guu0rqsd81n"},{"name":"12","parent":"cl10uw9gr002p0guu2gb4hxnd","_id":"cl10uw9gu002y0guubt2n2u4g"}],"Data":[],"Page":[{"title":"GithubPages","date":"2021-10-25T16:58:24.000Z","_content":"\n## TTT\n\nsadf\n\n\n### kk\n\n- dafd","source":"GithubPages/index.md","raw":"---\ntitle: GithubPages\ndate: 2021-10-26 00:58:24\n---\n\n## TTT\n\nsadf\n\n\n### kk\n\n- dafd","updated":"2021-10-25T17:10:08.306Z","path":"GithubPages/index.html","comments":1,"layout":"page","_id":"cl10uw8uk00000guuf7c82qel","content":"<h2 id=\"TTT\"><a href=\"#TTT\" class=\"headerlink\" title=\"TTT\"></a>TTT</h2><p>sadf</p>\n<h3 id=\"kk\"><a href=\"#kk\" class=\"headerlink\" title=\"kk\"></a>kk</h3><ul>\n<li>dafd</li>\n</ul>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"length":13,"excerpt":"","more":"<h2 id=\"TTT\"><a href=\"#TTT\" class=\"headerlink\" title=\"TTT\"></a>TTT</h2><p>sadf</p>\n<h3 id=\"kk\"><a href=\"#kk\" class=\"headerlink\" title=\"kk\"></a>kk</h3><ul>\n<li>dafd</li>\n</ul>\n"},{"title":"标签","date":"2021-10-25T17:30:18.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-10-26 01:30:18\ntype: \"tags\"\n---\n","updated":"2021-10-26T15:36:24.034Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl10uw8uv00020guuakx7e49b","content":"<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"分类","date":"2021-10-25T17:28:51.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-10-26 01:28:51\ntype: \"categories\"\n---\n","updated":"2021-10-26T15:37:59.021Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl10uw8v200060guu69rghc7u","content":"<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"关于","date":"2021-10-25T17:30:59.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2021-10-26 01:30:59\n---\n","updated":"2021-10-26T14:56:07.912Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl10uw8v400080guu8wevht1p","content":"<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"length":0,"excerpt":"","more":""},{"_content":"","source":"guestbook/index.md","raw":"","date":"2021-12-12T14:29:54.649Z","updated":"2021-12-12T14:29:54.649Z","path":"guestbook/index.html","title":"","comments":1,"layout":"page","_id":"cl10uw8v7000a0guu985dc6bs","content":"<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"WSL","date":"2021-10-26T16:47:53.000Z","updated":"2021-10-26T16:53:53.000Z","_content":"\n\n## 安装ubuntu20.04\n\n安装到非系统盘目录，下载离线安装包，复制到想要安装的目录下，解压，以管理员身份运行ubuntu2004.exe\n\n## 卸载wsl\n\n```sh\nwslconfig /l\n# 从列表中选择要卸载的发行版（例如Ubuntu）并键入命令\nwslconfig /u Ubuntu\n```\n参考链接：[WSL系列操作：安装，卸载](https://blog.csdn.net/zhangpeterx/article/details/97616268\n)\n\n<!--more-->\n\n## 设置wsl\n```sh\n# 更改默认root用户登录\nubuntu1804.exe config --default-user root\n# 更改默认登陆目录\n# list 中 Ubuntu-20.04 条目中添加\n\"startingDirectory\": \"//wsl$/Ubuntu-20.04\"\n```\n\n## ubuntu 换源\n\n```sh\n# 备份\ncp /etc/apt/sources.list /etc/apt/sources.list.20211013\nlsb_release -c\nlsb_release -a\n# \n\nsudo apt-get update\nsudo apt-get upgrade\n\n```\n参考链接：[ubuntu20.04更改国内镜像源](https://blog.csdn.net/qq_33706673/article/details/106869016)\n\n\n## Read The Docs 环境搭建\n\n```sh\n\nsudo apt-get install python3-pip\n\npip install sphinx sphinx-autobuild sphinx_rtd_theme\npip install recommonmark\npip install sphinx-markdown-tables\npip install Pyinstaller -i http://pypi.douban.com/simple --trusted-host pypi.douban.com\n（其中的Pyinstaller是你需要下载的库或包名，根据自己需求自行更改即可）\n\nextensions = [\n    'recommonmark',\n    'sphinx_markdown_tables'\n]\n\npython3 -m pip freeze > requirements.txt\n```\n\n参考链接：\n[VsCode +Read The Docs 环境搭建](https://zhuanlan.zhihu.com/p/112919704)\n<br>\n\n[Sphinx + Read the Docs 从懵逼到入门](https://zhuanlan.zhihu.com/p/264647009)\n<br>\n\n[ReadTheDocs搭建第一本电子书](https://zhuanlan.zhihu.com/p/388640347)\n\n\nhttps://www.jianshu.com/p/8aae1c1453ae\n\n## git\n\ngit push -u origin main\n\n[玩转WSL(6)之Git配置](https://zhuanlan.zhihu.com/p/252505037)\n\n## PowerShell\n\nwinget search Microsoft.PowerShell\n\n- [Windows Powershell和Windows Terminal的区别](https://blog.csdn.net/The_Time_Runner/article/details/106038222)\n<br>\n\n[安装和设置 Windows 终端](https://docs.microsoft.com/zh-cn/windows/terminal/get-started)\n\n\n## windows 包管理工具\n\n- winget 官方推出\n```sh\n# 使用 WinGet 安装一遍\nwinget install postman\nwinget search postman\n\n# 卸载，再用 Scoop 安装一遍\nscoop install postman\n```\n- choro\n\n- vcpkg\n[Get started with vcpkg](https://vcpkg.io/en/getting-started.html)\n\n<br>\n\n- cget\nhttps://cget.readthedocs.io/en/latest/#\n\n[开源库集成器Vcpkg全教程](https://blog.csdn.net/cjmqas/article/details/79282847)\n\n\n Scoop ","source":"_posts/WSL.md","raw":"---\ntitle: WSL\ndate: 2021-10-27 00:47:53\nupdated: 2021-10-27 00:53:53\ncategories: \n    - tool\ntags: \n    - 实用教程\n    - Another Tag\n---\n\n\n## 安装ubuntu20.04\n\n安装到非系统盘目录，下载离线安装包，复制到想要安装的目录下，解压，以管理员身份运行ubuntu2004.exe\n\n## 卸载wsl\n\n```sh\nwslconfig /l\n# 从列表中选择要卸载的发行版（例如Ubuntu）并键入命令\nwslconfig /u Ubuntu\n```\n参考链接：[WSL系列操作：安装，卸载](https://blog.csdn.net/zhangpeterx/article/details/97616268\n)\n\n<!--more-->\n\n## 设置wsl\n```sh\n# 更改默认root用户登录\nubuntu1804.exe config --default-user root\n# 更改默认登陆目录\n# list 中 Ubuntu-20.04 条目中添加\n\"startingDirectory\": \"//wsl$/Ubuntu-20.04\"\n```\n\n## ubuntu 换源\n\n```sh\n# 备份\ncp /etc/apt/sources.list /etc/apt/sources.list.20211013\nlsb_release -c\nlsb_release -a\n# \n\nsudo apt-get update\nsudo apt-get upgrade\n\n```\n参考链接：[ubuntu20.04更改国内镜像源](https://blog.csdn.net/qq_33706673/article/details/106869016)\n\n\n## Read The Docs 环境搭建\n\n```sh\n\nsudo apt-get install python3-pip\n\npip install sphinx sphinx-autobuild sphinx_rtd_theme\npip install recommonmark\npip install sphinx-markdown-tables\npip install Pyinstaller -i http://pypi.douban.com/simple --trusted-host pypi.douban.com\n（其中的Pyinstaller是你需要下载的库或包名，根据自己需求自行更改即可）\n\nextensions = [\n    'recommonmark',\n    'sphinx_markdown_tables'\n]\n\npython3 -m pip freeze > requirements.txt\n```\n\n参考链接：\n[VsCode +Read The Docs 环境搭建](https://zhuanlan.zhihu.com/p/112919704)\n<br>\n\n[Sphinx + Read the Docs 从懵逼到入门](https://zhuanlan.zhihu.com/p/264647009)\n<br>\n\n[ReadTheDocs搭建第一本电子书](https://zhuanlan.zhihu.com/p/388640347)\n\n\nhttps://www.jianshu.com/p/8aae1c1453ae\n\n## git\n\ngit push -u origin main\n\n[玩转WSL(6)之Git配置](https://zhuanlan.zhihu.com/p/252505037)\n\n## PowerShell\n\nwinget search Microsoft.PowerShell\n\n- [Windows Powershell和Windows Terminal的区别](https://blog.csdn.net/The_Time_Runner/article/details/106038222)\n<br>\n\n[安装和设置 Windows 终端](https://docs.microsoft.com/zh-cn/windows/terminal/get-started)\n\n\n## windows 包管理工具\n\n- winget 官方推出\n```sh\n# 使用 WinGet 安装一遍\nwinget install postman\nwinget search postman\n\n# 卸载，再用 Scoop 安装一遍\nscoop install postman\n```\n- choro\n\n- vcpkg\n[Get started with vcpkg](https://vcpkg.io/en/getting-started.html)\n\n<br>\n\n- cget\nhttps://cget.readthedocs.io/en/latest/#\n\n[开源库集成器Vcpkg全教程](https://blog.csdn.net/cjmqas/article/details/79282847)\n\n\n Scoop ","slug":"WSL","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8uq00010guu80qyfien","content":"<h2 id=\"安装ubuntu20-04\"><a href=\"#安装ubuntu20-04\" class=\"headerlink\" title=\"安装ubuntu20.04\"></a>安装ubuntu20.04</h2><p>安装到非系统盘目录，下载离线安装包，复制到想要安装的目录下，解压，以管理员身份运行ubuntu2004.exe</p>\n<h2 id=\"卸载wsl\"><a href=\"#卸载wsl\" class=\"headerlink\" title=\"卸载wsl\"></a>卸载wsl</h2><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wslconfig /l</span><br><span class=\"line\"><span class=\"comment\"># 从列表中选择要卸载的发行版（例如Ubuntu）并键入命令</span></span><br><span class=\"line\">wslconfig /u Ubuntu</span><br></pre></td></tr></tbody></table></figure>\n<p>参考链接：<a href=\"https://blog.csdn.net/zhangpeterx/article/details/97616268\">WSL系列操作：安装，卸载</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"设置wsl\"><a href=\"#设置wsl\" class=\"headerlink\" title=\"设置wsl\"></a>设置wsl</h2><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 更改默认root用户登录</span></span><br><span class=\"line\">ubuntu1804.exe config --default-user root</span><br><span class=\"line\"><span class=\"comment\"># 更改默认登陆目录</span></span><br><span class=\"line\"><span class=\"comment\"># list 中 Ubuntu-20.04 条目中添加</span></span><br><span class=\"line\"><span class=\"string\">\"startingDirectory\"</span>: <span class=\"string\">\"//wsl$/Ubuntu-20.04\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"ubuntu-换源\"><a href=\"#ubuntu-换源\" class=\"headerlink\" title=\"ubuntu 换源\"></a>ubuntu 换源</h2><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 备份</span></span><br><span class=\"line\">cp /etc/apt/sources.list /etc/apt/sources.list.20211013</span><br><span class=\"line\">lsb_release -c</span><br><span class=\"line\">lsb_release -a</span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n<p>参考链接：<a href=\"https://blog.csdn.net/qq_33706673/article/details/106869016\">ubuntu20.04更改国内镜像源</a></p>\n<h2 id=\"Read-The-Docs-环境搭建\"><a href=\"#Read-The-Docs-环境搭建\" class=\"headerlink\" title=\"Read The Docs 环境搭建\"></a>Read The Docs 环境搭建</h2><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install python3-pip</span><br><span class=\"line\"></span><br><span class=\"line\">pip install sphinx sphinx-autobuild sphinx_rtd_theme</span><br><span class=\"line\">pip install recommonmark</span><br><span class=\"line\">pip install sphinx-markdown-tables</span><br><span class=\"line\">pip install Pyinstaller -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br><span class=\"line\">（其中的Pyinstaller是你需要下载的库或包名，根据自己需求自行更改即可）</span><br><span class=\"line\"></span><br><span class=\"line\">extensions = [</span><br><span class=\"line\">    <span class=\"string\">'recommonmark'</span>,</span><br><span class=\"line\">    <span class=\"string\">'sphinx_markdown_tables'</span></span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">python3 -m pip freeze &gt; requirements.txt</span><br></pre></td></tr></tbody></table></figure>\n\n<p>参考链接：<br><a href=\"https://zhuanlan.zhihu.com/p/112919704\">VsCode +Read The Docs 环境搭建</a><br><br></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/264647009\">Sphinx + Read the Docs 从懵逼到入门</a><br><br></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/388640347\">ReadTheDocs搭建第一本电子书</a></p>\n<p><a href=\"https://www.jianshu.com/p/8aae1c1453ae\">https://www.jianshu.com/p/8aae1c1453ae</a></p>\n<h2 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h2><p>git push -u origin main</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/252505037\">玩转WSL(6)之Git配置</a></p>\n<h2 id=\"PowerShell\"><a href=\"#PowerShell\" class=\"headerlink\" title=\"PowerShell\"></a>PowerShell</h2><p>winget search Microsoft.PowerShell</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/The_Time_Runner/article/details/106038222\">Windows Powershell和Windows Terminal的区别</a><br></li>\n</ul>\n<p><a href=\"https://docs.microsoft.com/zh-cn/windows/terminal/get-started\">安装和设置 Windows 终端</a></p>\n<h2 id=\"windows-包管理工具\"><a href=\"#windows-包管理工具\" class=\"headerlink\" title=\"windows 包管理工具\"></a>windows 包管理工具</h2><ul>\n<li><p>winget 官方推出</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 WinGet 安装一遍</span></span><br><span class=\"line\">winget install postman</span><br><span class=\"line\">winget search postman</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 卸载，再用 Scoop 安装一遍</span></span><br><span class=\"line\">scoop install postman</span><br></pre></td></tr></tbody></table></figure></li>\n<li><p>choro</p>\n</li>\n<li><p>vcpkg<br><a href=\"https://vcpkg.io/en/getting-started.html\">Get started with vcpkg</a></p>\n</li>\n</ul>\n<br>\n\n<ul>\n<li>cget<br><a href=\"https://cget.readthedocs.io/en/latest/#\">https://cget.readthedocs.io/en/latest/#</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/cjmqas/article/details/79282847\">开源库集成器Vcpkg全教程</a></p>\n<p> Scoop </p>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"1W4XRGB","length":1302,"excerpt":"<h2 id=\"安装ubuntu20-04\"><a href=\"#安装ubuntu20-04\" class=\"headerlink\" title=\"安装ubuntu20.04\"></a>安装ubuntu20.04</h2><p>安装到非系统盘目录，下载离线安装包，复制到想要安装的目录下，解压，以管理员身份运行ubuntu2004.exe</p>\n<h2 id=\"卸载wsl\"><a href=\"#卸载wsl\" class=\"headerlink\" title=\"卸载wsl\"></a>卸载wsl</h2><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wslconfig /l</span><br><span class=\"line\"><span class=\"comment\"># 从列表中选择要卸载的发行版（例如Ubuntu）并键入命令</span></span><br><span class=\"line\">wslconfig /u Ubuntu</span><br></pre></td></tr></tbody></table></figure>\n<p>参考链接：<a href=\"https://blog.csdn.net/zhangpeterx/article/details/97616268\">WSL系列操作：安装，卸载</a></p>","more":"<h2 id=\"设置wsl\"><a href=\"#设置wsl\" class=\"headerlink\" title=\"设置wsl\"></a>设置wsl</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 更改默认root用户登录</span></span><br><span class=\"line\">ubuntu1804.exe config --default-user root</span><br><span class=\"line\"><span class=\"comment\"># 更改默认登陆目录</span></span><br><span class=\"line\"><span class=\"comment\"># list 中 Ubuntu-20.04 条目中添加</span></span><br><span class=\"line\"><span class=\"string\">&quot;startingDirectory&quot;</span>: <span class=\"string\">&quot;//wsl$/Ubuntu-20.04&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ubuntu-换源\"><a href=\"#ubuntu-换源\" class=\"headerlink\" title=\"ubuntu 换源\"></a>ubuntu 换源</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 备份</span></span><br><span class=\"line\">cp /etc/apt/sources.list /etc/apt/sources.list.20211013</span><br><span class=\"line\">lsb_release -c</span><br><span class=\"line\">lsb_release -a</span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>参考链接：<a href=\"https://blog.csdn.net/qq_33706673/article/details/106869016\">ubuntu20.04更改国内镜像源</a></p>\n<h2 id=\"Read-The-Docs-环境搭建\"><a href=\"#Read-The-Docs-环境搭建\" class=\"headerlink\" title=\"Read The Docs 环境搭建\"></a>Read The Docs 环境搭建</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install python3-pip</span><br><span class=\"line\"></span><br><span class=\"line\">pip install sphinx sphinx-autobuild sphinx_rtd_theme</span><br><span class=\"line\">pip install recommonmark</span><br><span class=\"line\">pip install sphinx-markdown-tables</span><br><span class=\"line\">pip install Pyinstaller -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br><span class=\"line\">（其中的Pyinstaller是你需要下载的库或包名，根据自己需求自行更改即可）</span><br><span class=\"line\"></span><br><span class=\"line\">extensions = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;recommonmark&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;sphinx_markdown_tables&#x27;</span></span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">python3 -m pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>\n\n<p>参考链接：<br><a href=\"https://zhuanlan.zhihu.com/p/112919704\">VsCode +Read The Docs 环境搭建</a><br><br></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/264647009\">Sphinx + Read the Docs 从懵逼到入门</a><br><br></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/388640347\">ReadTheDocs搭建第一本电子书</a></p>\n<p><a href=\"https://www.jianshu.com/p/8aae1c1453ae\">https://www.jianshu.com/p/8aae1c1453ae</a></p>\n<h2 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h2><p>git push -u origin main</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/252505037\">玩转WSL(6)之Git配置</a></p>\n<h2 id=\"PowerShell\"><a href=\"#PowerShell\" class=\"headerlink\" title=\"PowerShell\"></a>PowerShell</h2><p>winget search Microsoft.PowerShell</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/The_Time_Runner/article/details/106038222\">Windows Powershell和Windows Terminal的区别</a><br></li>\n</ul>\n<p><a href=\"https://docs.microsoft.com/zh-cn/windows/terminal/get-started\">安装和设置 Windows 终端</a></p>\n<h2 id=\"windows-包管理工具\"><a href=\"#windows-包管理工具\" class=\"headerlink\" title=\"windows 包管理工具\"></a>windows 包管理工具</h2><ul>\n<li><p>winget 官方推出</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 WinGet 安装一遍</span></span><br><span class=\"line\">winget install postman</span><br><span class=\"line\">winget search postman</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 卸载，再用 Scoop 安装一遍</span></span><br><span class=\"line\">scoop install postman</span><br></pre></td></tr></table></figure></li>\n<li><p>choro</p>\n</li>\n<li><p>vcpkg<br><a href=\"https://vcpkg.io/en/getting-started.html\">Get started with vcpkg</a></p>\n</li>\n</ul>\n<br>\n\n<ul>\n<li>cget<br><a href=\"https://cget.readthedocs.io/en/latest/#\">https://cget.readthedocs.io/en/latest/#</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/cjmqas/article/details/79282847\">开源库集成器Vcpkg全教程</a></p>\n<p> Scoop </p>"},{"title":"书单&电影","date":"2021-10-26T16:47:53.000Z","updated":"2021-10-26T16:53:53.000Z","_content":"\n\n## 书\n\n### \n- 豆豆三部曲\n背叛\n遥远的救世主\n天幕红尘\n\n- \n### computer\n- C语言编程魔法书：基于C11标准\n- 剑指offer 名企面试官精讲典型编程题\n- C Primer Plus(第六版)\n- C语言解惑：指针、数组、函数和文件\n回看第七章\n- 算法图解\n- 大话数据结构\n- 软件故事\n\n\n\n\n\n<!--more-->\n\n## 电影\n\n### 未看\n\n- 越哥说电影\n  - 黑炮事件\n  - 乌龟也会飞: 伊拉克,美伊战争\n  - 牧马人: 改编自张贤亮的小说<令与肉>特殊时期,被批判的人遇到善良的爱人.汗水浸过的土地,相濡以沫的.传统女性,自信,高贵.\n  - 最爱 : 章子怡(琴琴),郭富城(得意);卖血,艾滋病村,艾滋病人的人生,爱情.贫穷,人性,善良,荒凉.\n  - 香火   求,乞,骗\n\n教父三部曲\n\n\n\n勇敢的心\n\n\n\n### 已看\n\n- 夜色人生\n禁酒令是黑帮斗争,爱尔兰人;\n- 控方证人\n犯罪悬疑,1958年的英国谋杀案电影\n- 小岛惊魂\n惊悚悬疑,为什么杀了两个孩子?战争?\n- 千钧一发 1997年\n基因筛选,基因歧视,依靠基因来判定一个人,文生借用优等基因人的身份,入选土卫十四飞行员.\n- 致命ID\n多重人格\n\n\n```plantuml\n@startuml\n\nBob -> Alice : Hello, how are you\nAlice -> Bob : Fine, thank you, and you?\n\n@enduml\n```\n\n{% plantuml %}\n!theme spacelab\nBob -> Alice :  hello\nBob <- Alice :  $success(\"success: hello B.\")\nBob -x Alice :  $failure(\"failure\")\nBob ->> Alice : $warning(\"warning\")\n{% endplantuml %}\n\n\n{% plantuml %}\n  Alice -> Bob: Authentication Request\n  Bob --> Alice: Authentication Response\n\n  Alice -> Bob: Another atuhentication Request\n  Alice <-- Bob: Another authentication Response\n{% endplantuml %}","source":"_posts/书单.md","raw":"---\ntitle: 书单&电影\ndate: 2021-10-27 00:47:53\nupdated: 2021-10-27 00:53:53\ncategories: \n    - tool\ntags: \n    - 实用教程\n    - Another Tag\n---\n\n\n## 书\n\n### \n- 豆豆三部曲\n背叛\n遥远的救世主\n天幕红尘\n\n- \n### computer\n- C语言编程魔法书：基于C11标准\n- 剑指offer 名企面试官精讲典型编程题\n- C Primer Plus(第六版)\n- C语言解惑：指针、数组、函数和文件\n回看第七章\n- 算法图解\n- 大话数据结构\n- 软件故事\n\n\n\n\n\n<!--more-->\n\n## 电影\n\n### 未看\n\n- 越哥说电影\n  - 黑炮事件\n  - 乌龟也会飞: 伊拉克,美伊战争\n  - 牧马人: 改编自张贤亮的小说<令与肉>特殊时期,被批判的人遇到善良的爱人.汗水浸过的土地,相濡以沫的.传统女性,自信,高贵.\n  - 最爱 : 章子怡(琴琴),郭富城(得意);卖血,艾滋病村,艾滋病人的人生,爱情.贫穷,人性,善良,荒凉.\n  - 香火   求,乞,骗\n\n教父三部曲\n\n\n\n勇敢的心\n\n\n\n### 已看\n\n- 夜色人生\n禁酒令是黑帮斗争,爱尔兰人;\n- 控方证人\n犯罪悬疑,1958年的英国谋杀案电影\n- 小岛惊魂\n惊悚悬疑,为什么杀了两个孩子?战争?\n- 千钧一发 1997年\n基因筛选,基因歧视,依靠基因来判定一个人,文生借用优等基因人的身份,入选土卫十四飞行员.\n- 致命ID\n多重人格\n\n\n```plantuml\n@startuml\n\nBob -> Alice : Hello, how are you\nAlice -> Bob : Fine, thank you, and you?\n\n@enduml\n```\n\n{% plantuml %}\n!theme spacelab\nBob -> Alice :  hello\nBob <- Alice :  $success(\"success: hello B.\")\nBob -x Alice :  $failure(\"failure\")\nBob ->> Alice : $warning(\"warning\")\n{% endplantuml %}\n\n\n{% plantuml %}\n  Alice -> Bob: Authentication Request\n  Bob --> Alice: Authentication Response\n\n  Alice -> Bob: Another atuhentication Request\n  Alice <-- Bob: Another authentication Response\n{% endplantuml %}","slug":"书单","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8uw00030guug70xcdow","content":"<h2 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><ul>\n<li><p>豆豆三部曲<br>背叛<br>遥远的救世主<br>天幕红尘</p>\n</li>\n<li><h3 id=\"computer\"><a href=\"#computer\" class=\"headerlink\" title=\"computer\"></a>computer</h3></li>\n<li><p>C语言编程魔法书：基于C11标准</p>\n</li>\n<li><p>剑指offer 名企面试官精讲典型编程题</p>\n</li>\n<li><p>C Primer Plus(第六版)</p>\n</li>\n<li><p>C语言解惑：指针、数组、函数和文件<br>回看第七章</p>\n</li>\n<li><p>算法图解</p>\n</li>\n<li><p>大话数据结构</p>\n</li>\n<li><p>软件故事</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h2><h3 id=\"未看\"><a href=\"#未看\" class=\"headerlink\" title=\"未看\"></a>未看</h3><ul>\n<li>越哥说电影<ul>\n<li>黑炮事件</li>\n<li>乌龟也会飞: 伊拉克,美伊战争</li>\n<li>牧马人: 改编自张贤亮的小说&lt;令与肉&gt;特殊时期,被批判的人遇到善良的爱人.汗水浸过的土地,相濡以沫的.传统女性,自信,高贵.</li>\n<li>最爱 : 章子怡(琴琴),郭富城(得意);卖血,艾滋病村,艾滋病人的人生,爱情.贫穷,人性,善良,荒凉.</li>\n<li>香火   求,乞,骗</li>\n</ul>\n</li>\n</ul>\n<p>教父三部曲</p>\n<p>勇敢的心</p>\n<h3 id=\"已看\"><a href=\"#已看\" class=\"headerlink\" title=\"已看\"></a>已看</h3><ul>\n<li>夜色人生<br>禁酒令是黑帮斗争,爱尔兰人;</li>\n<li>控方证人<br>犯罪悬疑,1958年的英国谋杀案电影</li>\n<li>小岛惊魂<br>惊悚悬疑,为什么杀了两个孩子?战争?</li>\n<li>千钧一发 1997年<br>基因筛选,基因歧视,依靠基因来判定一个人,文生借用优等基因人的身份,入选土卫十四飞行员.</li>\n<li>致命ID<br>多重人格</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@startuml</span><br><span class=\"line\"></span><br><span class=\"line\">Bob -&gt; Alice : Hello, how are you</span><br><span class=\"line\">Alice -&gt; Bob : Fine, thank you, and you?</span><br><span class=\"line\"></span><br><span class=\"line\">@enduml</span><br></pre></td></tr></tbody></table></figure>\n\n<img src=\"http://www.plantuml.com/plantuml/svg/Kop9ICrDLIWkI4nEpKbCudBAJrBGjLDmpCbCJbMmKb38ICt9oGUBskWYH5MAIvEJKukBDPIW32k8GWKdFILDY1aLIAhJ4ZDpIejIDPIW39WQEuH5AkM9HNcPUUaQIb26aYO0\">\n\n\n<img src=\"http://www.plantuml.com/plantuml/svg/Syp9J4vLqBLJSCfFib9mB2t9ICqhoKnEBCdCprC8IYqiJIqkuGBAAUW2rJY256DHLLoGdrUSoiNbY6fONZvGNP52OaafDaCXYcrqTT5KOpSS0000\"><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"1DMG0PV","length":484,"excerpt":"<h2 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><ul>\n<li><p>豆豆三部曲<br>背叛<br>遥远的救世主<br>天幕红尘</p>\n</li>\n<li><h3 id=\"computer\"><a href=\"#computer\" class=\"headerlink\" title=\"computer\"></a>computer</h3></li>\n<li><p>C语言编程魔法书：基于C11标准</p>\n</li>\n<li><p>剑指offer 名企面试官精讲典型编程题</p>\n</li>\n<li><p>C Primer Plus(第六版)</p>\n</li>\n<li><p>C语言解惑：指针、数组、函数和文件<br>回看第七章</p>\n</li>\n<li><p>算法图解</p>\n</li>\n<li><p>大话数据结构</p>\n</li>\n<li><p>软件故事</p>\n</li>\n</ul>","more":"<h2 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h2><h3 id=\"未看\"><a href=\"#未看\" class=\"headerlink\" title=\"未看\"></a>未看</h3><ul>\n<li>越哥说电影<ul>\n<li>黑炮事件</li>\n<li>乌龟也会飞: 伊拉克,美伊战争</li>\n<li>牧马人: 改编自张贤亮的小说&lt;令与肉&gt;特殊时期,被批判的人遇到善良的爱人.汗水浸过的土地,相濡以沫的.传统女性,自信,高贵.</li>\n<li>最爱 : 章子怡(琴琴),郭富城(得意);卖血,艾滋病村,艾滋病人的人生,爱情.贫穷,人性,善良,荒凉.</li>\n<li>香火   求,乞,骗</li>\n</ul>\n</li>\n</ul>\n<p>教父三部曲</p>\n<p>勇敢的心</p>\n<h3 id=\"已看\"><a href=\"#已看\" class=\"headerlink\" title=\"已看\"></a>已看</h3><ul>\n<li>夜色人生<br>禁酒令是黑帮斗争,爱尔兰人;</li>\n<li>控方证人<br>犯罪悬疑,1958年的英国谋杀案电影</li>\n<li>小岛惊魂<br>惊悚悬疑,为什么杀了两个孩子?战争?</li>\n<li>千钧一发 1997年<br>基因筛选,基因歧视,依靠基因来判定一个人,文生借用优等基因人的身份,入选土卫十四飞行员.</li>\n<li>致命ID<br>多重人格</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@startuml</span><br><span class=\"line\"></span><br><span class=\"line\">Bob -&gt; Alice : Hello, how are you</span><br><span class=\"line\">Alice -&gt; Bob : Fine, thank you, and you?</span><br><span class=\"line\"></span><br><span class=\"line\">@enduml</span><br></pre></td></tr></table></figure>\n\n<img  src=http://www.plantuml.com/plantuml/svg/Kop9ICrDLIWkI4nEpKbCudBAJrBGjLDmpCbCJbMmKb38ICt9oGUBskWYH5MAIvEJKukBDPIW32k8GWKdFILDY1aLIAhJ4ZDpIejIDPIW39WQEuH5AkM9HNcPUUaQIb26aYO0>\n\n\n<img  src=http://www.plantuml.com/plantuml/svg/Syp9J4vLqBLJSCfFib9mB2t9ICqhoKnEBCdCprC8IYqiJIqkuGBAAUW2rJY256DHLLoGdrUSoiNbY6fONZvGNP52OaafDaCXYcrqTT5KOpSS0000>"},{"title":"Software&Tool","date":"2021-10-25T16:47:53.000Z","updated":"2021-10-26T16:53:53.000Z","_content":"\n\n## GitHub Pages + Hexo使用及配置\n\ngithub上创建一个  username.github.io 的工程，username 必须为github的用户名\n\n<!--more-->\n\n### Hexo 安装\n\n```sh\n# 清理缓存\nhexo clean\n# 生成网页\nhexo g\n# 启动本地服务端口\nhexo s\n# 发布到github\nhexo d\n\n\n# 强制推送备份源码分支\ngit push -f origin backup\n```\n\n## 参考链接\n\nhttps://www.jianshu.com/p/f82c76b90336\n\nhttps://www.jianshu.com/p/5d0b31032d55\n\nhttps://blog.csdn.net/weixin_41922289/article/details/95639870\n\nhttps://theme-next.org/\n\nhttps://hexo.io/zh-cn/docs/\n\nhttps://www.jianshu.com/p/3a05351a37dc\n\nhttps://www.zhyong.cn/posts/ca02/\n\nhttp://theme-next.iissnan.com/\n\nhttps://liam.page/\n\nhttps://liam.page/en/\n\n- Hexo博客添加helper-live2d动态模型插件\nhttps://blog.csdn.net/qq_30930805/article/details/\n\n## vscode\n\n### vscode 上传图片\n\n```sh\n# 上传剪贴板中的图片到服务器。\nctrl + alt + u\n# 打开文件浏览器选择图片上传。\nctrl + alt + e\n\n```\n- https://www.jianshu.com/p/868b3a2028f8\nhttps://zhuanlan.zhihu.com/p/131584831\n\n## plantuml\n\n\n\n\n## windows 开源软件\n\n potplayer \nhttps://iptv-org.github.io/iptv/index.m3u\n\n\n\neveryting\n\n7zip\n\nrustdesk  远程开源软件\n\nmaya\n\nimagine\n\nscreentogif\n\nditto\n\nbleachbit\n\nqbittorrent\n\ngrammarly\n\n剪切板win10自带的有很多剪切记录的快捷键Windows键➕V键\n\n线上思维导图\nhttps://gitmind.cn/app/template\n在线文档转换\nhttps://www.aconvert.com/cn/\n开源软件下载网站\nhttps://www.fosshub.com/#\n\n### windows ternial \n- 添加 git base 到ternial\n\n\n## linux\n\n### linux 各种系统\n\nubuntu、Linux Mint、suse、Manjaro\n\n### chrome插件\n\n油猴\n\n\n\n## React Router\n\n\nhttp://react-guide.github.io/react-router-cn/index.html\n\n\n## youtube 下载\nhttps://www.ganbey.com/youtube-download-3774\n\n\n\n## zlog\nhttps://blog.csdn.net/twd_1991/article/details/80481920\n\nhttp://hardysimpson.github.io/zlog/UsersGuide-CN.html\n\n\n## gdb\n\nhttps://leetcode-cn.com/circle/article/7mxorv","source":"_posts/Software&Tool.md","raw":"---\ntitle: Software&Tool\ndate: 2021-10-26 00:47:53\nupdated: 2021-10-27 00:53:53\ncategories: \n    - tool\ntags: \n    - 实用教程\n    - Another Tag\n---\n\n\n## GitHub Pages + Hexo使用及配置\n\ngithub上创建一个  username.github.io 的工程，username 必须为github的用户名\n\n<!--more-->\n\n### Hexo 安装\n\n```sh\n# 清理缓存\nhexo clean\n# 生成网页\nhexo g\n# 启动本地服务端口\nhexo s\n# 发布到github\nhexo d\n\n\n# 强制推送备份源码分支\ngit push -f origin backup\n```\n\n## 参考链接\n\nhttps://www.jianshu.com/p/f82c76b90336\n\nhttps://www.jianshu.com/p/5d0b31032d55\n\nhttps://blog.csdn.net/weixin_41922289/article/details/95639870\n\nhttps://theme-next.org/\n\nhttps://hexo.io/zh-cn/docs/\n\nhttps://www.jianshu.com/p/3a05351a37dc\n\nhttps://www.zhyong.cn/posts/ca02/\n\nhttp://theme-next.iissnan.com/\n\nhttps://liam.page/\n\nhttps://liam.page/en/\n\n- Hexo博客添加helper-live2d动态模型插件\nhttps://blog.csdn.net/qq_30930805/article/details/\n\n## vscode\n\n### vscode 上传图片\n\n```sh\n# 上传剪贴板中的图片到服务器。\nctrl + alt + u\n# 打开文件浏览器选择图片上传。\nctrl + alt + e\n\n```\n- https://www.jianshu.com/p/868b3a2028f8\nhttps://zhuanlan.zhihu.com/p/131584831\n\n## plantuml\n\n\n\n\n## windows 开源软件\n\n potplayer \nhttps://iptv-org.github.io/iptv/index.m3u\n\n\n\neveryting\n\n7zip\n\nrustdesk  远程开源软件\n\nmaya\n\nimagine\n\nscreentogif\n\nditto\n\nbleachbit\n\nqbittorrent\n\ngrammarly\n\n剪切板win10自带的有很多剪切记录的快捷键Windows键➕V键\n\n线上思维导图\nhttps://gitmind.cn/app/template\n在线文档转换\nhttps://www.aconvert.com/cn/\n开源软件下载网站\nhttps://www.fosshub.com/#\n\n### windows ternial \n- 添加 git base 到ternial\n\n\n## linux\n\n### linux 各种系统\n\nubuntu、Linux Mint、suse、Manjaro\n\n### chrome插件\n\n油猴\n\n\n\n## React Router\n\n\nhttp://react-guide.github.io/react-router-cn/index.html\n\n\n## youtube 下载\nhttps://www.ganbey.com/youtube-download-3774\n\n\n\n## zlog\nhttps://blog.csdn.net/twd_1991/article/details/80481920\n\nhttp://hardysimpson.github.io/zlog/UsersGuide-CN.html\n\n\n## gdb\n\nhttps://leetcode-cn.com/circle/article/7mxorv","slug":"Software&Tool","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8v200070guu7p4kfzfe","content":"<h2 id=\"GitHub-Pages-Hexo使用及配置\"><a href=\"#GitHub-Pages-Hexo使用及配置\" class=\"headerlink\" title=\"GitHub Pages + Hexo使用及配置\"></a>GitHub Pages + Hexo使用及配置</h2><p>github上创建一个  username.github.io 的工程，username 必须为github的用户名</p>\n<span id=\"more\"></span>\n\n<h3 id=\"Hexo-安装\"><a href=\"#Hexo-安装\" class=\"headerlink\" title=\"Hexo 安装\"></a>Hexo 安装</h3><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理缓存</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\"><span class=\"comment\"># 生成网页</span></span><br><span class=\"line\">hexo g</span><br><span class=\"line\"><span class=\"comment\"># 启动本地服务端口</span></span><br><span class=\"line\">hexo s</span><br><span class=\"line\"><span class=\"comment\"># 发布到github</span></span><br><span class=\"line\">hexo d</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 强制推送备份源码分支</span></span><br><span class=\"line\">git push -f origin backup</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.jianshu.com/p/f82c76b90336\">https://www.jianshu.com/p/f82c76b90336</a></p>\n<p><a href=\"https://www.jianshu.com/p/5d0b31032d55\">https://www.jianshu.com/p/5d0b31032d55</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_41922289/article/details/95639870\">https://blog.csdn.net/weixin_41922289/article/details/95639870</a></p>\n<p><a href=\"https://theme-next.org/\">https://theme-next.org/</a></p>\n<p><a href=\"https://hexo.io/zh-cn/docs/\">https://hexo.io/zh-cn/docs/</a></p>\n<p><a href=\"https://www.jianshu.com/p/3a05351a37dc\">https://www.jianshu.com/p/3a05351a37dc</a></p>\n<p><a href=\"https://www.zhyong.cn/posts/ca02/\">https://www.zhyong.cn/posts/ca02/</a></p>\n<p><a href=\"http://theme-next.iissnan.com/\">http://theme-next.iissnan.com/</a></p>\n<p><a href=\"https://liam.page/\">https://liam.page/</a></p>\n<p><a href=\"https://liam.page/en/\">https://liam.page/en/</a></p>\n<ul>\n<li>Hexo博客添加helper-live2d动态模型插件<br><a href=\"https://blog.csdn.net/qq_30930805/article/details/\">https://blog.csdn.net/qq_30930805/article/details/</a></li>\n</ul>\n<h2 id=\"vscode\"><a href=\"#vscode\" class=\"headerlink\" title=\"vscode\"></a>vscode</h2><h3 id=\"vscode-上传图片\"><a href=\"#vscode-上传图片\" class=\"headerlink\" title=\"vscode 上传图片\"></a>vscode 上传图片</h3><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 上传剪贴板中的图片到服务器。</span></span><br><span class=\"line\">ctrl + alt + u</span><br><span class=\"line\"><span class=\"comment\"># 打开文件浏览器选择图片上传。</span></span><br><span class=\"line\">ctrl + alt + e</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/868b3a2028f8\">https://www.jianshu.com/p/868b3a2028f8</a><br><a href=\"https://zhuanlan.zhihu.com/p/131584831\">https://zhuanlan.zhihu.com/p/131584831</a></li>\n</ul>\n<h2 id=\"plantuml\"><a href=\"#plantuml\" class=\"headerlink\" title=\"plantuml\"></a>plantuml</h2><h2 id=\"windows-开源软件\"><a href=\"#windows-开源软件\" class=\"headerlink\" title=\"windows 开源软件\"></a>windows 开源软件</h2><p> potplayer<br><a href=\"https://iptv-org.github.io/iptv/index.m3u\">https://iptv-org.github.io/iptv/index.m3u</a></p>\n<p>everyting</p>\n<p>7zip</p>\n<p>rustdesk  远程开源软件</p>\n<p>maya</p>\n<p>imagine</p>\n<p>screentogif</p>\n<p>ditto</p>\n<p>bleachbit</p>\n<p>qbittorrent</p>\n<p>grammarly</p>\n<p>剪切板win10自带的有很多剪切记录的快捷键Windows键➕V键</p>\n<p>线上思维导图<br><a href=\"https://gitmind.cn/app/template\">https://gitmind.cn/app/template</a><br>在线文档转换<br><a href=\"https://www.aconvert.com/cn/\">https://www.aconvert.com/cn/</a><br>开源软件下载网站<br><a href=\"https://www.fosshub.com/#\">https://www.fosshub.com/#</a></p>\n<h3 id=\"windows-ternial\"><a href=\"#windows-ternial\" class=\"headerlink\" title=\"windows ternial\"></a>windows ternial</h3><ul>\n<li>添加 git base 到ternial</li>\n</ul>\n<h2 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h2><h3 id=\"linux-各种系统\"><a href=\"#linux-各种系统\" class=\"headerlink\" title=\"linux 各种系统\"></a>linux 各种系统</h3><p>ubuntu、Linux Mint、suse、Manjaro</p>\n<h3 id=\"chrome插件\"><a href=\"#chrome插件\" class=\"headerlink\" title=\"chrome插件\"></a>chrome插件</h3><p>油猴</p>\n<h2 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React Router\"></a>React Router</h2><p><a href=\"http://react-guide.github.io/react-router-cn/index.html\">http://react-guide.github.io/react-router-cn/index.html</a></p>\n<h2 id=\"youtube-下载\"><a href=\"#youtube-下载\" class=\"headerlink\" title=\"youtube 下载\"></a>youtube 下载</h2><p><a href=\"https://www.ganbey.com/youtube-download-3774\">https://www.ganbey.com/youtube-download-3774</a></p>\n<h2 id=\"zlog\"><a href=\"#zlog\" class=\"headerlink\" title=\"zlog\"></a>zlog</h2><p><a href=\"https://blog.csdn.net/twd_1991/article/details/80481920\">https://blog.csdn.net/twd_1991/article/details/80481920</a></p>\n<p><a href=\"http://hardysimpson.github.io/zlog/UsersGuide-CN.html\">http://hardysimpson.github.io/zlog/UsersGuide-CN.html</a></p>\n<h2 id=\"gdb\"><a href=\"#gdb\" class=\"headerlink\" title=\"gdb\"></a>gdb</h2><p><a href=\"https://leetcode-cn.com/circle/article/7mxorv\">https://leetcode-cn.com/circle/article/7mxorv</a></p>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"3H7GMJR","length":1389,"excerpt":"<h2 id=\"GitHub-Pages-Hexo使用及配置\"><a href=\"#GitHub-Pages-Hexo使用及配置\" class=\"headerlink\" title=\"GitHub Pages + Hexo使用及配置\"></a>GitHub Pages + Hexo使用及配置</h2><p>github上创建一个  username.github.io 的工程，username 必须为github的用户名</p>","more":"<h3 id=\"Hexo-安装\"><a href=\"#Hexo-安装\" class=\"headerlink\" title=\"Hexo 安装\"></a>Hexo 安装</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理缓存</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\"><span class=\"comment\"># 生成网页</span></span><br><span class=\"line\">hexo g</span><br><span class=\"line\"><span class=\"comment\"># 启动本地服务端口</span></span><br><span class=\"line\">hexo s</span><br><span class=\"line\"><span class=\"comment\"># 发布到github</span></span><br><span class=\"line\">hexo d</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 强制推送备份源码分支</span></span><br><span class=\"line\">git push -f origin backup</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.jianshu.com/p/f82c76b90336\">https://www.jianshu.com/p/f82c76b90336</a></p>\n<p><a href=\"https://www.jianshu.com/p/5d0b31032d55\">https://www.jianshu.com/p/5d0b31032d55</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_41922289/article/details/95639870\">https://blog.csdn.net/weixin_41922289/article/details/95639870</a></p>\n<p><a href=\"https://theme-next.org/\">https://theme-next.org/</a></p>\n<p><a href=\"https://hexo.io/zh-cn/docs/\">https://hexo.io/zh-cn/docs/</a></p>\n<p><a href=\"https://www.jianshu.com/p/3a05351a37dc\">https://www.jianshu.com/p/3a05351a37dc</a></p>\n<p><a href=\"https://www.zhyong.cn/posts/ca02/\">https://www.zhyong.cn/posts/ca02/</a></p>\n<p><a href=\"http://theme-next.iissnan.com/\">http://theme-next.iissnan.com/</a></p>\n<p><a href=\"https://liam.page/\">https://liam.page/</a></p>\n<p><a href=\"https://liam.page/en/\">https://liam.page/en/</a></p>\n<ul>\n<li>Hexo博客添加helper-live2d动态模型插件<br><a href=\"https://blog.csdn.net/qq_30930805/article/details/\">https://blog.csdn.net/qq_30930805/article/details/</a></li>\n</ul>\n<h2 id=\"vscode\"><a href=\"#vscode\" class=\"headerlink\" title=\"vscode\"></a>vscode</h2><h3 id=\"vscode-上传图片\"><a href=\"#vscode-上传图片\" class=\"headerlink\" title=\"vscode 上传图片\"></a>vscode 上传图片</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 上传剪贴板中的图片到服务器。</span></span><br><span class=\"line\">ctrl + alt + u</span><br><span class=\"line\"><span class=\"comment\"># 打开文件浏览器选择图片上传。</span></span><br><span class=\"line\">ctrl + alt + e</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/868b3a2028f8\">https://www.jianshu.com/p/868b3a2028f8</a><br><a href=\"https://zhuanlan.zhihu.com/p/131584831\">https://zhuanlan.zhihu.com/p/131584831</a></li>\n</ul>\n<h2 id=\"plantuml\"><a href=\"#plantuml\" class=\"headerlink\" title=\"plantuml\"></a>plantuml</h2><h2 id=\"windows-开源软件\"><a href=\"#windows-开源软件\" class=\"headerlink\" title=\"windows 开源软件\"></a>windows 开源软件</h2><p> potplayer<br><a href=\"https://iptv-org.github.io/iptv/index.m3u\">https://iptv-org.github.io/iptv/index.m3u</a></p>\n<p>everyting</p>\n<p>7zip</p>\n<p>rustdesk  远程开源软件</p>\n<p>maya</p>\n<p>imagine</p>\n<p>screentogif</p>\n<p>ditto</p>\n<p>bleachbit</p>\n<p>qbittorrent</p>\n<p>grammarly</p>\n<p>剪切板win10自带的有很多剪切记录的快捷键Windows键➕V键</p>\n<p>线上思维导图<br><a href=\"https://gitmind.cn/app/template\">https://gitmind.cn/app/template</a><br>在线文档转换<br><a href=\"https://www.aconvert.com/cn/\">https://www.aconvert.com/cn/</a><br>开源软件下载网站<br><a href=\"https://www.fosshub.com/#\">https://www.fosshub.com/#</a></p>\n<h3 id=\"windows-ternial\"><a href=\"#windows-ternial\" class=\"headerlink\" title=\"windows ternial\"></a>windows ternial</h3><ul>\n<li>添加 git base 到ternial</li>\n</ul>\n<h2 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h2><h3 id=\"linux-各种系统\"><a href=\"#linux-各种系统\" class=\"headerlink\" title=\"linux 各种系统\"></a>linux 各种系统</h3><p>ubuntu、Linux Mint、suse、Manjaro</p>\n<h3 id=\"chrome插件\"><a href=\"#chrome插件\" class=\"headerlink\" title=\"chrome插件\"></a>chrome插件</h3><p>油猴</p>\n<h2 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React Router\"></a>React Router</h2><p><a href=\"http://react-guide.github.io/react-router-cn/index.html\">http://react-guide.github.io/react-router-cn/index.html</a></p>\n<h2 id=\"youtube-下载\"><a href=\"#youtube-下载\" class=\"headerlink\" title=\"youtube 下载\"></a>youtube 下载</h2><p><a href=\"https://www.ganbey.com/youtube-download-3774\">https://www.ganbey.com/youtube-download-3774</a></p>\n<h2 id=\"zlog\"><a href=\"#zlog\" class=\"headerlink\" title=\"zlog\"></a>zlog</h2><p><a href=\"https://blog.csdn.net/twd_1991/article/details/80481920\">https://blog.csdn.net/twd_1991/article/details/80481920</a></p>\n<p><a href=\"http://hardysimpson.github.io/zlog/UsersGuide-CN.html\">http://hardysimpson.github.io/zlog/UsersGuide-CN.html</a></p>\n<h2 id=\"gdb\"><a href=\"#gdb\" class=\"headerlink\" title=\"gdb\"></a>gdb</h2><p><a href=\"https://leetcode-cn.com/circle/article/7mxorv\">https://leetcode-cn.com/circle/article/7mxorv</a></p>"},{"title":"Hello World","_content":"\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\n\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n\n","slug":"hello-world","published":1,"date":"2021-10-25T15:41:26.082Z","updated":"2021-10-26T14:34:13.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8v500090guuhbykcppc","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></tbody></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"151FCAP","length":367,"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"leetcode刷题笔记","date":"2022-01-31T16:47:53.000Z","updated":"2022-01-31T16:53:53.000Z","_content":"\n## 双指针\n\n### 3 [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n> 思路：前后两个指针，从零开始向字符串尾移动，和一个标记字符在两个指针中间的表，判断前指针字符是否在表中，不在，记录表中，右指针加一；在，左指针对应字符提出表，左指针加一；左右指针差的最大值即为最长长度。\n\n<!--more-->\n\n```c\nint lengthOfLongestSubstring(char * s){\n    int len = strlen(s);\n    int left = 0;\n    int right = 0;\n    char table[256] = {0};\n    int maxLen = 0;\n    while (right < len) {\n        if (table[s[right]] == 0) {\n            table[s[right]] = 1;\n            right++;\n        //} else if (table[s[right]] == 1) {\n        } else {\n            table[s[left]] = 0;\n            left++;\n        }\n        maxLen = fmax(maxLen, right - left);\n    }\n    return maxLen;\n}\n```\n\n\n## 并查集\n\n### 128.[最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)\n\n```c\ntypedef struct {\n    int key;\n    int cnt;\n    UT_hash_handle hh;\n} Hash;\n\nHash *g_usrs = NULL;\n\nvoid AddUser(int key)\n{\n    Hash *cur_usr = NULL;\n    HASH_FIND_INT(g_usrs, &key, cur_usr);\n    if (cur_usr == NULL) {\n        cur_usr = (Hash *)malloc(sizeof(Hash));\n        cur_usr->key = key;\n        cur_usr->cnt = 1;\n        HASH_ADD_INT(g_usrs, key, cur_usr);\n    } else {\n        cur_usr->cnt++;\n    }\n}\n\nbool FindUser(int key)\n{\n    Hash *cur_usr = NULL;\n    HASH_FIND_INT(g_usrs, &key, cur_usr);\n    if (cur_usr == NULL) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nint Cmp(const void *a, const void *b)\n{\n    return *(int *)a - *(int *)b;\n}\n\nint longestConsecutive(int* nums, int numsSize)\n{\n    int res = 0, local = 0;\n    g_usrs = NULL;\n    for (int i = 0; i < numsSize; i++) {\n        AddUser(nums[i]);\n    }\n    HASH_SORT(g_usrs, Cmp);\n    Hash *cur_usr = NULL;\n    Hash *next_usr = NULL;\n    HASH_ITER(hh, g_usrs, cur_usr, next_usr) {\n        if (next_usr != NULL) {\n            if (next_usr->key - cur_usr->key == 1) {\n                local++;\n            } else {\n                local = 0;\n            }\n        }\n        res = fmax(res, local + 1);\n    }\n    return res;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2022/leetcode刷题笔记.md","raw":"---\ntitle: leetcode刷题笔记\ndate: 2022-02-01 00:47:53\nupdated: 2022-02-01  00:53:53\ncategories: \n    - tool\ntags: \n    - 实用教程\n    - Another Tag\n---\n\n## 双指针\n\n### 3 [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n> 思路：前后两个指针，从零开始向字符串尾移动，和一个标记字符在两个指针中间的表，判断前指针字符是否在表中，不在，记录表中，右指针加一；在，左指针对应字符提出表，左指针加一；左右指针差的最大值即为最长长度。\n\n<!--more-->\n\n```c\nint lengthOfLongestSubstring(char * s){\n    int len = strlen(s);\n    int left = 0;\n    int right = 0;\n    char table[256] = {0};\n    int maxLen = 0;\n    while (right < len) {\n        if (table[s[right]] == 0) {\n            table[s[right]] = 1;\n            right++;\n        //} else if (table[s[right]] == 1) {\n        } else {\n            table[s[left]] = 0;\n            left++;\n        }\n        maxLen = fmax(maxLen, right - left);\n    }\n    return maxLen;\n}\n```\n\n\n## 并查集\n\n### 128.[最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)\n\n```c\ntypedef struct {\n    int key;\n    int cnt;\n    UT_hash_handle hh;\n} Hash;\n\nHash *g_usrs = NULL;\n\nvoid AddUser(int key)\n{\n    Hash *cur_usr = NULL;\n    HASH_FIND_INT(g_usrs, &key, cur_usr);\n    if (cur_usr == NULL) {\n        cur_usr = (Hash *)malloc(sizeof(Hash));\n        cur_usr->key = key;\n        cur_usr->cnt = 1;\n        HASH_ADD_INT(g_usrs, key, cur_usr);\n    } else {\n        cur_usr->cnt++;\n    }\n}\n\nbool FindUser(int key)\n{\n    Hash *cur_usr = NULL;\n    HASH_FIND_INT(g_usrs, &key, cur_usr);\n    if (cur_usr == NULL) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nint Cmp(const void *a, const void *b)\n{\n    return *(int *)a - *(int *)b;\n}\n\nint longestConsecutive(int* nums, int numsSize)\n{\n    int res = 0, local = 0;\n    g_usrs = NULL;\n    for (int i = 0; i < numsSize; i++) {\n        AddUser(nums[i]);\n    }\n    HASH_SORT(g_usrs, Cmp);\n    Hash *cur_usr = NULL;\n    Hash *next_usr = NULL;\n    HASH_ITER(hh, g_usrs, cur_usr, next_usr) {\n        if (next_usr != NULL) {\n            if (next_usr->key - cur_usr->key == 1) {\n                local++;\n            } else {\n                local = 0;\n            }\n        }\n        res = fmax(res, local + 1);\n    }\n    return res;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2022/leetcode刷题笔记","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8v8000b0guu4kp4apw3","content":"<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><h3 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3 无重复字符的最长子串\"></a>3 <a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">无重复字符的最长子串</a></h3><blockquote>\n<p>思路：前后两个指针，从零开始向字符串尾移动，和一个标记字符在两个指针中间的表，判断前指针字符是否在表中，不在，记录表中，右指针加一；在，左指针对应字符提出表，左指针加一；左右指针差的最大值即为最长长度。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> table[<span class=\"number\">256</span>] = {<span class=\"number\">0</span>};</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right &lt; len) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[s[right]] == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            table[s[right]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        <span class=\"comment\">//} else if (table[s[right]] == 1) {</span></span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            table[s[left]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        maxLen = fmax(maxLen, right - left);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h2 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h2><h3 id=\"128-最长连续序列\"><a href=\"#128-最长连续序列\" class=\"headerlink\" title=\"128.最长连续序列\"></a>128.<a href=\"https://leetcode-cn.com/problems/longest-consecutive-sequence/\">最长连续序列</a></h3><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt;</span><br><span class=\"line\">    UT_hash_handle hh;</span><br><span class=\"line\">} Hash;</span><br><span class=\"line\"></span><br><span class=\"line\">Hash *g_usrs = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AddUser</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Hash *cur_usr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    HASH_FIND_INT(g_usrs, &amp;key, cur_usr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur_usr == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        cur_usr = (Hash *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Hash));</span><br><span class=\"line\">        cur_usr-&gt;key = key;</span><br><span class=\"line\">        cur_usr-&gt;cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">        HASH_ADD_INT(g_usrs, key, cur_usr);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        cur_usr-&gt;cnt++;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">FindUser</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Hash *cur_usr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    HASH_FIND_INT(g_usrs, &amp;key, cur_usr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur_usr == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">int</span> *)a - *(<span class=\"keyword\">int</span> *)b;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestConsecutive</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, local = <span class=\"number\">0</span>;</span><br><span class=\"line\">    g_usrs = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        AddUser(nums[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    HASH_SORT(g_usrs, Cmp);</span><br><span class=\"line\">    Hash *cur_usr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Hash *next_usr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    HASH_ITER(hh, g_usrs, cur_usr, next_usr) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next_usr != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next_usr-&gt;key - cur_usr-&gt;key == <span class=\"number\">1</span>) {</span><br><span class=\"line\">                local++;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                local = <span class=\"number\">0</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        res = fmax(res, local + <span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"RVN12Q","length":1564,"excerpt":"<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><h3 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3 无重复字符的最长子串\"></a>3 <a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">无重复字符的最长子串</a></h3><blockquote>\n<p>思路：前后两个指针，从零开始向字符串尾移动，和一个标记字符在两个指针中间的表，判断前指针字符是否在表中，不在，记录表中，右指针加一；在，左指针对应字符提出表，左指针加一；左右指针差的最大值即为最长长度。</p>\n</blockquote>","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> table[<span class=\"number\">256</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right &lt; len) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[s[right]] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            table[s[right]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        <span class=\"comment\">//&#125; else if (table[s[right]] == 1) &#123;</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            table[s[left]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        maxLen = fmax(maxLen, right - left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h2><h3 id=\"128-最长连续序列\"><a href=\"#128-最长连续序列\" class=\"headerlink\" title=\"128.最长连续序列\"></a>128.<a href=\"https://leetcode-cn.com/problems/longest-consecutive-sequence/\">最长连续序列</a></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt;</span><br><span class=\"line\">    UT_hash_handle hh;</span><br><span class=\"line\">&#125; Hash;</span><br><span class=\"line\"></span><br><span class=\"line\">Hash *g_usrs = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AddUser</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Hash *cur_usr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    HASH_FIND_INT(g_usrs, &amp;key, cur_usr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur_usr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        cur_usr = (Hash *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Hash));</span><br><span class=\"line\">        cur_usr-&gt;key = key;</span><br><span class=\"line\">        cur_usr-&gt;cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">        HASH_ADD_INT(g_usrs, key, cur_usr);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cur_usr-&gt;cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">FindUser</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Hash *cur_usr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    HASH_FIND_INT(g_usrs, &amp;key, cur_usr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur_usr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">int</span> *)a - *(<span class=\"keyword\">int</span> *)b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestConsecutive</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, local = <span class=\"number\">0</span>;</span><br><span class=\"line\">    g_usrs = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        AddUser(nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    HASH_SORT(g_usrs, Cmp);</span><br><span class=\"line\">    Hash *cur_usr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Hash *next_usr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    HASH_ITER(hh, g_usrs, cur_usr, next_usr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next_usr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next_usr-&gt;key - cur_usr-&gt;key == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                local++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                local = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = fmax(res, local + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"c语言","date":"2022-01-19T16:47:53.000Z","updated":"2022-01-19T16:53:53.000Z","_content":"\n\n\n## 库函数\n\n<!--more-->\n\n### string.h\n#### strcpy 字符串复制函数\n```c\n// strDestination 目的字符串；strSource 源字符串\nchar* strcpy(char* strDestination, const char* strSource);\n// strcpy() 会把 strSource 指向的字符串复制到 strDestination。\n// 返回值：目的字符串，也即 strDestination。\n    char dest[50] = { 0 };\n    char src[50] = { \"http://c.biancheng.net\" };\n    strcpy(dest, src);\n```\n\n#### strlen 求字符串长度\n```c\n\n```\n\n\n#### strcspn 求字符串互补跨度(长度)\n```c\n// 回从字符串 str 开头算起，连续有几个字符都不在 reject 中；也就是说，str 中连续有几个字符和 reject 没有交集\n// str 要检索的字符串\n// reject 该字符串包含要在str中进行匹配的字符列表\nsize_t strcspn(const char* str, const char* reject);\n// 返回值：返回从字符串 str 开头算起，连续不在 reject 中的字符的个数；也可以理解为，str 中第一次出现 reject 中字符的位置。\nchar str[50] = { \"http://c.biancheng.net\" };\nchar keys[50] = { \"?.,:\\\"\\'-!\" };\nint i = strcspn(str, keys);\n// i = 4\n```\n\n#### strcmp 比较两个字符串\n```c\n// strcmp() 会根据 ASCII 编码依次比较 str1 和 str2 的每一个字符，直到出现不到的字符，或者到达字符串末尾（遇见\\0）\nint strcmp(const char* str1, const char* str2);\n\nchar str1[50] = { 0 };\nchar str2[50] = { 0 };\nstrcmp(str1, str2)\n```\n返回值：\n- 如果返回值 < 0，则表示 str1 小于 str2。\n- 如果返回值 > 0，则表示 str2 小于 str1。\n- 如果返回值 = 0，则表示 str1 等于 str2。\n\n\n#### strchr 字符查找函数\n- strchr() 函数会依次检索字符串 str 中的每一个字符，直到遇见字符 c，或者到达字符串末尾（遇见\\0）。\n```c\n// str 被查找的字符串\n// c  要查找的字符\nchar* strchr(const char* str, int c);\n\nconst char *str = \"http://c.biancheng.net/\";\nint c = 'g';\nchar *p = strchr(str, c);\n```\n返回值：\n- 返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符 c 则返回 NULL。\n\n#### strcat 字符串拼接\n- strcat() 函数把 strSource 所指向的字符串追加到 strDestination 所指向的字符串的结尾\n```c\n// strDestination 目的字符串\n// strSource  源字符串\nchar* strcat(char* strDestination, const char* strSource);\n\nchar str1[101] = { 0 };\nchar str2[50] = { 0 };\nstrcat(str1, str2);\n```\n返回值：\n- 指向 strDestination 的指针。\n\n\n\n### ctype.h\n\n#### isupper 判断一个字符是否是大写字母\n```c\n// c\nint isupper(int c);\n\nchar str[] = \"C++ Java Python C# Linux Golang Shell\\n\";\nint re = isupper(s[i]);\n```\n返回值：\n- 返回值为非 0（真）表示 c 是大写字母，返回值为 0（假）表示 c 不是大写字母。\n\n#### islower 判断一个字符是否是小写字母\n```c\nint islower(int c);\n\nchar c = 'a';\nint re = islower(c);\n```\n\n\n#### isspace 判断一个字符是否是空白字符\n\n```c\n// \nint isspace(int c);\n\nint i = 0;\nchar str[] = \"Linux C++\\tPython Shell\\nC# Java\\n\";\nwhile (str[i]) {\n    if(isspace(s[i])) {\n        printf(\"c = %c \", s[i]);\n    }\n    i++;\n}\n```\n- 空白字符：空格、水平制表符、换行符、垂直制表符、换页、回车\n返回值：\n- 返回值为非 0（真）表示c是空白符，返回值为 0（假）表示c不是空白符。\n\n\n#### isprint 判断一个字符是否是可打印字符\n```c\nint isprint(int c);\n\nint i=0;\nchar str[]=\"C++ Java \\n C# Python \\t Shell Linux\\n\";\nwhile(str[i]) {\n    if(isprint(str[i])) putchar (str[i]);\n    i++;\n}\n// C++ Java  C# Python  Shell Linux\n```\n- 可打印字符和控制字符是相对的，控制字符是指那些具有某种特殊功能、不会显示在屏幕上、不会占用字符位置的“特殊”字符。要检测一个字符是否是控制字符，请使用 iscntrl() 函数\n返回值：\n- 返回值为非 0（真）表示 c 是可打印字符，返回值为 0（假）表示 c 不是可打印字符。\n\n\n\n#### isgraph 判断一个字符是否是图形字符\n- 字符是图形字符，就是说这个字符需要在显示器上绘制出来，而空格、换行、Tab 缩进等字符只会占用输出的位置，不需要绘制。\n```c\nint isgraph(int c);\n\nchar c = '';\nint res = isgraph(c)\n```\n返回值\n- 返回值为非 0（真）表示 c 是图形字符，返回值为 0（假）表示 c 不是图形字符。\n\n#### iscntrl 判断一个字符是否为控制字符\n- “控制字符”是指那些具有某种特殊功能、不会显示在屏幕上、不会占用字符位置的特殊字符。默认情况下，C语言使用的是 ASCII 编码，控制字符的范围是0x00 (NUL) ~ 0x1f (US)，再加上最后的0x7f (DEL)，一共 33 个。\n```c\nint iscntrl(int c);\n\nint res = iscntrl(c);\n```\n返回值\n- 返回值为非 0（真）表示 c 是控制字符，返回值为 0（假）表示 c 不是控制字符。\n\n\n#### isdigit  判断一个字符是否为数字\n- isdigit() 函数用来判断一个字符是否是数字，也即 0~9。\n```c\nint isdigit(int c);\n\nchar s[50] = {0};\nint res = isdigit(s[i]);\n```\n返回值\n- 返回值为非 0（真）表示 c 是数字，返回值为 0（假）表示 c 不是数字。\n\n#### isalpha 判断一个字符是否是字母\n- isalpha() 函数用来检测一个字符是否是字母，包括大写字母和小写字母。\n```c\nint isalpha(int c);\n\nchar str[] = \"C++ Java C#\";\nwhile (str[i]) {\n    if (isalpha(str[i])) {\n        printf(\"%c is alphabetic\\n\", str[i]);\n    } else {\n        printf(\"%c is not alphabetic\\n\", str[i]);\n    }\n    i++;\n}\n```\n返回值\n- 回非 0（真）表示 c 是字母，返回 0（假）表示 c 不是字母。\n\n\n#### isalnum 判断一个字符是否是字母或数字\n-  isalnum() 函数用于判断一个字符是否是字母（包括大写字母和小写字母）或者数字（0~9）。\n```c\nint isalnum(int c);\n\nchar str[] = \"*http://c.biancheng.net is 7 years old\";\nwhile (str[i]) {\n    if (isalnum(str[i])) n++;\n    i++;\n}\n```\n返回值\n- 返回非 0（真）表示 c 是字母或者数字，返回 0（假）表示 c 既不是数字也不是字母。\n\n\n\n### math.h\n\n#### ldexp \n返回x乘以2的exponent次方\n- ldexp() 函数用来计算 x 乘以 2 的 exponent 次方（次幂）的值，也即返回 x * 2^exponent 的值。\n```c\n// x 双精度浮点数\n// exponnent  2的指数\ndouble ldexp(double x, int exponent);\n\ndouble f=0.964453, n=7;  //为变量赋初值\ndouble x = ldexp(f, n);  //求f * 2^n 的结果\n```\n返回值：\n- x*2^exponent 的计算结果\n\n\n#### labs 求整数的绝对值(针对long类型)\n```c\nlong labs(long n);\n\nlong m = 11;\nlong a = labs(m); // 求m的绝对值\n```\n返回值：\n- 参数n的绝对值\n\n#### abs 求整数的绝对值\n- abs()函数用于求整数的绝对值\n```c\nint abs(int n);\n\nint a = 3, b = -4, c, d;  //为变量赋初值\nc = abs(a);  //求a的绝对值\nd = abs(b);  //求b的绝对值\n```\n返回值\n- 参数的绝对值\n\n#### pow 求x的y次方的值\n-  pow() 函数用来求 x 的 y 次方的值。\n```c\n// x 双精度数  y 双精度数\ndouble pow(double x, double y);\n\ndouble x = 4, y = 6;  //为变量赋初值\ndouble result = pow(x, y);  //求a的b次方\n```\n返回值\n- x 的 y 次方的值。\n\n#### frexp 提取浮点数的尾数和指数部分\n- rexp() 函数用来提取一个浮点数（小数）的指数部分和尾数部分。\n```c\n// x 要被计算的浮点数\n// exponent  一个指向指数部分的指针\ndouble frexp(double x, int* exponent);\n\n\nint exp;\ndouble mant = frexp(19.625, &exp);\n```\n指数部分被存入参数 exponent 中，尾数部分被放入返回值中，最终 x = mantissa * 2 ^ exponent（mantissa 表示尾数）。\n返回值\n- 浮点数 x 的尾数部分。\n\n#### modf 提取浮点数的小数和整数部分\n- double modf(double x, double *intptr) 将提取浮点数 x 的整数部分和小数部分，整数部分被存入参数 intptr 中，小数部分被放入返回值中。\n```c\n// x 要被计算的浮点数\n// 一个指向整数部分的指针\ndouble modf(double x, double *intptr);\n\n\ndouble x=3.1415, intpart;  //为变量赋初值\ndouble fractpart = modf(x, &intpart);  //求3.1415的小数部分\n```\n返回值\n- x的小数部分\n\n#### fmod 求x/y的余数(针对浮点数)\n- fmod()函数用于求x/y的余数，针对浮点数。\n```c\ndouble fmod(double x, double y);\n\ndouble m=10.1, n=3.1;  //为变量赋初值\ndouble x = fmod(m,n);  //求m/n的余数\n```\n返回值\n- x/y的余数\n\n\n\n#### log10 返回以10为底的对数\n\n```c\n\n```\n\n\n#### log 返回x的自然对数\n\n```c\n\n```\n\n#### ceil 求不小于x的最小整数\n- ceil() 函数用于求不小于 x 的最小整数，也即向上取整。\n```c\ndouble ceil(double x);\n\ndouble m = 6.123;\nint n = ceil(m);  //求不小于m的最小整数\n```\n返回值\n- 不小于x的最小整数\n\n\n#### floor 求不大于x的最大整数（向下取整）\n- floor() 函数用于求不大于 x 的最大整数，也即向下取整。\n```c\ndouble floor(double x);\n\ndouble m = 6.123;  //为变量赋初值\ndouble n = floor(m);  //求不大于m的最大整数\n```\n返回值\n- 不大于x的最大整数\n\n\n### stdlib.h\n\n#### ldiv 求两个数的商和余数\n- ldiv() 函数用于求两个长整型数的商和余数。\n```c\n// numer 被除数  denom 除数\nldiv_t ldiv(long int numer, long int denom);\n\nlong x = 234, y = 23;  //为变量赋初值\nldiv_t a = ldiv(x, y);  //求234除以23的商和余数\n```\n返回值\n- ldiv_t 类型的商和余数\nldiv_t 是在 stdlib.h 头文件中定义的结构体，它有两个成员，分别是 quot 和 rem：quot 表示商，rem 表示余数。\n\n#### div 求两个数的商和余数\n- div()函数用于求两个数的商和余数\n```c\n// numer 是被除数  denom 除数\ndiv_t div(int numer, int denom);\n\n\nint x = 512, y = 28;  //为变量赋初值\ndiv_t a = div(x, y);  //求512除以28的商和余数\n```\n返回值\n-- div_t 类型的商和余数\n\n\n参考链接：\nhttp://c.biancheng.net/c/ref/\n\n\n\n\n\n\n\n","source":"_posts/2022/c语言.md","raw":"---\ntitle: c语言\ndate: 2022-01-20 00:47:53\nupdated: 2022-01-20 00:53:53\ncategories: \n    - tool\ntags: \n    - Computer Science\n    - Another Tag\n---\n\n\n\n## 库函数\n\n<!--more-->\n\n### string.h\n#### strcpy 字符串复制函数\n```c\n// strDestination 目的字符串；strSource 源字符串\nchar* strcpy(char* strDestination, const char* strSource);\n// strcpy() 会把 strSource 指向的字符串复制到 strDestination。\n// 返回值：目的字符串，也即 strDestination。\n    char dest[50] = { 0 };\n    char src[50] = { \"http://c.biancheng.net\" };\n    strcpy(dest, src);\n```\n\n#### strlen 求字符串长度\n```c\n\n```\n\n\n#### strcspn 求字符串互补跨度(长度)\n```c\n// 回从字符串 str 开头算起，连续有几个字符都不在 reject 中；也就是说，str 中连续有几个字符和 reject 没有交集\n// str 要检索的字符串\n// reject 该字符串包含要在str中进行匹配的字符列表\nsize_t strcspn(const char* str, const char* reject);\n// 返回值：返回从字符串 str 开头算起，连续不在 reject 中的字符的个数；也可以理解为，str 中第一次出现 reject 中字符的位置。\nchar str[50] = { \"http://c.biancheng.net\" };\nchar keys[50] = { \"?.,:\\\"\\'-!\" };\nint i = strcspn(str, keys);\n// i = 4\n```\n\n#### strcmp 比较两个字符串\n```c\n// strcmp() 会根据 ASCII 编码依次比较 str1 和 str2 的每一个字符，直到出现不到的字符，或者到达字符串末尾（遇见\\0）\nint strcmp(const char* str1, const char* str2);\n\nchar str1[50] = { 0 };\nchar str2[50] = { 0 };\nstrcmp(str1, str2)\n```\n返回值：\n- 如果返回值 < 0，则表示 str1 小于 str2。\n- 如果返回值 > 0，则表示 str2 小于 str1。\n- 如果返回值 = 0，则表示 str1 等于 str2。\n\n\n#### strchr 字符查找函数\n- strchr() 函数会依次检索字符串 str 中的每一个字符，直到遇见字符 c，或者到达字符串末尾（遇见\\0）。\n```c\n// str 被查找的字符串\n// c  要查找的字符\nchar* strchr(const char* str, int c);\n\nconst char *str = \"http://c.biancheng.net/\";\nint c = 'g';\nchar *p = strchr(str, c);\n```\n返回值：\n- 返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符 c 则返回 NULL。\n\n#### strcat 字符串拼接\n- strcat() 函数把 strSource 所指向的字符串追加到 strDestination 所指向的字符串的结尾\n```c\n// strDestination 目的字符串\n// strSource  源字符串\nchar* strcat(char* strDestination, const char* strSource);\n\nchar str1[101] = { 0 };\nchar str2[50] = { 0 };\nstrcat(str1, str2);\n```\n返回值：\n- 指向 strDestination 的指针。\n\n\n\n### ctype.h\n\n#### isupper 判断一个字符是否是大写字母\n```c\n// c\nint isupper(int c);\n\nchar str[] = \"C++ Java Python C# Linux Golang Shell\\n\";\nint re = isupper(s[i]);\n```\n返回值：\n- 返回值为非 0（真）表示 c 是大写字母，返回值为 0（假）表示 c 不是大写字母。\n\n#### islower 判断一个字符是否是小写字母\n```c\nint islower(int c);\n\nchar c = 'a';\nint re = islower(c);\n```\n\n\n#### isspace 判断一个字符是否是空白字符\n\n```c\n// \nint isspace(int c);\n\nint i = 0;\nchar str[] = \"Linux C++\\tPython Shell\\nC# Java\\n\";\nwhile (str[i]) {\n    if(isspace(s[i])) {\n        printf(\"c = %c \", s[i]);\n    }\n    i++;\n}\n```\n- 空白字符：空格、水平制表符、换行符、垂直制表符、换页、回车\n返回值：\n- 返回值为非 0（真）表示c是空白符，返回值为 0（假）表示c不是空白符。\n\n\n#### isprint 判断一个字符是否是可打印字符\n```c\nint isprint(int c);\n\nint i=0;\nchar str[]=\"C++ Java \\n C# Python \\t Shell Linux\\n\";\nwhile(str[i]) {\n    if(isprint(str[i])) putchar (str[i]);\n    i++;\n}\n// C++ Java  C# Python  Shell Linux\n```\n- 可打印字符和控制字符是相对的，控制字符是指那些具有某种特殊功能、不会显示在屏幕上、不会占用字符位置的“特殊”字符。要检测一个字符是否是控制字符，请使用 iscntrl() 函数\n返回值：\n- 返回值为非 0（真）表示 c 是可打印字符，返回值为 0（假）表示 c 不是可打印字符。\n\n\n\n#### isgraph 判断一个字符是否是图形字符\n- 字符是图形字符，就是说这个字符需要在显示器上绘制出来，而空格、换行、Tab 缩进等字符只会占用输出的位置，不需要绘制。\n```c\nint isgraph(int c);\n\nchar c = '';\nint res = isgraph(c)\n```\n返回值\n- 返回值为非 0（真）表示 c 是图形字符，返回值为 0（假）表示 c 不是图形字符。\n\n#### iscntrl 判断一个字符是否为控制字符\n- “控制字符”是指那些具有某种特殊功能、不会显示在屏幕上、不会占用字符位置的特殊字符。默认情况下，C语言使用的是 ASCII 编码，控制字符的范围是0x00 (NUL) ~ 0x1f (US)，再加上最后的0x7f (DEL)，一共 33 个。\n```c\nint iscntrl(int c);\n\nint res = iscntrl(c);\n```\n返回值\n- 返回值为非 0（真）表示 c 是控制字符，返回值为 0（假）表示 c 不是控制字符。\n\n\n#### isdigit  判断一个字符是否为数字\n- isdigit() 函数用来判断一个字符是否是数字，也即 0~9。\n```c\nint isdigit(int c);\n\nchar s[50] = {0};\nint res = isdigit(s[i]);\n```\n返回值\n- 返回值为非 0（真）表示 c 是数字，返回值为 0（假）表示 c 不是数字。\n\n#### isalpha 判断一个字符是否是字母\n- isalpha() 函数用来检测一个字符是否是字母，包括大写字母和小写字母。\n```c\nint isalpha(int c);\n\nchar str[] = \"C++ Java C#\";\nwhile (str[i]) {\n    if (isalpha(str[i])) {\n        printf(\"%c is alphabetic\\n\", str[i]);\n    } else {\n        printf(\"%c is not alphabetic\\n\", str[i]);\n    }\n    i++;\n}\n```\n返回值\n- 回非 0（真）表示 c 是字母，返回 0（假）表示 c 不是字母。\n\n\n#### isalnum 判断一个字符是否是字母或数字\n-  isalnum() 函数用于判断一个字符是否是字母（包括大写字母和小写字母）或者数字（0~9）。\n```c\nint isalnum(int c);\n\nchar str[] = \"*http://c.biancheng.net is 7 years old\";\nwhile (str[i]) {\n    if (isalnum(str[i])) n++;\n    i++;\n}\n```\n返回值\n- 返回非 0（真）表示 c 是字母或者数字，返回 0（假）表示 c 既不是数字也不是字母。\n\n\n\n### math.h\n\n#### ldexp \n返回x乘以2的exponent次方\n- ldexp() 函数用来计算 x 乘以 2 的 exponent 次方（次幂）的值，也即返回 x * 2^exponent 的值。\n```c\n// x 双精度浮点数\n// exponnent  2的指数\ndouble ldexp(double x, int exponent);\n\ndouble f=0.964453, n=7;  //为变量赋初值\ndouble x = ldexp(f, n);  //求f * 2^n 的结果\n```\n返回值：\n- x*2^exponent 的计算结果\n\n\n#### labs 求整数的绝对值(针对long类型)\n```c\nlong labs(long n);\n\nlong m = 11;\nlong a = labs(m); // 求m的绝对值\n```\n返回值：\n- 参数n的绝对值\n\n#### abs 求整数的绝对值\n- abs()函数用于求整数的绝对值\n```c\nint abs(int n);\n\nint a = 3, b = -4, c, d;  //为变量赋初值\nc = abs(a);  //求a的绝对值\nd = abs(b);  //求b的绝对值\n```\n返回值\n- 参数的绝对值\n\n#### pow 求x的y次方的值\n-  pow() 函数用来求 x 的 y 次方的值。\n```c\n// x 双精度数  y 双精度数\ndouble pow(double x, double y);\n\ndouble x = 4, y = 6;  //为变量赋初值\ndouble result = pow(x, y);  //求a的b次方\n```\n返回值\n- x 的 y 次方的值。\n\n#### frexp 提取浮点数的尾数和指数部分\n- rexp() 函数用来提取一个浮点数（小数）的指数部分和尾数部分。\n```c\n// x 要被计算的浮点数\n// exponent  一个指向指数部分的指针\ndouble frexp(double x, int* exponent);\n\n\nint exp;\ndouble mant = frexp(19.625, &exp);\n```\n指数部分被存入参数 exponent 中，尾数部分被放入返回值中，最终 x = mantissa * 2 ^ exponent（mantissa 表示尾数）。\n返回值\n- 浮点数 x 的尾数部分。\n\n#### modf 提取浮点数的小数和整数部分\n- double modf(double x, double *intptr) 将提取浮点数 x 的整数部分和小数部分，整数部分被存入参数 intptr 中，小数部分被放入返回值中。\n```c\n// x 要被计算的浮点数\n// 一个指向整数部分的指针\ndouble modf(double x, double *intptr);\n\n\ndouble x=3.1415, intpart;  //为变量赋初值\ndouble fractpart = modf(x, &intpart);  //求3.1415的小数部分\n```\n返回值\n- x的小数部分\n\n#### fmod 求x/y的余数(针对浮点数)\n- fmod()函数用于求x/y的余数，针对浮点数。\n```c\ndouble fmod(double x, double y);\n\ndouble m=10.1, n=3.1;  //为变量赋初值\ndouble x = fmod(m,n);  //求m/n的余数\n```\n返回值\n- x/y的余数\n\n\n\n#### log10 返回以10为底的对数\n\n```c\n\n```\n\n\n#### log 返回x的自然对数\n\n```c\n\n```\n\n#### ceil 求不小于x的最小整数\n- ceil() 函数用于求不小于 x 的最小整数，也即向上取整。\n```c\ndouble ceil(double x);\n\ndouble m = 6.123;\nint n = ceil(m);  //求不小于m的最小整数\n```\n返回值\n- 不小于x的最小整数\n\n\n#### floor 求不大于x的最大整数（向下取整）\n- floor() 函数用于求不大于 x 的最大整数，也即向下取整。\n```c\ndouble floor(double x);\n\ndouble m = 6.123;  //为变量赋初值\ndouble n = floor(m);  //求不大于m的最大整数\n```\n返回值\n- 不大于x的最大整数\n\n\n### stdlib.h\n\n#### ldiv 求两个数的商和余数\n- ldiv() 函数用于求两个长整型数的商和余数。\n```c\n// numer 被除数  denom 除数\nldiv_t ldiv(long int numer, long int denom);\n\nlong x = 234, y = 23;  //为变量赋初值\nldiv_t a = ldiv(x, y);  //求234除以23的商和余数\n```\n返回值\n- ldiv_t 类型的商和余数\nldiv_t 是在 stdlib.h 头文件中定义的结构体，它有两个成员，分别是 quot 和 rem：quot 表示商，rem 表示余数。\n\n#### div 求两个数的商和余数\n- div()函数用于求两个数的商和余数\n```c\n// numer 是被除数  denom 除数\ndiv_t div(int numer, int denom);\n\n\nint x = 512, y = 28;  //为变量赋初值\ndiv_t a = div(x, y);  //求512除以28的商和余数\n```\n返回值\n-- div_t 类型的商和余数\n\n\n参考链接：\nhttp://c.biancheng.net/c/ref/\n\n\n\n\n\n\n\n","slug":"2022/c语言","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8vc000e0guu78qy3x9e","content":"<h2 id=\"库函数\"><a href=\"#库函数\" class=\"headerlink\" title=\"库函数\"></a>库函数</h2><span id=\"more\"></span>\n\n<h3 id=\"string-h\"><a href=\"#string-h\" class=\"headerlink\" title=\"string.h\"></a>string.h</h3><h4 id=\"strcpy-字符串复制函数\"><a href=\"#strcpy-字符串复制函数\" class=\"headerlink\" title=\"strcpy 字符串复制函数\"></a>strcpy 字符串复制函数</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// strDestination 目的字符串；strSource 源字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* strDestination, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* strSource)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// strcpy() 会把 strSource 指向的字符串复制到 strDestination。</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值：目的字符串，也即 strDestination。</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> dest[<span class=\"number\">50</span>] = { <span class=\"number\">0</span> };</span><br><span class=\"line\">    <span class=\"keyword\">char</span> src[<span class=\"number\">50</span>] = { <span class=\"string\">\"http://c.biancheng.net\"</span> };</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(dest, src);</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"strlen-求字符串长度\"><a href=\"#strlen-求字符串长度\" class=\"headerlink\" title=\"strlen 求字符串长度\"></a>strlen 求字符串长度</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n\n<h4 id=\"strcspn-求字符串互补跨度-长度\"><a href=\"#strcspn-求字符串互补跨度-长度\" class=\"headerlink\" title=\"strcspn 求字符串互补跨度(长度)\"></a>strcspn 求字符串互补跨度(长度)</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 回从字符串 str 开头算起，连续有几个字符都不在 reject 中；也就是说，str 中连续有几个字符和 reject 没有交集</span></span><br><span class=\"line\"><span class=\"comment\">// str 要检索的字符串</span></span><br><span class=\"line\"><span class=\"comment\">// reject 该字符串包含要在str中进行匹配的字符列表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">strcspn</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* reject)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 返回值：返回从字符串 str 开头算起，连续不在 reject 中的字符的个数；也可以理解为，str 中第一次出现 reject 中字符的位置。</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">50</span>] = { <span class=\"string\">\"http://c.biancheng.net\"</span> };</span><br><span class=\"line\"><span class=\"keyword\">char</span> keys[<span class=\"number\">50</span>] = { <span class=\"string\">\"?.,:\\\"\\'-!\"</span> };</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"built_in\">strcspn</span>(str, keys);</span><br><span class=\"line\"><span class=\"comment\">// i = 4</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"strcmp-比较两个字符串\"><a href=\"#strcmp-比较两个字符串\" class=\"headerlink\" title=\"strcmp 比较两个字符串\"></a>strcmp 比较两个字符串</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// strcmp() 会根据 ASCII 编码依次比较 str1 和 str2 的每一个字符，直到出现不到的字符，或者到达字符串末尾（遇见\\0）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strcmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str1, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> str1[<span class=\"number\">50</span>] = { <span class=\"number\">0</span> };</span><br><span class=\"line\"><span class=\"keyword\">char</span> str2[<span class=\"number\">50</span>] = { <span class=\"number\">0</span> };</span><br><span class=\"line\"><span class=\"built_in\">strcmp</span>(str1, str2)</span><br></pre></td></tr></tbody></table></figure>\n<p>返回值：</p>\n<ul>\n<li>如果返回值 &lt; 0，则表示 str1 小于 str2。</li>\n<li>如果返回值 &gt; 0，则表示 str2 小于 str1。</li>\n<li>如果返回值 = 0，则表示 str1 等于 str2。</li>\n</ul>\n<h4 id=\"strchr-字符查找函数\"><a href=\"#strchr-字符查找函数\" class=\"headerlink\" title=\"strchr 字符查找函数\"></a>strchr 字符查找函数</h4><ul>\n<li>strchr() 函数会依次检索字符串 str 中的每一个字符，直到遇见字符 c，或者到达字符串末尾（遇见\\0）。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// str 被查找的字符串</span></span><br><span class=\"line\"><span class=\"comment\">// c  要查找的字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">strchr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str, <span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str = <span class=\"string\">\"http://c.biancheng.net/\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c = <span class=\"string\">'g'</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *p = <span class=\"built_in\">strchr</span>(str, c);</span><br></pre></td></tr></tbody></table></figure>\n返回值：</li>\n<li>返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符 c 则返回 NULL。</li>\n</ul>\n<h4 id=\"strcat-字符串拼接\"><a href=\"#strcat-字符串拼接\" class=\"headerlink\" title=\"strcat 字符串拼接\"></a>strcat 字符串拼接</h4><ul>\n<li>strcat() 函数把 strSource 所指向的字符串追加到 strDestination 所指向的字符串的结尾<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// strDestination 目的字符串</span></span><br><span class=\"line\"><span class=\"comment\">// strSource  源字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">strcat</span><span class=\"params\">(<span class=\"keyword\">char</span>* strDestination, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* strSource)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> str1[<span class=\"number\">101</span>] = { <span class=\"number\">0</span> };</span><br><span class=\"line\"><span class=\"keyword\">char</span> str2[<span class=\"number\">50</span>] = { <span class=\"number\">0</span> };</span><br><span class=\"line\"><span class=\"built_in\">strcat</span>(str1, str2);</span><br></pre></td></tr></tbody></table></figure>\n返回值：</li>\n<li>指向 strDestination 的指针。</li>\n</ul>\n<h3 id=\"ctype-h\"><a href=\"#ctype-h\" class=\"headerlink\" title=\"ctype.h\"></a>ctype.h</h3><h4 id=\"isupper-判断一个字符是否是大写字母\"><a href=\"#isupper-判断一个字符是否是大写字母\" class=\"headerlink\" title=\"isupper 判断一个字符是否是大写字母\"></a>isupper 判断一个字符是否是大写字母</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isupper</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> str[] = <span class=\"string\">\"C++ Java Python C# Linux Golang Shell\\n\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> re = <span class=\"built_in\">isupper</span>(s[i]);</span><br></pre></td></tr></tbody></table></figure>\n<p>返回值：</p>\n<ul>\n<li>返回值为非 0（真）表示 c 是大写字母，返回值为 0（假）表示 c 不是大写字母。</li>\n</ul>\n<h4 id=\"islower-判断一个字符是否是小写字母\"><a href=\"#islower-判断一个字符是否是小写字母\" class=\"headerlink\" title=\"islower 判断一个字符是否是小写字母\"></a>islower 判断一个字符是否是小写字母</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">islower</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> c = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> re = <span class=\"built_in\">islower</span>(c);</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h4 id=\"isspace-判断一个字符是否是空白字符\"><a href=\"#isspace-判断一个字符是否是空白字符\" class=\"headerlink\" title=\"isspace 判断一个字符是否是空白字符\"></a>isspace 判断一个字符是否是空白字符</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isspace</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str[] = <span class=\"string\">\"Linux C++\\tPython Shell\\nC# Java\\n\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (str[i]) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">isspace</span>(s[i])) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"c = %c \"</span>, s[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li>空白字符：空格、水平制表符、换行符、垂直制表符、换页、回车<br>返回值：</li>\n<li>返回值为非 0（真）表示c是空白符，返回值为 0（假）表示c不是空白符。</li>\n</ul>\n<h4 id=\"isprint-判断一个字符是否是可打印字符\"><a href=\"#isprint-判断一个字符是否是可打印字符\" class=\"headerlink\" title=\"isprint 判断一个字符是否是可打印字符\"></a>isprint 判断一个字符是否是可打印字符</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isprint</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str[]=<span class=\"string\">\"C++ Java \\n C# Python \\t Shell Linux\\n\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(str[i]) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">isprint</span>(str[i])) <span class=\"built_in\">putchar</span> (str[i]);</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// C++ Java  C# Python  Shell Linux</span></span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li>可打印字符和控制字符是相对的，控制字符是指那些具有某种特殊功能、不会显示在屏幕上、不会占用字符位置的“特殊”字符。要检测一个字符是否是控制字符，请使用 iscntrl() 函数<br>返回值：</li>\n<li>返回值为非 0（真）表示 c 是可打印字符，返回值为 0（假）表示 c 不是可打印字符。</li>\n</ul>\n<h4 id=\"isgraph-判断一个字符是否是图形字符\"><a href=\"#isgraph-判断一个字符是否是图形字符\" class=\"headerlink\" title=\"isgraph 判断一个字符是否是图形字符\"></a>isgraph 判断一个字符是否是图形字符</h4><ul>\n<li>字符是图形字符，就是说这个字符需要在显示器上绘制出来，而空格、换行、Tab 缩进等字符只会占用输出的位置，不需要绘制。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isgraph</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> c = <span class=\"string\">'';</span></span><br><span class=\"line\"><span class=\"string\">int res = isgraph(c)</span></span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>返回值为非 0（真）表示 c 是图形字符，返回值为 0（假）表示 c 不是图形字符。</li>\n</ul>\n<h4 id=\"iscntrl-判断一个字符是否为控制字符\"><a href=\"#iscntrl-判断一个字符是否为控制字符\" class=\"headerlink\" title=\"iscntrl 判断一个字符是否为控制字符\"></a>iscntrl 判断一个字符是否为控制字符</h4><ul>\n<li>“控制字符”是指那些具有某种特殊功能、不会显示在屏幕上、不会占用字符位置的特殊字符。默认情况下，C语言使用的是 ASCII 编码，控制字符的范围是0x00 (NUL) ~ 0x1f (US)，再加上最后的0x7f (DEL)，一共 33 个。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">iscntrl</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> res = <span class=\"built_in\">iscntrl</span>(c);</span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>返回值为非 0（真）表示 c 是控制字符，返回值为 0（假）表示 c 不是控制字符。</li>\n</ul>\n<h4 id=\"isdigit-判断一个字符是否为数字\"><a href=\"#isdigit-判断一个字符是否为数字\" class=\"headerlink\" title=\"isdigit  判断一个字符是否为数字\"></a>isdigit  判断一个字符是否为数字</h4><ul>\n<li>isdigit() 函数用来判断一个字符是否是数字，也即 0~9。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isdigit</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> s[<span class=\"number\">50</span>] = {<span class=\"number\">0</span>};</span><br><span class=\"line\"><span class=\"keyword\">int</span> res = <span class=\"built_in\">isdigit</span>(s[i]);</span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>返回值为非 0（真）表示 c 是数字，返回值为 0（假）表示 c 不是数字。</li>\n</ul>\n<h4 id=\"isalpha-判断一个字符是否是字母\"><a href=\"#isalpha-判断一个字符是否是字母\" class=\"headerlink\" title=\"isalpha 判断一个字符是否是字母\"></a>isalpha 判断一个字符是否是字母</h4><ul>\n<li>isalpha() 函数用来检测一个字符是否是字母，包括大写字母和小写字母。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isalpha</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> str[] = <span class=\"string\">\"C++ Java C#\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (str[i]) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isalpha</span>(str[i])) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c is alphabetic\\n\"</span>, str[i]);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c is not alphabetic\\n\"</span>, str[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>回非 0（真）表示 c 是字母，返回 0（假）表示 c 不是字母。</li>\n</ul>\n<h4 id=\"isalnum-判断一个字符是否是字母或数字\"><a href=\"#isalnum-判断一个字符是否是字母或数字\" class=\"headerlink\" title=\"isalnum 判断一个字符是否是字母或数字\"></a>isalnum 判断一个字符是否是字母或数字</h4><ul>\n<li> isalnum() 函数用于判断一个字符是否是字母（包括大写字母和小写字母）或者数字（0~9）。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isalnum</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> str[] = <span class=\"string\">\"*http://c.biancheng.net is 7 years old\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (str[i]) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isalnum</span>(str[i])) n++;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>返回非 0（真）表示 c 是字母或者数字，返回 0（假）表示 c 既不是数字也不是字母。</li>\n</ul>\n<h3 id=\"math-h\"><a href=\"#math-h\" class=\"headerlink\" title=\"math.h\"></a>math.h</h3><h4 id=\"ldexp\"><a href=\"#ldexp\" class=\"headerlink\" title=\"ldexp\"></a>ldexp</h4><p>返回x乘以2的exponent次方</p>\n<ul>\n<li>ldexp() 函数用来计算 x 乘以 2 的 exponent 次方（次幂）的值，也即返回 x * 2^exponent 的值。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x 双精度浮点数</span></span><br><span class=\"line\"><span class=\"comment\">// exponnent  2的指数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">ldexp</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span> exponent)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> f=<span class=\"number\">0.964453</span>, n=<span class=\"number\">7</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> x = <span class=\"built_in\">ldexp</span>(f, n);  <span class=\"comment\">//求f * 2^n 的结果</span></span><br></pre></td></tr></tbody></table></figure>\n返回值：</li>\n<li>x*2^exponent 的计算结果</li>\n</ul>\n<h4 id=\"labs-求整数的绝对值-针对long类型\"><a href=\"#labs-求整数的绝对值-针对long类型\" class=\"headerlink\" title=\"labs 求整数的绝对值(针对long类型)\"></a>labs 求整数的绝对值(针对long类型)</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">labs</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> m = <span class=\"number\">11</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> a = <span class=\"built_in\">labs</span>(m); <span class=\"comment\">// 求m的绝对值</span></span><br></pre></td></tr></tbody></table></figure>\n<p>返回值：</p>\n<ul>\n<li>参数n的绝对值</li>\n</ul>\n<h4 id=\"abs-求整数的绝对值\"><a href=\"#abs-求整数的绝对值\" class=\"headerlink\" title=\"abs 求整数的绝对值\"></a>abs 求整数的绝对值</h4><ul>\n<li>abs()函数用于求整数的绝对值<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">abs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">3</span>, b = <span class=\"number\">-4</span>, c, d;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\">c = <span class=\"built_in\">abs</span>(a);  <span class=\"comment\">//求a的绝对值</span></span><br><span class=\"line\">d = <span class=\"built_in\">abs</span>(b);  <span class=\"comment\">//求b的绝对值</span></span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>参数的绝对值</li>\n</ul>\n<h4 id=\"pow-求x的y次方的值\"><a href=\"#pow-求x的y次方的值\" class=\"headerlink\" title=\"pow 求x的y次方的值\"></a>pow 求x的y次方的值</h4><ul>\n<li> pow() 函数用来求 x 的 y 次方的值。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x 双精度数  y 双精度数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">pow</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> x = <span class=\"number\">4</span>, y = <span class=\"number\">6</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> result = <span class=\"built_in\">pow</span>(x, y);  <span class=\"comment\">//求a的b次方</span></span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>x 的 y 次方的值。</li>\n</ul>\n<h4 id=\"frexp-提取浮点数的尾数和指数部分\"><a href=\"#frexp-提取浮点数的尾数和指数部分\" class=\"headerlink\" title=\"frexp 提取浮点数的尾数和指数部分\"></a>frexp 提取浮点数的尾数和指数部分</h4><ul>\n<li>rexp() 函数用来提取一个浮点数（小数）的指数部分和尾数部分。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x 要被计算的浮点数</span></span><br><span class=\"line\"><span class=\"comment\">// exponent  一个指向指数部分的指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">frexp</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span>* exponent)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">exp</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> mant = <span class=\"built_in\">frexp</span>(<span class=\"number\">19.625</span>, &amp;<span class=\"built_in\">exp</span>);</span><br></pre></td></tr></tbody></table></figure>\n指数部分被存入参数 exponent 中，尾数部分被放入返回值中，最终 x = mantissa * 2 ^ exponent（mantissa 表示尾数）。<br>返回值</li>\n<li>浮点数 x 的尾数部分。</li>\n</ul>\n<h4 id=\"modf-提取浮点数的小数和整数部分\"><a href=\"#modf-提取浮点数的小数和整数部分\" class=\"headerlink\" title=\"modf 提取浮点数的小数和整数部分\"></a>modf 提取浮点数的小数和整数部分</h4><ul>\n<li>double modf(double x, double *intptr) 将提取浮点数 x 的整数部分和小数部分，整数部分被存入参数 intptr 中，小数部分被放入返回值中。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x 要被计算的浮点数</span></span><br><span class=\"line\"><span class=\"comment\">// 一个指向整数部分的指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">modf</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> *intptr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> x=<span class=\"number\">3.1415</span>, intpart;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> fractpart = <span class=\"built_in\">modf</span>(x, &amp;intpart);  <span class=\"comment\">//求3.1415的小数部分</span></span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>x的小数部分</li>\n</ul>\n<h4 id=\"fmod-求x-y的余数-针对浮点数\"><a href=\"#fmod-求x-y的余数-针对浮点数\" class=\"headerlink\" title=\"fmod 求x/y的余数(针对浮点数)\"></a>fmod 求x/y的余数(针对浮点数)</h4><ul>\n<li>fmod()函数用于求x/y的余数，针对浮点数。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">fmod</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> m=<span class=\"number\">10.1</span>, n=<span class=\"number\">3.1</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> x = <span class=\"built_in\">fmod</span>(m,n);  <span class=\"comment\">//求m/n的余数</span></span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>x/y的余数</li>\n</ul>\n<h4 id=\"log10-返回以10为底的对数\"><a href=\"#log10-返回以10为底的对数\" class=\"headerlink\" title=\"log10 返回以10为底的对数\"></a>log10 返回以10为底的对数</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n\n<h4 id=\"log-返回x的自然对数\"><a href=\"#log-返回x的自然对数\" class=\"headerlink\" title=\"log 返回x的自然对数\"></a>log 返回x的自然对数</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"ceil-求不小于x的最小整数\"><a href=\"#ceil-求不小于x的最小整数\" class=\"headerlink\" title=\"ceil 求不小于x的最小整数\"></a>ceil 求不小于x的最小整数</h4><ul>\n<li>ceil() 函数用于求不小于 x 的最小整数，也即向上取整。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">ceil</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> m = <span class=\"number\">6.123</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"built_in\">ceil</span>(m);  <span class=\"comment\">//求不小于m的最小整数</span></span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>不小于x的最小整数</li>\n</ul>\n<h4 id=\"floor-求不大于x的最大整数（向下取整）\"><a href=\"#floor-求不大于x的最大整数（向下取整）\" class=\"headerlink\" title=\"floor 求不大于x的最大整数（向下取整）\"></a>floor 求不大于x的最大整数（向下取整）</h4><ul>\n<li>floor() 函数用于求不大于 x 的最大整数，也即向下取整。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">floor</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> m = <span class=\"number\">6.123</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> n = <span class=\"built_in\">floor</span>(m);  <span class=\"comment\">//求不大于m的最大整数</span></span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>不大于x的最大整数</li>\n</ul>\n<h3 id=\"stdlib-h\"><a href=\"#stdlib-h\" class=\"headerlink\" title=\"stdlib.h\"></a>stdlib.h</h3><h4 id=\"ldiv-求两个数的商和余数\"><a href=\"#ldiv-求两个数的商和余数\" class=\"headerlink\" title=\"ldiv 求两个数的商和余数\"></a>ldiv 求两个数的商和余数</h4><ul>\n<li>ldiv() 函数用于求两个长整型数的商和余数。<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// numer 被除数  denom 除数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ldiv_t</span> <span class=\"title\">ldiv</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">int</span> numer, <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> denom)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> x = <span class=\"number\">234</span>, y = <span class=\"number\">23</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">ldiv_t</span> a = ldiv(x, y);  <span class=\"comment\">//求234除以23的商和余数</span></span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li>ldiv_t 类型的商和余数<br>ldiv_t 是在 stdlib.h 头文件中定义的结构体，它有两个成员，分别是 quot 和 rem：quot 表示商，rem 表示余数。</li>\n</ul>\n<h4 id=\"div-求两个数的商和余数\"><a href=\"#div-求两个数的商和余数\" class=\"headerlink\" title=\"div 求两个数的商和余数\"></a>div 求两个数的商和余数</h4><ul>\n<li>div()函数用于求两个数的商和余数<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// numer 是被除数  denom 除数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">div_t</span> <span class=\"title\">div</span><span class=\"params\">(<span class=\"keyword\">int</span> numer, <span class=\"keyword\">int</span> denom)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">512</span>, y = <span class=\"number\">28</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">div_t</span> a = div(x, y);  <span class=\"comment\">//求512除以28的商和余数</span></span><br></pre></td></tr></tbody></table></figure>\n返回值</li>\n<li><ul>\n<li>div_t 类型的商和余数</li>\n</ul>\n</li>\n</ul>\n<p>参考链接：<br><a href=\"http://c.biancheng.net/c/ref/\">http://c.biancheng.net/c/ref/</a></p>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"2YC9VDF","length":5310,"excerpt":"<h2 id=\"库函数\"><a href=\"#库函数\" class=\"headerlink\" title=\"库函数\"></a>库函数</h2>","more":"<h3 id=\"string-h\"><a href=\"#string-h\" class=\"headerlink\" title=\"string.h\"></a>string.h</h3><h4 id=\"strcpy-字符串复制函数\"><a href=\"#strcpy-字符串复制函数\" class=\"headerlink\" title=\"strcpy 字符串复制函数\"></a>strcpy 字符串复制函数</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// strDestination 目的字符串；strSource 源字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* strDestination, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* strSource)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// strcpy() 会把 strSource 指向的字符串复制到 strDestination。</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值：目的字符串，也即 strDestination。</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> dest[<span class=\"number\">50</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> src[<span class=\"number\">50</span>] = &#123; <span class=\"string\">&quot;http://c.biancheng.net&quot;</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(dest, src);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"strlen-求字符串长度\"><a href=\"#strlen-求字符串长度\" class=\"headerlink\" title=\"strlen 求字符串长度\"></a>strlen 求字符串长度</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"strcspn-求字符串互补跨度-长度\"><a href=\"#strcspn-求字符串互补跨度-长度\" class=\"headerlink\" title=\"strcspn 求字符串互补跨度(长度)\"></a>strcspn 求字符串互补跨度(长度)</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 回从字符串 str 开头算起，连续有几个字符都不在 reject 中；也就是说，str 中连续有几个字符和 reject 没有交集</span></span><br><span class=\"line\"><span class=\"comment\">// str 要检索的字符串</span></span><br><span class=\"line\"><span class=\"comment\">// reject 该字符串包含要在str中进行匹配的字符列表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">strcspn</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* reject)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 返回值：返回从字符串 str 开头算起，连续不在 reject 中的字符的个数；也可以理解为，str 中第一次出现 reject 中字符的位置。</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">50</span>] = &#123; <span class=\"string\">&quot;http://c.biancheng.net&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">char</span> keys[<span class=\"number\">50</span>] = &#123; <span class=\"string\">&quot;?.,:\\&quot;\\&#x27;-!&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"built_in\">strcspn</span>(str, keys);</span><br><span class=\"line\"><span class=\"comment\">// i = 4</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"strcmp-比较两个字符串\"><a href=\"#strcmp-比较两个字符串\" class=\"headerlink\" title=\"strcmp 比较两个字符串\"></a>strcmp 比较两个字符串</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// strcmp() 会根据 ASCII 编码依次比较 str1 和 str2 的每一个字符，直到出现不到的字符，或者到达字符串末尾（遇见\\0）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strcmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str1, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> str1[<span class=\"number\">50</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str2[<span class=\"number\">50</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">strcmp</span>(str1, str2)</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<ul>\n<li>如果返回值 &lt; 0，则表示 str1 小于 str2。</li>\n<li>如果返回值 &gt; 0，则表示 str2 小于 str1。</li>\n<li>如果返回值 = 0，则表示 str1 等于 str2。</li>\n</ul>\n<h4 id=\"strchr-字符查找函数\"><a href=\"#strchr-字符查找函数\" class=\"headerlink\" title=\"strchr 字符查找函数\"></a>strchr 字符查找函数</h4><ul>\n<li>strchr() 函数会依次检索字符串 str 中的每一个字符，直到遇见字符 c，或者到达字符串末尾（遇见\\0）。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// str 被查找的字符串</span></span><br><span class=\"line\"><span class=\"comment\">// c  要查找的字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">strchr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str, <span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str = <span class=\"string\">&quot;http://c.biancheng.net/&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c = <span class=\"string\">&#x27;g&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *p = <span class=\"built_in\">strchr</span>(str, c);</span><br></pre></td></tr></table></figure>\n返回值：</li>\n<li>返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符 c 则返回 NULL。</li>\n</ul>\n<h4 id=\"strcat-字符串拼接\"><a href=\"#strcat-字符串拼接\" class=\"headerlink\" title=\"strcat 字符串拼接\"></a>strcat 字符串拼接</h4><ul>\n<li>strcat() 函数把 strSource 所指向的字符串追加到 strDestination 所指向的字符串的结尾<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// strDestination 目的字符串</span></span><br><span class=\"line\"><span class=\"comment\">// strSource  源字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">strcat</span><span class=\"params\">(<span class=\"keyword\">char</span>* strDestination, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* strSource)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> str1[<span class=\"number\">101</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str2[<span class=\"number\">50</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">strcat</span>(str1, str2);</span><br></pre></td></tr></table></figure>\n返回值：</li>\n<li>指向 strDestination 的指针。</li>\n</ul>\n<h3 id=\"ctype-h\"><a href=\"#ctype-h\" class=\"headerlink\" title=\"ctype.h\"></a>ctype.h</h3><h4 id=\"isupper-判断一个字符是否是大写字母\"><a href=\"#isupper-判断一个字符是否是大写字母\" class=\"headerlink\" title=\"isupper 判断一个字符是否是大写字母\"></a>isupper 判断一个字符是否是大写字母</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isupper</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> str[] = <span class=\"string\">&quot;C++ Java Python C# Linux Golang Shell\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> re = <span class=\"built_in\">isupper</span>(s[i]);</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<ul>\n<li>返回值为非 0（真）表示 c 是大写字母，返回值为 0（假）表示 c 不是大写字母。</li>\n</ul>\n<h4 id=\"islower-判断一个字符是否是小写字母\"><a href=\"#islower-判断一个字符是否是小写字母\" class=\"headerlink\" title=\"islower 判断一个字符是否是小写字母\"></a>islower 判断一个字符是否是小写字母</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">islower</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> c = <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> re = <span class=\"built_in\">islower</span>(c);</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"isspace-判断一个字符是否是空白字符\"><a href=\"#isspace-判断一个字符是否是空白字符\" class=\"headerlink\" title=\"isspace 判断一个字符是否是空白字符\"></a>isspace 判断一个字符是否是空白字符</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isspace</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str[] = <span class=\"string\">&quot;Linux C++\\tPython Shell\\nC# Java\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (str[i]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">isspace</span>(s[i])) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;c = %c &quot;</span>, s[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>空白字符：空格、水平制表符、换行符、垂直制表符、换页、回车<br>返回值：</li>\n<li>返回值为非 0（真）表示c是空白符，返回值为 0（假）表示c不是空白符。</li>\n</ul>\n<h4 id=\"isprint-判断一个字符是否是可打印字符\"><a href=\"#isprint-判断一个字符是否是可打印字符\" class=\"headerlink\" title=\"isprint 判断一个字符是否是可打印字符\"></a>isprint 判断一个字符是否是可打印字符</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isprint</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str[]=<span class=\"string\">&quot;C++ Java \\n C# Python \\t Shell Linux\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(str[i]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">isprint</span>(str[i])) <span class=\"built_in\">putchar</span> (str[i]);</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// C++ Java  C# Python  Shell Linux</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>可打印字符和控制字符是相对的，控制字符是指那些具有某种特殊功能、不会显示在屏幕上、不会占用字符位置的“特殊”字符。要检测一个字符是否是控制字符，请使用 iscntrl() 函数<br>返回值：</li>\n<li>返回值为非 0（真）表示 c 是可打印字符，返回值为 0（假）表示 c 不是可打印字符。</li>\n</ul>\n<h4 id=\"isgraph-判断一个字符是否是图形字符\"><a href=\"#isgraph-判断一个字符是否是图形字符\" class=\"headerlink\" title=\"isgraph 判断一个字符是否是图形字符\"></a>isgraph 判断一个字符是否是图形字符</h4><ul>\n<li>字符是图形字符，就是说这个字符需要在显示器上绘制出来，而空格、换行、Tab 缩进等字符只会占用输出的位置，不需要绘制。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isgraph</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> c = <span class=\"string\">&#x27;&#x27;;</span></span><br><span class=\"line\"><span class=\"string\">int res = isgraph(c)</span></span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>返回值为非 0（真）表示 c 是图形字符，返回值为 0（假）表示 c 不是图形字符。</li>\n</ul>\n<h4 id=\"iscntrl-判断一个字符是否为控制字符\"><a href=\"#iscntrl-判断一个字符是否为控制字符\" class=\"headerlink\" title=\"iscntrl 判断一个字符是否为控制字符\"></a>iscntrl 判断一个字符是否为控制字符</h4><ul>\n<li>“控制字符”是指那些具有某种特殊功能、不会显示在屏幕上、不会占用字符位置的特殊字符。默认情况下，C语言使用的是 ASCII 编码，控制字符的范围是0x00 (NUL) ~ 0x1f (US)，再加上最后的0x7f (DEL)，一共 33 个。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">iscntrl</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> res = <span class=\"built_in\">iscntrl</span>(c);</span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>返回值为非 0（真）表示 c 是控制字符，返回值为 0（假）表示 c 不是控制字符。</li>\n</ul>\n<h4 id=\"isdigit-判断一个字符是否为数字\"><a href=\"#isdigit-判断一个字符是否为数字\" class=\"headerlink\" title=\"isdigit  判断一个字符是否为数字\"></a>isdigit  判断一个字符是否为数字</h4><ul>\n<li>isdigit() 函数用来判断一个字符是否是数字，也即 0~9。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isdigit</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> s[<span class=\"number\">50</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> res = <span class=\"built_in\">isdigit</span>(s[i]);</span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>返回值为非 0（真）表示 c 是数字，返回值为 0（假）表示 c 不是数字。</li>\n</ul>\n<h4 id=\"isalpha-判断一个字符是否是字母\"><a href=\"#isalpha-判断一个字符是否是字母\" class=\"headerlink\" title=\"isalpha 判断一个字符是否是字母\"></a>isalpha 判断一个字符是否是字母</h4><ul>\n<li>isalpha() 函数用来检测一个字符是否是字母，包括大写字母和小写字母。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isalpha</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> str[] = <span class=\"string\">&quot;C++ Java C#&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (str[i]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isalpha</span>(str[i])) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c is alphabetic\\n&quot;</span>, str[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c is not alphabetic\\n&quot;</span>, str[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>回非 0（真）表示 c 是字母，返回 0（假）表示 c 不是字母。</li>\n</ul>\n<h4 id=\"isalnum-判断一个字符是否是字母或数字\"><a href=\"#isalnum-判断一个字符是否是字母或数字\" class=\"headerlink\" title=\"isalnum 判断一个字符是否是字母或数字\"></a>isalnum 判断一个字符是否是字母或数字</h4><ul>\n<li> isalnum() 函数用于判断一个字符是否是字母（包括大写字母和小写字母）或者数字（0~9）。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isalnum</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> str[] = <span class=\"string\">&quot;*http://c.biancheng.net is 7 years old&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (str[i]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isalnum</span>(str[i])) n++;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>返回非 0（真）表示 c 是字母或者数字，返回 0（假）表示 c 既不是数字也不是字母。</li>\n</ul>\n<h3 id=\"math-h\"><a href=\"#math-h\" class=\"headerlink\" title=\"math.h\"></a>math.h</h3><h4 id=\"ldexp\"><a href=\"#ldexp\" class=\"headerlink\" title=\"ldexp\"></a>ldexp</h4><p>返回x乘以2的exponent次方</p>\n<ul>\n<li>ldexp() 函数用来计算 x 乘以 2 的 exponent 次方（次幂）的值，也即返回 x * 2^exponent 的值。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x 双精度浮点数</span></span><br><span class=\"line\"><span class=\"comment\">// exponnent  2的指数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">ldexp</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span> exponent)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> f=<span class=\"number\">0.964453</span>, n=<span class=\"number\">7</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> x = <span class=\"built_in\">ldexp</span>(f, n);  <span class=\"comment\">//求f * 2^n 的结果</span></span><br></pre></td></tr></table></figure>\n返回值：</li>\n<li>x*2^exponent 的计算结果</li>\n</ul>\n<h4 id=\"labs-求整数的绝对值-针对long类型\"><a href=\"#labs-求整数的绝对值-针对long类型\" class=\"headerlink\" title=\"labs 求整数的绝对值(针对long类型)\"></a>labs 求整数的绝对值(针对long类型)</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">labs</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> m = <span class=\"number\">11</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> a = <span class=\"built_in\">labs</span>(m); <span class=\"comment\">// 求m的绝对值</span></span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<ul>\n<li>参数n的绝对值</li>\n</ul>\n<h4 id=\"abs-求整数的绝对值\"><a href=\"#abs-求整数的绝对值\" class=\"headerlink\" title=\"abs 求整数的绝对值\"></a>abs 求整数的绝对值</h4><ul>\n<li>abs()函数用于求整数的绝对值<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">abs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">3</span>, b = <span class=\"number\">-4</span>, c, d;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\">c = <span class=\"built_in\">abs</span>(a);  <span class=\"comment\">//求a的绝对值</span></span><br><span class=\"line\">d = <span class=\"built_in\">abs</span>(b);  <span class=\"comment\">//求b的绝对值</span></span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>参数的绝对值</li>\n</ul>\n<h4 id=\"pow-求x的y次方的值\"><a href=\"#pow-求x的y次方的值\" class=\"headerlink\" title=\"pow 求x的y次方的值\"></a>pow 求x的y次方的值</h4><ul>\n<li> pow() 函数用来求 x 的 y 次方的值。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x 双精度数  y 双精度数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">pow</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> x = <span class=\"number\">4</span>, y = <span class=\"number\">6</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> result = <span class=\"built_in\">pow</span>(x, y);  <span class=\"comment\">//求a的b次方</span></span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>x 的 y 次方的值。</li>\n</ul>\n<h4 id=\"frexp-提取浮点数的尾数和指数部分\"><a href=\"#frexp-提取浮点数的尾数和指数部分\" class=\"headerlink\" title=\"frexp 提取浮点数的尾数和指数部分\"></a>frexp 提取浮点数的尾数和指数部分</h4><ul>\n<li>rexp() 函数用来提取一个浮点数（小数）的指数部分和尾数部分。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x 要被计算的浮点数</span></span><br><span class=\"line\"><span class=\"comment\">// exponent  一个指向指数部分的指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">frexp</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span>* exponent)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">exp</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> mant = <span class=\"built_in\">frexp</span>(<span class=\"number\">19.625</span>, &amp;<span class=\"built_in\">exp</span>);</span><br></pre></td></tr></table></figure>\n指数部分被存入参数 exponent 中，尾数部分被放入返回值中，最终 x = mantissa * 2 ^ exponent（mantissa 表示尾数）。<br>返回值</li>\n<li>浮点数 x 的尾数部分。</li>\n</ul>\n<h4 id=\"modf-提取浮点数的小数和整数部分\"><a href=\"#modf-提取浮点数的小数和整数部分\" class=\"headerlink\" title=\"modf 提取浮点数的小数和整数部分\"></a>modf 提取浮点数的小数和整数部分</h4><ul>\n<li>double modf(double x, double *intptr) 将提取浮点数 x 的整数部分和小数部分，整数部分被存入参数 intptr 中，小数部分被放入返回值中。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x 要被计算的浮点数</span></span><br><span class=\"line\"><span class=\"comment\">// 一个指向整数部分的指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">modf</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> *intptr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> x=<span class=\"number\">3.1415</span>, intpart;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> fractpart = <span class=\"built_in\">modf</span>(x, &amp;intpart);  <span class=\"comment\">//求3.1415的小数部分</span></span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>x的小数部分</li>\n</ul>\n<h4 id=\"fmod-求x-y的余数-针对浮点数\"><a href=\"#fmod-求x-y的余数-针对浮点数\" class=\"headerlink\" title=\"fmod 求x/y的余数(针对浮点数)\"></a>fmod 求x/y的余数(针对浮点数)</h4><ul>\n<li>fmod()函数用于求x/y的余数，针对浮点数。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">fmod</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> m=<span class=\"number\">10.1</span>, n=<span class=\"number\">3.1</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> x = <span class=\"built_in\">fmod</span>(m,n);  <span class=\"comment\">//求m/n的余数</span></span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>x/y的余数</li>\n</ul>\n<h4 id=\"log10-返回以10为底的对数\"><a href=\"#log10-返回以10为底的对数\" class=\"headerlink\" title=\"log10 返回以10为底的对数\"></a>log10 返回以10为底的对数</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"log-返回x的自然对数\"><a href=\"#log-返回x的自然对数\" class=\"headerlink\" title=\"log 返回x的自然对数\"></a>log 返回x的自然对数</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ceil-求不小于x的最小整数\"><a href=\"#ceil-求不小于x的最小整数\" class=\"headerlink\" title=\"ceil 求不小于x的最小整数\"></a>ceil 求不小于x的最小整数</h4><ul>\n<li>ceil() 函数用于求不小于 x 的最小整数，也即向上取整。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">ceil</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> m = <span class=\"number\">6.123</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"built_in\">ceil</span>(m);  <span class=\"comment\">//求不小于m的最小整数</span></span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>不小于x的最小整数</li>\n</ul>\n<h4 id=\"floor-求不大于x的最大整数（向下取整）\"><a href=\"#floor-求不大于x的最大整数（向下取整）\" class=\"headerlink\" title=\"floor 求不大于x的最大整数（向下取整）\"></a>floor 求不大于x的最大整数（向下取整）</h4><ul>\n<li>floor() 函数用于求不大于 x 的最大整数，也即向下取整。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">floor</span><span class=\"params\">(<span class=\"keyword\">double</span> x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> m = <span class=\"number\">6.123</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> n = <span class=\"built_in\">floor</span>(m);  <span class=\"comment\">//求不大于m的最大整数</span></span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>不大于x的最大整数</li>\n</ul>\n<h3 id=\"stdlib-h\"><a href=\"#stdlib-h\" class=\"headerlink\" title=\"stdlib.h\"></a>stdlib.h</h3><h4 id=\"ldiv-求两个数的商和余数\"><a href=\"#ldiv-求两个数的商和余数\" class=\"headerlink\" title=\"ldiv 求两个数的商和余数\"></a>ldiv 求两个数的商和余数</h4><ul>\n<li>ldiv() 函数用于求两个长整型数的商和余数。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// numer 被除数  denom 除数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ldiv_t</span> <span class=\"title\">ldiv</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">int</span> numer, <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> denom)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> x = <span class=\"number\">234</span>, y = <span class=\"number\">23</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">ldiv_t</span> a = ldiv(x, y);  <span class=\"comment\">//求234除以23的商和余数</span></span><br></pre></td></tr></table></figure>\n返回值</li>\n<li>ldiv_t 类型的商和余数<br>ldiv_t 是在 stdlib.h 头文件中定义的结构体，它有两个成员，分别是 quot 和 rem：quot 表示商，rem 表示余数。</li>\n</ul>\n<h4 id=\"div-求两个数的商和余数\"><a href=\"#div-求两个数的商和余数\" class=\"headerlink\" title=\"div 求两个数的商和余数\"></a>div 求两个数的商和余数</h4><ul>\n<li>div()函数用于求两个数的商和余数<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// numer 是被除数  denom 除数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">div_t</span> <span class=\"title\">div</span><span class=\"params\">(<span class=\"keyword\">int</span> numer, <span class=\"keyword\">int</span> denom)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">512</span>, y = <span class=\"number\">28</span>;  <span class=\"comment\">//为变量赋初值</span></span><br><span class=\"line\"><span class=\"keyword\">div_t</span> a = div(x, y);  <span class=\"comment\">//求512除以28的商和余数</span></span><br></pre></td></tr></table></figure>\n返回值</li>\n<li><ul>\n<li>div_t 类型的商和余数</li>\n</ul>\n</li>\n</ul>\n<p>参考链接：<br><a href=\"http://c.biancheng.net/c/ref/\">http://c.biancheng.net/c/ref/</a></p>"},{"title":"leetcode基础","date":"2022-01-31T16:47:53.000Z","updated":"2022-01-31T16:53:53.000Z","_content":"\n1207, 876, 701, 674, 367， 231  206 201  189  160\n\n\n\n<!--more-->\n\n## 146.[只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n> 思路：n ^ n = 0 一个数与自己异或为 0\n\n```c\nint singleNumber(int* nums, int numsSize){\n    int res = 0;\n    for (int i = 0; i < numsSize; i++) {\n        res = res ^ nums[i];\n    }\n    return res;\n\n}\n```\n\n## 141.[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)\n\n> 思路：快慢双指针\n\n```c\nbool hasCycle(struct ListNode *head) {\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n    while (slow && fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## 142.[环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n> 思路：快慢双指针\n\n```c\nstruct ListNode *detectCycle(struct ListNode *head) {\n    struct ListNode* slow = (struct ListNode*)malloc(sizeof(struct ListNode));\n    struct ListNode* fast = (struct ListNode*)malloc(sizeof(struct ListNode));\n    slow = head;\n    fast = head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            struct ListNode* entry = head;\n            while (slow != entry) {\n                slow = slow->next;\n                entry = entry->next;\n            }\n            return entry;\n        }\n    }\n    return NULL;\n}\n```\n\n## 153.[寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)\n\n> 思路：二分查找\n\n```c\nint findMin(int* nums, int numsSize){\n    int low = 0;\n    int high = numsSize - 1;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return nums[low];\n}\n```\n\n```c\nint findMin(int* nums, int numsSize){\n    int i;\n    for (i = 0; i < numsSize - 1; i++) {\n        if (nums[i] > nums[(i+1)]) {\n            return nums[i+1];\n        }\n    }\n    return nums[0];\n\n}\n```\n\n## 160.[相交链表](https://leetcode-cn.com/problemset/all/?page=1&search=160)\n\n> 思路：\n一、\n二、先统计两个链表结点个数，然后长链表先走个数差位\n\n```c\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\n    struct ListNode *cur1 = headA;\n    struct ListNode *cur2 = headB;\n    if (cur1 == NULL || cur2 == NULL)\n        return NULL;\n    while (cur1 && cur2 && cur1 != cur2) {\n        cur1 = cur1->next;\n        cur2 = cur2->next;\n        if (cur1 == cur2) {\n            return cur1;\n        }\n        if (!cur1) {\n            cur1 = headB;\n        }\n        if (!cur2) {\n            cur2 = headA;\n        }\n    }\n    return cur1;\n}\n```\n\n\n## 169.[多数元素](https://leetcode-cn.com/problems/majority-element/)\n\n> 思路：选定一个主元素，计数器\n\n```c\nint majorityElement(int* nums, int numsSize){\n    int count = 1;\n    int majorNum = nums[0];\n    for (int i = 1; i < numsSize; i++) {\n        if (count == 0) {\n            majorNum = nums[i];\n            count++;\n        } else if (majorNum == nums[i]) {\n            count++;\n        } else {\n            count--;\n        }\n    }\n    return majorNum;\n}\n```\n\n\n## 173.[二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n\n> 思路：\n\n```c\ntypedef struct {\n    int* res;\n    int size;\n    int idx;\n} BSTIterator;\n\nint getTreeSize(struct TreeNode* root) {\n    if (root == NULL) {\n        return 0;\n    }\n    return 1 + getTreeSize(root->left) + getTreeSize(root->right);\n}\n\nvoid inorder(int* ret, int* retSize, struct TreeNode* root) {\n    if (root == NULL) {\n        return;\n    }\n    inorder(ret, retSize, root->left);\n    ret[(*retSize)++] = root->val;\n    inorder(ret, retSize, root->right);\n}\n\nint* inorderTraversal(int* retSize, struct TreeNode* root) {\n    *retSize = 0;\n    int* ret = malloc(sizeof(int) * getTreeSize(root));\n    inorder(ret, retSize, root);\n    return ret;\n}\n\nBSTIterator* bSTIteratorCreate(struct TreeNode* root) {\n    BSTIterator* ret = malloc(sizeof(BSTIterator));\n    ret->res = inorderTraversal(&(ret->size), root);\n    ret->idx = 0;\n    return ret;\n}\n\nint bSTIteratorNext(BSTIterator* obj) {\n    return obj->res[(obj->idx)++];\n}\n\nbool bSTIteratorHasNext(BSTIterator* obj) {\n    return (obj->idx < obj->size);\n}\n\nvoid bSTIteratorFree(BSTIterator* obj) {\n    free(obj->res);\n    free(obj);\n}\n```\n\n## 189.[轮转数组](https://leetcode-cn.com/problems/rotate-array/)\n\n> 思路：\n一、每次移动一个数\n二、先整体翻转，在翻转前k个，最后翻转 numsSize - k个\n\n\n```c\nvoid moveOne(int* nums, int numsSize)\n{\n    int tmp = nums[numsSize - 1];\n    for (int i = numsSize - 1; i > 0; i--) {\n        nums[i] = nums[i-1]; \n    }\n    nums[0] = tmp;\n}\n\nvoid rotate(int* nums, int numsSize, int k)\n{\n    for (int i = 0; i < k; i++) {\n        moveOne(nums, numsSize);\n    }\n}\n```\n\n```c\n/* */ \nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\nvoid reverse(int* nums, int start, int end) {\n    while (start < end) {\n        swap(&nums[start], &nums[end]);\n        start += 1;\n        end -= 1;\n    }\n}\nvoid rotate(int* nums, int numsSize, int k) {\n    k %= numsSize;\n    for (int i = 0; i < numsSize; i++) {\n        printf(\"nums[%d] = %d\\t\", i, nums[i]);\n    }\n    printf(\"\\n\");\n    reverse(nums, 0, numsSize - 1);\n    for (int i = 0; i < numsSize; i++) {\n        printf(\"nums[%d] = %d\\t\", i, nums[i]);\n    }\n    printf(\"\\n\");\n    reverse(nums, 0, k - 1);\n    for (int i = 0; i < numsSize; i++) {\n        printf(\"nums[%d] = %d\\t\", i, nums[i]);\n    }\n    printf(\"\\n\");\n    reverse(nums, k, numsSize - 1);\n    for (int i = 0; i < numsSize; i++) {\n        printf(\"nums[%d] = %d\\t\", i, nums[i]);\n    }\n    printf(\"\\n\");\n}\n\n\n\n/*\nvoid rotate(int* nums, int numsSize, int k){\n     for (int i = 0; i < k; i++) {\n        int lastElement = nums[numsSize - 1];\n        for (int j = numsSize - 1; j > 0; j--) {\n            nums[j] = nums[j - 1];\n        }\n        nums[0] = lastElement;\n    } \n}*/\n\n/*  \nvoid rotate(int* nums, int numsSize, int k){\n    if (k == numsSize / 2 && numsSize % 2 != 1) {\n        for (int i = 0; i < k; i++) {\n            int tmp = nums[i];\n            nums[i] = nums[k+i];\n            nums[k+i] = tmp;\n        }\n        return;\n    }\n  \n    int i = 0;\n    int tmp = nums[0];\n    int p = 0;\n    int count = 0;\n    do {\n        p = (i + k) % numsSize;\n        printf(\"p = %d\\n\",p);\n        int t = nums[p];\n        nums[p] = tmp;\n        tmp = t;\n        i = p;\n     } while (i != 0);\n} */ \n```\n\n## 190.[颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/submissions/)\n\n> 思路：32位，\n\n```c\nuint32_t reverseBits(uint32_t n) {\n    uint32_t m = 0;\n    int cnt = 32;\n    while (cnt) {\n        m <<= 1;\n        m += (n & 0x1);\n        n >>= 1;\n        cnt--;\n    }\n    return m;\n}\n```\n\n## 191.[位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/submissions/)\n\n> 思路：n & 0x1\n\n```c\nint hammingWeight(uint32_t n) {\n    int cnt = 0;\n    while (n) {\n        if (n & 0x1) {\n            cnt++;\n        }\n        n >>= 1;\n    }\n    return cnt;\n    \n}\n```\n\n## 201.[数字范围按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/)\n\n> 思路：n & (n - 1) 去除n最高位的1\n\n```c\nint rangeBitwiseAnd(int left, int right){\n    while (left < right) {\n        right &= right - 1;\n    }\n    return right;\n}\n```\n\n## 203.[移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)\n\n> 思路：递归\n\n```c\nstruct ListNode *removeElements(struct ListNode *head, int val)\n{\n    if (head == NULL) {\n         return NULL;\n    }\n\n    if (head->val == val) {\n        return removeElements(head->next, val);\n    } else {\n        head->next = removeElements(head->next, val);\n    }\n    return head;\n}\n\n```\n\n## 206.[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n> 思路：\n\n```c\nstruct ListNode* reverseList(struct ListNode* head){\n    struct ListNode* res = NULL;\n    while (head) {\n        struct ListNode* pre_node = head;\n        head = head->next;\n        pre_node->next = res;\n        res = pre_node;\n    }\n    return res;\n}\n```\n\n## 215.[数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n> 思路：排序，第k个最大\n\n```c\nint Cmp(const void* a, const void* b)\n{\n    return *(int *)b - *(int *)a;\n}\n\nint findKthLargest(int* nums, int numsSize, int k){\n    qsort(nums, numsSize, sizeof(int), Cmp);\n    return nums[k-1];\n}\n```\n\n## 217.[存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)\n\n> 思路：\n一、排序，比较前一个数和当前数是否相等\n二、uthash\n\n```c\nint Cmp(const void* a, const void* b)\n{\n    return *(int *)a - *(int *)b;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    if (numsSize <= 1) {\n        return true;\n    }\n    qsort(nums, numsSize, sizeof(int), Cmp);\n    for (int i = 1; i < numsSize; i++) {\n        if (nums[i-1] == nums[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n```c\nstruct my_struct {\n    int id;\n    UT_hash_handle hh;\n};\n\nstruct my_struct *users = NULL;\n\nbool containsDuplicate(int* nums, int numsSize){\n   struct my_struct *s;\n   HASH_FIND_INT(users, nums[i], s);\n   if (s == NULL) {\n       s = (struct my_struct*)malloc(sizeof(struct my_struct));\n       s->id = nums[i];\n       HASH_ADD_INT(users, id, s);\n   } else {\n       return true;\n   }\n   return false;\n}\n```\n\n## 226.[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)\n\n> 思路：判空，交换左右子树，递归调用\n\n```c\nstruct TreeNode* invertTree(struct TreeNode* root){\n    \n    if (root == NULL) {\n        return NULL;\n    }\n\n    struct TreeNode* tmp = root->left;\n    root->left = root->right;\n    root->right = tmp;\n\n    invertTree(root->left);\n    invertTree(root->right);\n    return root;\n}\n```\n\n```c\nstruct TreeNode* invertTree(struct TreeNode* root){\n    if (root == NULL) {\n        return NULL;\n    }\n\n    struct TreeNode *left = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n    struct TreeNode *right = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n    left = invertTree(root->left);\n    right = invertTree(root->right);\n    root->left = right;\n    root->right = left;\n    return root;\n}\n```\n\n## 231.[2的幂](https://leetcode-cn.com/problems/power-of-two/)\n\n> 思路：\n\n```c\nbool isPowerOfTwo(int n)\n{\n    if (!n) {\n        return false;\n    }\n        \n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    return n == 1;\n}\n```\n\n```c\nbool isPowerOfTwo(int n){\n\n    if (n == 0) {\n        return false;\n    }\n\n    if (n == 1) {\n        return true;\n    }\n    \n    bool res = false;\n    if (n % 2 != 0) {\n        return false;\n    }else {\n       res = isPowerOfTwo(n/2);\n    }\n    return res;\n}\n```\n\n```c\nbool isPowerOfTwo(int n){\n    //用位运算来判断有几个1，要是只有一个1那就是2的幂。\n    if (n >= 2147483647 || n <= -2147483648) {\n        return false;\n    }\n    int nu m =0;\n    while (n>0 && n!=0) {\n        n &= (n-1);\n        num++;\n    }\n    if (num!=1) {\n        return false;\n    }\n    return true;\n\n}\n\n```\n\n## 234.[回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/submissions/)\n\n> 思路；\n一、通过一个数组记录链表中的元素值，在判断数组是否是回文。\n二、翻转链表\n\n```c\n#define MAXSIZE 100000\n\nbool isPalindrome(struct ListNode* head){\n    int size = 0;\n    int nums[MAXSIZE] = {0};\n    struct ListNode* p = head;\n    // 判断条件\n    while (p) {\n        nums[size++] = p->val;\n        p = p->next;\n    }\n    printf(\"size = %d\\n\", size);\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        if (nums[left] != nums[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```\n\n```c\nstruct ListNode *reverse(struct ListNode *head)\n{\n    struct ListNode *res = NULL;\n    while (head) {\n        struct ListNode *pre_node = head;\n        head = head->next;\n        pre_node->next = res;\n        res = pre_node;\n    }\n    return res;\n}\nbool isPalindrome(struct ListNode *head)\n{\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n    struct ListNode *last;\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    if (fast != NULL) {\n        slow = slow->next;\n    }\n    last = reverse(slow);\n    while (last) {\n        if (head->val != last->val) {\n            return 0;\n        }\n        head = head->next;\n        last = last->next;\n    }\n    return 1;\n}\n```\n\n## 242.[有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/submissions/)\n\n> 思路：先比较长度，不相等 false，通过表格记录第一个字符串中字符，遍历第二个字符串时表格记录--，最后，判断表格中所有值是否为零\n\n```c\n#define NUMSIZE 256\n\nbool isAnagram(char * s, char * t){\n    int sLen = strlen(s);\n    int tLen = strlen(t);\n    if (sLen != tLen) {\n        return false;\n    }\n    int table[256] = {0};\n\n    for (int i = 0; i < sLen; i++) {\n        table[s[i]]++;\n    }\n    for (int i = 0; i < tLen; i++) {\n        table[t[i]]--;\n    }\n\n    for (int i = 0; i < NUMSIZE; i++) {\n        if (table[i] != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n## 268.[丢失的数字](https://leetcode-cn.com/problems/missing-number/)\n\n> 思路：边求和，边减去数组中的数字\n\n```c\nint missingNumber(int* nums, int numsSize){\n    int mNum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        mNum += (i + 1);\n        mNum -= nums[i];\n    }\n    return mNum;\n}\n```\n\n\n\n## 278.[第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)\n\n> 思路：二分查找\n\n```c\nint firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid) && !isBadVersion(mid-1)) {\n            return mid;\n        } else if (isBadVersion(mid) && isBadVersion(mid-1)) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n\n```c\nint firstBadVersion(int n) {\n    int low = 1, high = n;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (isBadVersion(mid)) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return low;\n}\n```\n\n## 283.[移动零](https://leetcode-cn.com/problems/move-zeroes/)\n\n> 思路：不等于零时向数组中添加，等于零时跳过，最后填充0\nnums[start++] = nums[i]\n\n```c\nvoid moveZeroes(int* nums, int numsSize){\n    int start = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] != 0) {\n            nums[start++] = nums[i];\n        }\n    }\n\n    for (; start < numsSize; start++) {\n        nums[start] = 0;\n    }    \n}\n```\n\n## 287.[寻找重复整数](https://leetcode-cn.com/problems/find-the-duplicate-number/)\n\n> 思路：循环遍历，标记，判断是否标记过，return\n\n```c\n#define MAXSIZE 100001\n\nint findDuplicate(int* nums, int numsSize){\n    int table[MAXSIZE] = {0};\n    for (int i = 0; i < numsSize; i++) {\n        if (table[nums[i]] != 0) {\n            return nums[i];\n        } else {\n            table[nums[i]]++;\n        }\n    }\n    return -1;\n}\n```\n\n## 344.[反转字符串](https://leetcode-cn.com/problems/reverse-string/)\n\n> 思路：双指针，交换\n\n```c\nvoid reverseString(char* s, int sSize){\n    int left =0;\n    int right = sSize - 1;\n    while (left < right) {\n        char c = s[left];\n        s[left] = s[right];\n        s[right] = c;\n        left++;\n        right--;\n    }\n}\n```\n\n## 367.[有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)\n\n> 思路：for 循环，条件 i * i <= num \n\n```c\nbool isPerfectSquare(int num)\n{\n    for (long i = 0; i * i <= num; i++) {\n        if (i * i == num) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n```\n\n## 387.[字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)\n\n> 思路：两次遍历，第一次遍历见字母标记得到统计表格中，第二次遍历找出统计表格中第一个为1字符，返回对应下标。\n\n```c\n#define NUMSIZE 256\n\nint firstUniqChar(char * s){\n    int sLen = strlen(s);\n    int table[NUMSIZE] = {0};\n    for (int i = 0; i < sLen; i++) {\n        table[s[i]]++;\n    }\n\n    for (int i = 0; i < sLen; i++) {\n        if (table[s[i]] == 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n## 389.[找不同](https://leetcode-cn.com/problems/find-the-difference/)\n\n> 思路：字符可以转化为数字，为了防止溢出通过 - 'a'，求两个字符串的差值，在加上'a'\n\n```c\nchar findTheDifference(char * s, char * t){\n    int sLen = strlen(s);\n    int tLen = strlen(t);\n    int nS = 0;\n    int nT = 0;\n    for (int i = 0; i < sLen; i++) {\n        nS += s[i] - 'a';\n    }\n    for (int i = 0; i < tLen; i++) {\n        nT += t[i] - 'a';\n    }\n    return (char)(nT - nS + 'a');\n}\n```\n\n## 404.[左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)\n\n> 思路：递归：判断左子树是否为叶子结点，是则记录sum，返回 sum + 递归调用左子树 + 递归调用右子树\n\n```c\nint sumOfLeftLeaves(struct TreeNode* root){\n    if (root == NULL) {\n        return 0;\n    }\n    int sum = 0;\n    if (root->left) {\n        if (root->left->left == NULL && root->left->right == NULL) {\n            sum += root->left->val;\n        }\n    }\n    return  sum + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);\n}\n```\n\n```c\nint isleaf(struct TreeNode* root)\n{\n    return root->left == NULL && root->right == NULL;\n}\n\nint sumOfLeftLeaves(struct TreeNode* root)\n{\n    if(root == NULL) {\n        return 0;\n    }\n    if (root->left) {\n        if(isleaf(root->left)) {\n            // 此处直接递归，少一层调用\n            return root->left->val + sumOfLeftLeaves(root->right);\n        }\n    }\n    return sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);\n}\n```\n\n## 442.[数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)\n\n> 思路：\n一、通过表标记数组中出现过的数字，当再次出现时将数字添加到返回数组中。\n二、\n\n```c\n#define MAXSIZE 100000\n\nint* findDuplicates(int* nums, int numsSize, int* returnSize){\n    int table[MAXSIZE] = {0};\n    *returnSize = 0;\n    int *res = (int *)malloc(sizeof(int) * MAXSIZE);\n    for (int i = 0; i < numsSize; i++) {\n        if (table[nums[i]] == 1) {\n            res[*returnSize] = nums[i];\n            (*returnSize)++;\n        } else {\n            table[nums[i]]++;\n        }\n    }\n    return res;\n}\n```\n\n```c\nint* findDuplicates(int* nums, int numsSize, int* returnSize) {\n    int table[100000] = {0};\n    int *res = (int *)malloc(sizeof(int) * 100000);\n    int j = 0;\n    for (int i = 0; i < numsSize; i++) {\n        table[nums[i]]++;\n        if (table[nums[i]] == 2) {\n            res[j++] = nums[i];\n        }\n    }\n    *returnSize = j;\n    return res;\n}\n```\n\n\n## 461.[汉明距离](https://leetcode-cn.com/problems/hamming-distance/)\n\n> 思路：\n一、求 x ^ y 中 1 的个数\n二、比较x，y的每一位 和 1与\n\n```c\nint hammingDistance(int x, int y)\n{\n    int n = x ^ y;\n    int res = 0;\n    while (n) {\n        int p = n & 1;\n        if (p) {\n            res++;\n        }\n        n >>= 1;\n    }\n    return res;\n}\n```\n\n```c\nint hammingDistance(int x, int y){\n    int count = 0;\n    while (x || y) {\n        int nX = x & 0x1;\n        int nY = y & 0x1;\n        if (nX != nY) {\n            count++;\n        }\n        x >>= 1;\n        y >>= 1;\n    }\n    return count;\n\n}\n```\n\n## 476.[数字的补数](https://leetcode-cn.com/problems/number-complement/)\n\n> 思路：\n一、按位与1求与，再取反(!)，然后移位，\n二、先统计位数，在取位数相同全一数，最后与原数字求异或 ^\n\n```c\nint findComplement(int num){\n    int res = 0;\n    int count = 0;\n    while (num) {\n        int t = !(num & 0x1);\n        t <<= count;\n        printf(\"t = %d\\n\", t);\n        res += t;\n        count++;\n        num>>=1;\n    }\n    return res;\n\n}\n```\n\n```c\nint findComplement(int num){\n    int totalBits = 0;\n    int tmp = num;\n    while (tmp) {\n        totalBits++;\n        tmp >>= 1;\n    }\n    int flipNumber = 1;\n    for (int i = 1; i < totalBits; i++) {\n        flipNumber += UINT32_C(1) << i;\n    }\n    num = num ^ flipNumber;\n    return num;\n}\n\n```\n\n## 509.[斐波那契数列](https://leetcode-cn.com/problems/fibonacci-number/)\n\n> 思路：一、递归  二、迭代\n\n- 递归\n```c\nint fib(int n){\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n\n}\n```\n\n- 迭代\n```c\nint fib(int n){\n    if (n <= 1) {\n        return n;\n    }\n    int* nums = (int *)malloc(sizeof(int) * (n + 1));\n    nums[0] = 0;\n    nums[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        nums[i] = nums[i - 1] + nums[i - 2];\n    }\n    return nums[n];\n}\n```\n\n## 520.[检测大写字母](https://leetcode-cn.com/problems/detect-capital/submissions/)\n\n> 思路：\n一、先判断第二个字母是否为大写，1.word[1] 大写，从从零开始判断是否全为大写 2.word[1]为小写，从word是否全为小写。\n二、\n\n```c\nbool detectCapitalUse(char * word){\n\n    int len = strlen(word);\n    if (len <= 1) {\n        return true;\n    }\n\n    int i = 1;\n    if (isupper(word[i])) {\n        i = 0;\n        while (word[i] != '\\0') {\n            if (!isupper(word[i])) {\n                return false;\n            }\n            i++;\n        }\n    } else {\n        while (word[i] != '\\0') {\n            if (isupper(word[i])) {\n                return false;\n            }\n            i++;\n        }\n    }\n    return true;\n}\n```\n\n```c\nbool detectCapitalUse(char * word){\n    int len = strlen(word);\n    if (len == 1) {\n        return true;\n    }\n    for (int i = 1; i < len; i++) {\n        // word[0] 每次都需要判断，一个复杂度。\n        if (isupper(word[0]) && isupper(word[1])) {\n            if (!isupper(word[i])) {\n                return false;\n            }\n        } else {\n            if (isupper(word[i])) {\n                return false;\n            }\n        }\n    }\n    return true;\n   \n}\n```\n\n\n## 561.[拆分数组I](https://leetcode-cn.com/problems/array-partition-i/)\n\n> 思路：排序，取偶数位求和。\n\n```c\nint Cmp(const void* a, const void* b)\n{\n    return *(int *)a - *(int *)b;\n}\nint arrayPairSum(int* nums, int numsSize){\n    qsort(nums, numsSize, sizeof(int), Cmp);\n    int minSum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (i % 2 == 0) {\n            minSum += nums[i];\n        }    \n    }\n    return minSum;\n}\n```\n\n## 617.[合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)\n\n> 思路：递归，判空，\n\n```c\nstruct TreeNode* newNode(int val)\n{\n    struct TreeNode* node = malloc(sizeof(struct TreeNode));\n    node->val = val;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\n\n   /*  if (root1 == NULL && root2 == NULL) {\n        return NULL;\n    } */\n    if (root1 == NULL) {\n        return root2;\n    }\n\n    if (root2 == NULL) {\n        return root1;\n    }\n    \n   /*  struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val += root1 == NULL ? 0 : root1->val;\n    root->val += root2 == NULL ? 0 : root2->val;\n    root->left = NULL;\n    root->right = NULL; */\n    int val = (root1 == NULL ? 0 : root1->val) + (root2 == NULL ? 0 : root2->val);\n    struct TreeNode* root  = newNode(val);\n    root->left = mergeTrees(root1->left, root2->left);\n    root->right = mergeTrees(root1->right, root2->right);\n    return root;\n}\n```\n\n## 647.[回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)\n\n> 思路：左侧判断去重，左右判断相等。\n\n```c\nint countSubstrings(char * s)\n{\n    int len = strlen(s);\n    int res = len; // 每个字符都是回文\n    for (int i = 0; i < len; i++) {\n        int p = i - 1;\n        while (p >= 0 && s[p] == s[i]) { // 左侧去重\n            res++;\n            p--;\n        }\n        int q = i + 1;\n        while (p >= 0 && q < len && s[p] == s[q]) { // 判断左右相等\n            res++;\n            p--;\n            q++;\n        }\n    }\n    return res;\n}\n```\n\n```c\nint countSubstrings(char * s){\n    int len = strlen(s);\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        count += countPalin(s, i, i, len);\n        if (i != len - 1) {\n            count += countPalin(s, i, i+1, len);\n        }\n    }\n    return count;\n}\n\nint countPalin(char *s, int head, int tail, int len)\n{\n    int ret = (s[head] == s[tail]) ? 1 : 0;\n    if (ret && head - 1 >= 0 && tail + 1 < len) {\n        ret += countPalin(s, head - 1, tail + 1, len);\n    }\n    return ret;\n}\n```\n\n## 674.[最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)\n\n> 思路：双循环判断，\n\n```c\nint findLengthOfLCIS(int* nums, int numsSize){\n    if (numsSize == 1) {\n        return 1;\n    }\n    int p2 = 0;\n    int res = 0;\n    for (int i = 1; i < numsSize; i++) {\n        while (i < numsSize && nums[i-1] < nums[i]) {\n            i++;\n        }\n        res = res > i - p2 ? res : i - p2;\n        p2 = i;\n\n    } \n    return res;\n}\n```\n\n\n```c\nint findLengthOfLCIS(int* nums, int numsSize){\n    int maxLen = 0;\n    int i = 0;\n    while (i < numsSize) {\n        int start = i;\n        while (start + 1 < numsSize && nums[start] < nums[start + 1]) {\n            start++;\n        }\n        maxLen = maxLen > (start - i + 1) ? maxLen : (start - i + 1);\n        start++;\n        i = start;\n    }\n    return maxLen;\n}\n```\n\n## 700.[二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)\n\n> 思路：递归，注意 判空 root == NULL\n\n```c\nstruct TreeNode* searchBST(struct TreeNode* root, int val){\n    if (root == NULL) {\n        return NULL;\n    }\n    if (root->val == val) {\n        return root;\n    } else if (root->val > val) {\n        return searchBST(root->left, val);\n    } else {\n        return searchBST(root->right, val);\n    }\n    return NULL;\n}\n```\n\n## 701.[二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)\n\n> 思路：递归，递归出口，root == NULL, 新建树结点 malloc\n\n```c\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val){\n\n    if (root == NULL) {\n        struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        newNode->val = val;\n        newNode->left = NULL;\n        newNode->right = NULL;\n        return newNode;\n    }\n    if (root->val < val) {\n        root->right = insertIntoBST(root->right, val);\n    }\n    if (root->val > val) {\n        root->left = insertIntoBST(root->left, val);\n    }\n    return root;\n}\n```\n\n## 704.[二分查找](https://leetcode-cn.com/problems/binary-search/)\n\n> 思路：二分查找，注意 left <= right ，包含等于\n\n```c\nint search(int* nums, int numsSize, int target){\n    int left = 0;\n    int right = numsSize - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n\n## 709.[转换成小写字母](https://leetcode-cn.com/problems/to-lower-case/)\n\n> 思路；库函数 isupper, tolower\n\n```c\nchar * toLowerCase(char * s){\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) {\n        if (isupper(s[i])) {\n            s[i] = tolower(s[i]);\n        }\n    }\n    return s;\n}\n```\n\n## 771.[宝石和石头](https://leetcode-cn.com/problems/jewels-and-stones/)\n\n> 思路：表记录stones中每个字符个数，求和jewels字符表中的值\n\n```c\nint numJewelsInStones(char * jewels, char * stones){\n    int table[256] = {0};\n    int sLen = strlen(stones);\n    for (int i = 0; i < sLen; i++) {\n        table[stones[i]]++;\n    }\n\n    int jLen = strlen(jewels);\n    int sum = 0;\n    for (int i = 0; i < jLen; i++) {\n        sum +=  table[jewels[i]];\n    }\n    return sum;\n}\n```\n\n\n## 852.[山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)\n\n> 思路：判断条件，完全\n\n```c\nint peakIndexInMountainArray(int* arr, int arrSize){\n\n  int low = 1, high = arrSize;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1])\n            return mid;\n        else if (arr[mid - 1] < arr[mid] && arr[mid] < arr[mid + 1])\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n    return -1;\n\n}\n```\n\n## 876.[链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\n\n> 思路：快慢指针，第二个指针通过 偶数判断  for循环\n\n```c\nstruct ListNode* middleNode(struct ListNode* head){\n\n    struct ListNode* pos1 = head;\n    struct ListNode* pos2 = head;\n    for (int i = 0; pos1->next != NULL; pos1 = pos1->next, i++) {\n        if (i % 2 == 0) {\n            pos2 = pos2->next;\n        }\n    }\n    return pos2;\n}\n```\n\n## 905.[按奇偶排序数组](https://leetcode-cn.com/problems/sort-array-by-parity/)\n\n> 思路: 一、双指针，同917\n二、判断，前后索引移动，双指针\n\n- 解法一：\n```c\nint* sortArrayByParity(int* nums, int numsSize, int* returnSize)\n{\n    *returnSize = numsSize;\n    int start = 0;\n    int end = numsSize - 1;\n    while (start < end) {\n        while (start < end && nums[start] % 2 == 0) {\n            start++;\n        }\n        while (end > start && nums[end] % 2 == 1) {\n            end--;\n        }\n        while (start < end && nums[start] % 2 != 0 && nums[end] % 2 != 1) {\n            int tmp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = tmp;\n            start++;\n            end--;\n        }\n    }\n    return nums;\n}\n\nint* sortArrayByParity(int* nums, int numsSize, int* returnSize){\n    *returnSize = numsSize;\n    int left = 0;\n    int right = numsSize - 1;\n    while (left < right) {\n         if (nums[left] % 2 == 0) {\n            left++;\n            continue;\n         }\n         if (nums[right] % 2 == 1) {\n             right--;\n             continue;\n         }\n\n         int tmp = nums[left];\n         nums[left] = nums[right];\n         nums[right] = tmp;\n         left++;\n         right--;\n    }\n    return nums;\n\n}\n```\n\n- 解法二；\n```c\nint* sortArrayByParity(int* nums, int numsSize, int* returnSize){\n    int *res = (int *)malloc(sizeof(int) * numsSize);\n    *returnSize = numsSize;\n    int j = 0;\n    int p = numsSize - 1;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] % 2 == 0) {\n            res[j] = nums[i];\n            j++;\n        } else {\n            res[p] = nums[i];\n            p--;\n        }\n    }\n    return res;\n}\n```\n\n\n## 917.[仅仅反转字母](https://leetcode-cn.com/problems/reverse-only-letters/)\n\n> 思路：双指针，库函数 isalpha， continue\n\n```c\nchar * reverseOnlyLetters(char * s){\n    int len = strlen(s);\n    int left = 0;\n    int right = len - 1;\n    while (left < right) {\n        if (!isalpha(s[left])) {\n            left++;\n            continue;\n        }\n         if (!isalpha(s[right])) {\n            right--;\n            continue;\n        }\n        //if (isalpha(s[left]) && isalpha(s[right])) {\n            char c = s[left];\n            s[left] = s[right];\n            s[right] = c;\n            left++;\n            right--;\n        //}\n       \n    }\n    return s;\n}\n```\n\n\n## 938.[二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)\n\n```c\nint rangeSumBST(struct TreeNode* root, int low, int high){\n\n    if (root == NULL) {\n        return 0;\n    }\n\n    if (low > root->val) {\n        return rangeSumBST(root->right, low, high);\n    }\n    if (high < root->val) {\n        return rangeSumBST(root->left, low, high);\n    }\n    return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\n\n}\n```\n\n```c\nint rangeSumBST(struct TreeNode* root, int low, int high){\n    if (root == NULL) {\n        return 0;\n    } else if (root->val >= low && root->val <= high) {\n        return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\n    } else {\n        return rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\n    }\n}\n```\n\n\n\n\n## 965.[单值二叉树](https://leetcode-cn.com/problems/univalued-binary-tree/)\n\n> 思路：递归，递归出口：root == NULL\n\n```c\nbool isUnivalTree(struct TreeNode* root){\n    // root不判空会报错：\n    // member access within null pointer of type 'struct TreeNode'\n    if (root == NULL) {\n        return true;\n    }\n    // 多余\n   /*  if (root->left == NULL && root->right == NULL) {\n        return true;\n    } */\n\n\n    if (root->left != NULL) {\n        if (root->left->val != root->val) {\n            return false;\n        }\n    }\n\n    if (root->right != NULL) {\n        if (root->right->val != root->val) {\n            return false;\n        }\n    }\n\n    return isUnivalTree(root->left) && isUnivalTree(root->right);\n\n}\n```\n\n\n## 977.[有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/submissions/)\n\n> 思路\n\n```c\nint Cmp(const void* a,  const void* b)\n{\n    return *(int *)a - *(int *)b;\n}\n\nint* sortedSquares(int* nums, int numsSize, int* returnSize){\n\n    int* squareNum = (int *)malloc(sizeof(int) * numsSize);\n    *returnSize = numsSize;\n    for (int i = 0; i < numsSize; i++) {\n        //squareNum[i] = nums[i] * nums[i];\n        squareNum[i] = pow(nums[i], 2);\n    }\n    qsort(squareNum, numsSize, sizeof(int), Cmp);\n    return squareNum;\n}\n```\n\n## 1089.[复写零](https://leetcode-cn.com/problems/duplicate-zeros/)\n\n> 思路：将原数组复制一份，根据复制数组，修改原数组值\n\n```c\nvoid duplicateZeros(int* arr, int arrSize)\n{\n    int b[arrSize]; // = {0};\n    memcpy(b, arr, sizeof(int) * arrSize);\n    for (int i = 0, j = 0; i < arrSize && j < arrSize; i++) {\n        arr[j++] = b[i];\n        if (j < arrSize && b[i] == 0) {\n            arr[j++] = 0;\n        }\n    }W\n}\n```\n\n```c\nvoid duplicateZeros(int* arr, int arrSize){\n\n    int * nums = (int *)malloc(sizeof(int) * arrSize);\n    for (int i = 0; i < arrSize; i++) {\n        nums[i] = arr[i];\n    }\n\n    int j = 0;\n    for (int i = 0; i < arrSize; i++, j++) {\n        arr[i] = nums[j];\n        if (i + 1 < arrSize && nums[j] == 0) {\n            arr[++i] = 0; \n        }\n    }\n\n}\n```\n\n\n\n## 1184.[公交站间的距离](https://leetcode-cn.com/problems/distance-between-bus-stops/submissions/)\n\n> 思路: 保证 start 小于 destination， 计算一圈的总长度sum，计算start到destination的距离d，取d与sum-d两者较小值\n\n```c\nint distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination){\n    \n    if (start > destination) {\n        int tmp = start;\n        start = destination;\n        destination = tmp;\n    }\n\n    int min = 0;\n    int sum = 0;\n    for (int i = 0; i < distanceSize; i++) {\n        sum += distance[i];\n        if (i >= start && i < destination) {\n            min += distance[i];\n        }\n    }\n\n    min = min < (sum - min) ? min : sum - min;\n    return min;\n}\n```\n\n## 1189.[ “气球” 的最大数量](https://leetcode-cn.com/problems/maximum-number-of-balloons/)\n\n> 思路：统计字符次数，注意 字符串指针  取值 *p  或者 字符数组 test[i]\n\n```c\nint maxNumberOfBalloons(char * text){\n    int len = strlen(text);\n    int table[5] = {0};\n\n    char* p = text;\n    while (*p != '\\0') {\n        if (*p == 'b') {\n            table[0]++;\n        }\n        if (*p == 'a') {\n            table[1]++;\n        }\n        if (*p == 'l') {\n            table[2]++;\n        }\n        if (*p == 'o') {\n            table[3]++;\n        }\n        if (*p == 'n') {\n            table[4]++;\n        }\n        p++;\n    }\n\n    table[2] /= 2;\n    table[3] /= 2;\n    int min = INT_MAX;\n    for (int i = 0; i < 5; i++) {\n        min = min < table[i] ? min : table[i];\n    }\n    return min;\n\n}\n\n\n/* int maxNumberOfBalloons(char * text){\n    int len = strlen(text);\n\n    int testNum[5] = {0};\n\n    for (int i = 0; i < len; i++) {\n        if (text[i] == 'b') {\n            testNum[0]++;\n        }\n        if (text[i] == 'a') {\n            testNum[1]++;\n        }\n\n        if (text[i] == 'l') {\n            testNum[2]++;\n        }\n\n        if (text[i] == 'o') {\n            testNum[3]++;\n        }\n\n        if (text[i] == 'n') {\n            testNum[4]++;\n        }\n    }\n\n    testNum[2] /= 2;\n    testNum[3] /= 2;\n\n    int res = INT_MAX;\n    for (int i = 0; i < 5; i++) {\n        res = res < testNum[i] ? res : testNum[i];\n    }\n    return res;\n\n} */\n```\n\n\n\n## 1207.[独一无二的出现次数](https://leetcode-cn.com/problems/unique-number-of-occurrences/)\n\n解法一\n> 通过一个表统计每个数字出现的次数，定义另外一个表记录表一中每一项的，如果出现相同数字，则返回false，遍历到最后时返回true\n\n\n\n<details>\n<summary>uniqueOccurrences</summary>\n\n```c\nbool uniqueOccurrences(int* arr, int arrSize){\n    int table[2001] = {0};\n\n    for (int i = 0; i < arrSize; i++) {\n        table[arr[i] + 1000]++;\n        printf(\"table[arr[%d] + 1000] = %d\\n\", i, table[arr[i] + 1000]);\n    }\n\n    int table1[2001] = {0};\n    for (int i = 0; i < 2001; i++) {\n        table1[i] = 0;\n        if (table[i] != 0) {\n            if (table1[table[i]] != 0) {\n                printf(\"table1[table[%d]] = %d\\n\", i, table1[table[i]]);\n                return false;\n            } else {\n                table1[table[i]]++;\n            }\n        }\n        \n    }\n    return true;\n\n}\n```\n\n解法二：\n> 同解法一\n```c\n/* */\nbool uniqueOccurrences(int* arr, int arrSize){\n   int hashTable[2001]={0};//初始化一张表，下标对应元素值，存储对应元素出现的次数\n    for(int i=0;i<arrSize;i++) {\n        hashTable[arr[i]+1000]++;\n    }\n    bool visited[1001]={false};\n    for(int i=0;i<2001;i++) {\n        if(hashTable[i]) { //如果i在数组中\n            if(visited[hashTable[i]]) { //如果之前出现过与i相同的重复次数\n                return false;\n            } else {\n                visited[hashTable[i]]=true;//说明与i相同的重复次数还未出现，设置为已访问过\n            }\n        }\n    }\n    return true;\n\n} \n\n```\n</details>\n\n\n\n\n\n\n\n\n","source":"_posts/2022/leetcode未分类题目.md","raw":"---\ntitle: leetcode基础\ndate: 2022-02-01 00:47:53\nupdated: 2022-02-01  00:53:53\ncategories: \n    - tool\ntags: \n    - 实用教程\n    - Another Tag\n---\n\n1207, 876, 701, 674, 367， 231  206 201  189  160\n\n\n\n<!--more-->\n\n## 146.[只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n> 思路：n ^ n = 0 一个数与自己异或为 0\n\n```c\nint singleNumber(int* nums, int numsSize){\n    int res = 0;\n    for (int i = 0; i < numsSize; i++) {\n        res = res ^ nums[i];\n    }\n    return res;\n\n}\n```\n\n## 141.[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)\n\n> 思路：快慢双指针\n\n```c\nbool hasCycle(struct ListNode *head) {\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n    while (slow && fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n## 142.[环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n> 思路：快慢双指针\n\n```c\nstruct ListNode *detectCycle(struct ListNode *head) {\n    struct ListNode* slow = (struct ListNode*)malloc(sizeof(struct ListNode));\n    struct ListNode* fast = (struct ListNode*)malloc(sizeof(struct ListNode));\n    slow = head;\n    fast = head;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            struct ListNode* entry = head;\n            while (slow != entry) {\n                slow = slow->next;\n                entry = entry->next;\n            }\n            return entry;\n        }\n    }\n    return NULL;\n}\n```\n\n## 153.[寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)\n\n> 思路：二分查找\n\n```c\nint findMin(int* nums, int numsSize){\n    int low = 0;\n    int high = numsSize - 1;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return nums[low];\n}\n```\n\n```c\nint findMin(int* nums, int numsSize){\n    int i;\n    for (i = 0; i < numsSize - 1; i++) {\n        if (nums[i] > nums[(i+1)]) {\n            return nums[i+1];\n        }\n    }\n    return nums[0];\n\n}\n```\n\n## 160.[相交链表](https://leetcode-cn.com/problemset/all/?page=1&search=160)\n\n> 思路：\n一、\n二、先统计两个链表结点个数，然后长链表先走个数差位\n\n```c\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\n    struct ListNode *cur1 = headA;\n    struct ListNode *cur2 = headB;\n    if (cur1 == NULL || cur2 == NULL)\n        return NULL;\n    while (cur1 && cur2 && cur1 != cur2) {\n        cur1 = cur1->next;\n        cur2 = cur2->next;\n        if (cur1 == cur2) {\n            return cur1;\n        }\n        if (!cur1) {\n            cur1 = headB;\n        }\n        if (!cur2) {\n            cur2 = headA;\n        }\n    }\n    return cur1;\n}\n```\n\n\n## 169.[多数元素](https://leetcode-cn.com/problems/majority-element/)\n\n> 思路：选定一个主元素，计数器\n\n```c\nint majorityElement(int* nums, int numsSize){\n    int count = 1;\n    int majorNum = nums[0];\n    for (int i = 1; i < numsSize; i++) {\n        if (count == 0) {\n            majorNum = nums[i];\n            count++;\n        } else if (majorNum == nums[i]) {\n            count++;\n        } else {\n            count--;\n        }\n    }\n    return majorNum;\n}\n```\n\n\n## 173.[二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n\n> 思路：\n\n```c\ntypedef struct {\n    int* res;\n    int size;\n    int idx;\n} BSTIterator;\n\nint getTreeSize(struct TreeNode* root) {\n    if (root == NULL) {\n        return 0;\n    }\n    return 1 + getTreeSize(root->left) + getTreeSize(root->right);\n}\n\nvoid inorder(int* ret, int* retSize, struct TreeNode* root) {\n    if (root == NULL) {\n        return;\n    }\n    inorder(ret, retSize, root->left);\n    ret[(*retSize)++] = root->val;\n    inorder(ret, retSize, root->right);\n}\n\nint* inorderTraversal(int* retSize, struct TreeNode* root) {\n    *retSize = 0;\n    int* ret = malloc(sizeof(int) * getTreeSize(root));\n    inorder(ret, retSize, root);\n    return ret;\n}\n\nBSTIterator* bSTIteratorCreate(struct TreeNode* root) {\n    BSTIterator* ret = malloc(sizeof(BSTIterator));\n    ret->res = inorderTraversal(&(ret->size), root);\n    ret->idx = 0;\n    return ret;\n}\n\nint bSTIteratorNext(BSTIterator* obj) {\n    return obj->res[(obj->idx)++];\n}\n\nbool bSTIteratorHasNext(BSTIterator* obj) {\n    return (obj->idx < obj->size);\n}\n\nvoid bSTIteratorFree(BSTIterator* obj) {\n    free(obj->res);\n    free(obj);\n}\n```\n\n## 189.[轮转数组](https://leetcode-cn.com/problems/rotate-array/)\n\n> 思路：\n一、每次移动一个数\n二、先整体翻转，在翻转前k个，最后翻转 numsSize - k个\n\n\n```c\nvoid moveOne(int* nums, int numsSize)\n{\n    int tmp = nums[numsSize - 1];\n    for (int i = numsSize - 1; i > 0; i--) {\n        nums[i] = nums[i-1]; \n    }\n    nums[0] = tmp;\n}\n\nvoid rotate(int* nums, int numsSize, int k)\n{\n    for (int i = 0; i < k; i++) {\n        moveOne(nums, numsSize);\n    }\n}\n```\n\n```c\n/* */ \nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\nvoid reverse(int* nums, int start, int end) {\n    while (start < end) {\n        swap(&nums[start], &nums[end]);\n        start += 1;\n        end -= 1;\n    }\n}\nvoid rotate(int* nums, int numsSize, int k) {\n    k %= numsSize;\n    for (int i = 0; i < numsSize; i++) {\n        printf(\"nums[%d] = %d\\t\", i, nums[i]);\n    }\n    printf(\"\\n\");\n    reverse(nums, 0, numsSize - 1);\n    for (int i = 0; i < numsSize; i++) {\n        printf(\"nums[%d] = %d\\t\", i, nums[i]);\n    }\n    printf(\"\\n\");\n    reverse(nums, 0, k - 1);\n    for (int i = 0; i < numsSize; i++) {\n        printf(\"nums[%d] = %d\\t\", i, nums[i]);\n    }\n    printf(\"\\n\");\n    reverse(nums, k, numsSize - 1);\n    for (int i = 0; i < numsSize; i++) {\n        printf(\"nums[%d] = %d\\t\", i, nums[i]);\n    }\n    printf(\"\\n\");\n}\n\n\n\n/*\nvoid rotate(int* nums, int numsSize, int k){\n     for (int i = 0; i < k; i++) {\n        int lastElement = nums[numsSize - 1];\n        for (int j = numsSize - 1; j > 0; j--) {\n            nums[j] = nums[j - 1];\n        }\n        nums[0] = lastElement;\n    } \n}*/\n\n/*  \nvoid rotate(int* nums, int numsSize, int k){\n    if (k == numsSize / 2 && numsSize % 2 != 1) {\n        for (int i = 0; i < k; i++) {\n            int tmp = nums[i];\n            nums[i] = nums[k+i];\n            nums[k+i] = tmp;\n        }\n        return;\n    }\n  \n    int i = 0;\n    int tmp = nums[0];\n    int p = 0;\n    int count = 0;\n    do {\n        p = (i + k) % numsSize;\n        printf(\"p = %d\\n\",p);\n        int t = nums[p];\n        nums[p] = tmp;\n        tmp = t;\n        i = p;\n     } while (i != 0);\n} */ \n```\n\n## 190.[颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/submissions/)\n\n> 思路：32位，\n\n```c\nuint32_t reverseBits(uint32_t n) {\n    uint32_t m = 0;\n    int cnt = 32;\n    while (cnt) {\n        m <<= 1;\n        m += (n & 0x1);\n        n >>= 1;\n        cnt--;\n    }\n    return m;\n}\n```\n\n## 191.[位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/submissions/)\n\n> 思路：n & 0x1\n\n```c\nint hammingWeight(uint32_t n) {\n    int cnt = 0;\n    while (n) {\n        if (n & 0x1) {\n            cnt++;\n        }\n        n >>= 1;\n    }\n    return cnt;\n    \n}\n```\n\n## 201.[数字范围按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/)\n\n> 思路：n & (n - 1) 去除n最高位的1\n\n```c\nint rangeBitwiseAnd(int left, int right){\n    while (left < right) {\n        right &= right - 1;\n    }\n    return right;\n}\n```\n\n## 203.[移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)\n\n> 思路：递归\n\n```c\nstruct ListNode *removeElements(struct ListNode *head, int val)\n{\n    if (head == NULL) {\n         return NULL;\n    }\n\n    if (head->val == val) {\n        return removeElements(head->next, val);\n    } else {\n        head->next = removeElements(head->next, val);\n    }\n    return head;\n}\n\n```\n\n## 206.[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n> 思路：\n\n```c\nstruct ListNode* reverseList(struct ListNode* head){\n    struct ListNode* res = NULL;\n    while (head) {\n        struct ListNode* pre_node = head;\n        head = head->next;\n        pre_node->next = res;\n        res = pre_node;\n    }\n    return res;\n}\n```\n\n## 215.[数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n> 思路：排序，第k个最大\n\n```c\nint Cmp(const void* a, const void* b)\n{\n    return *(int *)b - *(int *)a;\n}\n\nint findKthLargest(int* nums, int numsSize, int k){\n    qsort(nums, numsSize, sizeof(int), Cmp);\n    return nums[k-1];\n}\n```\n\n## 217.[存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)\n\n> 思路：\n一、排序，比较前一个数和当前数是否相等\n二、uthash\n\n```c\nint Cmp(const void* a, const void* b)\n{\n    return *(int *)a - *(int *)b;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    if (numsSize <= 1) {\n        return true;\n    }\n    qsort(nums, numsSize, sizeof(int), Cmp);\n    for (int i = 1; i < numsSize; i++) {\n        if (nums[i-1] == nums[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n```c\nstruct my_struct {\n    int id;\n    UT_hash_handle hh;\n};\n\nstruct my_struct *users = NULL;\n\nbool containsDuplicate(int* nums, int numsSize){\n   struct my_struct *s;\n   HASH_FIND_INT(users, nums[i], s);\n   if (s == NULL) {\n       s = (struct my_struct*)malloc(sizeof(struct my_struct));\n       s->id = nums[i];\n       HASH_ADD_INT(users, id, s);\n   } else {\n       return true;\n   }\n   return false;\n}\n```\n\n## 226.[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)\n\n> 思路：判空，交换左右子树，递归调用\n\n```c\nstruct TreeNode* invertTree(struct TreeNode* root){\n    \n    if (root == NULL) {\n        return NULL;\n    }\n\n    struct TreeNode* tmp = root->left;\n    root->left = root->right;\n    root->right = tmp;\n\n    invertTree(root->left);\n    invertTree(root->right);\n    return root;\n}\n```\n\n```c\nstruct TreeNode* invertTree(struct TreeNode* root){\n    if (root == NULL) {\n        return NULL;\n    }\n\n    struct TreeNode *left = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n    struct TreeNode *right = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n    left = invertTree(root->left);\n    right = invertTree(root->right);\n    root->left = right;\n    root->right = left;\n    return root;\n}\n```\n\n## 231.[2的幂](https://leetcode-cn.com/problems/power-of-two/)\n\n> 思路：\n\n```c\nbool isPowerOfTwo(int n)\n{\n    if (!n) {\n        return false;\n    }\n        \n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    return n == 1;\n}\n```\n\n```c\nbool isPowerOfTwo(int n){\n\n    if (n == 0) {\n        return false;\n    }\n\n    if (n == 1) {\n        return true;\n    }\n    \n    bool res = false;\n    if (n % 2 != 0) {\n        return false;\n    }else {\n       res = isPowerOfTwo(n/2);\n    }\n    return res;\n}\n```\n\n```c\nbool isPowerOfTwo(int n){\n    //用位运算来判断有几个1，要是只有一个1那就是2的幂。\n    if (n >= 2147483647 || n <= -2147483648) {\n        return false;\n    }\n    int nu m =0;\n    while (n>0 && n!=0) {\n        n &= (n-1);\n        num++;\n    }\n    if (num!=1) {\n        return false;\n    }\n    return true;\n\n}\n\n```\n\n## 234.[回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/submissions/)\n\n> 思路；\n一、通过一个数组记录链表中的元素值，在判断数组是否是回文。\n二、翻转链表\n\n```c\n#define MAXSIZE 100000\n\nbool isPalindrome(struct ListNode* head){\n    int size = 0;\n    int nums[MAXSIZE] = {0};\n    struct ListNode* p = head;\n    // 判断条件\n    while (p) {\n        nums[size++] = p->val;\n        p = p->next;\n    }\n    printf(\"size = %d\\n\", size);\n    int left = 0;\n    int right = size - 1;\n    while (left <= right) {\n        if (nums[left] != nums[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```\n\n```c\nstruct ListNode *reverse(struct ListNode *head)\n{\n    struct ListNode *res = NULL;\n    while (head) {\n        struct ListNode *pre_node = head;\n        head = head->next;\n        pre_node->next = res;\n        res = pre_node;\n    }\n    return res;\n}\nbool isPalindrome(struct ListNode *head)\n{\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n    struct ListNode *last;\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    if (fast != NULL) {\n        slow = slow->next;\n    }\n    last = reverse(slow);\n    while (last) {\n        if (head->val != last->val) {\n            return 0;\n        }\n        head = head->next;\n        last = last->next;\n    }\n    return 1;\n}\n```\n\n## 242.[有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/submissions/)\n\n> 思路：先比较长度，不相等 false，通过表格记录第一个字符串中字符，遍历第二个字符串时表格记录--，最后，判断表格中所有值是否为零\n\n```c\n#define NUMSIZE 256\n\nbool isAnagram(char * s, char * t){\n    int sLen = strlen(s);\n    int tLen = strlen(t);\n    if (sLen != tLen) {\n        return false;\n    }\n    int table[256] = {0};\n\n    for (int i = 0; i < sLen; i++) {\n        table[s[i]]++;\n    }\n    for (int i = 0; i < tLen; i++) {\n        table[t[i]]--;\n    }\n\n    for (int i = 0; i < NUMSIZE; i++) {\n        if (table[i] != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n## 268.[丢失的数字](https://leetcode-cn.com/problems/missing-number/)\n\n> 思路：边求和，边减去数组中的数字\n\n```c\nint missingNumber(int* nums, int numsSize){\n    int mNum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        mNum += (i + 1);\n        mNum -= nums[i];\n    }\n    return mNum;\n}\n```\n\n\n\n## 278.[第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)\n\n> 思路：二分查找\n\n```c\nint firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid) && !isBadVersion(mid-1)) {\n            return mid;\n        } else if (isBadVersion(mid) && isBadVersion(mid-1)) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n\n```c\nint firstBadVersion(int n) {\n    int low = 1, high = n;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (isBadVersion(mid)) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return low;\n}\n```\n\n## 283.[移动零](https://leetcode-cn.com/problems/move-zeroes/)\n\n> 思路：不等于零时向数组中添加，等于零时跳过，最后填充0\nnums[start++] = nums[i]\n\n```c\nvoid moveZeroes(int* nums, int numsSize){\n    int start = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] != 0) {\n            nums[start++] = nums[i];\n        }\n    }\n\n    for (; start < numsSize; start++) {\n        nums[start] = 0;\n    }    \n}\n```\n\n## 287.[寻找重复整数](https://leetcode-cn.com/problems/find-the-duplicate-number/)\n\n> 思路：循环遍历，标记，判断是否标记过，return\n\n```c\n#define MAXSIZE 100001\n\nint findDuplicate(int* nums, int numsSize){\n    int table[MAXSIZE] = {0};\n    for (int i = 0; i < numsSize; i++) {\n        if (table[nums[i]] != 0) {\n            return nums[i];\n        } else {\n            table[nums[i]]++;\n        }\n    }\n    return -1;\n}\n```\n\n## 344.[反转字符串](https://leetcode-cn.com/problems/reverse-string/)\n\n> 思路：双指针，交换\n\n```c\nvoid reverseString(char* s, int sSize){\n    int left =0;\n    int right = sSize - 1;\n    while (left < right) {\n        char c = s[left];\n        s[left] = s[right];\n        s[right] = c;\n        left++;\n        right--;\n    }\n}\n```\n\n## 367.[有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)\n\n> 思路：for 循环，条件 i * i <= num \n\n```c\nbool isPerfectSquare(int num)\n{\n    for (long i = 0; i * i <= num; i++) {\n        if (i * i == num) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n```\n\n## 387.[字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)\n\n> 思路：两次遍历，第一次遍历见字母标记得到统计表格中，第二次遍历找出统计表格中第一个为1字符，返回对应下标。\n\n```c\n#define NUMSIZE 256\n\nint firstUniqChar(char * s){\n    int sLen = strlen(s);\n    int table[NUMSIZE] = {0};\n    for (int i = 0; i < sLen; i++) {\n        table[s[i]]++;\n    }\n\n    for (int i = 0; i < sLen; i++) {\n        if (table[s[i]] == 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n```\n\n## 389.[找不同](https://leetcode-cn.com/problems/find-the-difference/)\n\n> 思路：字符可以转化为数字，为了防止溢出通过 - 'a'，求两个字符串的差值，在加上'a'\n\n```c\nchar findTheDifference(char * s, char * t){\n    int sLen = strlen(s);\n    int tLen = strlen(t);\n    int nS = 0;\n    int nT = 0;\n    for (int i = 0; i < sLen; i++) {\n        nS += s[i] - 'a';\n    }\n    for (int i = 0; i < tLen; i++) {\n        nT += t[i] - 'a';\n    }\n    return (char)(nT - nS + 'a');\n}\n```\n\n## 404.[左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)\n\n> 思路：递归：判断左子树是否为叶子结点，是则记录sum，返回 sum + 递归调用左子树 + 递归调用右子树\n\n```c\nint sumOfLeftLeaves(struct TreeNode* root){\n    if (root == NULL) {\n        return 0;\n    }\n    int sum = 0;\n    if (root->left) {\n        if (root->left->left == NULL && root->left->right == NULL) {\n            sum += root->left->val;\n        }\n    }\n    return  sum + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);\n}\n```\n\n```c\nint isleaf(struct TreeNode* root)\n{\n    return root->left == NULL && root->right == NULL;\n}\n\nint sumOfLeftLeaves(struct TreeNode* root)\n{\n    if(root == NULL) {\n        return 0;\n    }\n    if (root->left) {\n        if(isleaf(root->left)) {\n            // 此处直接递归，少一层调用\n            return root->left->val + sumOfLeftLeaves(root->right);\n        }\n    }\n    return sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);\n}\n```\n\n## 442.[数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)\n\n> 思路：\n一、通过表标记数组中出现过的数字，当再次出现时将数字添加到返回数组中。\n二、\n\n```c\n#define MAXSIZE 100000\n\nint* findDuplicates(int* nums, int numsSize, int* returnSize){\n    int table[MAXSIZE] = {0};\n    *returnSize = 0;\n    int *res = (int *)malloc(sizeof(int) * MAXSIZE);\n    for (int i = 0; i < numsSize; i++) {\n        if (table[nums[i]] == 1) {\n            res[*returnSize] = nums[i];\n            (*returnSize)++;\n        } else {\n            table[nums[i]]++;\n        }\n    }\n    return res;\n}\n```\n\n```c\nint* findDuplicates(int* nums, int numsSize, int* returnSize) {\n    int table[100000] = {0};\n    int *res = (int *)malloc(sizeof(int) * 100000);\n    int j = 0;\n    for (int i = 0; i < numsSize; i++) {\n        table[nums[i]]++;\n        if (table[nums[i]] == 2) {\n            res[j++] = nums[i];\n        }\n    }\n    *returnSize = j;\n    return res;\n}\n```\n\n\n## 461.[汉明距离](https://leetcode-cn.com/problems/hamming-distance/)\n\n> 思路：\n一、求 x ^ y 中 1 的个数\n二、比较x，y的每一位 和 1与\n\n```c\nint hammingDistance(int x, int y)\n{\n    int n = x ^ y;\n    int res = 0;\n    while (n) {\n        int p = n & 1;\n        if (p) {\n            res++;\n        }\n        n >>= 1;\n    }\n    return res;\n}\n```\n\n```c\nint hammingDistance(int x, int y){\n    int count = 0;\n    while (x || y) {\n        int nX = x & 0x1;\n        int nY = y & 0x1;\n        if (nX != nY) {\n            count++;\n        }\n        x >>= 1;\n        y >>= 1;\n    }\n    return count;\n\n}\n```\n\n## 476.[数字的补数](https://leetcode-cn.com/problems/number-complement/)\n\n> 思路：\n一、按位与1求与，再取反(!)，然后移位，\n二、先统计位数，在取位数相同全一数，最后与原数字求异或 ^\n\n```c\nint findComplement(int num){\n    int res = 0;\n    int count = 0;\n    while (num) {\n        int t = !(num & 0x1);\n        t <<= count;\n        printf(\"t = %d\\n\", t);\n        res += t;\n        count++;\n        num>>=1;\n    }\n    return res;\n\n}\n```\n\n```c\nint findComplement(int num){\n    int totalBits = 0;\n    int tmp = num;\n    while (tmp) {\n        totalBits++;\n        tmp >>= 1;\n    }\n    int flipNumber = 1;\n    for (int i = 1; i < totalBits; i++) {\n        flipNumber += UINT32_C(1) << i;\n    }\n    num = num ^ flipNumber;\n    return num;\n}\n\n```\n\n## 509.[斐波那契数列](https://leetcode-cn.com/problems/fibonacci-number/)\n\n> 思路：一、递归  二、迭代\n\n- 递归\n```c\nint fib(int n){\n    if (n <= 1) {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n\n}\n```\n\n- 迭代\n```c\nint fib(int n){\n    if (n <= 1) {\n        return n;\n    }\n    int* nums = (int *)malloc(sizeof(int) * (n + 1));\n    nums[0] = 0;\n    nums[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        nums[i] = nums[i - 1] + nums[i - 2];\n    }\n    return nums[n];\n}\n```\n\n## 520.[检测大写字母](https://leetcode-cn.com/problems/detect-capital/submissions/)\n\n> 思路：\n一、先判断第二个字母是否为大写，1.word[1] 大写，从从零开始判断是否全为大写 2.word[1]为小写，从word是否全为小写。\n二、\n\n```c\nbool detectCapitalUse(char * word){\n\n    int len = strlen(word);\n    if (len <= 1) {\n        return true;\n    }\n\n    int i = 1;\n    if (isupper(word[i])) {\n        i = 0;\n        while (word[i] != '\\0') {\n            if (!isupper(word[i])) {\n                return false;\n            }\n            i++;\n        }\n    } else {\n        while (word[i] != '\\0') {\n            if (isupper(word[i])) {\n                return false;\n            }\n            i++;\n        }\n    }\n    return true;\n}\n```\n\n```c\nbool detectCapitalUse(char * word){\n    int len = strlen(word);\n    if (len == 1) {\n        return true;\n    }\n    for (int i = 1; i < len; i++) {\n        // word[0] 每次都需要判断，一个复杂度。\n        if (isupper(word[0]) && isupper(word[1])) {\n            if (!isupper(word[i])) {\n                return false;\n            }\n        } else {\n            if (isupper(word[i])) {\n                return false;\n            }\n        }\n    }\n    return true;\n   \n}\n```\n\n\n## 561.[拆分数组I](https://leetcode-cn.com/problems/array-partition-i/)\n\n> 思路：排序，取偶数位求和。\n\n```c\nint Cmp(const void* a, const void* b)\n{\n    return *(int *)a - *(int *)b;\n}\nint arrayPairSum(int* nums, int numsSize){\n    qsort(nums, numsSize, sizeof(int), Cmp);\n    int minSum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (i % 2 == 0) {\n            minSum += nums[i];\n        }    \n    }\n    return minSum;\n}\n```\n\n## 617.[合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)\n\n> 思路：递归，判空，\n\n```c\nstruct TreeNode* newNode(int val)\n{\n    struct TreeNode* node = malloc(sizeof(struct TreeNode));\n    node->val = val;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nstruct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){\n\n   /*  if (root1 == NULL && root2 == NULL) {\n        return NULL;\n    } */\n    if (root1 == NULL) {\n        return root2;\n    }\n\n    if (root2 == NULL) {\n        return root1;\n    }\n    \n   /*  struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val += root1 == NULL ? 0 : root1->val;\n    root->val += root2 == NULL ? 0 : root2->val;\n    root->left = NULL;\n    root->right = NULL; */\n    int val = (root1 == NULL ? 0 : root1->val) + (root2 == NULL ? 0 : root2->val);\n    struct TreeNode* root  = newNode(val);\n    root->left = mergeTrees(root1->left, root2->left);\n    root->right = mergeTrees(root1->right, root2->right);\n    return root;\n}\n```\n\n## 647.[回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)\n\n> 思路：左侧判断去重，左右判断相等。\n\n```c\nint countSubstrings(char * s)\n{\n    int len = strlen(s);\n    int res = len; // 每个字符都是回文\n    for (int i = 0; i < len; i++) {\n        int p = i - 1;\n        while (p >= 0 && s[p] == s[i]) { // 左侧去重\n            res++;\n            p--;\n        }\n        int q = i + 1;\n        while (p >= 0 && q < len && s[p] == s[q]) { // 判断左右相等\n            res++;\n            p--;\n            q++;\n        }\n    }\n    return res;\n}\n```\n\n```c\nint countSubstrings(char * s){\n    int len = strlen(s);\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        count += countPalin(s, i, i, len);\n        if (i != len - 1) {\n            count += countPalin(s, i, i+1, len);\n        }\n    }\n    return count;\n}\n\nint countPalin(char *s, int head, int tail, int len)\n{\n    int ret = (s[head] == s[tail]) ? 1 : 0;\n    if (ret && head - 1 >= 0 && tail + 1 < len) {\n        ret += countPalin(s, head - 1, tail + 1, len);\n    }\n    return ret;\n}\n```\n\n## 674.[最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)\n\n> 思路：双循环判断，\n\n```c\nint findLengthOfLCIS(int* nums, int numsSize){\n    if (numsSize == 1) {\n        return 1;\n    }\n    int p2 = 0;\n    int res = 0;\n    for (int i = 1; i < numsSize; i++) {\n        while (i < numsSize && nums[i-1] < nums[i]) {\n            i++;\n        }\n        res = res > i - p2 ? res : i - p2;\n        p2 = i;\n\n    } \n    return res;\n}\n```\n\n\n```c\nint findLengthOfLCIS(int* nums, int numsSize){\n    int maxLen = 0;\n    int i = 0;\n    while (i < numsSize) {\n        int start = i;\n        while (start + 1 < numsSize && nums[start] < nums[start + 1]) {\n            start++;\n        }\n        maxLen = maxLen > (start - i + 1) ? maxLen : (start - i + 1);\n        start++;\n        i = start;\n    }\n    return maxLen;\n}\n```\n\n## 700.[二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)\n\n> 思路：递归，注意 判空 root == NULL\n\n```c\nstruct TreeNode* searchBST(struct TreeNode* root, int val){\n    if (root == NULL) {\n        return NULL;\n    }\n    if (root->val == val) {\n        return root;\n    } else if (root->val > val) {\n        return searchBST(root->left, val);\n    } else {\n        return searchBST(root->right, val);\n    }\n    return NULL;\n}\n```\n\n## 701.[二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)\n\n> 思路：递归，递归出口，root == NULL, 新建树结点 malloc\n\n```c\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val){\n\n    if (root == NULL) {\n        struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        newNode->val = val;\n        newNode->left = NULL;\n        newNode->right = NULL;\n        return newNode;\n    }\n    if (root->val < val) {\n        root->right = insertIntoBST(root->right, val);\n    }\n    if (root->val > val) {\n        root->left = insertIntoBST(root->left, val);\n    }\n    return root;\n}\n```\n\n## 704.[二分查找](https://leetcode-cn.com/problems/binary-search/)\n\n> 思路：二分查找，注意 left <= right ，包含等于\n\n```c\nint search(int* nums, int numsSize, int target){\n    int left = 0;\n    int right = numsSize - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n\n## 709.[转换成小写字母](https://leetcode-cn.com/problems/to-lower-case/)\n\n> 思路；库函数 isupper, tolower\n\n```c\nchar * toLowerCase(char * s){\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) {\n        if (isupper(s[i])) {\n            s[i] = tolower(s[i]);\n        }\n    }\n    return s;\n}\n```\n\n## 771.[宝石和石头](https://leetcode-cn.com/problems/jewels-and-stones/)\n\n> 思路：表记录stones中每个字符个数，求和jewels字符表中的值\n\n```c\nint numJewelsInStones(char * jewels, char * stones){\n    int table[256] = {0};\n    int sLen = strlen(stones);\n    for (int i = 0; i < sLen; i++) {\n        table[stones[i]]++;\n    }\n\n    int jLen = strlen(jewels);\n    int sum = 0;\n    for (int i = 0; i < jLen; i++) {\n        sum +=  table[jewels[i]];\n    }\n    return sum;\n}\n```\n\n\n## 852.[山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)\n\n> 思路：判断条件，完全\n\n```c\nint peakIndexInMountainArray(int* arr, int arrSize){\n\n  int low = 1, high = arrSize;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1])\n            return mid;\n        else if (arr[mid - 1] < arr[mid] && arr[mid] < arr[mid + 1])\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n    return -1;\n\n}\n```\n\n## 876.[链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\n\n> 思路：快慢指针，第二个指针通过 偶数判断  for循环\n\n```c\nstruct ListNode* middleNode(struct ListNode* head){\n\n    struct ListNode* pos1 = head;\n    struct ListNode* pos2 = head;\n    for (int i = 0; pos1->next != NULL; pos1 = pos1->next, i++) {\n        if (i % 2 == 0) {\n            pos2 = pos2->next;\n        }\n    }\n    return pos2;\n}\n```\n\n## 905.[按奇偶排序数组](https://leetcode-cn.com/problems/sort-array-by-parity/)\n\n> 思路: 一、双指针，同917\n二、判断，前后索引移动，双指针\n\n- 解法一：\n```c\nint* sortArrayByParity(int* nums, int numsSize, int* returnSize)\n{\n    *returnSize = numsSize;\n    int start = 0;\n    int end = numsSize - 1;\n    while (start < end) {\n        while (start < end && nums[start] % 2 == 0) {\n            start++;\n        }\n        while (end > start && nums[end] % 2 == 1) {\n            end--;\n        }\n        while (start < end && nums[start] % 2 != 0 && nums[end] % 2 != 1) {\n            int tmp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = tmp;\n            start++;\n            end--;\n        }\n    }\n    return nums;\n}\n\nint* sortArrayByParity(int* nums, int numsSize, int* returnSize){\n    *returnSize = numsSize;\n    int left = 0;\n    int right = numsSize - 1;\n    while (left < right) {\n         if (nums[left] % 2 == 0) {\n            left++;\n            continue;\n         }\n         if (nums[right] % 2 == 1) {\n             right--;\n             continue;\n         }\n\n         int tmp = nums[left];\n         nums[left] = nums[right];\n         nums[right] = tmp;\n         left++;\n         right--;\n    }\n    return nums;\n\n}\n```\n\n- 解法二；\n```c\nint* sortArrayByParity(int* nums, int numsSize, int* returnSize){\n    int *res = (int *)malloc(sizeof(int) * numsSize);\n    *returnSize = numsSize;\n    int j = 0;\n    int p = numsSize - 1;\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] % 2 == 0) {\n            res[j] = nums[i];\n            j++;\n        } else {\n            res[p] = nums[i];\n            p--;\n        }\n    }\n    return res;\n}\n```\n\n\n## 917.[仅仅反转字母](https://leetcode-cn.com/problems/reverse-only-letters/)\n\n> 思路：双指针，库函数 isalpha， continue\n\n```c\nchar * reverseOnlyLetters(char * s){\n    int len = strlen(s);\n    int left = 0;\n    int right = len - 1;\n    while (left < right) {\n        if (!isalpha(s[left])) {\n            left++;\n            continue;\n        }\n         if (!isalpha(s[right])) {\n            right--;\n            continue;\n        }\n        //if (isalpha(s[left]) && isalpha(s[right])) {\n            char c = s[left];\n            s[left] = s[right];\n            s[right] = c;\n            left++;\n            right--;\n        //}\n       \n    }\n    return s;\n}\n```\n\n\n## 938.[二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)\n\n```c\nint rangeSumBST(struct TreeNode* root, int low, int high){\n\n    if (root == NULL) {\n        return 0;\n    }\n\n    if (low > root->val) {\n        return rangeSumBST(root->right, low, high);\n    }\n    if (high < root->val) {\n        return rangeSumBST(root->left, low, high);\n    }\n    return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\n\n}\n```\n\n```c\nint rangeSumBST(struct TreeNode* root, int low, int high){\n    if (root == NULL) {\n        return 0;\n    } else if (root->val >= low && root->val <= high) {\n        return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\n    } else {\n        return rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\n    }\n}\n```\n\n\n\n\n## 965.[单值二叉树](https://leetcode-cn.com/problems/univalued-binary-tree/)\n\n> 思路：递归，递归出口：root == NULL\n\n```c\nbool isUnivalTree(struct TreeNode* root){\n    // root不判空会报错：\n    // member access within null pointer of type 'struct TreeNode'\n    if (root == NULL) {\n        return true;\n    }\n    // 多余\n   /*  if (root->left == NULL && root->right == NULL) {\n        return true;\n    } */\n\n\n    if (root->left != NULL) {\n        if (root->left->val != root->val) {\n            return false;\n        }\n    }\n\n    if (root->right != NULL) {\n        if (root->right->val != root->val) {\n            return false;\n        }\n    }\n\n    return isUnivalTree(root->left) && isUnivalTree(root->right);\n\n}\n```\n\n\n## 977.[有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/submissions/)\n\n> 思路\n\n```c\nint Cmp(const void* a,  const void* b)\n{\n    return *(int *)a - *(int *)b;\n}\n\nint* sortedSquares(int* nums, int numsSize, int* returnSize){\n\n    int* squareNum = (int *)malloc(sizeof(int) * numsSize);\n    *returnSize = numsSize;\n    for (int i = 0; i < numsSize; i++) {\n        //squareNum[i] = nums[i] * nums[i];\n        squareNum[i] = pow(nums[i], 2);\n    }\n    qsort(squareNum, numsSize, sizeof(int), Cmp);\n    return squareNum;\n}\n```\n\n## 1089.[复写零](https://leetcode-cn.com/problems/duplicate-zeros/)\n\n> 思路：将原数组复制一份，根据复制数组，修改原数组值\n\n```c\nvoid duplicateZeros(int* arr, int arrSize)\n{\n    int b[arrSize]; // = {0};\n    memcpy(b, arr, sizeof(int) * arrSize);\n    for (int i = 0, j = 0; i < arrSize && j < arrSize; i++) {\n        arr[j++] = b[i];\n        if (j < arrSize && b[i] == 0) {\n            arr[j++] = 0;\n        }\n    }W\n}\n```\n\n```c\nvoid duplicateZeros(int* arr, int arrSize){\n\n    int * nums = (int *)malloc(sizeof(int) * arrSize);\n    for (int i = 0; i < arrSize; i++) {\n        nums[i] = arr[i];\n    }\n\n    int j = 0;\n    for (int i = 0; i < arrSize; i++, j++) {\n        arr[i] = nums[j];\n        if (i + 1 < arrSize && nums[j] == 0) {\n            arr[++i] = 0; \n        }\n    }\n\n}\n```\n\n\n\n## 1184.[公交站间的距离](https://leetcode-cn.com/problems/distance-between-bus-stops/submissions/)\n\n> 思路: 保证 start 小于 destination， 计算一圈的总长度sum，计算start到destination的距离d，取d与sum-d两者较小值\n\n```c\nint distanceBetweenBusStops(int* distance, int distanceSize, int start, int destination){\n    \n    if (start > destination) {\n        int tmp = start;\n        start = destination;\n        destination = tmp;\n    }\n\n    int min = 0;\n    int sum = 0;\n    for (int i = 0; i < distanceSize; i++) {\n        sum += distance[i];\n        if (i >= start && i < destination) {\n            min += distance[i];\n        }\n    }\n\n    min = min < (sum - min) ? min : sum - min;\n    return min;\n}\n```\n\n## 1189.[ “气球” 的最大数量](https://leetcode-cn.com/problems/maximum-number-of-balloons/)\n\n> 思路：统计字符次数，注意 字符串指针  取值 *p  或者 字符数组 test[i]\n\n```c\nint maxNumberOfBalloons(char * text){\n    int len = strlen(text);\n    int table[5] = {0};\n\n    char* p = text;\n    while (*p != '\\0') {\n        if (*p == 'b') {\n            table[0]++;\n        }\n        if (*p == 'a') {\n            table[1]++;\n        }\n        if (*p == 'l') {\n            table[2]++;\n        }\n        if (*p == 'o') {\n            table[3]++;\n        }\n        if (*p == 'n') {\n            table[4]++;\n        }\n        p++;\n    }\n\n    table[2] /= 2;\n    table[3] /= 2;\n    int min = INT_MAX;\n    for (int i = 0; i < 5; i++) {\n        min = min < table[i] ? min : table[i];\n    }\n    return min;\n\n}\n\n\n/* int maxNumberOfBalloons(char * text){\n    int len = strlen(text);\n\n    int testNum[5] = {0};\n\n    for (int i = 0; i < len; i++) {\n        if (text[i] == 'b') {\n            testNum[0]++;\n        }\n        if (text[i] == 'a') {\n            testNum[1]++;\n        }\n\n        if (text[i] == 'l') {\n            testNum[2]++;\n        }\n\n        if (text[i] == 'o') {\n            testNum[3]++;\n        }\n\n        if (text[i] == 'n') {\n            testNum[4]++;\n        }\n    }\n\n    testNum[2] /= 2;\n    testNum[3] /= 2;\n\n    int res = INT_MAX;\n    for (int i = 0; i < 5; i++) {\n        res = res < testNum[i] ? res : testNum[i];\n    }\n    return res;\n\n} */\n```\n\n\n\n## 1207.[独一无二的出现次数](https://leetcode-cn.com/problems/unique-number-of-occurrences/)\n\n解法一\n> 通过一个表统计每个数字出现的次数，定义另外一个表记录表一中每一项的，如果出现相同数字，则返回false，遍历到最后时返回true\n\n\n\n<details>\n<summary>uniqueOccurrences</summary>\n\n```c\nbool uniqueOccurrences(int* arr, int arrSize){\n    int table[2001] = {0};\n\n    for (int i = 0; i < arrSize; i++) {\n        table[arr[i] + 1000]++;\n        printf(\"table[arr[%d] + 1000] = %d\\n\", i, table[arr[i] + 1000]);\n    }\n\n    int table1[2001] = {0};\n    for (int i = 0; i < 2001; i++) {\n        table1[i] = 0;\n        if (table[i] != 0) {\n            if (table1[table[i]] != 0) {\n                printf(\"table1[table[%d]] = %d\\n\", i, table1[table[i]]);\n                return false;\n            } else {\n                table1[table[i]]++;\n            }\n        }\n        \n    }\n    return true;\n\n}\n```\n\n解法二：\n> 同解法一\n```c\n/* */\nbool uniqueOccurrences(int* arr, int arrSize){\n   int hashTable[2001]={0};//初始化一张表，下标对应元素值，存储对应元素出现的次数\n    for(int i=0;i<arrSize;i++) {\n        hashTable[arr[i]+1000]++;\n    }\n    bool visited[1001]={false};\n    for(int i=0;i<2001;i++) {\n        if(hashTable[i]) { //如果i在数组中\n            if(visited[hashTable[i]]) { //如果之前出现过与i相同的重复次数\n                return false;\n            } else {\n                visited[hashTable[i]]=true;//说明与i相同的重复次数还未出现，设置为已访问过\n            }\n        }\n    }\n    return true;\n\n} \n\n```\n</details>\n\n\n\n\n\n\n\n\n","slug":"2022/leetcode未分类题目","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8ve000f0guu98z98h5n","content":"<p>1207, 876, 701, 674, 367， 231  206 201  189  160</p>\n<span id=\"more\"></span>\n\n<h2 id=\"146-只出现一次的数字\"><a href=\"#146-只出现一次的数字\" class=\"headerlink\" title=\"146.只出现一次的数字\"></a>146.<a href=\"https://leetcode-cn.com/problems/single-number/\">只出现一次的数字</a></h2><blockquote>\n<p>思路：n ^ n = 0 一个数与自己异或为 0</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        res = res ^ nums[i];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"141-环形链表\"><a href=\"#141-环形链表\" class=\"headerlink\" title=\"141.环形链表\"></a>141.<a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\">环形链表</a></h2><blockquote>\n<p>思路：快慢双指针</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(struct ListNode *head)</span> </span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">slow</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">fast</span> =</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) {</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slow == fast) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"142-环形链表-II\"><a href=\"#142-环形链表-II\" class=\"headerlink\" title=\"142.环形链表 II\"></a>142.<a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">环形链表 II</a></h2><blockquote>\n<p>思路：快慢双指针</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(struct ListNode *head)</span> </span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">slow</span> =</span> (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">fast</span> =</span> (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">    slow = head;</span><br><span class=\"line\">    fast = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slow == fast) {</span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">entry</span> =</span> head;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (slow != entry) {</span><br><span class=\"line\">                slow = slow-&gt;next;</span><br><span class=\"line\">                entry = entry-&gt;next;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">return</span> entry;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"153-寻找旋转排序数组中的最小值\"><a href=\"#153-寻找旋转排序数组中的最小值\" class=\"headerlink\" title=\"153.寻找旋转排序数组中的最小值\"></a>153.<a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/\">寻找旋转排序数组中的最小值</a></h2><blockquote>\n<p>思路：二分查找</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = numsSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] &lt; nums[high]) {</span><br><span class=\"line\">            high = mid;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[low];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; numsSize - <span class=\"number\">1</span>; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &gt; nums[(i+<span class=\"number\">1</span>)]) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"160-相交链表\"><a href=\"#160-相交链表\" class=\"headerlink\" title=\"160.相交链表\"></a>160.<a href=\"https://leetcode-cn.com/problemset/all/?page=1&amp;search=160\">相交链表</a></h2><blockquote>\n<p>思路：<br>一、<br>二、先统计两个链表结点个数，然后长链表先走个数差位</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(struct ListNode *headA, struct ListNode *headB)</span> </span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">cur1</span> =</span> headA;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">cur2</span> =</span> headB;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur1 == <span class=\"literal\">NULL</span> || cur2 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur1 &amp;&amp; cur2 &amp;&amp; cur1 != cur2) {</span><br><span class=\"line\">        cur1 = cur1-&gt;next;</span><br><span class=\"line\">        cur2 = cur2-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur1 == cur2) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur1;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cur1) {</span><br><span class=\"line\">            cur1 = headB;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cur2) {</span><br><span class=\"line\">            cur2 = headA;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur1;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h2 id=\"169-多数元素\"><a href=\"#169-多数元素\" class=\"headerlink\" title=\"169.多数元素\"></a>169.<a href=\"https://leetcode-cn.com/problems/majority-element/\">多数元素</a></h2><blockquote>\n<p>思路：选定一个主元素，计数器</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> majorNum = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            majorNum = nums[i];</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (majorNum == nums[i]) {</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            count--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> majorNum;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h2 id=\"173-二叉搜索树迭代器\"><a href=\"#173-二叉搜索树迭代器\" class=\"headerlink\" title=\"173.二叉搜索树迭代器\"></a>173.<a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator/\">二叉搜索树迭代器</a></h2><blockquote>\n<p>思路：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>* res;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx;</span><br><span class=\"line\">} BSTIterator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getTreeSize</span><span class=\"params\">(struct TreeNode* root)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> + getTreeSize(root-&gt;left) + getTreeSize(root-&gt;right);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">int</span>* retSize, struct TreeNode* root)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    inorder(ret, retSize, root-&gt;left);</span><br><span class=\"line\">    ret[(*retSize)++] = root-&gt;val;</span><br><span class=\"line\">    inorder(ret, retSize, root-&gt;right);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">inorderTraversal</span><span class=\"params\">(<span class=\"keyword\">int</span>* retSize, struct TreeNode* root)</span> </span>{</span><br><span class=\"line\">    *retSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* ret = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * getTreeSize(root));</span><br><span class=\"line\">    inorder(ret, retSize, root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">BSTIterator* <span class=\"title\">bSTIteratorCreate</span><span class=\"params\">(struct TreeNode* root)</span> </span>{</span><br><span class=\"line\">    BSTIterator* ret = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BSTIterator));</span><br><span class=\"line\">    ret-&gt;res = inorderTraversal(&amp;(ret-&gt;size), root);</span><br><span class=\"line\">    ret-&gt;idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bSTIteratorNext</span><span class=\"params\">(BSTIterator* obj)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj-&gt;res[(obj-&gt;idx)++];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bSTIteratorHasNext</span><span class=\"params\">(BSTIterator* obj)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj-&gt;idx &lt; obj-&gt;size);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bSTIteratorFree</span><span class=\"params\">(BSTIterator* obj)</span> </span>{</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj-&gt;res);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"189-轮转数组\"><a href=\"#189-轮转数组\" class=\"headerlink\" title=\"189.轮转数组\"></a>189.<a href=\"https://leetcode-cn.com/problems/rotate-array/\">轮转数组</a></h2><blockquote>\n<p>思路：<br>一、每次移动一个数<br>二、先整体翻转，在翻转前k个，最后翻转 numsSize - k个</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveOne</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = nums[numsSize - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = numsSize - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) {</span><br><span class=\"line\">        nums[i] = nums[i<span class=\"number\">-1</span>]; </span><br><span class=\"line\">    }</span><br><span class=\"line\">    nums[<span class=\"number\">0</span>] = tmp;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) {</span><br><span class=\"line\">        moveOne(nums, numsSize);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>* a, <span class=\"keyword\">int</span>* b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = *a;</span><br><span class=\"line\">    *a = *b;</span><br><span class=\"line\">    *b = t;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start &lt; end) {</span><br><span class=\"line\">        swap(&amp;nums[start], &amp;nums[end]);</span><br><span class=\"line\">        start += <span class=\"number\">1</span>;</span><br><span class=\"line\">        end -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> k)</span> </span>{</span><br><span class=\"line\">    k %= numsSize;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"nums[%d] = %d\\t\"</span>, i, nums[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    reverse(nums, <span class=\"number\">0</span>, numsSize - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"nums[%d] = %d\\t\"</span>, i, nums[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    reverse(nums, <span class=\"number\">0</span>, k - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"nums[%d] = %d\\t\"</span>, i, nums[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    reverse(nums, k, numsSize - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"nums[%d] = %d\\t\"</span>, i, nums[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">void rotate(int* nums, int numsSize, int k){</span></span><br><span class=\"line\"><span class=\"comment\">     for (int i = 0; i &lt; k; i++) {</span></span><br><span class=\"line\"><span class=\"comment\">        int lastElement = nums[numsSize - 1];</span></span><br><span class=\"line\"><span class=\"comment\">        for (int j = numsSize - 1; j &gt; 0; j--) {</span></span><br><span class=\"line\"><span class=\"comment\">            nums[j] = nums[j - 1];</span></span><br><span class=\"line\"><span class=\"comment\">        }</span></span><br><span class=\"line\"><span class=\"comment\">        nums[0] = lastElement;</span></span><br><span class=\"line\"><span class=\"comment\">    } </span></span><br><span class=\"line\"><span class=\"comment\">}*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">void rotate(int* nums, int numsSize, int k){</span></span><br><span class=\"line\"><span class=\"comment\">    if (k == numsSize / 2 &amp;&amp; numsSize % 2 != 1) {</span></span><br><span class=\"line\"><span class=\"comment\">        for (int i = 0; i &lt; k; i++) {</span></span><br><span class=\"line\"><span class=\"comment\">            int tmp = nums[i];</span></span><br><span class=\"line\"><span class=\"comment\">            nums[i] = nums[k+i];</span></span><br><span class=\"line\"><span class=\"comment\">            nums[k+i] = tmp;</span></span><br><span class=\"line\"><span class=\"comment\">        }</span></span><br><span class=\"line\"><span class=\"comment\">        return;</span></span><br><span class=\"line\"><span class=\"comment\">    }</span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">    int i = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    int tmp = nums[0];</span></span><br><span class=\"line\"><span class=\"comment\">    int p = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    int count = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    do {</span></span><br><span class=\"line\"><span class=\"comment\">        p = (i + k) % numsSize;</span></span><br><span class=\"line\"><span class=\"comment\">        printf(\"p = %d\\n\",p);</span></span><br><span class=\"line\"><span class=\"comment\">        int t = nums[p];</span></span><br><span class=\"line\"><span class=\"comment\">        nums[p] = tmp;</span></span><br><span class=\"line\"><span class=\"comment\">        tmp = t;</span></span><br><span class=\"line\"><span class=\"comment\">        i = p;</span></span><br><span class=\"line\"><span class=\"comment\">     } while (i != 0);</span></span><br><span class=\"line\"><span class=\"comment\">} */</span> </span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"190-颠倒二进制位\"><a href=\"#190-颠倒二进制位\" class=\"headerlink\" title=\"190.颠倒二进制位\"></a>190.<a href=\"https://leetcode-cn.com/problems/reverse-bits/submissions/\">颠倒二进制位</a></h2><blockquote>\n<p>思路：32位，</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint32_t</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> n)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> m = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">32</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cnt) {</span><br><span class=\"line\">        m &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        m += (n &amp; <span class=\"number\">0x1</span>);</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        cnt--;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"191-位1的个数\"><a href=\"#191-位1的个数\" class=\"headerlink\" title=\"191.位1的个数\"></a>191.<a href=\"https://leetcode-cn.com/problems/number-of-1-bits/submissions/\">位1的个数</a></h2><blockquote>\n<p>思路：n &amp; 0x1</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> n)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">0x1</span>) {</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"201-数字范围按位与\"><a href=\"#201-数字范围按位与\" class=\"headerlink\" title=\"201.数字范围按位与\"></a>201.<a href=\"https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/\">数字范围按位与</a></h2><blockquote>\n<p>思路：n &amp; (n - 1) 去除n最高位的1</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rangeBitwiseAnd</span><span class=\"params\">(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) {</span><br><span class=\"line\">        right &amp;= right - <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203.移除链表元素\"></a>203.<a href=\"https://leetcode-cn.com/problems/remove-linked-list-elements/\">移除链表元素</a></h2><blockquote>\n<p>思路：递归</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode *<span class=\"title\">removeElements</span><span class=\"params\">(struct ListNode *head, <span class=\"keyword\">int</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head-&gt;val == val) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> removeElements(head-&gt;next, val);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206.反转链表\"></a>206.<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">反转链表</a></h2><blockquote>\n<p>思路：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(struct ListNode* head)</span></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">res</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (head) {</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">pre_node</span> =</span> head;</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">        pre_node-&gt;next = res;</span><br><span class=\"line\">        res = pre_node;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"215-数组中的第K个最大元素\"><a href=\"#215-数组中的第K个最大元素\" class=\"headerlink\" title=\"215.数组中的第K个最大元素\"></a>215.<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">数组中的第K个最大元素</a></h2><blockquote>\n<p>思路：排序，第k个最大</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">int</span> *)b - *(<span class=\"keyword\">int</span> *)a;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> k)</span></span>{</span><br><span class=\"line\">    qsort(nums, numsSize, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), Cmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[k<span class=\"number\">-1</span>];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"217-存在重复元素\"><a href=\"#217-存在重复元素\" class=\"headerlink\" title=\"217.存在重复元素\"></a>217.<a href=\"https://leetcode-cn.com/problems/contains-duplicate/\">存在重复元素</a></h2><blockquote>\n<p>思路：<br>一、排序，比较前一个数和当前数是否相等<br>二、uthash</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">int</span> *)a - *(<span class=\"keyword\">int</span> *)b;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numsSize &lt;= <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    qsort(nums, numsSize, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), Cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i<span class=\"number\">-1</span>] == nums[i]) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    UT_hash_handle hh;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">users</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">s</span>;</span></span><br><span class=\"line\">   HASH_FIND_INT(users, nums[i], s);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">       s = (struct my_struct*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct my_struct));</span><br><span class=\"line\">       s-&gt;id = nums[i];</span><br><span class=\"line\">       HASH_ADD_INT(users, id, s);</span><br><span class=\"line\">   } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">   }</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"226-翻转二叉树\"><a href=\"#226-翻转二叉树\" class=\"headerlink\" title=\"226.翻转二叉树\"></a>226.<a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\">翻转二叉树</a></h2><blockquote>\n<p>思路：判空，交换左右子树，递归调用</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(struct TreeNode* root)</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">tmp</span> =</span> root-&gt;left;</span><br><span class=\"line\">    root-&gt;left = root-&gt;right;</span><br><span class=\"line\">    root-&gt;right = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">    invertTree(root-&gt;left);</span><br><span class=\"line\">    invertTree(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(struct TreeNode* root)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">left</span> =</span> (struct TreeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TreeNode));</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">right</span> =</span> (struct TreeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TreeNode));</span><br><span class=\"line\">    left = invertTree(root-&gt;left);</span><br><span class=\"line\">    right = invertTree(root-&gt;right);</span><br><span class=\"line\">    root-&gt;left = right;</span><br><span class=\"line\">    root-&gt;right = left;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"231-2的幂\"><a href=\"#231-2的幂\" class=\"headerlink\" title=\"231.2的幂\"></a>231.<a href=\"https://leetcode-cn.com/problems/power-of-two/\">2的幂</a></h2><blockquote>\n<p>思路：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!n) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        n /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n == <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> res = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> != <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }<span class=\"keyword\">else</span> {</span><br><span class=\"line\">       res = isPowerOfTwo(n/<span class=\"number\">2</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>{</span><br><span class=\"line\">    <span class=\"comment\">//用位运算来判断有几个1，要是只有一个1那就是2的幂。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt;= <span class=\"number\">2147483647</span> || n &lt;= <span class=\"number\">-2147483648</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nu m =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n&gt;<span class=\"number\">0</span> &amp;&amp; n!=<span class=\"number\">0</span>) {</span><br><span class=\"line\">        n &amp;= (n<span class=\"number\">-1</span>);</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num!=<span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"234-回文链表\"><a href=\"#234-回文链表\" class=\"headerlink\" title=\"234.回文链表\"></a>234.<a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/submissions/\">回文链表</a></h2><blockquote>\n<p>思路；<br>一、通过一个数组记录链表中的元素值，在判断数组是否是回文。<br>二、翻转链表</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 100000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(struct ListNode* head)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nums[MAXSIZE] = {<span class=\"number\">0</span>};</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">p</span> =</span> head;</span><br><span class=\"line\">    <span class=\"comment\">// 判断条件</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p) {</span><br><span class=\"line\">        nums[size++] = p-&gt;val;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"size = %d\\n\"</span>, size);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = size - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt;= right) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[left] != nums[right]) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode *<span class=\"title\">reverse</span><span class=\"params\">(struct ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">res</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (head) {</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">pre_node</span> =</span> head;</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">        pre_node-&gt;next = res;</span><br><span class=\"line\">        res = pre_node;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(struct ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">slow</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">fast</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">last</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast &amp;&amp; fast-&gt;next) {</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fast != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    last = reverse(slow);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (last) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head-&gt;val != last-&gt;val) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">        last = last-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"242-有效的字母异位词\"><a href=\"#242-有效的字母异位词\" class=\"headerlink\" title=\"242.有效的字母异位词\"></a>242.<a href=\"https://leetcode-cn.com/problems/valid-anagram/submissions/\">有效的字母异位词</a></h2><blockquote>\n<p>思路：先比较长度，不相等 false，通过表格记录第一个字符串中字符，遍历第二个字符串时表格记录–，最后，判断表格中所有值是否为零</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NUMSIZE 256</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isAnagram</span><span class=\"params\">(<span class=\"keyword\">char</span> * s, <span class=\"keyword\">char</span> * t)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tLen = <span class=\"built_in\">strlen</span>(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sLen != tLen) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[<span class=\"number\">256</span>] = {<span class=\"number\">0</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sLen; i++) {</span><br><span class=\"line\">        table[s[i]]++;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tLen; i++) {</span><br><span class=\"line\">        table[t[i]]--;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NUMSIZE; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[i] != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"268-丢失的数字\"><a href=\"#268-丢失的数字\" class=\"headerlink\" title=\"268.丢失的数字\"></a>268.<a href=\"https://leetcode-cn.com/problems/missing-number/\">丢失的数字</a></h2><blockquote>\n<p>思路：边求和，边减去数组中的数字</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        mNum += (i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        mNum -= nums[i];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mNum;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"278-第一个错误的版本\"><a href=\"#278-第一个错误的版本\" class=\"headerlink\" title=\"278.第一个错误的版本\"></a>278.<a href=\"https://leetcode-cn.com/problems/first-bad-version/\">第一个错误的版本</a></h2><blockquote>\n<p>思路：二分查找</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">firstBadVersion</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt;= right) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isBadVersion(mid) &amp;&amp; !isBadVersion(mid<span class=\"number\">-1</span>)) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isBadVersion(mid) &amp;&amp; isBadVersion(mid<span class=\"number\">-1</span>)) {</span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">firstBadVersion</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">1</span>, high = n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isBadVersion(mid)) {</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"283-移动零\"><a href=\"#283-移动零\" class=\"headerlink\" title=\"283.移动零\"></a>283.<a href=\"https://leetcode-cn.com/problems/move-zeroes/\">移动零</a></h2><blockquote>\n<p>思路：不等于零时向数组中添加，等于零时跳过，最后填充0<br>nums[start++] = nums[i]</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            nums[start++] = nums[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; start &lt; numsSize; start++) {</span><br><span class=\"line\">        nums[start] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    }    </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"287-寻找重复整数\"><a href=\"#287-寻找重复整数\" class=\"headerlink\" title=\"287.寻找重复整数\"></a>287.<a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number/\">寻找重复整数</a></h2><blockquote>\n<p>思路：循环遍历，标记，判断是否标记过，return</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 100001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[MAXSIZE] = {<span class=\"number\">0</span>};</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[nums[i]] != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            table[nums[i]]++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"344-反转字符串\"><a href=\"#344-反转字符串\" class=\"headerlink\" title=\"344.反转字符串\"></a>344.<a href=\"https://leetcode-cn.com/problems/reverse-string/\">反转字符串</a></h2><blockquote>\n<p>思路：双指针，交换</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverseString</span><span class=\"params\">(<span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> sSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = sSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) {</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = s[left];</span><br><span class=\"line\">        s[left] = s[right];</span><br><span class=\"line\">        s[right] = c;</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"367-有效的完全平方数\"><a href=\"#367-有效的完全平方数\" class=\"headerlink\" title=\"367.有效的完全平方数\"></a>367.<a href=\"https://leetcode-cn.com/problems/valid-perfect-square/\">有效的完全平方数</a></h2><blockquote>\n<p>思路：for 循环，条件 i * i &lt;= num </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPerfectSquare</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> i = <span class=\"number\">0</span>; i * i &lt;= num; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i * i == num) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"387-字符串中的第一个唯一字符\"><a href=\"#387-字符串中的第一个唯一字符\" class=\"headerlink\" title=\"387.字符串中的第一个唯一字符\"></a>387.<a href=\"https://leetcode-cn.com/problems/first-unique-character-in-a-string/\">字符串中的第一个唯一字符</a></h2><blockquote>\n<p>思路：两次遍历，第一次遍历见字母标记得到统计表格中，第二次遍历找出统计表格中第一个为1字符，返回对应下标。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NUMSIZE 256</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[NUMSIZE] = {<span class=\"number\">0</span>};</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sLen; i++) {</span><br><span class=\"line\">        table[s[i]]++;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sLen; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[s[i]] == <span class=\"number\">1</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"389-找不同\"><a href=\"#389-找不同\" class=\"headerlink\" title=\"389.找不同\"></a>389.<a href=\"https://leetcode-cn.com/problems/find-the-difference/\">找不同</a></h2><blockquote>\n<p>思路：字符可以转化为数字，为了防止溢出通过 - ‘a’，求两个字符串的差值，在加上’a’</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">findTheDifference</span><span class=\"params\">(<span class=\"keyword\">char</span> * s, <span class=\"keyword\">char</span> * t)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tLen = <span class=\"built_in\">strlen</span>(t);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nS = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nT = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sLen; i++) {</span><br><span class=\"line\">        nS += s[i] - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tLen; i++) {</span><br><span class=\"line\">        nT += t[i] - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">char</span>)(nT - nS + <span class=\"string\">'a'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"404-左叶子之和\"><a href=\"#404-左叶子之和\" class=\"headerlink\" title=\"404.左叶子之和\"></a>404.<a href=\"https://leetcode-cn.com/problems/sum-of-left-leaves/\">左叶子之和</a></h2><blockquote>\n<p>思路：递归：判断左子树是否为叶子结点，是则记录sum，返回 sum + 递归调用左子树 + 递归调用右子树</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfLeftLeaves</span><span class=\"params\">(struct TreeNode* root)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left-&gt;left == <span class=\"literal\">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            sum += root-&gt;left-&gt;val;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  sum + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isleaf</span><span class=\"params\">(struct TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root-&gt;left == <span class=\"literal\">NULL</span> &amp;&amp; root-&gt;right == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfLeftLeaves</span><span class=\"params\">(struct TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isleaf(root-&gt;left)) {</span><br><span class=\"line\">            <span class=\"comment\">// 此处直接递归，少一层调用</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"442-数组中重复的数据\"><a href=\"#442-数组中重复的数据\" class=\"headerlink\" title=\"442.数组中重复的数据\"></a>442.<a href=\"https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/\">数组中重复的数据</a></h2><blockquote>\n<p>思路：<br>一、通过表标记数组中出现过的数字，当再次出现时将数字添加到返回数组中。<br>二、</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 100000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">findDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[MAXSIZE] = {<span class=\"number\">0</span>};</span><br><span class=\"line\">    *returnSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *res = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * MAXSIZE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[nums[i]] == <span class=\"number\">1</span>) {</span><br><span class=\"line\">            res[*returnSize] = nums[i];</span><br><span class=\"line\">            (*returnSize)++;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            table[nums[i]]++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">findDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[<span class=\"number\">100000</span>] = {<span class=\"number\">0</span>};</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *res = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">100000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        table[nums[i]]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[nums[i]] == <span class=\"number\">2</span>) {</span><br><span class=\"line\">            res[j++] = nums[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    *returnSize = j;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h2 id=\"461-汉明距离\"><a href=\"#461-汉明距离\" class=\"headerlink\" title=\"461.汉明距离\"></a>461.<a href=\"https://leetcode-cn.com/problems/hamming-distance/\">汉明距离</a></h2><blockquote>\n<p>思路：<br>一、求 x ^ y 中 1 的个数<br>二、比较x，y的每一位 和 1与</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = x ^ y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = n &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p) {</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x || y) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nX = x &amp; <span class=\"number\">0x1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nY = y &amp; <span class=\"number\">0x1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nX != nY) {</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        x &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        y &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"476-数字的补数\"><a href=\"#476-数字的补数\" class=\"headerlink\" title=\"476.数字的补数\"></a>476.<a href=\"https://leetcode-cn.com/problems/number-complement/\">数字的补数</a></h2><blockquote>\n<p>思路：<br>一、按位与1求与，再取反(!)，然后移位，<br>二、先统计位数，在取位数相同全一数，最后与原数字求异或 ^</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findComplement</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (num) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = !(num &amp; <span class=\"number\">0x1</span>);</span><br><span class=\"line\">        t &lt;&lt;= count;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"t = %d\\n\"</span>, t);</span><br><span class=\"line\">        res += t;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        num&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findComplement</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> totalBits = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = num;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp) {</span><br><span class=\"line\">        totalBits++;</span><br><span class=\"line\">        tmp &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flipNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; totalBits; i++) {</span><br><span class=\"line\">        flipNumber += UINT32_C(<span class=\"number\">1</span>) &lt;&lt; i;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    num = num ^ flipNumber;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"509-斐波那契数列\"><a href=\"#509-斐波那契数列\" class=\"headerlink\" title=\"509.斐波那契数列\"></a>509.<a href=\"https://leetcode-cn.com/problems/fibonacci-number/\">斐波那契数列</a></h2><blockquote>\n<p>思路：一、递归  二、迭代</p>\n</blockquote>\n<ul>\n<li><p>递归</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(n - <span class=\"number\">1</span>) + fib(n - <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n<li><p>迭代</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* nums = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * (n + <span class=\"number\">1</span>));</span><br><span class=\"line\">    nums[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    nums[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) {</span><br><span class=\"line\">        nums[i] = nums[i - <span class=\"number\">1</span>] + nums[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[n];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h2 id=\"520-检测大写字母\"><a href=\"#520-检测大写字母\" class=\"headerlink\" title=\"520.检测大写字母\"></a>520.<a href=\"https://leetcode-cn.com/problems/detect-capital/submissions/\">检测大写字母</a></h2><blockquote>\n<p>思路：<br>一、先判断第二个字母是否为大写，1.word[1] 大写，从从零开始判断是否全为大写 2.word[1]为小写，从word是否全为小写。<br>二、</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">detectCapitalUse</span><span class=\"params\">(<span class=\"keyword\">char</span> * word)</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(word);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isupper</span>(word[i])) {</span><br><span class=\"line\">        i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (word[i] != <span class=\"string\">'\\0'</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">isupper</span>(word[i])) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (word[i] != <span class=\"string\">'\\0'</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isupper</span>(word[i])) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">detectCapitalUse</span><span class=\"params\">(<span class=\"keyword\">char</span> * word)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(word);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; len; i++) {</span><br><span class=\"line\">        <span class=\"comment\">// word[0] 每次都需要判断，一个复杂度。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isupper</span>(word[<span class=\"number\">0</span>]) &amp;&amp; <span class=\"built_in\">isupper</span>(word[<span class=\"number\">1</span>])) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">isupper</span>(word[i])) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isupper</span>(word[i])) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h2 id=\"561-拆分数组I\"><a href=\"#561-拆分数组I\" class=\"headerlink\" title=\"561.拆分数组I\"></a>561.<a href=\"https://leetcode-cn.com/problems/array-partition-i/\">拆分数组I</a></h2><blockquote>\n<p>思路：排序，取偶数位求和。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">int</span> *)a - *(<span class=\"keyword\">int</span> *)b;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrayPairSum</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">    qsort(nums, numsSize, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), Cmp);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            minSum += nums[i];</span><br><span class=\"line\">        }    </span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minSum;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"617-合并二叉树\"><a href=\"#617-合并二叉树\" class=\"headerlink\" title=\"617.合并二叉树\"></a>617.<a href=\"https://leetcode-cn.com/problems/merge-two-binary-trees/\">合并二叉树</a></h2><blockquote>\n<p>思路：递归，判空，</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">newNode</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">node</span> =</span> <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TreeNode));</span><br><span class=\"line\">    node-&gt;val = val;</span><br><span class=\"line\">    node-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">mergeTrees</span><span class=\"params\">(struct TreeNode* root1, struct TreeNode* root2)</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/*  if (root1 == NULL &amp;&amp; root2 == NULL) {</span></span><br><span class=\"line\"><span class=\"comment\">        return NULL;</span></span><br><span class=\"line\"><span class=\"comment\">    } */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root1 == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root2;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root2 == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root1;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"comment\">/*  struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));</span></span><br><span class=\"line\"><span class=\"comment\">    root-&gt;val += root1 == NULL ? 0 : root1-&gt;val;</span></span><br><span class=\"line\"><span class=\"comment\">    root-&gt;val += root2 == NULL ? 0 : root2-&gt;val;</span></span><br><span class=\"line\"><span class=\"comment\">    root-&gt;left = NULL;</span></span><br><span class=\"line\"><span class=\"comment\">    root-&gt;right = NULL; */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val = (root1 == <span class=\"literal\">NULL</span> ? <span class=\"number\">0</span> : root1-&gt;val) + (root2 == <span class=\"literal\">NULL</span> ? <span class=\"number\">0</span> : root2-&gt;val);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">root</span>  =</span> newNode(val);</span><br><span class=\"line\">    root-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class=\"line\">    root-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"647-回文子串\"><a href=\"#647-回文子串\" class=\"headerlink\" title=\"647.回文子串\"></a>647.<a href=\"https://leetcode-cn.com/problems/palindromic-substrings/\">回文子串</a></h2><blockquote>\n<p>思路：左侧判断去重，左右判断相等。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countSubstrings</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = len; <span class=\"comment\">// 每个字符都是回文</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p &gt;= <span class=\"number\">0</span> &amp;&amp; s[p] == s[i]) { <span class=\"comment\">// 左侧去重</span></span><br><span class=\"line\">            res++;</span><br><span class=\"line\">            p--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">int</span> q = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p &gt;= <span class=\"number\">0</span> &amp;&amp; q &lt; len &amp;&amp; s[p] == s[q]) { <span class=\"comment\">// 判断左右相等</span></span><br><span class=\"line\">            res++;</span><br><span class=\"line\">            p--;</span><br><span class=\"line\">            q++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countSubstrings</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">        count += countPalin(s, i, i, len);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != len - <span class=\"number\">1</span>) {</span><br><span class=\"line\">            count += countPalin(s, i, i+<span class=\"number\">1</span>, len);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countPalin</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">int</span> head, <span class=\"keyword\">int</span> tail, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = (s[head] == s[tail]) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &amp;&amp; head - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> &amp;&amp; tail + <span class=\"number\">1</span> &lt; len) {</span><br><span class=\"line\">        ret += countPalin(s, head - <span class=\"number\">1</span>, tail + <span class=\"number\">1</span>, len);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"674-最长连续递增序列\"><a href=\"#674-最长连续递增序列\" class=\"headerlink\" title=\"674.最长连续递增序列\"></a>674.<a href=\"https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/\">最长连续递增序列</a></h2><blockquote>\n<p>思路：双循环判断，</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLengthOfLCIS</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numsSize == <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; numsSize &amp;&amp; nums[i<span class=\"number\">-1</span>] &lt; nums[i]) {</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        res = res &gt; i - p2 ? res : i - p2;</span><br><span class=\"line\">        p2 = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    } </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLengthOfLCIS</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; numsSize) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = i;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start + <span class=\"number\">1</span> &lt; numsSize &amp;&amp; nums[start] &lt; nums[start + <span class=\"number\">1</span>]) {</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        maxLen = maxLen &gt; (start - i + <span class=\"number\">1</span>) ? maxLen : (start - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        start++;</span><br><span class=\"line\">        i = start;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"700-二叉搜索树中的搜索\"><a href=\"#700-二叉搜索树中的搜索\" class=\"headerlink\" title=\"700.二叉搜索树中的搜索\"></a>700.<a href=\"https://leetcode-cn.com/problems/search-in-a-binary-search-tree/\">二叉搜索树中的搜索</a></h2><blockquote>\n<p>思路：递归，注意 判空 root == NULL</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">searchBST</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span> val)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val == val) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &gt; val) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> searchBST(root-&gt;left, val);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> searchBST(root-&gt;right, val);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"701-二叉搜索树中的插入操作\"><a href=\"#701-二叉搜索树中的插入操作\" class=\"headerlink\" title=\"701.二叉搜索树中的插入操作\"></a>701.<a href=\"https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/\">二叉搜索树中的插入操作</a></h2><blockquote>\n<p>思路：递归，递归出口，root == NULL, 新建树结点 malloc</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">insertIntoBST</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span> val)</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">newNode</span> =</span> (struct TreeNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TreeNode));</span><br><span class=\"line\">        newNode-&gt;val = val;</span><br><span class=\"line\">        newNode-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        newNode-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newNode;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val &lt; val) {</span><br><span class=\"line\">        root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val &gt; val) {</span><br><span class=\"line\">        root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704.二分查找\"></a>704.<a href=\"https://leetcode-cn.com/problems/binary-search/\">二分查找</a></h2><blockquote>\n<p>思路：二分查找，注意 left &lt;= right ，包含等于</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> target)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = numsSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt;= right) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] == target) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) {</span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"709-转换成小写字母\"><a href=\"#709-转换成小写字母\" class=\"headerlink\" title=\"709.转换成小写字母\"></a>709.<a href=\"https://leetcode-cn.com/problems/to-lower-case/\">转换成小写字母</a></h2><blockquote>\n<p>思路；库函数 isupper, tolower</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">toLowerCase</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isupper</span>(s[i])) {</span><br><span class=\"line\">            s[i] = <span class=\"built_in\">tolower</span>(s[i]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"771-宝石和石头\"><a href=\"#771-宝石和石头\" class=\"headerlink\" title=\"771.宝石和石头\"></a>771.<a href=\"https://leetcode-cn.com/problems/jewels-and-stones/\">宝石和石头</a></h2><blockquote>\n<p>思路：表记录stones中每个字符个数，求和jewels字符表中的值</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numJewelsInStones</span><span class=\"params\">(<span class=\"keyword\">char</span> * jewels, <span class=\"keyword\">char</span> * stones)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[<span class=\"number\">256</span>] = {<span class=\"number\">0</span>};</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = <span class=\"built_in\">strlen</span>(stones);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sLen; i++) {</span><br><span class=\"line\">        table[stones[i]]++;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> jLen = <span class=\"built_in\">strlen</span>(jewels);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; jLen; i++) {</span><br><span class=\"line\">        sum +=  table[jewels[i]];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h2 id=\"852-山脉数组的峰顶索引\"><a href=\"#852-山脉数组的峰顶索引\" class=\"headerlink\" title=\"852.山脉数组的峰顶索引\"></a>852.<a href=\"https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/\">山脉数组的峰顶索引</a></h2><blockquote>\n<p>思路：判断条件，完全</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">peakIndexInMountainArray</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> arrSize)</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> low = <span class=\"number\">1</span>, high = arrSize;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[mid - <span class=\"number\">1</span>] &lt; arr[mid] &amp;&amp; arr[mid] &gt; arr[mid + <span class=\"number\">1</span>])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[mid - <span class=\"number\">1</span>] &lt; arr[mid] &amp;&amp; arr[mid] &lt; arr[mid + <span class=\"number\">1</span>])</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"876-链表的中间结点\"><a href=\"#876-链表的中间结点\" class=\"headerlink\" title=\"876.链表的中间结点\"></a>876.<a href=\"https://leetcode-cn.com/problems/middle-of-the-linked-list/\">链表的中间结点</a></h2><blockquote>\n<p>思路：快慢指针，第二个指针通过 偶数判断  for循环</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">middleNode</span><span class=\"params\">(struct ListNode* head)</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">pos1</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">pos2</span> =</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; pos1-&gt;next != <span class=\"literal\">NULL</span>; pos1 = pos1-&gt;next, i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            pos2 = pos2-&gt;next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pos2;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"905-按奇偶排序数组\"><a href=\"#905-按奇偶排序数组\" class=\"headerlink\" title=\"905.按奇偶排序数组\"></a>905.<a href=\"https://leetcode-cn.com/problems/sort-array-by-parity/\">按奇偶排序数组</a></h2><blockquote>\n<p>思路: 一、双指针，同917<br>二、判断，前后索引移动，双指针</p>\n</blockquote>\n<ul>\n<li><p>解法一：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">sortArrayByParity</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    *returnSize = numsSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = numsSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start &lt; end) {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; end &amp;&amp; nums[start] % <span class=\"number\">2</span> == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (end &gt; start &amp;&amp; nums[end] % <span class=\"number\">2</span> == <span class=\"number\">1</span>) {</span><br><span class=\"line\">            end--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; end &amp;&amp; nums[start] % <span class=\"number\">2</span> != <span class=\"number\">0</span> &amp;&amp; nums[end] % <span class=\"number\">2</span> != <span class=\"number\">1</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = nums[start];</span><br><span class=\"line\">            nums[start] = nums[end];</span><br><span class=\"line\">            nums[end] = tmp;</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">            end--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">sortArrayByParity</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span></span>{</span><br><span class=\"line\">    *returnSize = numsSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = numsSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) {</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (nums[left] % <span class=\"number\">2</span> == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">         }</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (nums[right] % <span class=\"number\">2</span> == <span class=\"number\">1</span>) {</span><br><span class=\"line\">             right--;</span><br><span class=\"line\">             <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">         }</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">int</span> tmp = nums[left];</span><br><span class=\"line\">         nums[left] = nums[right];</span><br><span class=\"line\">         nums[right] = tmp;</span><br><span class=\"line\">         left++;</span><br><span class=\"line\">         right--;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n<li><p>解法二；</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">sortArrayByParity</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *res = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * numsSize);</span><br><span class=\"line\">    *returnSize = numsSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = numsSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] % <span class=\"number\">2</span> == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            res[j] = nums[i];</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            res[p] = nums[i];</span><br><span class=\"line\">            p--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h2 id=\"917-仅仅反转字母\"><a href=\"#917-仅仅反转字母\" class=\"headerlink\" title=\"917.仅仅反转字母\"></a>917.<a href=\"https://leetcode-cn.com/problems/reverse-only-letters/\">仅仅反转字母</a></h2><blockquote>\n<p>思路：双指针，库函数 isalpha， continue</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">reverseOnlyLetters</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = len - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">isalpha</span>(s[left])) {</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!<span class=\"built_in\">isalpha</span>(s[right])) {</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">//if (isalpha(s[left]) &amp;&amp; isalpha(s[right])) {</span></span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s[left];</span><br><span class=\"line\">            s[left] = s[right];</span><br><span class=\"line\">            s[right] = c;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        <span class=\"comment\">//}</span></span><br><span class=\"line\">       </span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h2 id=\"938-二叉搜索树的范围和\"><a href=\"#938-二叉搜索树的范围和\" class=\"headerlink\" title=\"938.二叉搜索树的范围和\"></a>938.<a href=\"https://leetcode-cn.com/problems/range-sum-of-bst/\">二叉搜索树的范围和</a></h2><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rangeSumBST</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &gt; root-&gt;val) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rangeSumBST(root-&gt;right, low, high);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (high &lt; root-&gt;val) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rangeSumBST(root-&gt;left, low, high);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root-&gt;val + rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high);</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rangeSumBST</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;val + rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n\n<h2 id=\"965-单值二叉树\"><a href=\"#965-单值二叉树\" class=\"headerlink\" title=\"965.单值二叉树\"></a>965.<a href=\"https://leetcode-cn.com/problems/univalued-binary-tree/\">单值二叉树</a></h2><blockquote>\n<p>思路：递归，递归出口：root == NULL</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isUnivalTree</span><span class=\"params\">(struct TreeNode* root)</span></span>{</span><br><span class=\"line\">    <span class=\"comment\">// root不判空会报错：</span></span><br><span class=\"line\">    <span class=\"comment\">// member access within null pointer of type 'struct TreeNode'</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 多余</span></span><br><span class=\"line\">   <span class=\"comment\">/*  if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) {</span></span><br><span class=\"line\"><span class=\"comment\">        return true;</span></span><br><span class=\"line\"><span class=\"comment\">    } */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left-&gt;val != root-&gt;val) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right-&gt;val != root-&gt;val) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> isUnivalTree(root-&gt;left) &amp;&amp; isUnivalTree(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h2 id=\"977-有序数组的平方\"><a href=\"#977-有序数组的平方\" class=\"headerlink\" title=\"977.有序数组的平方\"></a>977.<a href=\"https://leetcode-cn.com/problems/squares-of-a-sorted-array/submissions/\">有序数组的平方</a></h2><blockquote>\n<p>思路</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a,  <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">int</span> *)a - *(<span class=\"keyword\">int</span> *)b;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">sortedSquares</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>* squareNum = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * numsSize);</span><br><span class=\"line\">    *returnSize = numsSize;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) {</span><br><span class=\"line\">        <span class=\"comment\">//squareNum[i] = nums[i] * nums[i];</span></span><br><span class=\"line\">        squareNum[i] = <span class=\"built_in\">pow</span>(nums[i], <span class=\"number\">2</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    qsort(squareNum, numsSize, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), Cmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> squareNum;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"1089-复写零\"><a href=\"#1089-复写零\" class=\"headerlink\" title=\"1089.复写零\"></a>1089.<a href=\"https://leetcode-cn.com/problems/duplicate-zeros/\">复写零</a></h2><blockquote>\n<p>思路：将原数组复制一份，根据复制数组，修改原数组值</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">duplicateZeros</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> arrSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b[arrSize]; <span class=\"comment\">// = {0};</span></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(b, arr, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * arrSize);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; arrSize &amp;&amp; j &lt; arrSize; i++) {</span><br><span class=\"line\">        arr[j++] = b[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &lt; arrSize &amp;&amp; b[i] == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            arr[j++] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }W</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">duplicateZeros</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> arrSize)</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> * nums = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * arrSize);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arrSize; i++) {</span><br><span class=\"line\">        nums[i] = arr[i];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arrSize; i++, j++) {</span><br><span class=\"line\">        arr[i] = nums[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; arrSize &amp;&amp; nums[j] == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            arr[++i] = <span class=\"number\">0</span>; </span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"1184-公交站间的距离\"><a href=\"#1184-公交站间的距离\" class=\"headerlink\" title=\"1184.公交站间的距离\"></a>1184.<a href=\"https://leetcode-cn.com/problems/distance-between-bus-stops/submissions/\">公交站间的距离</a></h2><blockquote>\n<p>思路: 保证 start 小于 destination， 计算一圈的总长度sum，计算start到destination的距离d，取d与sum-d两者较小值</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">distanceBetweenBusStops</span><span class=\"params\">(<span class=\"keyword\">int</span>* distance, <span class=\"keyword\">int</span> distanceSize, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> destination)</span></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt; destination) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = start;</span><br><span class=\"line\">        start = destination;</span><br><span class=\"line\">        destination = tmp;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; distanceSize; i++) {</span><br><span class=\"line\">        sum += distance[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= start &amp;&amp; i &lt; destination) {</span><br><span class=\"line\">            min += distance[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    min = min &lt; (sum - min) ? min : sum - min;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"1189-“气球”-的最大数量\"><a href=\"#1189-“气球”-的最大数量\" class=\"headerlink\" title=\"1189. “气球” 的最大数量\"></a>1189.<a href=\"https://leetcode-cn.com/problems/maximum-number-of-balloons/\"> “气球” 的最大数量</a></h2><blockquote>\n<p>思路：统计字符次数，注意 字符串指针  取值 *p  或者 字符数组 test[i]</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxNumberOfBalloons</span><span class=\"params\">(<span class=\"keyword\">char</span> * text)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(text);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[<span class=\"number\">5</span>] = {<span class=\"number\">0</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span>* p = text;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*p != <span class=\"string\">'\\0'</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*p == <span class=\"string\">'b'</span>) {</span><br><span class=\"line\">            table[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*p == <span class=\"string\">'a'</span>) {</span><br><span class=\"line\">            table[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*p == <span class=\"string\">'l'</span>) {</span><br><span class=\"line\">            table[<span class=\"number\">2</span>]++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*p == <span class=\"string\">'o'</span>) {</span><br><span class=\"line\">            table[<span class=\"number\">3</span>]++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*p == <span class=\"string\">'n'</span>) {</span><br><span class=\"line\">            table[<span class=\"number\">4</span>]++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        p++;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    table[<span class=\"number\">2</span>] /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    table[<span class=\"number\">3</span>] /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) {</span><br><span class=\"line\">        min = min &lt; table[i] ? min : table[i];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* int maxNumberOfBalloons(char * text){</span></span><br><span class=\"line\"><span class=\"comment\">    int len = strlen(text);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    int testNum[5] = {0};</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    for (int i = 0; i &lt; len; i++) {</span></span><br><span class=\"line\"><span class=\"comment\">        if (text[i] == 'b') {</span></span><br><span class=\"line\"><span class=\"comment\">            testNum[0]++;</span></span><br><span class=\"line\"><span class=\"comment\">        }</span></span><br><span class=\"line\"><span class=\"comment\">        if (text[i] == 'a') {</span></span><br><span class=\"line\"><span class=\"comment\">            testNum[1]++;</span></span><br><span class=\"line\"><span class=\"comment\">        }</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        if (text[i] == 'l') {</span></span><br><span class=\"line\"><span class=\"comment\">            testNum[2]++;</span></span><br><span class=\"line\"><span class=\"comment\">        }</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        if (text[i] == 'o') {</span></span><br><span class=\"line\"><span class=\"comment\">            testNum[3]++;</span></span><br><span class=\"line\"><span class=\"comment\">        }</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        if (text[i] == 'n') {</span></span><br><span class=\"line\"><span class=\"comment\">            testNum[4]++;</span></span><br><span class=\"line\"><span class=\"comment\">        }</span></span><br><span class=\"line\"><span class=\"comment\">    }</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    testNum[2] /= 2;</span></span><br><span class=\"line\"><span class=\"comment\">    testNum[3] /= 2;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    int res = INT_MAX;</span></span><br><span class=\"line\"><span class=\"comment\">    for (int i = 0; i &lt; 5; i++) {</span></span><br><span class=\"line\"><span class=\"comment\">        res = res &lt; testNum[i] ? res : testNum[i];</span></span><br><span class=\"line\"><span class=\"comment\">    }</span></span><br><span class=\"line\"><span class=\"comment\">    return res;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">} */</span></span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"1207-独一无二的出现次数\"><a href=\"#1207-独一无二的出现次数\" class=\"headerlink\" title=\"1207.独一无二的出现次数\"></a>1207.<a href=\"https://leetcode-cn.com/problems/unique-number-of-occurrences/\">独一无二的出现次数</a></h2><p>解法一</p>\n<blockquote>\n<p>通过一个表统计每个数字出现的次数，定义另外一个表记录表一中每一项的，如果出现相同数字，则返回false，遍历到最后时返回true</p>\n</blockquote>\n<details>\n<summary>uniqueOccurrences</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">uniqueOccurrences</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> arrSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[<span class=\"number\">2001</span>] = {<span class=\"number\">0</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arrSize; i++) {</span><br><span class=\"line\">        table[arr[i] + <span class=\"number\">1000</span>]++;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"table[arr[%d] + 1000] = %d\\n\"</span>, i, table[arr[i] + <span class=\"number\">1000</span>]);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> table1[<span class=\"number\">2001</span>] = {<span class=\"number\">0</span>};</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2001</span>; i++) {</span><br><span class=\"line\">        table1[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[i] != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table1[table[i]] != <span class=\"number\">0</span>) {</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"table1[table[%d]] = %d\\n\"</span>, i, table1[table[i]]);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                table1[table[i]]++;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>解法二：</p>\n<blockquote>\n<p>同解法一</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">uniqueOccurrences</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> arrSize)</span></span>{</span><br><span class=\"line\">   <span class=\"keyword\">int</span> hashTable[<span class=\"number\">2001</span>]={<span class=\"number\">0</span>};<span class=\"comment\">//初始化一张表，下标对应元素值，存储对应元素出现的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;arrSize;i++) {</span><br><span class=\"line\">        hashTable[arr[i]+<span class=\"number\">1000</span>]++;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> visited[<span class=\"number\">1001</span>]={<span class=\"literal\">false</span>};</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2001</span>;i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(hashTable[i]) { <span class=\"comment\">//如果i在数组中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(visited[hashTable[i]]) { <span class=\"comment\">//如果之前出现过与i相同的重复次数</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                visited[hashTable[i]]=<span class=\"literal\">true</span>;<span class=\"comment\">//说明与i相同的重复次数还未出现，设置为已访问过</span></span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">} </span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n\n\n\n\n\n\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"ZQJN21","length":27126,"excerpt":"<p>1207, 876, 701, 674, 367， 231  206 201  189  160</p>","more":"<h2 id=\"146-只出现一次的数字\"><a href=\"#146-只出现一次的数字\" class=\"headerlink\" title=\"146.只出现一次的数字\"></a>146.<a href=\"https://leetcode-cn.com/problems/single-number/\">只出现一次的数字</a></h2><blockquote>\n<p>思路：n ^ n = 0 一个数与自己异或为 0</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        res = res ^ nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"141-环形链表\"><a href=\"#141-环形链表\" class=\"headerlink\" title=\"141.环形链表\"></a>141.<a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\">环形链表</a></h2><blockquote>\n<p>思路：快慢双指针</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(struct ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">slow</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">fast</span> =</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slow == fast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"142-环形链表-II\"><a href=\"#142-环形链表-II\" class=\"headerlink\" title=\"142.环形链表 II\"></a>142.<a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">环形链表 II</a></h2><blockquote>\n<p>思路：快慢双指针</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(struct ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">slow</span> =</span> (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">fast</span> =</span> (struct ListNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct ListNode));</span><br><span class=\"line\">    slow = head;</span><br><span class=\"line\">    fast = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slow == fast) &#123;</span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">entry</span> =</span> head;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (slow != entry) &#123;</span><br><span class=\"line\">                slow = slow-&gt;next;</span><br><span class=\"line\">                entry = entry-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> entry;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"153-寻找旋转排序数组中的最小值\"><a href=\"#153-寻找旋转排序数组中的最小值\" class=\"headerlink\" title=\"153.寻找旋转排序数组中的最小值\"></a>153.<a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/\">寻找旋转排序数组中的最小值</a></h2><blockquote>\n<p>思路：二分查找</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = numsSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt; high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] &lt; nums[high]) &#123;</span><br><span class=\"line\">            high = mid;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[low];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; numsSize - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &gt; nums[(i+<span class=\"number\">1</span>)]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"160-相交链表\"><a href=\"#160-相交链表\" class=\"headerlink\" title=\"160.相交链表\"></a>160.<a href=\"https://leetcode-cn.com/problemset/all/?page=1&search=160\">相交链表</a></h2><blockquote>\n<p>思路：<br>一、<br>二、先统计两个链表结点个数，然后长链表先走个数差位</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">cur1</span> =</span> headA;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">cur2</span> =</span> headB;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur1 == <span class=\"literal\">NULL</span> || cur2 == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur1 &amp;&amp; cur2 &amp;&amp; cur1 != cur2) &#123;</span><br><span class=\"line\">        cur1 = cur1-&gt;next;</span><br><span class=\"line\">        cur2 = cur2-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur1 == cur2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cur1) &#123;</span><br><span class=\"line\">            cur1 = headB;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cur2) &#123;</span><br><span class=\"line\">            cur2 = headA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"169-多数元素\"><a href=\"#169-多数元素\" class=\"headerlink\" title=\"169.多数元素\"></a>169.<a href=\"https://leetcode-cn.com/problems/majority-element/\">多数元素</a></h2><blockquote>\n<p>思路：选定一个主元素，计数器</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> majorNum = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            majorNum = nums[i];</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (majorNum == nums[i]) &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            count--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> majorNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"173-二叉搜索树迭代器\"><a href=\"#173-二叉搜索树迭代器\" class=\"headerlink\" title=\"173.二叉搜索树迭代器\"></a>173.<a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator/\">二叉搜索树迭代器</a></h2><blockquote>\n<p>思路：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>* res;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx;</span><br><span class=\"line\">&#125; BSTIterator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getTreeSize</span><span class=\"params\">(struct TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> + getTreeSize(root-&gt;left) + getTreeSize(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">int</span>* retSize, struct TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    inorder(ret, retSize, root-&gt;left);</span><br><span class=\"line\">    ret[(*retSize)++] = root-&gt;val;</span><br><span class=\"line\">    inorder(ret, retSize, root-&gt;right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">inorderTraversal</span><span class=\"params\">(<span class=\"keyword\">int</span>* retSize, struct TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    *retSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* ret = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * getTreeSize(root));</span><br><span class=\"line\">    inorder(ret, retSize, root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">BSTIterator* <span class=\"title\">bSTIteratorCreate</span><span class=\"params\">(struct TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">    BSTIterator* ret = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BSTIterator));</span><br><span class=\"line\">    ret-&gt;res = inorderTraversal(&amp;(ret-&gt;size), root);</span><br><span class=\"line\">    ret-&gt;idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bSTIteratorNext</span><span class=\"params\">(BSTIterator* obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj-&gt;res[(obj-&gt;idx)++];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bSTIteratorHasNext</span><span class=\"params\">(BSTIterator* obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj-&gt;idx &lt; obj-&gt;size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bSTIteratorFree</span><span class=\"params\">(BSTIterator* obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj-&gt;res);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"189-轮转数组\"><a href=\"#189-轮转数组\" class=\"headerlink\" title=\"189.轮转数组\"></a>189.<a href=\"https://leetcode-cn.com/problems/rotate-array/\">轮转数组</a></h2><blockquote>\n<p>思路：<br>一、每次移动一个数<br>二、先整体翻转，在翻转前k个，最后翻转 numsSize - k个</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveOne</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = nums[numsSize - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = numsSize - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        nums[i] = nums[i<span class=\"number\">-1</span>]; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nums[<span class=\"number\">0</span>] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">        moveOne(nums, numsSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>* a, <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = *a;</span><br><span class=\"line\">    *a = *b;</span><br><span class=\"line\">    *b = t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start &lt; end) &#123;</span><br><span class=\"line\">        swap(&amp;nums[start], &amp;nums[end]);</span><br><span class=\"line\">        start += <span class=\"number\">1</span>;</span><br><span class=\"line\">        end -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    k %= numsSize;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;nums[%d] = %d\\t&quot;</span>, i, nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    reverse(nums, <span class=\"number\">0</span>, numsSize - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;nums[%d] = %d\\t&quot;</span>, i, nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    reverse(nums, <span class=\"number\">0</span>, k - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;nums[%d] = %d\\t&quot;</span>, i, nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    reverse(nums, k, numsSize - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;nums[%d] = %d\\t&quot;</span>, i, nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">void rotate(int* nums, int numsSize, int k)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">     for (int i = 0; i &lt; k; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        int lastElement = nums[numsSize - 1];</span></span><br><span class=\"line\"><span class=\"comment\">        for (int j = numsSize - 1; j &gt; 0; j--) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            nums[j] = nums[j - 1];</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        nums[0] = lastElement;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125; </span></span><br><span class=\"line\"><span class=\"comment\">&#125;*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">void rotate(int* nums, int numsSize, int k)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    if (k == numsSize / 2 &amp;&amp; numsSize % 2 != 1) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        for (int i = 0; i &lt; k; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            int tmp = nums[i];</span></span><br><span class=\"line\"><span class=\"comment\">            nums[i] = nums[k+i];</span></span><br><span class=\"line\"><span class=\"comment\">            nums[k+i] = tmp;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        return;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">    int i = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    int tmp = nums[0];</span></span><br><span class=\"line\"><span class=\"comment\">    int p = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    int count = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    do &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        p = (i + k) % numsSize;</span></span><br><span class=\"line\"><span class=\"comment\">        printf(&quot;p = %d\\n&quot;,p);</span></span><br><span class=\"line\"><span class=\"comment\">        int t = nums[p];</span></span><br><span class=\"line\"><span class=\"comment\">        nums[p] = tmp;</span></span><br><span class=\"line\"><span class=\"comment\">        tmp = t;</span></span><br><span class=\"line\"><span class=\"comment\">        i = p;</span></span><br><span class=\"line\"><span class=\"comment\">     &#125; while (i != 0);</span></span><br><span class=\"line\"><span class=\"comment\">&#125; */</span> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"190-颠倒二进制位\"><a href=\"#190-颠倒二进制位\" class=\"headerlink\" title=\"190.颠倒二进制位\"></a>190.<a href=\"https://leetcode-cn.com/problems/reverse-bits/submissions/\">颠倒二进制位</a></h2><blockquote>\n<p>思路：32位，</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint32_t</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> m = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">32</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cnt) &#123;</span><br><span class=\"line\">        m &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        m += (n &amp; <span class=\"number\">0x1</span>);</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        cnt--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"191-位1的个数\"><a href=\"#191-位1的个数\" class=\"headerlink\" title=\"191.位1的个数\"></a>191.<a href=\"https://leetcode-cn.com/problems/number-of-1-bits/submissions/\">位1的个数</a></h2><blockquote>\n<p>思路：n &amp; 0x1</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &amp; <span class=\"number\">0x1</span>) &#123;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"201-数字范围按位与\"><a href=\"#201-数字范围按位与\" class=\"headerlink\" title=\"201.数字范围按位与\"></a>201.<a href=\"https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/\">数字范围按位与</a></h2><blockquote>\n<p>思路：n &amp; (n - 1) 去除n最高位的1</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rangeBitwiseAnd</span><span class=\"params\">(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">        right &amp;= right - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203.移除链表元素\"></a>203.<a href=\"https://leetcode-cn.com/problems/remove-linked-list-elements/\">移除链表元素</a></h2><blockquote>\n<p>思路：递归</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode *<span class=\"title\">removeElements</span><span class=\"params\">(struct ListNode *head, <span class=\"keyword\">int</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head-&gt;val == val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> removeElements(head-&gt;next, val);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206.反转链表\"></a>206.<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">反转链表</a></h2><blockquote>\n<p>思路：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(struct ListNode* head)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">res</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">pre_node</span> =</span> head;</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">        pre_node-&gt;next = res;</span><br><span class=\"line\">        res = pre_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"215-数组中的第K个最大元素\"><a href=\"#215-数组中的第K个最大元素\" class=\"headerlink\" title=\"215.数组中的第K个最大元素\"></a>215.<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">数组中的第K个最大元素</a></h2><blockquote>\n<p>思路：排序，第k个最大</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">int</span> *)b - *(<span class=\"keyword\">int</span> *)a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    qsort(nums, numsSize, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), Cmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[k<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"217-存在重复元素\"><a href=\"#217-存在重复元素\" class=\"headerlink\" title=\"217.存在重复元素\"></a>217.<a href=\"https://leetcode-cn.com/problems/contains-duplicate/\">存在重复元素</a></h2><blockquote>\n<p>思路：<br>一、排序，比较前一个数和当前数是否相等<br>二、uthash</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">int</span> *)a - *(<span class=\"keyword\">int</span> *)b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numsSize &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    qsort(nums, numsSize, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), Cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i<span class=\"number\">-1</span>] == nums[i]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    UT_hash_handle hh;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">users</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">s</span>;</span></span><br><span class=\"line\">   HASH_FIND_INT(users, nums[i], s);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">       s = (struct my_struct*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct my_struct));</span><br><span class=\"line\">       s-&gt;id = nums[i];</span><br><span class=\"line\">       HASH_ADD_INT(users, id, s);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"226-翻转二叉树\"><a href=\"#226-翻转二叉树\" class=\"headerlink\" title=\"226.翻转二叉树\"></a>226.<a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\">翻转二叉树</a></h2><blockquote>\n<p>思路：判空，交换左右子树，递归调用</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(struct TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">tmp</span> =</span> root-&gt;left;</span><br><span class=\"line\">    root-&gt;left = root-&gt;right;</span><br><span class=\"line\">    root-&gt;right = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">    invertTree(root-&gt;left);</span><br><span class=\"line\">    invertTree(root-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(struct TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">left</span> =</span> (struct TreeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TreeNode));</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">right</span> =</span> (struct TreeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TreeNode));</span><br><span class=\"line\">    left = invertTree(root-&gt;left);</span><br><span class=\"line\">    right = invertTree(root-&gt;right);</span><br><span class=\"line\">    root-&gt;left = right;</span><br><span class=\"line\">    root-&gt;right = left;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"231-2的幂\"><a href=\"#231-2的幂\" class=\"headerlink\" title=\"231.2的幂\"></a>231.<a href=\"https://leetcode-cn.com/problems/power-of-two/\">2的幂</a></h2><blockquote>\n<p>思路：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        n /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n == <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> res = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       res = isPowerOfTwo(n/<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//用位运算来判断有几个1，要是只有一个1那就是2的幂。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt;= <span class=\"number\">2147483647</span> || n &lt;= <span class=\"number\">-2147483648</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nu m =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n&gt;<span class=\"number\">0</span> &amp;&amp; n!=<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        n &amp;= (n<span class=\"number\">-1</span>);</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num!=<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"234-回文链表\"><a href=\"#234-回文链表\" class=\"headerlink\" title=\"234.回文链表\"></a>234.<a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/submissions/\">回文链表</a></h2><blockquote>\n<p>思路；<br>一、通过一个数组记录链表中的元素值，在判断数组是否是回文。<br>二、翻转链表</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 100000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(struct ListNode* head)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nums[MAXSIZE] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">p</span> =</span> head;</span><br><span class=\"line\">    <span class=\"comment\">// 判断条件</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p) &#123;</span><br><span class=\"line\">        nums[size++] = p-&gt;val;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;size = %d\\n&quot;</span>, size);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = size - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[left] != nums[right]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode *<span class=\"title\">reverse</span><span class=\"params\">(struct ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">res</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">pre_node</span> =</span> head;</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">        pre_node-&gt;next = res;</span><br><span class=\"line\">        res = pre_node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(struct ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">slow</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">fast</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">last</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fast != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    last = reverse(slow);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head-&gt;val != last-&gt;val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">        last = last-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"242-有效的字母异位词\"><a href=\"#242-有效的字母异位词\" class=\"headerlink\" title=\"242.有效的字母异位词\"></a>242.<a href=\"https://leetcode-cn.com/problems/valid-anagram/submissions/\">有效的字母异位词</a></h2><blockquote>\n<p>思路：先比较长度，不相等 false，通过表格记录第一个字符串中字符，遍历第二个字符串时表格记录–，最后，判断表格中所有值是否为零</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NUMSIZE 256</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isAnagram</span><span class=\"params\">(<span class=\"keyword\">char</span> * s, <span class=\"keyword\">char</span> * t)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tLen = <span class=\"built_in\">strlen</span>(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sLen != tLen) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[<span class=\"number\">256</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sLen; i++) &#123;</span><br><span class=\"line\">        table[s[i]]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tLen; i++) &#123;</span><br><span class=\"line\">        table[t[i]]--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NUMSIZE; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"268-丢失的数字\"><a href=\"#268-丢失的数字\" class=\"headerlink\" title=\"268.丢失的数字\"></a>268.<a href=\"https://leetcode-cn.com/problems/missing-number/\">丢失的数字</a></h2><blockquote>\n<p>思路：边求和，边减去数组中的数字</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        mNum += (i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        mNum -= nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"278-第一个错误的版本\"><a href=\"#278-第一个错误的版本\" class=\"headerlink\" title=\"278.第一个错误的版本\"></a>278.<a href=\"https://leetcode-cn.com/problems/first-bad-version/\">第一个错误的版本</a></h2><blockquote>\n<p>思路：二分查找</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">firstBadVersion</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isBadVersion(mid) &amp;&amp; !isBadVersion(mid<span class=\"number\">-1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isBadVersion(mid) &amp;&amp; isBadVersion(mid<span class=\"number\">-1</span>)) &#123;</span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">firstBadVersion</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">1</span>, high = n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isBadVersion(mid)) &#123;</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"283-移动零\"><a href=\"#283-移动零\" class=\"headerlink\" title=\"283.移动零\"></a>283.<a href=\"https://leetcode-cn.com/problems/move-zeroes/\">移动零</a></h2><blockquote>\n<p>思路：不等于零时向数组中添加，等于零时跳过，最后填充0<br>nums[start++] = nums[i]</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            nums[start++] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; start &lt; numsSize; start++) &#123;</span><br><span class=\"line\">        nums[start] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"287-寻找重复整数\"><a href=\"#287-寻找重复整数\" class=\"headerlink\" title=\"287.寻找重复整数\"></a>287.<a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number/\">寻找重复整数</a></h2><blockquote>\n<p>思路：循环遍历，标记，判断是否标记过，return</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 100001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[MAXSIZE] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[nums[i]] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            table[nums[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"344-反转字符串\"><a href=\"#344-反转字符串\" class=\"headerlink\" title=\"344.反转字符串\"></a>344.<a href=\"https://leetcode-cn.com/problems/reverse-string/\">反转字符串</a></h2><blockquote>\n<p>思路：双指针，交换</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverseString</span><span class=\"params\">(<span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> sSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = sSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = s[left];</span><br><span class=\"line\">        s[left] = s[right];</span><br><span class=\"line\">        s[right] = c;</span><br><span class=\"line\">        left++;</span><br><span class=\"line\">        right--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"367-有效的完全平方数\"><a href=\"#367-有效的完全平方数\" class=\"headerlink\" title=\"367.有效的完全平方数\"></a>367.<a href=\"https://leetcode-cn.com/problems/valid-perfect-square/\">有效的完全平方数</a></h2><blockquote>\n<p>思路：for 循环，条件 i * i &lt;= num </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPerfectSquare</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> i = <span class=\"number\">0</span>; i * i &lt;= num; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i * i == num) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"387-字符串中的第一个唯一字符\"><a href=\"#387-字符串中的第一个唯一字符\" class=\"headerlink\" title=\"387.字符串中的第一个唯一字符\"></a>387.<a href=\"https://leetcode-cn.com/problems/first-unique-character-in-a-string/\">字符串中的第一个唯一字符</a></h2><blockquote>\n<p>思路：两次遍历，第一次遍历见字母标记得到统计表格中，第二次遍历找出统计表格中第一个为1字符，返回对应下标。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NUMSIZE 256</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[NUMSIZE] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sLen; i++) &#123;</span><br><span class=\"line\">        table[s[i]]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sLen; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[s[i]] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"389-找不同\"><a href=\"#389-找不同\" class=\"headerlink\" title=\"389.找不同\"></a>389.<a href=\"https://leetcode-cn.com/problems/find-the-difference/\">找不同</a></h2><blockquote>\n<p>思路：字符可以转化为数字，为了防止溢出通过 - ‘a’，求两个字符串的差值，在加上’a’</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">findTheDifference</span><span class=\"params\">(<span class=\"keyword\">char</span> * s, <span class=\"keyword\">char</span> * t)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tLen = <span class=\"built_in\">strlen</span>(t);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nS = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nT = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sLen; i++) &#123;</span><br><span class=\"line\">        nS += s[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tLen; i++) &#123;</span><br><span class=\"line\">        nT += t[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">char</span>)(nT - nS + <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"404-左叶子之和\"><a href=\"#404-左叶子之和\" class=\"headerlink\" title=\"404.左叶子之和\"></a>404.<a href=\"https://leetcode-cn.com/problems/sum-of-left-leaves/\">左叶子之和</a></h2><blockquote>\n<p>思路：递归：判断左子树是否为叶子结点，是则记录sum，返回 sum + 递归调用左子树 + 递归调用右子树</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfLeftLeaves</span><span class=\"params\">(struct TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left-&gt;left == <span class=\"literal\">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            sum += root-&gt;left-&gt;val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  sum + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isleaf</span><span class=\"params\">(struct TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root-&gt;left == <span class=\"literal\">NULL</span> &amp;&amp; root-&gt;right == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfLeftLeaves</span><span class=\"params\">(struct TreeNode* root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isleaf(root-&gt;left)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 此处直接递归，少一层调用</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"442-数组中重复的数据\"><a href=\"#442-数组中重复的数据\" class=\"headerlink\" title=\"442.数组中重复的数据\"></a>442.<a href=\"https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/\">数组中重复的数据</a></h2><blockquote>\n<p>思路：<br>一、通过表标记数组中出现过的数字，当再次出现时将数字添加到返回数组中。<br>二、</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 100000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">findDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[MAXSIZE] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    *returnSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *res = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * MAXSIZE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[nums[i]] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            res[*returnSize] = nums[i];</span><br><span class=\"line\">            (*returnSize)++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            table[nums[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">findDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[<span class=\"number\">100000</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *res = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">100000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        table[nums[i]]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[nums[i]] == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            res[j++] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *returnSize = j;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"461-汉明距离\"><a href=\"#461-汉明距离\" class=\"headerlink\" title=\"461.汉明距离\"></a>461.<a href=\"https://leetcode-cn.com/problems/hamming-distance/\">汉明距离</a></h2><blockquote>\n<p>思路：<br>一、求 x ^ y 中 1 的个数<br>二、比较x，y的每一位 和 1与</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = x ^ y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = n &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p) &#123;</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x || y) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nX = x &amp; <span class=\"number\">0x1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nY = y &amp; <span class=\"number\">0x1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nX != nY) &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        y &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"476-数字的补数\"><a href=\"#476-数字的补数\" class=\"headerlink\" title=\"476.数字的补数\"></a>476.<a href=\"https://leetcode-cn.com/problems/number-complement/\">数字的补数</a></h2><blockquote>\n<p>思路：<br>一、按位与1求与，再取反(!)，然后移位，<br>二、先统计位数，在取位数相同全一数，最后与原数字求异或 ^</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findComplement</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (num) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = !(num &amp; <span class=\"number\">0x1</span>);</span><br><span class=\"line\">        t &lt;&lt;= count;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;t = %d\\n&quot;</span>, t);</span><br><span class=\"line\">        res += t;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        num&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findComplement</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> totalBits = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = num;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp) &#123;</span><br><span class=\"line\">        totalBits++;</span><br><span class=\"line\">        tmp &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flipNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; totalBits; i++) &#123;</span><br><span class=\"line\">        flipNumber += UINT32_C(<span class=\"number\">1</span>) &lt;&lt; i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    num = num ^ flipNumber;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"509-斐波那契数列\"><a href=\"#509-斐波那契数列\" class=\"headerlink\" title=\"509.斐波那契数列\"></a>509.<a href=\"https://leetcode-cn.com/problems/fibonacci-number/\">斐波那契数列</a></h2><blockquote>\n<p>思路：一、递归  二、迭代</p>\n</blockquote>\n<ul>\n<li><p>递归</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(n - <span class=\"number\">1</span>) + fib(n - <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>迭代</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* nums = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * (n + <span class=\"number\">1</span>));</span><br><span class=\"line\">    nums[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    nums[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        nums[i] = nums[i - <span class=\"number\">1</span>] + nums[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"520-检测大写字母\"><a href=\"#520-检测大写字母\" class=\"headerlink\" title=\"520.检测大写字母\"></a>520.<a href=\"https://leetcode-cn.com/problems/detect-capital/submissions/\">检测大写字母</a></h2><blockquote>\n<p>思路：<br>一、先判断第二个字母是否为大写，1.word[1] 大写，从从零开始判断是否全为大写 2.word[1]为小写，从word是否全为小写。<br>二、</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">detectCapitalUse</span><span class=\"params\">(<span class=\"keyword\">char</span> * word)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(word);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isupper</span>(word[i])) &#123;</span><br><span class=\"line\">        i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (word[i] != <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">isupper</span>(word[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (word[i] != <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isupper</span>(word[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">detectCapitalUse</span><span class=\"params\">(<span class=\"keyword\">char</span> * word)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(word);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// word[0] 每次都需要判断，一个复杂度。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isupper</span>(word[<span class=\"number\">0</span>]) &amp;&amp; <span class=\"built_in\">isupper</span>(word[<span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">isupper</span>(word[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isupper</span>(word[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"561-拆分数组I\"><a href=\"#561-拆分数组I\" class=\"headerlink\" title=\"561.拆分数组I\"></a>561.<a href=\"https://leetcode-cn.com/problems/array-partition-i/\">拆分数组I</a></h2><blockquote>\n<p>思路：排序，取偶数位求和。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">int</span> *)a - *(<span class=\"keyword\">int</span> *)b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrayPairSum</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">    qsort(nums, numsSize, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), Cmp);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            minSum += nums[i];</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"617-合并二叉树\"><a href=\"#617-合并二叉树\" class=\"headerlink\" title=\"617.合并二叉树\"></a>617.<a href=\"https://leetcode-cn.com/problems/merge-two-binary-trees/\">合并二叉树</a></h2><blockquote>\n<p>思路：递归，判空，</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">newNode</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">node</span> =</span> <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TreeNode));</span><br><span class=\"line\">    node-&gt;val = val;</span><br><span class=\"line\">    node-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">mergeTrees</span><span class=\"params\">(struct TreeNode* root1, struct TreeNode* root2)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/*  if (root1 == NULL &amp;&amp; root2 == NULL) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        return NULL;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125; */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root1 == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root2 == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"comment\">/*  struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));</span></span><br><span class=\"line\"><span class=\"comment\">    root-&gt;val += root1 == NULL ? 0 : root1-&gt;val;</span></span><br><span class=\"line\"><span class=\"comment\">    root-&gt;val += root2 == NULL ? 0 : root2-&gt;val;</span></span><br><span class=\"line\"><span class=\"comment\">    root-&gt;left = NULL;</span></span><br><span class=\"line\"><span class=\"comment\">    root-&gt;right = NULL; */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val = (root1 == <span class=\"literal\">NULL</span> ? <span class=\"number\">0</span> : root1-&gt;val) + (root2 == <span class=\"literal\">NULL</span> ? <span class=\"number\">0</span> : root2-&gt;val);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">root</span>  =</span> newNode(val);</span><br><span class=\"line\">    root-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class=\"line\">    root-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"647-回文子串\"><a href=\"#647-回文子串\" class=\"headerlink\" title=\"647.回文子串\"></a>647.<a href=\"https://leetcode-cn.com/problems/palindromic-substrings/\">回文子串</a></h2><blockquote>\n<p>思路：左侧判断去重，左右判断相等。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countSubstrings</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = len; <span class=\"comment\">// 每个字符都是回文</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p &gt;= <span class=\"number\">0</span> &amp;&amp; s[p] == s[i]) &#123; <span class=\"comment\">// 左侧去重</span></span><br><span class=\"line\">            res++;</span><br><span class=\"line\">            p--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> q = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p &gt;= <span class=\"number\">0</span> &amp;&amp; q &lt; len &amp;&amp; s[p] == s[q]) &#123; <span class=\"comment\">// 判断左右相等</span></span><br><span class=\"line\">            res++;</span><br><span class=\"line\">            p--;</span><br><span class=\"line\">            q++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countSubstrings</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        count += countPalin(s, i, i, len);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != len - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            count += countPalin(s, i, i+<span class=\"number\">1</span>, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countPalin</span><span class=\"params\">(<span class=\"keyword\">char</span> *s, <span class=\"keyword\">int</span> head, <span class=\"keyword\">int</span> tail, <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = (s[head] == s[tail]) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &amp;&amp; head - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> &amp;&amp; tail + <span class=\"number\">1</span> &lt; len) &#123;</span><br><span class=\"line\">        ret += countPalin(s, head - <span class=\"number\">1</span>, tail + <span class=\"number\">1</span>, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"674-最长连续递增序列\"><a href=\"#674-最长连续递增序列\" class=\"headerlink\" title=\"674.最长连续递增序列\"></a>674.<a href=\"https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/\">最长连续递增序列</a></h2><blockquote>\n<p>思路：双循环判断，</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLengthOfLCIS</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numsSize == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; numsSize &amp;&amp; nums[i<span class=\"number\">-1</span>] &lt; nums[i]) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = res &gt; i - p2 ? res : i - p2;</span><br><span class=\"line\">        p2 = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findLengthOfLCIS</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; numsSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = i;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start + <span class=\"number\">1</span> &lt; numsSize &amp;&amp; nums[start] &lt; nums[start + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        maxLen = maxLen &gt; (start - i + <span class=\"number\">1</span>) ? maxLen : (start - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        start++;</span><br><span class=\"line\">        i = start;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"700-二叉搜索树中的搜索\"><a href=\"#700-二叉搜索树中的搜索\" class=\"headerlink\" title=\"700.二叉搜索树中的搜索\"></a>700.<a href=\"https://leetcode-cn.com/problems/search-in-a-binary-search-tree/\">二叉搜索树中的搜索</a></h2><blockquote>\n<p>思路：递归，注意 判空 root == NULL</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">searchBST</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val == val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &gt; val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> searchBST(root-&gt;left, val);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> searchBST(root-&gt;right, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"701-二叉搜索树中的插入操作\"><a href=\"#701-二叉搜索树中的插入操作\" class=\"headerlink\" title=\"701.二叉搜索树中的插入操作\"></a>701.<a href=\"https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/\">二叉搜索树中的插入操作</a></h2><blockquote>\n<p>思路：递归，递归出口，root == NULL, 新建树结点 malloc</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct TreeNode* <span class=\"title\">insertIntoBST</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span>* <span class=\"title\">newNode</span> =</span> (struct TreeNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct TreeNode));</span><br><span class=\"line\">        newNode-&gt;val = val;</span><br><span class=\"line\">        newNode-&gt;left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        newNode-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val &lt; val) &#123;</span><br><span class=\"line\">        root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val &gt; val) &#123;</span><br><span class=\"line\">        root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704.二分查找\"></a>704.<a href=\"https://leetcode-cn.com/problems/binary-search/\">二分查找</a></h2><blockquote>\n<p>思路：二分查找，注意 left &lt;= right ，包含等于</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = numsSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"709-转换成小写字母\"><a href=\"#709-转换成小写字母\" class=\"headerlink\" title=\"709.转换成小写字母\"></a>709.<a href=\"https://leetcode-cn.com/problems/to-lower-case/\">转换成小写字母</a></h2><blockquote>\n<p>思路；库函数 isupper, tolower</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">toLowerCase</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isupper</span>(s[i])) &#123;</span><br><span class=\"line\">            s[i] = <span class=\"built_in\">tolower</span>(s[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"771-宝石和石头\"><a href=\"#771-宝石和石头\" class=\"headerlink\" title=\"771.宝石和石头\"></a>771.<a href=\"https://leetcode-cn.com/problems/jewels-and-stones/\">宝石和石头</a></h2><blockquote>\n<p>思路：表记录stones中每个字符个数，求和jewels字符表中的值</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numJewelsInStones</span><span class=\"params\">(<span class=\"keyword\">char</span> * jewels, <span class=\"keyword\">char</span> * stones)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[<span class=\"number\">256</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sLen = <span class=\"built_in\">strlen</span>(stones);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sLen; i++) &#123;</span><br><span class=\"line\">        table[stones[i]]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> jLen = <span class=\"built_in\">strlen</span>(jewels);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; jLen; i++) &#123;</span><br><span class=\"line\">        sum +=  table[jewels[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"852-山脉数组的峰顶索引\"><a href=\"#852-山脉数组的峰顶索引\" class=\"headerlink\" title=\"852.山脉数组的峰顶索引\"></a>852.<a href=\"https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/\">山脉数组的峰顶索引</a></h2><blockquote>\n<p>思路：判断条件，完全</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">peakIndexInMountainArray</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> arrSize)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> low = <span class=\"number\">1</span>, high = arrSize;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[mid - <span class=\"number\">1</span>] &lt; arr[mid] &amp;&amp; arr[mid] &gt; arr[mid + <span class=\"number\">1</span>])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[mid - <span class=\"number\">1</span>] &lt; arr[mid] &amp;&amp; arr[mid] &lt; arr[mid + <span class=\"number\">1</span>])</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"876-链表的中间结点\"><a href=\"#876-链表的中间结点\" class=\"headerlink\" title=\"876.链表的中间结点\"></a>876.<a href=\"https://leetcode-cn.com/problems/middle-of-the-linked-list/\">链表的中间结点</a></h2><blockquote>\n<p>思路：快慢指针，第二个指针通过 偶数判断  for循环</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">struct ListNode* <span class=\"title\">middleNode</span><span class=\"params\">(struct ListNode* head)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">pos1</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">pos2</span> =</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; pos1-&gt;next != <span class=\"literal\">NULL</span>; pos1 = pos1-&gt;next, i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            pos2 = pos2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pos2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"905-按奇偶排序数组\"><a href=\"#905-按奇偶排序数组\" class=\"headerlink\" title=\"905.按奇偶排序数组\"></a>905.<a href=\"https://leetcode-cn.com/problems/sort-array-by-parity/\">按奇偶排序数组</a></h2><blockquote>\n<p>思路: 一、双指针，同917<br>二、判断，前后索引移动，双指针</p>\n</blockquote>\n<ul>\n<li><p>解法一：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">sortArrayByParity</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    *returnSize = numsSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = numsSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start &lt; end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; end &amp;&amp; nums[start] % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (end &gt; start &amp;&amp; nums[end] % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            end--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; end &amp;&amp; nums[start] % <span class=\"number\">2</span> != <span class=\"number\">0</span> &amp;&amp; nums[end] % <span class=\"number\">2</span> != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = nums[start];</span><br><span class=\"line\">            nums[start] = nums[end];</span><br><span class=\"line\">            nums[end] = tmp;</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">            end--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">sortArrayByParity</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span></span>&#123;</span><br><span class=\"line\">    *returnSize = numsSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = numsSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (nums[left] % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (nums[right] % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">             right--;</span><br><span class=\"line\">             <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">int</span> tmp = nums[left];</span><br><span class=\"line\">         nums[left] = nums[right];</span><br><span class=\"line\">         nums[right] = tmp;</span><br><span class=\"line\">         left++;</span><br><span class=\"line\">         right--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>解法二；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">sortArrayByParity</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *res = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * numsSize);</span><br><span class=\"line\">    *returnSize = numsSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = numsSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res[j] = nums[i];</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res[p] = nums[i];</span><br><span class=\"line\">            p--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"917-仅仅反转字母\"><a href=\"#917-仅仅反转字母\" class=\"headerlink\" title=\"917.仅仅反转字母\"></a>917.<a href=\"https://leetcode-cn.com/problems/reverse-only-letters/\">仅仅反转字母</a></h2><blockquote>\n<p>思路：双指针，库函数 isalpha， continue</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">reverseOnlyLetters</span><span class=\"params\">(<span class=\"keyword\">char</span> * s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right = len - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">isalpha</span>(s[left])) &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!<span class=\"built_in\">isalpha</span>(s[right])) &#123;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//if (isalpha(s[left]) &amp;&amp; isalpha(s[right])) &#123;</span></span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s[left];</span><br><span class=\"line\">            s[left] = s[right];</span><br><span class=\"line\">            s[right] = c;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"938-二叉搜索树的范围和\"><a href=\"#938-二叉搜索树的范围和\" class=\"headerlink\" title=\"938.二叉搜索树的范围和\"></a>938.<a href=\"https://leetcode-cn.com/problems/range-sum-of-bst/\">二叉搜索树的范围和</a></h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rangeSumBST</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &gt; root-&gt;val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rangeSumBST(root-&gt;right, low, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (high &lt; root-&gt;val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rangeSumBST(root-&gt;left, low, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root-&gt;val + rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rangeSumBST</span><span class=\"params\">(struct TreeNode* root, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;val + rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"965-单值二叉树\"><a href=\"#965-单值二叉树\" class=\"headerlink\" title=\"965.单值二叉树\"></a>965.<a href=\"https://leetcode-cn.com/problems/univalued-binary-tree/\">单值二叉树</a></h2><blockquote>\n<p>思路：递归，递归出口：root == NULL</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isUnivalTree</span><span class=\"params\">(struct TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// root不判空会报错：</span></span><br><span class=\"line\">    <span class=\"comment\">// member access within null pointer of type &#x27;struct TreeNode&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 多余</span></span><br><span class=\"line\">   <span class=\"comment\">/*  if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        return true;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125; */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;left != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left-&gt;val != root-&gt;val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;right != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right-&gt;val != root-&gt;val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> isUnivalTree(root-&gt;left) &amp;&amp; isUnivalTree(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"977-有序数组的平方\"><a href=\"#977-有序数组的平方\" class=\"headerlink\" title=\"977.有序数组的平方\"></a>977.<a href=\"https://leetcode-cn.com/problems/squares-of-a-sorted-array/submissions/\">有序数组的平方</a></h2><blockquote>\n<p>思路</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a,  <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">int</span> *)a - *(<span class=\"keyword\">int</span> *)b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">sortedSquares</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>* squareNum = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * numsSize);</span><br><span class=\"line\">    *returnSize = numsSize;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//squareNum[i] = nums[i] * nums[i];</span></span><br><span class=\"line\">        squareNum[i] = <span class=\"built_in\">pow</span>(nums[i], <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    qsort(squareNum, numsSize, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), Cmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> squareNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1089-复写零\"><a href=\"#1089-复写零\" class=\"headerlink\" title=\"1089.复写零\"></a>1089.<a href=\"https://leetcode-cn.com/problems/duplicate-zeros/\">复写零</a></h2><blockquote>\n<p>思路：将原数组复制一份，根据复制数组，修改原数组值</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">duplicateZeros</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> arrSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b[arrSize]; <span class=\"comment\">// = &#123;0&#125;;</span></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(b, arr, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * arrSize);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; arrSize &amp;&amp; j &lt; arrSize; i++) &#123;</span><br><span class=\"line\">        arr[j++] = b[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &lt; arrSize &amp;&amp; b[i] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            arr[j++] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;W</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">duplicateZeros</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> arrSize)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> * nums = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * arrSize);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class=\"line\">        nums[i] = arr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arrSize; i++, j++) &#123;</span><br><span class=\"line\">        arr[i] = nums[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; arrSize &amp;&amp; nums[j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            arr[++i] = <span class=\"number\">0</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"1184-公交站间的距离\"><a href=\"#1184-公交站间的距离\" class=\"headerlink\" title=\"1184.公交站间的距离\"></a>1184.<a href=\"https://leetcode-cn.com/problems/distance-between-bus-stops/submissions/\">公交站间的距离</a></h2><blockquote>\n<p>思路: 保证 start 小于 destination， 计算一圈的总长度sum，计算start到destination的距离d，取d与sum-d两者较小值</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">distanceBetweenBusStops</span><span class=\"params\">(<span class=\"keyword\">int</span>* distance, <span class=\"keyword\">int</span> distanceSize, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> destination)</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt; destination) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = start;</span><br><span class=\"line\">        start = destination;</span><br><span class=\"line\">        destination = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; distanceSize; i++) &#123;</span><br><span class=\"line\">        sum += distance[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= start &amp;&amp; i &lt; destination) &#123;</span><br><span class=\"line\">            min += distance[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    min = min &lt; (sum - min) ? min : sum - min;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1189-“气球”-的最大数量\"><a href=\"#1189-“气球”-的最大数量\" class=\"headerlink\" title=\"1189. “气球” 的最大数量\"></a>1189.<a href=\"https://leetcode-cn.com/problems/maximum-number-of-balloons/\"> “气球” 的最大数量</a></h2><blockquote>\n<p>思路：统计字符次数，注意 字符串指针  取值 *p  或者 字符数组 test[i]</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxNumberOfBalloons</span><span class=\"params\">(<span class=\"keyword\">char</span> * text)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(text);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span>* p = text;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*p != <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*p == <span class=\"string\">&#x27;b&#x27;</span>) &#123;</span><br><span class=\"line\">            table[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*p == <span class=\"string\">&#x27;a&#x27;</span>) &#123;</span><br><span class=\"line\">            table[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*p == <span class=\"string\">&#x27;l&#x27;</span>) &#123;</span><br><span class=\"line\">            table[<span class=\"number\">2</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*p == <span class=\"string\">&#x27;o&#x27;</span>) &#123;</span><br><span class=\"line\">            table[<span class=\"number\">3</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*p == <span class=\"string\">&#x27;n&#x27;</span>) &#123;</span><br><span class=\"line\">            table[<span class=\"number\">4</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    table[<span class=\"number\">2</span>] /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    table[<span class=\"number\">3</span>] /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        min = min &lt; table[i] ? min : table[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* int maxNumberOfBalloons(char * text)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    int len = strlen(text);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    int testNum[5] = &#123;0&#125;;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        if (text[i] == &#x27;b&#x27;) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            testNum[0]++;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        if (text[i] == &#x27;a&#x27;) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            testNum[1]++;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        if (text[i] == &#x27;l&#x27;) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            testNum[2]++;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        if (text[i] == &#x27;o&#x27;) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            testNum[3]++;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        if (text[i] == &#x27;n&#x27;) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            testNum[4]++;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    testNum[2] /= 2;</span></span><br><span class=\"line\"><span class=\"comment\">    testNum[3] /= 2;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    int res = INT_MAX;</span></span><br><span class=\"line\"><span class=\"comment\">    for (int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        res = res &lt; testNum[i] ? res : testNum[i];</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    return res;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&#125; */</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"1207-独一无二的出现次数\"><a href=\"#1207-独一无二的出现次数\" class=\"headerlink\" title=\"1207.独一无二的出现次数\"></a>1207.<a href=\"https://leetcode-cn.com/problems/unique-number-of-occurrences/\">独一无二的出现次数</a></h2><p>解法一</p>\n<blockquote>\n<p>通过一个表统计每个数字出现的次数，定义另外一个表记录表一中每一项的，如果出现相同数字，则返回false，遍历到最后时返回true</p>\n</blockquote>\n<details>\n<summary>uniqueOccurrences</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">uniqueOccurrences</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> arrSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> table[<span class=\"number\">2001</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class=\"line\">        table[arr[i] + <span class=\"number\">1000</span>]++;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;table[arr[%d] + 1000] = %d\\n&quot;</span>, i, table[arr[i] + <span class=\"number\">1000</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> table1[<span class=\"number\">2001</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2001</span>; i++) &#123;</span><br><span class=\"line\">        table1[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table1[table[i]] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;table1[table[%d]] = %d\\n&quot;</span>, i, table1[table[i]]);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                table1[table[i]]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解法二：</p>\n<blockquote>\n<p>同解法一</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">uniqueOccurrences</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> arrSize)</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> hashTable[<span class=\"number\">2001</span>]=&#123;<span class=\"number\">0</span>&#125;;<span class=\"comment\">//初始化一张表，下标对应元素值，存储对应元素出现的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;arrSize;i++) &#123;</span><br><span class=\"line\">        hashTable[arr[i]+<span class=\"number\">1000</span>]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> visited[<span class=\"number\">1001</span>]=&#123;<span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2001</span>;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(hashTable[i]) &#123; <span class=\"comment\">//如果i在数组中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(visited[hashTable[i]]) &#123; <span class=\"comment\">//如果之前出现过与i相同的重复次数</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                visited[hashTable[i]]=<span class=\"literal\">true</span>;<span class=\"comment\">//说明与i相同的重复次数还未出现，设置为已访问过</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</details>"},{"title":"剑指offer","date":"2022-01-16T16:47:53.000Z","updated":"2022-01-26T16:53:53.000Z","_content":"\n\n\n\n\n\n\n\n\n","source":"_posts/2022/剑指offer.md","raw":"---\ntitle: 剑指offer\ndate: 2022-01-17 00:47:53\nupdated: 2022-01-27 00:53:53\ncategories: \n    - tool\ntags: \n    - Computer Science\n    - Another Tag\n---\n\n\n\n\n\n\n\n\n\n","slug":"2022/剑指offer","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8vi000j0guu8qo7eait","content":"<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"E56CMW","length":0,"excerpt":"","more":""},{"title":"读书随记","date":"2022-01-26T16:47:53.000Z","updated":"2022-01-26T16:53:53.000Z","_content":"\n## 软件故事\n\n1946年 ENIAC\n\n批处理系统\n硬件发展-》 分时系统\n机器语言--纸带\n汇编语言-- 指令 操作\nFortran语言 - 第一种高级计算机语言\nCOBOL 语言\nBASIC\n\n<!--more-->\n\n卡耐基 -- 人工智能\n\nIBM 701  704(Fortran商用)\nIBM OS/360\n\n存储时计算机\n\n\nUnix\nc 语言\n\n欧洲计算机技术：\nlinux 芬兰\n万维网 瑞典\n\n\nAPPLE II\nMacish\n\n微软\n收购DOS  \nwindows BASIC\n\n\n鼠标、\n显示器\n\n\nC++\n\nJava \nJava与互联网\n\n阿帕奇\nIBM linux\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2022/读书随记.md","raw":"---\ntitle: 读书随记\ndate: 2022-01-27 00:47:53\nupdated: 2022-01-27 00:53:53\ncategories: \n    - tool\ntags: \n    - 实用教程\n    - Another Tag\n---\n\n## 软件故事\n\n1946年 ENIAC\n\n批处理系统\n硬件发展-》 分时系统\n机器语言--纸带\n汇编语言-- 指令 操作\nFortran语言 - 第一种高级计算机语言\nCOBOL 语言\nBASIC\n\n<!--more-->\n\n卡耐基 -- 人工智能\n\nIBM 701  704(Fortran商用)\nIBM OS/360\n\n存储时计算机\n\n\nUnix\nc 语言\n\n欧洲计算机技术：\nlinux 芬兰\n万维网 瑞典\n\n\nAPPLE II\nMacish\n\n微软\n收购DOS  \nwindows BASIC\n\n\n鼠标、\n显示器\n\n\nC++\n\nJava \nJava与互联网\n\n阿帕奇\nIBM linux\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2022/读书随记","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8vl000m0guuhbx0c49k","content":"<h2 id=\"软件故事\"><a href=\"#软件故事\" class=\"headerlink\" title=\"软件故事\"></a>软件故事</h2><p>1946年 ENIAC</p>\n<p>批处理系统<br>硬件发展-》 分时系统<br>机器语言–纸带<br>汇编语言– 指令 操作<br>Fortran语言 - 第一种高级计算机语言<br>COBOL 语言<br>BASIC</p>\n<span id=\"more\"></span>\n\n<p>卡耐基 – 人工智能</p>\n<p>IBM 701  704(Fortran商用)<br>IBM OS/360</p>\n<p>存储时计算机</p>\n<p>Unix<br>c 语言</p>\n<p>欧洲计算机技术：<br>linux 芬兰<br>万维网 瑞典</p>\n<p>APPLE II<br>Macish</p>\n<p>微软<br>收购DOS<br>windows BASIC</p>\n<p>鼠标、<br>显示器</p>\n<p>C++</p>\n<p>Java<br>Java与互联网</p>\n<p>阿帕奇<br>IBM linux</p>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"3M181K3","length":211,"excerpt":"<h2 id=\"软件故事\"><a href=\"#软件故事\" class=\"headerlink\" title=\"软件故事\"></a>软件故事</h2><p>1946年 ENIAC</p>\n<p>批处理系统<br>硬件发展-》 分时系统<br>机器语言–纸带<br>汇编语言– 指令 操作<br>Fortran语言 - 第一种高级计算机语言<br>COBOL 语言<br>BASIC</p>","more":"<p>卡耐基 – 人工智能</p>\n<p>IBM 701  704(Fortran商用)<br>IBM OS/360</p>\n<p>存储时计算机</p>\n<p>Unix<br>c 语言</p>\n<p>欧洲计算机技术：<br>linux 芬兰<br>万维网 瑞典</p>\n<p>APPLE II<br>Macish</p>\n<p>微软<br>收购DOS<br>windows BASIC</p>\n<p>鼠标、<br>显示器</p>\n<p>C++</p>\n<p>Java<br>Java与互联网</p>\n<p>阿帕奇<br>IBM linux</p>"},{"title":"C/C++","date":"2021-12-06T16:47:53.000Z","updated":"2021-10-26T16:53:53.000Z","_content":"\n\n\n\n## 1\n\n\n\n\n- 开源 C++ 库列表\nhttps://zh.cppreference.com/w/cpp/links/libs\n- C 语言\nhttps://zh.cppreference.com/w/c/language\n","source":"_posts/2021/12/C++.md","raw":"---\ntitle: C/C++\ndate: 2021-12-07 00:47:53\nupdated: 2021-10-27 00:53:53\ncategories: \n    - tool\ntags: \n    - c/c++\n    - cs\n---\n\n\n\n\n## 1\n\n\n\n\n- 开源 C++ 库列表\nhttps://zh.cppreference.com/w/cpp/links/libs\n- C 语言\nhttps://zh.cppreference.com/w/c/language\n","slug":"2021/12/C++","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8vo000q0guu5ets0c17","content":"<h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><ul>\n<li>开源 C++ 库列表<br><a href=\"https://zh.cppreference.com/w/cpp/links/libs\">https://zh.cppreference.com/w/cpp/links/libs</a></li>\n<li>C 语言<br><a href=\"https://zh.cppreference.com/w/c/language\">https://zh.cppreference.com/w/c/language</a></li>\n</ul>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"24K0QAW","length":96,"excerpt":"","more":"<h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><ul>\n<li>开源 C++ 库列表<br><a href=\"https://zh.cppreference.com/w/cpp/links/libs\">https://zh.cppreference.com/w/cpp/links/libs</a></li>\n<li>C 语言<br><a href=\"https://zh.cppreference.com/w/c/language\">https://zh.cppreference.com/w/c/language</a></li>\n</ul>\n"},{"title":"数据结构与算法基础","date":"2021-10-26T16:47:53.000Z","updated":"2021-10-26T16:53:53.000Z","password":"liuz0000","abstract":"这是一篇加密博文，请输入密码后查看","message":"这里需要密码才能访问。","wrong_pass_message":"抱歉, 这个密码看着不太对, 请再试试.","_content":"\n## 1 程序性能\n\n<!--more-->\n\n&ensp;程序性能是指运行程序所需要的**内存大小(空间复杂度)和时间(时间复杂度)**,运行时间和占用空间是算法性能最关键的指标。\n&ensp;软件程序性能衡量指标:\n&emsp;响应时间、启动时间、执行时间、执行速度、计算资源分配、内存分配、磁盘吞吐量、网络吞吐量、负载承受能力\n\n\n### 1.1 空间复杂度\n&ensp;空间复杂度(Space complexity)，算法完全运行所需存储空间。表示算法的存储空间与数据规模之间的增长关系：常量空间、线性空间、二维空间。\n&ensp;算法在计算机存储器上所占用的存储空间，包括**存储程序本身占用的存储空间，算法输入输出数据所占的存储空间和算法在运行过程中临时占用的存储空间**。\n\n\n### 1.2 时间复杂度\n&ensp;时间复杂度(Time complexity)，算法完全运行所需运算时间。时间复杂度通常用大O符合表示。\n\n![20211027233029](https://i.loli.net/2021/10/27/UxWCvnRQLYz5eiG.png)\n\n#### 1.2.1 常见算法大O\n&emsp; 常量阶O(1); 对数阶O(logn); 线性阶O(n); 线性对数阶O(nlogn); k次方阶O(n^k)\n![20211028010721](https://i.loli.net/2021/10/28/GWOFcUi3qdVIlmf.png)\n\n#### 1.2.2 常见数据结构\n\n{% pullquote mindmap mindmap-md %}\n- 数据结构与算法\n    - 线性表\n        - 数组\n        - 链表\n            - 单链表\n            - 双链表\n            - 循环链表\n            - 双向循环链表\n            - 静态链表\n        - 栈\n            - 顺序栈\n            - 链式栈\n        - 队列\n            - 普通队列\n            - 双端队列\n            - 阻塞队列\n            - 并发队列\n            - 阻塞并发队列\n    - 散列表\n        - 散列函数\n        - 冲突解决\n            - 链表法\n            - 开放地址\n            - 其他\n        - 动态扩容\n        - 位置\n    - 树\n        - 二叉树\n            - 二叉查找树\n            - 平衡二叉树\n            - 平衡二叉查找树\n                - AVL树\n                - 红黑树\n            - 完全二叉树\n            - 满二叉树\n        - 多路查找树\n            - B树\n            - B+树\n            - 2-3树\n            - 2-3-4树\n        - 堆\n            - 小顶堆\n            - 大顶堆\n            - 优先级队列\n            - 斐波那契堆\n            - 二项堆\n        - 其他\n            - 树状数组\n            - 线段树\n    - 图\n        - 图的存储\n            - 邻接矩阵\n            - 邻接表\n        - 拓扑排序\n        - 最短路径\n        - 关键路径\n        - 最小生成树\n        - 二分图\n        - 最大流\n    - 复杂度分析\n        - 空间复杂度\n        - 时间复杂度\n    - 基本算法思想\n        - 分治法\n        - 递归算法\n        - 贪心算法\n        - 动态规划\n        - 回溯法\n        - 枚举法\n    - 排序\n        - O(n^2)\n            - 冒泡排序\n            - 插入排序\n            - 选择排序\n            - 希尔排序\n        - O(nlogn)\n            - 归并排序\n            - 快速排序\n            - 堆排序\n        - O(n)\n            - 计数排序\n            - 基数排序\n            - 桶排序\n    - 搜索\n        - 深度优先搜索\n        - 广度优先搜索\n        - A*启发式搜索\n    - 查找\n        - 线性表查找\n        - 树结构查找\n        - 散列表查找\n    - 字符串匹配\n        - 朴素\n        - KMP\n        - Robin-Karp\n        - Boyer-Moore\n        - AC自动机\n        - Trie\n        - 后缀数组\n    - 其他\n        - 数论\n        - 计算几何\n        - 概率分析\n        - 并查集\n        - 拓扑网络\n        - 矩阵运算\n{% endpullquote %}\n\n### 本章参考：\n- 复杂度速查表\nhttps://liam.page/2016/06/20/big-O-cheat-sheet/\n\n## 2 基本数据结构\n### 2.1 线性表\n&ensp;线性表是n个具有相同特性的数据元素的有序序列。线性表除第一个和最后一个数据元素之外，其他数据元素都是首尾相接的。\n&ensp;数据在实际的物理存储中有两种形式：分散存储和集中存储,常见数据结构有栈、队列、字符串、链表等。\n&ensp;两种情况下数据的存储问题：\n&emsp; 数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；\n&emsp; 数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”\n\n#### 2.1.1 数组\n&emsp;数组是一批相同数据的集合。数组的三部分：`地址 大小 和 空间`。数组的保存形式为线性表。\n```c\nint arr[10]; // /[]内必须是常量/常量表达式(3+8)，不能是一个变量(x...)\n// 数组初始化\nint arr1[3] = {1, 2, 3};\nchar arr6[] = \"abcdef\";\n// 指针\nint *ptr = NULL;//定义一个整型的指针变量，初始化为NULL\nchar *ptr = NULL;//定义一个字符的指针变量，初始化为NULL\n// 二维数组\nint arr[3][5] = { 0 };\n// C 传递数组给函数\n// \nvoid myFunction(int *param)\nvoid myFunction(int param[10])\nvoid myFunction(int param[])\n// C 从函数返回数组\nint * myFunction()\n{\n...\n}\n```\n\n<details>\n<summary>array</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct array {\n    int size;\n    int used;\n    int *arr;\n};\n\nvoid dump(struct array *array)\n{\n    for (int idx = 0; idx < array->used; idx++) {\n        printf(\"[%02d]: %08d\\n\", idx, array->arr[idx]);\n    }\n}\n\nvoid alloc(struct array *array)\n{\n    array->arr = (int *)malloc(array->size * sizeof(int));\n}\n\nint insert(struct array *array, int elem)\n{\n    int idx;\n    if (array->used >= array->size)\n        return -1;\n\n    for (idx = 0; idx < array->used; idx++) {\n        if (array->arr[idx] > elem)\n            break;\n    }\n\n    if (idx < array->used)\n        memmove(&array->arr[idx+1], &array->arr[idx],\n            (array->used - idx) * sizeof(int));\n\n    array->arr[idx] = elem;\n    array->used++;\n    return idx;\n}\n\nint delete(struct array *array, int idx)\n{\n    if (idx < 0 || idx >= array->used)\n        return -1;\n\n    memmove(&array->arr[idx], &array->arr[idx+1],\n        (array->used - idx - 1) * sizeof(int));\n    array->used--;\n    return 0;\n}\n\nint search(struct array *array, int elem)\n{\n    for (int idx = 0; idx < array->used; idx++) {\n        if (array->arr[idx] == elem)\n            return idx;\n        if (array->arr[idx] > elem)\n            return -1;\n    }\n\n    return -1;\n}\n\nint main()\n{\n    struct array ten_int = {10, 0, NULL};\n\n    alloc(&ten_int);\n    if (!ten_int.arr) {\n        return -1;\n    }\n    insert(&ten_int, 1);\n    insert(&ten_int, 3);\n    insert(&ten_int, 2);\n    printf(\"=== insert 1, 3, 2\\n\");\n    dump(&ten_int);\n\n    int idx = search(&ten_int, 2);\n    printf(\"2 is at position %d\\n\", idx);\n    idx = search(&ten_int, 9);\n    printf(\"9 is at position %d\\n\", idx);\n\n    printf(\"=== delete [6] element \\n\");\n    delete(&ten_int, 6);\n    dump(&ten_int);\n    printf(\"=== delete [0] element \\n\");\n    delete(&ten_int, 0);\n    dump(&ten_int);\n    return 0;\n}\n```\n</details>\n\n\n<br>\n\n**二分搜索**\n&emsp;基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）\n&emsp;二分搜索的时间复杂度为 ***对数时间O(logn)***\n```c\nint binary_search(int key, int a[], int n)\n{\n    int low = 0;\n    int high = n - 1;\n    int mid, count = 0, count1 = 0;\n\n    while(low < high) {\n        count++;\n        mid = (low + high) / 2;\n        if (key < a[mid]) {\n            high = mid - 1;\n        } else if (key > a[mid]) {\n            low = mid + 1;\n        } else if (key == a[mid]) {\n            count1++;\n            break;\n        }\n    }\n\n    if (count1 == 0) {\n        return 1;\n    }\n    return 0;\n}\n```\n\n#### 2.1.2 单链表\n&emsp; 单链表元素之间有一个单独的指针链接。这种结构的链表可以使得从第一个元素遍历到最后一个元素\n```c\ntypedef struct ListElmt_ {\n    void *data;  // 数据成员\n    struct ListElmt_ * next; // next指针\n} ListElmt;\n\ntypedef struct List_ {\n    int size;\n    int (*match)(const void *key1, const void *key2);\n    void (*destroy)(void *data);\n    ListElmt *head;\n    ListElmt *tail;\n} List;\n```\n&emsp;单链表操作：插入、删除、\n&emsp;如何判断单链表存在回环？\n&emsp;&emsp;设有两个指针p1，p2。在美学循环的时候，p1先走一步，p2走两步，直到p2碰到空指针或者两者相等时循环结束，如果两个指针相等则说明存在回环。\n\n<details>\n<summary>singleList</summary>\n\n```c\n#ifndef __SINGLELIST_H__\n#define __SINGLELIST_H__\n\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct listNode {\n    struct listNode *next;\n    void *value;\n}listNode;\n\ntypedef struct linkedList {\n    listNode *head;\n    size_t len;\n    size_t typesize;\n\n    void(*dup)(void*, void*);\n    int(*match)(void*, void*);\n    void(*free)(void*);\n}linkedList;\n\n#define listSetDupMethod(l,m) ((l)->dup = (m))\n#define listSetFreeMethod(l,m) ((l)->free = (m))\n#define listSetMatchMethod(l,m) ((l)->match = (m))\n\n#define listGetDupMethod(l) ((l)->dup)\n#define listGetFree(l) ((l)->free)\n#define listGetMatchMethod(l) ((l)->match)\n\nlinkedList *listCreate();\nvoid listRelease(linkedList *list);\nvoid listEmpty(linkedList *list);\nlinkedList *listAddNodeHead(linkedList *list, void *value);\nlinkedList *listAddNodeTail(linkedList *list, void *value);\nlinkedList *listInsertNode(linkedList *list, listNode *old_node, void *value, bool after);\nvoid listDelNode(linkedList *list, listNode *node);\n\nlistNode *listSearchKey(linkedList *list, void *key);\nlistNode *listIndex(linkedList *list, long index);\nlinkedList* listRewind(linkedList *list);\n\nsize_t listLength(linkedList *list);\n\n#endif // !__SINGLELIST_H__\n\n//\n#include \"singleList.h\"\n#include <string.h>\n\nlinkedList * listCreate()\n{\n    linkedList *list = NULL;\n    list = malloc(sizeof(*list));\n    if (NULL == list) {\n        return NULL;\n    }\n\n    list->dup = NULL;\n    list->free = NULL;\n    list->match = NULL;\n\n    list->head = NULL;\n    list->len = 0;\n\n    return list;\n}\n\n// \nvoid listRelease(linkedList *list)\n{\n    if (NULL == list) {\n        return;\n    }\n\n    listEmpty(list);\n\n    free(list);\n    list = NULL;\n}\n\nvoid listEmpty(linkedList *list)\n{\n    if (NULL == list) {\n        return;\n    }\n\n    while (NULL != list->head) {\n        listNode *pNode = list->head;\n        list->head = pNode->next;\n        if (NULL != list->free) {\n            list->free(pNode->value);\n        } else {\n            free(pNode->value);\n        }\n\n        pNode->next = NULL;\n        free(pNode);\n        pNode = NULL;\n    }\n}\n\nlinkedList * listAddNodeHead(linkedList *list, void * value)\n{\n    if (NULL == list || NULL == value) {\n        return list;\n    }\n\n    listNode *node = NULL;\n    node = malloc(sizeof(*node));\n    if (NULL == node) {\n        return list;\n    }\n\n    node->value = value;\n    node->next = list->head;\n    list->head = node;\n\n    ++list->len;\n    return list;\n}\n\nlinkedList * listAddNodeTail(linkedList *list, void *value)\n{\n    if (NULL == list || NULL == value) {\n        return list;\n    }\n\n    listNode *node = NULL;\n    node = malloc(sizeof(*node));\n    if (NULL == node) {\n        return list;\n    }\n\n    node->value = value;\n    node->next = NULL;\n\n    if (NULL == list->head && list->len == 0) {\n        list->head = node;\n    } else {\n        listNode *tail = list->head;\n        listNode *pre = list->head;\n        while (NULL != tail) {\n            pre = tail;\n            tail = tail->next;\n        }\n\n        pre->next = node;\n    }\n\n    ++list->len;\n    return list;\n}\n\nlinkedList * listInsertNode(linkedList *list, listNode *old_node, void *value, bool after)\n{\n    if (NULL == list || NULL == old_node) {\n        return list;\n    }\n\n    listNode *pNode = NULL;\n    pNode = malloc(sizeof(*pNode));\n    if (NULL == pNode) {\n        return list;\n    }\n\n    pNode->value = value;\n    if (after) {\n        pNode->next = old_node->next;\n        old_node->next = pNode;\n    } else {\n        listNode *pre = list->head;\n        while (pre->next != old_node) {\n            pre = pre->next;\n        }\n\n        if (NULL != pre) {\n            pre->next = pNode;\n            pNode->next = old_node;\n        }\n    }\n\n    ++list->len;\n    return list;\n}\n\n// \nvoid listDelNode(linkedList *list, listNode *node)\n{\n    if (NULL == list || NULL == node) {\n        return;\n    }\n\n    listNode *pre = list->head;\n    listNode *cur = list->head;\n    while (NULL != cur && cur != node) {\n        pre = cur;\n        cur = cur->next;\n    }\n\n    // \n    if (NULL == pre) {\n        return;\n    }\n\n    pre->next = node->next;\n    node->next = NULL;\n    --list->len;\n\n    if (NULL != list->free) {\n        list->free(node->value);\n        free(node);\n        node = NULL;\n    }\n}\n\nlistNode * listSearchKey(linkedList *list, void *key)\n{\n    if (NULL == list) {\n        return NULL;\n    }\n\n    listNode *node = list->head;\n    while (NULL != node) {\n        if (NULL != list->match) {\n            if (list->match(key, node->value) == 0) {\n                return node;\n            }\n        } else {\n            if (key == node->value) {\n                return node;\n            }\n        }\n\n        node = node->next;\n    }\n\n    return NULL;\n}\n\nlistNode * listIndex(linkedList *list, long index)\n{\n    if (NULL == list) {\n        return NULL;\n    }\n\n    if (index <= 0 || index > list->len) {\n        return NULL;\n    }\n\n    listNode *pNode = list->head;\n    for (long i = 0; i < index; ++i) {\n        pNode = pNode->next;\n    }\n\n    return pNode;\n}\n\nlinkedList* listRewind(linkedList *list)\n{\n    if (NULL == list) {\n        return NULL;\n    }\n\n    listNode *head = list->head;\n    listNode *pre = NULL;\n    listNode *next = NULL;\n    while (NULL != head) {\n        next = head->next;\n        head->next = pre;\n        pre = head;\n        head = next;\n    }\n\n    list->head = pre;\n    return list;\n}\n\nsize_t listLength(linkedList *list)\n{\n    if (NULL == list) {\n        return 0;\n    }\n\n    return list->len;\n}\n```\n</details>\n\n\n<details>\n<summary>single_list</summary>\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n\nstruct single_list {\n    struct single_list *next;\n    int val;\n};\n\nstruct single_list_head {\n    struct single_list *head;\n};\n\nbool is_empty(struct single_list_head *head)\n{\n    return head->head == NULL;\n}\n\nvoid dump(struct single_list_head *head)\n{\n    struct single_list *tmp = head->head;\n    int idx = 0;\n\n    while (tmp) {\n        printf(\"[%02d]: %08d\\n\", idx++, tmp->val);\n        tmp = tmp->next;\n    }\n}\n\nvoid insert(struct single_list **prev, struct single_list *elem)\n{\n    if (!prev)\n        return;\n\n    elem->next = *prev;\n    *prev = elem;\n}\n\nvoid insert_head(struct single_list_head *head, struct single_list *elem)\n{\n    insert(&head->head, elem);\n}\n\nstruct single_list* del(struct single_list **prev)\n{\n    struct single_list *tmp;\n\n    if (!prev)\n        return NULL;\n    if (*prev == NULL)\n        return NULL;\n    tmp = *prev;\n    *prev = (*prev)->next;\n    tmp->next = NULL;\n\n    return tmp;\n};\n\nstruct single_list* delete_head(struct single_list_head* head)\n{\n    return del(&head->head);\n};\n\nstruct single_list** search(struct single_list_head* head, int target)\n{\n    struct single_list **prev, *tmp;\n\n    for (prev = &head->head, tmp = *prev; tmp && (tmp->val < target);\n    prev = &tmp->next, tmp = *prev);\n\n    return prev;\n};\n\nvoid reverse(struct single_list_head* head)\n{\n    struct single_list_head tmp = {NULL};\n    struct single_list *elem;\n\n    while (!is_empty(head)) {\n        elem = delete_head(head);\n        insert_head(&tmp, elem);\n    }\n\n    head->head = tmp.head;\n}\n\nbool is_cyclic(struct single_list_head* head)\n{\n    struct single_list *s1, *s2;\n\n    s1 = s2 = head->head;\n\n    while(s1 && s2) {\n        s1 = s1->next;\n        s2 = s2->next ? s2->next->next:s2->next;\n\n        if (s1 == s2)\n            return true;\n    }\n    return false;\n}\n\nstruct single_list* middle(struct single_list_head* head)\n{\n    struct single_list *s1, *s2;\n    struct single_list pseudo_head;\n\n    pseudo_head.next = head->head;\n    s1 = s2 = &pseudo_head;\n\n    while (true) {\n        if (!s2 || !s2->next)\n            return s1;\n        s1 = s1->next;\n        s2 = s2->next->next;\n    }\n\n    return NULL;\n};\n\nint main()\n{\n    struct single_list_head head = {NULL};\n    struct single_list lists[10];\n    struct single_list **prev;\n    int idx;\n\n    for (idx = 0; idx < 10; idx++) {\n        lists[idx].val = idx;\n        lists[idx].next = NULL;\n    }\n\n    insert_head(&head, &lists[6]);\n    insert_head(&head, &lists[5]);\n    insert_head(&head, &lists[4]);\n    insert_head(&head, &lists[1]);\n    insert_head(&head, &lists[0]);\n\n    printf(\"=== insert 0, 1, 4, 5, 6\\n\");\n    dump(&head);\n\n    prev = search(&head, 2);\n    insert(prev, &lists[2]);\n    printf(\"=== insert 2\\n\");\n    dump(&head);\n\n    printf(\"middle elem is %d\\n\", middle(&head)->val);\n\n    prev = search(&head, 2);\n    if ((*prev) && ((*prev)->val == 2))\n        printf(\"The list contains 2\\n\");\n    else\n        printf(\"The list not contains 2\\n\");\n\n    del(prev);\n    prev = search(&head, 2);\n    printf(\"After remove 2\\n\");\n    if ((*prev) && ((*prev)->val == 2))\n        printf(\"The list contains 2\\n\");\n    else\n        printf(\"The list not contains 2\\n\");\n    dump(&head);\n\n    printf(\"After reverse \\n\");\n    reverse(&head);\n    dump(&head);\n\n    printf(\"middle elem is %d\\n\", middle(&head)->val);\n\n    lists[0].next = &lists[6];\n    printf(\"list is%s cyclic\\n\", is_cyclic(&head)?\"\":\" not\");\n\n    return 0;\n}\n```\n</details>\n\n\n<details>\n<summary>LinkedListAlgo</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * 1) 单链表反转\n * 2) 链表中环的检测\n * 3) 两个有序的链表合并\n * 4) 删除链表倒数第 n 个结点\n * 5) 求链表的中间结点\n *\n * Author: Smallfly\n */\n\ntypedef struct SinglyLinkedNode {\n    int data;\n    struct SinglyLinkedNode* next;\n} SinglyLinkedNode;\n\nvoid insertNode(SinglyLinkedNode** head_ref, int data);\nvoid printLinkedList(SinglyLinkedNode* head);\n\n/** 反转单链表 */\nvoid reverse(SinglyLinkedNode** head_ref) {\n    if (*head_ref == NULL) return;\n    \n    SinglyLinkedNode *prev = NULL;\n    SinglyLinkedNode *current = *head_ref;\n    while (current) {\n        SinglyLinkedNode *next = current->next;\n        if (!next) {\n            // 到达尾结点时，将地址存入 head_ref\n            *head_ref = current;\n        }\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n}\n\nvoid test_reverse() {\n    SinglyLinkedNode* head = NULL;\n    insertNode(&head, 3);\n    insertNode(&head, 2);\n    insertNode(&head, 1);\n    \n    reverse(&head);\n    printLinkedList(head);\n}\n\n/** 检测单链表是否有环 */\n// 这里使用一级指针也可以\nint checkCircle(SinglyLinkedNode** head_ref) {\n    if (*head_ref == NULL) return 0;\n    SinglyLinkedNode *slow = *head_ref, *fast = *head_ref;\n    while (fast != NULL && fast->next != NULL) {\n        fast = fast->next->next;\n        slow = slow->next;\n        if (slow == fast) return 1;\n    }\n    return 0;\n}\n\nvoid test_checkCircle() {\n    SinglyLinkedNode* head = NULL;\n    insertNode(&head, 3);\n    insertNode(&head, 2);\n    insertNode(&head, 1);\n    \n    int result1 = checkCircle(&head);\n    printf(\"has circle: %d\\n\", result1);\n    \n    // make circle linklist\n    SinglyLinkedNode* current = malloc(sizeof(SinglyLinkedNode));\n    current->data = 0;\n    SinglyLinkedNode* h = current;\n    for (int i = 1; i < 4; ++i) {\n        SinglyLinkedNode* node = malloc(sizeof(SinglyLinkedNode));\n        node->data = i;\n        current->next = node;\n        //reset current node\n        current = node;\n    }\n    current->next = h;\n    \n    int result2 = checkCircle(&h);\n    printf(\"has circle: %d\\n\", result2);\n}\n\n/** 有序链表合并 */\nvoid moveNode(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref);\n\nSinglyLinkedNode* mergeSortedLinkedList(SinglyLinkedNode* la, SinglyLinkedNode* lb) {\n    // 辅助结点，next 指针持有合并后的有序链表\n    SinglyLinkedNode dummy;\n    \n    // 有序链表的尾结点\n    SinglyLinkedNode* tail = &dummy;\n    \n    while (1) {\n        // 如果有一个链表为空，直接与另一个链表接起来\n        if (!la) {\n            tail->next = lb;\n            break;\n        } else if (!lb) {\n            tail->next = la;\n            break;\n        }\n        \n        // 将头结点较小的优先添加到 tail\n        if (la->data <= lb->data) {\n            moveNode(&(tail->next), &la);\n        } else {\n            moveNode(&(tail->next), &lb);\n        }\n        tail = tail->next;\n    }\n    \n    return dummy.next;\n}\n\n// 将 src_ref 的头结点，添加到 dest_ref 的头部。\nvoid moveNode(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref) {\n    if (*src_ref == NULL) return;\n    SinglyLinkedNode* new_node = *src_ref;\n    \n    *src_ref = new_node->next;\n    \n    new_node->next = *dest_ref;\n    *dest_ref = new_node;\n}\n\nvoid test_mergeSortedLinkedList() {\n    SinglyLinkedNode* a = NULL;\n    insertNode(&a, 10);\n    insertNode(&a, 5);\n    insertNode(&a, 0);\n    \n    SinglyLinkedNode* b = NULL;\n    insertNode(&b, 8);\n    insertNode(&b, 6);\n    insertNode(&b, 3);\n    \n    SinglyLinkedNode* result = mergeSortedLinkedList(a, b);\n    printLinkedList(result);\n    \n    SinglyLinkedNode* result2 = mergeSortedLinkedList(a, NULL);\n    printLinkedList(result2);\n}\n\n/** 删除倒数第 K 个结点 */\nvoid deleteLastKth(SinglyLinkedNode** head_ref, int k) {\n    if (*head_ref == NULL || k == 0) return;\n    \n    // 快指针向前移动 k-1\n    SinglyLinkedNode* fast = *head_ref;\n    int i = 1;\n    while (i < k && fast != NULL) {\n        fast = fast->next;\n        ++i;\n    }\n    \n    // 如果快指针为空，说明结点个数小于 k\n    if (fast == NULL) return;\n    \n    SinglyLinkedNode* slow = *head_ref;\n    SinglyLinkedNode* prev = NULL;\n    while (fast->next != NULL) {\n        fast = fast->next;\n        prev = slow;\n        slow = slow->next;\n    }\n    \n    // 如果 prev 为空，头结点刚好是第 k 个结点\n    if (!prev) {\n        (*head_ref) = (*head_ref)->next;\n    } else {\n        prev->next = slow->next;\n    }\n    free(slow);\n}\n\nvoid test_deleteLastKth() {\n    SinglyLinkedNode* head = NULL;\n    insertNode(&head, 1);\n    insertNode(&head, 2);\n    insertNode(&head, 3);\n    insertNode(&head, 4);\n    insertNode(&head, 5);\n    \n    // 1. 删除头结点\n    deleteLastKth(&head, 5);\n    printLinkedList(head);\n    \n    // 2. 删除中间结点\n    deleteLastKth(&head, 2);\n    printLinkedList(head);\n    \n}\n\n/** 求中间结点  */\nSinglyLinkedNode* findMiddleNode(SinglyLinkedNode* head) {\n    if (!head) return NULL;\n    SinglyLinkedNode* slow = head;\n    SinglyLinkedNode* fast = head;\n    \n    // 1. 慢指针走一步，快指针两步\n    while (fast->next != NULL && fast->next->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    \n    return slow;\n}\n\nvoid test_findMiddleNode() {\n    SinglyLinkedNode* head = NULL;\n    insertNode(&head, 1);\n    insertNode(&head, 2);\n    insertNode(&head, 3);\n    insertNode(&head, 4);\n    insertNode(&head, 5);\n    \n    SinglyLinkedNode* middleNode = findMiddleNode(head);\n    printf(\"%d\\n\", middleNode->data);\n    printLinkedList(head);\n}\n\n/** 工具方法 */\n// 插入新结点到链表头部\nvoid insertNode(SinglyLinkedNode** head_ref, int data) {\n    SinglyLinkedNode* new_node = malloc(sizeof(SinglyLinkedNode));\n    new_node->data = data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n\n// 打印链表\nvoid printLinkedList(SinglyLinkedNode* node) {\n    printf(\"--- start ---\\n\");\n    while (node) {\n        printf(\"data: %d\\n\", node->data);\n        node = node->next;\n    }\n    printf(\"--- end ---\\n\");\n}\n\n// 跑测试\nvoid test() {\n    \n    test_reverse();  \n//    test_checkCircle();\n//    test_mergeSortedLinkedList();\n//    test_deleteLastKth();  \n//    test_findMiddleNode();\n}\n```\n</details>\n\n\n<details>\n<summary>linklist_jinshaohui</summary>\n\n```c\n/*************************************************************************\n > File Name: lisklist.c\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-10-07  \n ************************************************************************/\n#include<stdio.h>\n\nstruct stlistNode\n{\n    int val;\n    struct listNode *next;\n}listNode;\n\n/*反转链表*/\nlistNode reverseList(listNode *head)\n{\n    listNode *prev = NULL;\n    listNode *next = NULL;\n\n    while(head != NULL) {\n        next = head->next;\n        head->next = prev;\n        prev = head;\n        head = next;\n    }\n\n    return prev;\n}\n\n/*判断链表是否有环*/\nint hasCycle(listNode *head)\n{\n    listNode * fast = head;\n    listNode * low = head;\n\n    while(fast != NULL && fast->next != NULL) {\n        low = low->next;\n        fast = fast->next->next;\n        if (low == fast) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n/*合并有序链表*/\nlistNode *mergeTwoLists(listNode *l1,listNode *l2)\n{\n    listNode head = {0};\n    listNode *pRes = &head;\n\n    while(1) {\n        if(l1 == NULL) {\n            pRes->next = l2;\n        }\n\n        if (l2 == NULL) {\n            pRes->next = l1;\n        }\n\n        if(l1->val < l2->val) {\n            pRes->next = l1;\n            l1 = l1->next;\n        } else {\n            pRes->next = l2;\n            l2 = l2->next;\n        }\n        pRes = pRes->next;\n    }\n\n    return head;\n}\n/*\n *删除链表倒数第n个节点，并返回链表头节点 */\nlistNode * removeNthFromEnd(listNode*headi,int n)\n{\n    listNode *fast = head;\n    listNode *prev = NULL;\n    listNpde *next = head;\n    int k = n;\n    \n    /*快指针往后移动k-1*/\n    while((k > 1) && (fast != NULL)) {\n        fast = fast->next;\n        k--;\n    }\n    \n    /*说明链表数目不足n个*/\n    if (fast == NULL) {\n        return head;\n    }\n\n    while (fast->next != NULL) {\n        fast = fast->next;\n        prev = next;\n        next = next->next;\n    }\n\n    if(prev == NULL) {\n        head = head->next;\n    } else {\n        prev->next = prev->next->next;\n    }\n\n    return head;\n}\n/*求链表的中间节点*/\nlistNode *middleNode(listNode *head)\n{\n    listNode * fast = head;\n    listNode * low = head;\n\n    while(fast != NULL && fast->next != NULL) {\n        low = low->next;\n        fast = fast->next->next;\n    }\n\n    return low;\n}\n```\n</details>\n\n\n#### 2.1.3 双链表\n&emsp; 双向链表的元素通过两个指针链接，一个指向直接后继，一个指向直接前驱。双向链表可以正向遍历，也可反向遍历。\n```c\ntypedef struct DListElmt_ {\n    void *data;\n    struct DListElmt_ *prev;\n    struct DListElmt_ *next;\n} DListElmt;\n\ntypedef struct DList_ {\n    int size;\n    int (*match)(const void *key1, const void *key2);\n    void (*destroy)(void *data);\n    DListElmt *head;\n    DListElmt *tail;\n} DList;\n```\n\n<details>\n<summary>Dlist</summary>\n\n```c\n// Dlist.h\n#include<stdio.h>\n\ntypedef struct DlistNode {    //双向链表中每一个节点\n    struct DlistNode *prev;   //节点前项指针\n    struct DlistNode *next;   //节点后项指针\n    int    data;              //数据\n}stDlistNode;\n\ntypedef struct Dlisthead {    //定义链表总体\n    int size;                 //链表长度\n    stDlistNode *head;        //头指针\n    stDlistNode *tail;        //尾部指针\n}stDlistHead;\n\n// Dlist.c\n#include<stdio.h>\n#include <stdbool.h>\n#include \"./Dlist.h\"\n\nvoid dlist_init(stDlistHead *dlist)    //链表初始化\n{\n    dlist->size = 0;\n    dlist->head = NULL;\n    dlist->tail = NULL;\n    return;\n}\n\nvoid dlist_destory(stDlistHead *dlist)    //删除链表\n{\n    stDlistNode *pNode = NULL;\n\n    while(dlist->size > 0) {\n        pNode = dlist->head;\n        dlist->head = dlist->head->next;\n        free(pNode);\n        dlist->size--;\n    }\n\n    memset(dlist,0,sizeof(stDlistHead));\n\n    return;\n}\n\nint dlist_insert_head(stDlistHead *dlist,stDlistNode *pNode,int data)    //插入头结点，操作的链表，操作的节点，数据\n{\n    if(pNode == NULL) {   //当只传递一个数据时\n        pNode = (stDlistNode *)malloc(sizeof(stDlistNode));    //新建节点，为节点分配空间（malloc（）可能需要#include<malloc.h>）\n        if (pNode == NULL) {\n            return -1;\n        }\n    }\n\n    pNode->data = data;    \n    pNode->prev = NULL;\n    pNode->next = NULL;\n\n    if (dlist->size == 0) {  //如果链表长度为0，即链表当前无节点，\n        dlist->head = pNode;\n        dlist->tail = pNode;\n    } else {                 //如果链表已有节点，则令新插入节点为头节点\n        pNode->next = dlist->head;\n        dlist->head->prev = pNode;\n        dlist->head = pNode;    \n    }\n\n    dlist->size++;    //每成功调用一次，链表长度+1\n    return 0;\n}\n\nstDlistNode * dlist_remove_tail(stDlistHead *dlist)    //删除尾部节点,并返回删除节点\n{\n    stDlistNode *pNode = NULL;\n\n    if(dlist->size == 0) {\n        return NULL;\n    }\n\n    pNode = dlist->tail;\n    if(dlist->size > 1) {\n        dlist->tail = dlist->tail->prev;\n        dlist->tail->next = NULL;\n    } else {\n        dlist->head = NULL;\n        dlist->tail = NULL;\n    }\n    dlist->size--;\n    return pNode;\n}\n\nvoid dlist_remove_node(stDlistHead * dlist,stDlistNode *pNode)     //删除指定节点\n{\n    if ((dlist == NULL)||(pNode == NULL)) {\n        return;\n    }\n\n    if (dlist->head == pNode) {\n        dlist->head = dlist->head->next;\n    } else if (dlist->tail == pNode) {\n        dlist->tail = pNode->prev;\n        dlist->tail->next = NULL;\n    } else {\n        pNode->prev->next = pNode->next;\n        pNode->next->prev = pNode->prev;\n    }\n    dlist->size--;\n    pNode->prev = NULL;\n    pNode->next = NULL;\n\n    if (dlist->size == 0) {\n        memset(dlist,0,sizeof(stDlistHead));     //将dlist占用内存块的所有值置为0，也就是清空head,tail指针内容\n    }\n\n    return;\n}\nstDlistNode * dlist_search(stDlistHead * dlist,int data)     //根据值搜索节点，并返回\n{\n    stDlistNode *pNode = dlist->head;\n    while(pNode != NULL) {\n        if (pNode->data == data) {\n            return pNode;\n        }\n        pNode = pNode->next;\n    }\n    return NULL;\n}\n\nvoid dlist_dump(stDlistHead *dlist)    //显示链表中的数据\n{\n    int no = 0;\n    stDlistNode *pNode = dlist->head;\n    while(pNode != NULL) {\n        printf(\"\\r\\n [%d] = %d\",no++,pNode->data);\n        pNode = pNode->next;    //将pNode的下一个节点赋值给pNode，推进循环\n    }\n\n    return;\n}\n\n\nvoid Lru_dlist(stDlistHead *dlist,int data)     //LRU（最近最少使用）缓存淘汰算法\n{\n    stDlistNode *pNode = NULL;\n\n    pNode = dlist_search(dlist,data);    \n    if (pNode != NULL) {    //如果在链表中找到这个值，则删除储存这个值的节点，之后吧这个节点放在头部\n        dlist_remove_node(dlist,pNode);\n    } else if(dlist->size >= 4)    {    //没在链表中找到，且链表长度大于4，则从链表中删除尾部节点，将新数据放在头部\n        pNode = dlist_remove_tail(dlist);\n    }\n\n    dlist_insert_head(dlist ,pNode,data);\n\n    return;\n}\n\nint main()\n{\n    stDlistHead dlist = {0};\n    stDlistNode * pNode = NULL;\n\n    dlist_init(&dlist);\n\n    printf(\"\\r\\n inset 1,2,3\");\n    dlist_insert_head(&dlist,NULL,1);\n    dlist_insert_head(&dlist,NULL,2);\n    dlist_insert_head(&dlist,NULL,3);\n\n    dlist_dump(&dlist);\n\n    pNode = dlist_remove_tail(&dlist);\n    if(pNode != NULL) {\n        printf(\"\\r\\n remove %d\",pNode->data);\n    }\n    dlist_insert_head(&dlist,pNode,4);\n    dlist_dump(&dlist);\n\n    Lru_dlist(&dlist,5);\n    dlist_dump(&dlist);\n    Lru_dlist(&dlist,6);\n    dlist_dump(&dlist);\n    Lru_dlist(&dlist,7);\n    dlist_dump(&dlist);\n    Lru_dlist(&dlist,5);\n    dlist_dump(&dlist);\n\n    while(dlist.size > 0) {\n        pNode = dlist_remove_tail(&dlist);\n        if(pNode != NULL) { \n            printf(\"\\r\\n remove %d\",pNode->data);\n            free (pNode);\n        }\n    }\n\n    return 0;\n}\n```\n</details>\n\n<details>\n<summary>linux/list</summary>\n\n```c\n// linux内核源码双向链表实现include/linux/list.h\n#ifndef _LIST_HEAD_H\n#define _LIST_HEAD_H\n\n// 双向链表节点\nstruct list_head {\n    struct list_head *next, *prev;\n};\n\n// 初始化节点：设置name节点的前继节点和后继节点都是指向name本身。\n#define LIST_HEAD_INIT(name) { &(name), &(name) }\n\n// 定义表头(节点)：新建双向链表表头name，并设置name的前继节点和后继节点都是指向name本身。\n#define LIST_HEAD(name) \\\n    struct list_head name = LIST_HEAD_INIT(name)\n\n// 初始化节点：将list节点的前继节点和后继节点都是指向list本身。\nstatic inline void INIT_LIST_HEAD(struct list_head *list)\n{\n    list->next = list;\n    list->prev = list;\n}\n\n// 添加节点：将new插入到prev和next之间。\nstatic inline void __list_add(struct list_head *new,\n                  struct list_head *prev,\n                  struct list_head *next)\n{\n    next->prev = new;\n    new->next = next;\n    new->prev = prev;\n    prev->next = new;\n}\n\n// 添加new节点：将new添加到head之后，是new称为head的后继节点。\nstatic inline void list_add(struct list_head *new, struct list_head *head)\n{\n    __list_add(new, head, head->next);\n}\n\n// 添加new节点：将new添加到head之前，即将new添加到双链表的末尾。\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head)\n{\n    __list_add(new, head->prev, head);\n}\n\n// 从双链表中删除entry节点。\nstatic inline void __list_del(struct list_head * prev, struct list_head * next)\n{\n    next->prev = prev;\n    prev->next = next;\n}\n\n// 从双链表中删除entry节点。\nstatic inline void list_del(struct list_head *entry)\n{\n    __list_del(entry->prev, entry->next);\n}\n\n// 从双链表中删除entry节点。\nstatic inline void __list_del_entry(struct list_head *entry)\n{\n    __list_del(entry->prev, entry->next);\n}\n\n// 从双链表中删除entry节点，并将entry节点的前继节点和后继节点都指向entry本身。\nstatic inline void list_del_init(struct list_head *entry)\n{\n    __list_del_entry(entry);\n    INIT_LIST_HEAD(entry);\n}\n\n// 用new节点取代old节点\nstatic inline void list_replace(struct list_head *old,\n                struct list_head *new)\n{\n    new->next = old->next;\n    new->next->prev = new;\n    new->prev = old->prev;\n    new->prev->next = new;\n}\n\n// 双链表是否为空\nstatic inline int list_empty(const struct list_head *head)\n{\n    return head->next == head;\n}\n\n// 获取\"MEMBER成员\"在\"结构体TYPE\"中的位置偏移\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n\n// 根据\"结构体(type)变量\"中的\"域成员变量(member)的指针(ptr)\"来获取指向整个结构体变量的指针\n#define container_of(ptr, type, member) ({          \\\n    const typeof( ((type *)0)->member ) *__mptr = (ptr);    \\\n    (type *)( (char *)__mptr - offsetof(type,member) );})\n\n// 遍历双向链表\n#define list_for_each(pos, head) \\\n    for (pos = (head)->next; pos != (head); pos = pos->next)\n\n#define list_for_each_safe(pos, n, head) \\\n    for (pos = (head)->next, n = pos->next; pos != (head); \\\n        pos = n, n = pos->next)\n\n#define list_entry(ptr, type, member) \\\n    container_of(ptr, type, member)\n\n#endif\n```\n</details>\n\n#### 2.1.4 跳表\n&emsp;跳表对标的是平衡树(AVL Tree), 插入/删除/搜索都是 O(logn)的数据结构。\n\n<details>\n<summary>skiplist</summary>\n\n```c\n/*************************************************************************\n > File Name: skiplist.h\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-10-31\n > Desc:    \n ************************************************************************/\n#ifndef __SKIP_LIST_H__\n#define __SKIP_LIST_H__\n\ntypedef struct _node {\n    int key;    /*key是唯一的*/\n    int value;  /*存储的内容*/\n    int max_level; /*当前节点最大层数*/\n    struct _node *next[0];/*level层链表结构*/\n}node;\n\ntypedef struct _skiplist {\n    int level;\n    int count;\n    node *head;\n}skiplist;\n\n/*根据当前结构体元素的地址，获取到结构体首地址*/\n#define offsetof(TYPE,MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#define container(ptr,type,member) ({\\\n  const typeof( ((type *)0)->member) *__mptr = (ptr);\\\n  (type *) ( (char *)__mptr - offsetof(type,member));})\n\n#endif\n\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#include\"./skiplist.h\"\n\n/*创建node节点*/\nnode* skip_list_create_node(int level,int key,int value)\n{\n    node * tmp = NULL;\n    tmp =(node *)malloc(sizeof(node) + level*sizeof(node *));\n    assert(tmp != NULL);\n\n    memset(tmp,0,sizeof(node) + level*sizeof(node*));\n    tmp->key = key;\n    tmp->value = value;\n    tmp->max_level = level;\n    \n    return tmp;\n}\n\n/*创建跳表的表头，max_level层数*/\nskiplist * skip_list_create(int max_level)\n{\n    int i = 0;\n    skiplist * list = NULL;\n\n    list = (skiplist *)malloc (sizeof(skiplist));\n    assert(list != NULL);\n\n    list->level = 1;\n    list->count = 0;\n    list->head = skip_list_create_node(max_level,0,0);\n    if(list->head == NULL) {\n        free(list);\n        return NULL;\n    }\n    \n    return list;\n}\n\n/*skiplist 销毁*/\nvoid skip_list_destory(skiplist * list)\n{\n    int i = 0;\n    node * tmp = NULL;\n\n    if((list == NULL) || (list->head == NULL)) {\n        return;\n    }\n    while(list->head->next[0] != NULL) {\n        tmp = list->head->next[0];\n        list->head->next[0] = tmp->next[0];\n        free(tmp);\n    }\n\n    free(list->head);\n    free(list);\n    return;\n}\n\n/*插入元素获得层数，是随机产生的*/\nint skip_list_level(skiplist * list)\n{\n    int i = 0;\n    int level = 1;\n    for (i = 1; i < list->head->max_level; i++) {\n        if ((rand()%2) == 1) {\n            level++;\n        }\n    }\n\n    return level;\n}\nint skip_list_insert(skiplist *list,int key,int value)\n{\n    int i = 0;\n    int level = 0;\n    node **update = NULL;/*用来更新每层的指针*/\n    node *tmp = NULL;\n    node *prev = NULL;\n\n    if (list == NULL) {\n        return 1;\n    }\n\n    /*申请update空间用于保存每层的指针*/\n    update = (node **)malloc(sizeof(node *)*list->head->max_level);\n    if (update == NULL) {\n        return 2;\n    }\n\n    /*逐层查询节点的*/\n    prev = list->head;\n    for (i = (list->level -1); i >= 0; i--) {\n        /*初始化每level层的头指针*/\n        while(((tmp = prev->next[i]) != NULL) && (tmp->key < key)) {\n            prev  = tmp;\n        }\n        update[i] = prev;\n    }\n\n    /*当前key已经存在，返回错误*/\n    if ((tmp!= NULL) && (tmp->key == key)) {\n        return 3;\n    }\n    /*获取插入元素的随机层数，并更新跳表的最大层数*/\n    level = skip_list_level(list);\n    /*创建当前数据节点*/\n    tmp = skip_list_create_node(level,key,value);\n        if (tmp == NULL) {\n        return 4;\n    }\n\n    /*更新最大层数*/\n    if (level > list->level) {\n        for (i = list->level;i < level; i ++) {\n            update[i] = list->head;\n        }\n        list->level = level;\n    }\n\n    /*逐层更新节点的指针*/\n    for(i = 0; i < level; i++) {\n        tmp->next[i] = update[i]->next[i];\n        update[i]->next[i] = tmp; \n    }\n\n    list->count++;\n    return 0;\n}\n\nint skip_list_delete(skiplist * list, int key ,int *value)\n{\n    int i = 0;\n    node **update = NULL;/*用来更新每层的指针*/\n    node *tmp = NULL;\n    node *prev = NULL;\n\n    if ((list == NULL) && (value == NULL)&& (list->count == 0)) {\n        return 1;\n    }\n    /*申请update空间用于保存每层的指针*/\n    update = (node **)malloc(sizeof(node *)*list->level);\n    if (update == NULL) {\n        return 2;\n    }\n    /*逐层查询节点的*/\n    prev = list->head;\n    for (i = (list->level -1); i >= 0; i--) {\n        /*初始化每level层的头指针*/\n        while(((tmp = prev->next[i]) != NULL) && (tmp->key < key)) {\n            prev = tmp;\n        }\n        update[i] = prev;\n    }\n\n    if ((tmp != NULL) && (tmp->key == key)) {\n        *value = tmp->value;\n        /*逐层删除*/\n        for(i = 0; i < list->level; i++) {\n            if(update[i]->next[i] == tmp) {\n                update[i]->next[i] = tmp->next[i];       \n            }    \n        }\n\n        free(tmp);\n        tmp = NULL;\n        \n        /*更新level的层数*/\n        for (i = list->level - 1; i >= 0; i++) {\n            if (list->head->next[i] == NULL ) {\n                list->level--;\n            } else {\n                break;\n            }\n        }\n\n        list->count--;\n    } else {\n        return 3;/*未找到节点*/\n    }\n\n    return 0 ;\n}\n\n/*查询当前key是否在跳表中，如果存在返回查询的value数值，不存在返回-1*/\nint skip_list_search(skiplist *list,int key,int *value)\n{\n    int i = 0;\n    node *prev = NULL;\n    node *tmp = NULL;\n\n    if((list == NULL) || (list->count == 0) || (value == NULL)) {\n        return 1;\n    }\n    prev = list->head;\n    for(i = list->level - 1; i >= 0; i--) {\n        while(((tmp = prev->next[i]) != NULL) && (tmp->key <= key)) {\n            if (tmp->key == key) {\n                    *value = tmp->value;\n                    return 0;\n            }\n            prev = tmp;\n        }\n    }\n\n    return -1;\n}\n\nvoid skip_list_dump(skiplist *list)\n{\n    int i = 0;\n    node *ptmp = NULL;\n    printf(\"\\r\\n----------------------------------------------\");\n    printf(\"\\r\\n skip list level[%d],count[%d]\",list->level,list->count);\n    for(i = list->level - 1; i >= 0; i --) {\n        ptmp = list->head->next[i];\n        printf(\"\\r\\n level[%d]:\",i);\n        while(ptmp != NULL) {\n            printf(\"%d-%d \",ptmp->key,ptmp->value);\n            ptmp = ptmp->next[i];\n        }\n    }\n    printf(\"\\r\\n----------------------------------------------\");\n    return;\n}\n\nint main()\n{\n    int res = 0;\n    int key = 0;\n    int value = 0;\n    skiplist *list = NULL;\n\n\n    list = skip_list_create(5);\n    assert(list != NULL);\n\n    while(1) {\n        printf(\"\\r\\n 请输入key 和 value，当key = 1000时，退出输入：\");\n        scanf(\"%d%d\",&key,&value);\n        if (key == 1000) {\n            break;\n        }\n        res = skip_list_insert(list,key,value);\n        if (res != 0) {\n            printf(\"\\r\\n skip list insert %d,failed,res=%d.\",key,res);\n        }\n    }\n    skip_list_dump(list);\n\n    while(1) {\n        printf(\"\\r\\n 通过key 查询value的数值，当key = 1000时，退出查询\");\n        scanf(\"%d\",&key);\n        if(key == 1000) {\n            break;\n        }\n        res = skip_list_search(list,key,&value);\n        if (res != 0) {\n            printf(\"\\r\\n skip list search %d,failed,res=%d.\",key,res);\n        } else {\n            printf(\"\\r\\n skip list search %d,sucessful,value=%d.\",key,value);\n        }\n    }\n    skip_list_dump(list);\n    while(1) {\n        printf(\"\\r\\n 通过key 删除节点，当key = 1000时，退出删除\");\n        scanf(\"%d\",&key);\n        if(key == 1000) {\n            break;\n        }\n        res = skip_list_delete(list,key,&value);\n        if (res != 0) {\n            printf(\"\\r\\n skip list search %d,failed,res=%d.\",key,res);\n        } else {\n            printf(\"\\r\\n skip list search %d,sucessful,value=%d.\",key,value);\n        }\n    }\n\n    skip_list_dump(list);\n    skip_list_destory(list);\n\n    return 0;\n}\n```\n</details>\n\n\n#### 2.1.5 栈\n&emsp;栈按照后进先出(LIFO)的顺序存储和检索数据的数据结构，检索元素的顺序和存储元素顺序相反。\n&emsp;可通过链表来实现栈stack,允许插入和删除的为栈顶(`top`),另一端为栈底(`bottom`),栈中每个元素为`frame`,栈只支持三个操作:`pop`,`top`,`push`.\n```c\ntypedef List Stack;\n\n#define stack_init list_init;\nint stack_push(Stack *stack, const void *data);\nint stack_pop(Stack *stack, void **data);\n#define stack_peek(stack) ((stack)->head == NULL ? NULL : (stack)->head->data);\n#define stack_size list_size;\n```\n&emsp;c语言顺序栈\n```c\n// 元素elem进栈\nint push(char *a, int top, char elem) {\n    a[++top] = elem;\n    return top;\n}\n// 数据元素出栈\nint pop(char *a, int top)\n{\n    if (top == -1) {\n        return -1;\n    }\n\n    top--;\n    return top;\n}\n```\n\n\n<details>\n<summary>arrayStack</summary>\n\n```c\n/*************************************************************************\n > File Name: arrayStack\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-10-12\n > Desc:   数组实现顺序栈 \n ************************************************************************/\n#ifndef ARRAY_STACJ_H\n#define ARRAY_STACJ_H\n\ntypedef struct _array_stack {\n    int size;/*栈的大小*/\n    int pos;/*当前存储元素的个数，即栈顶元素下表*/\n    int *array;/*数据存储区*/\n}stArrayStack;\n\n#define arrayStack_size(arrayStack) (arrayStack->size)\n#define arrayStack_is_empty(arrayStack) (arrayStack->pos == -1)\n#define arrayStack_is_full(arrayStack)  (arrayStack->pos == (arrayStack->size-1))\n\n#endif\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include\"./arrayStack.h\"\n\n/*创建并初始化顺序栈*/\nstArrayStack * arrayStack_create(int size)\n{\n    stArrayStack *parrStack = NULL;\n\n    parrStack = (stArrayStack *)malloc(sizeof(stArrayStack));\n    if (parrStack == NULL) {\n        return NULL;\n    }\n    \n    parrStack->size = size;\n    parrStack->pos = -1;\n    parrStack->array = (int *)malloc(sizeof(int)*size);\n    if(parrStack->array == NULL) {\n        free(parrStack);\n        return NULL;\n    }\n\n    return parrStack;\n}\n/*销毁顺序栈*/\nvoid arrayStack_destory(stArrayStack * parrStack)\n{\n    if(parrStack == NULL) {\n        return;\n    }\n\n    if (parrStack->array != NULL) {\n        free(parrStack->array);\n    }\n\n    free(parrStack);\n    return;\n}\n/*出栈*/\nint arrayStack_pop(stArrayStack *parrStack)\n{\n    int data = 0;\n\n    if(arrayStack_is_empty(parrStack)) {\n        return -1;\n    }\n    data = parrStack->array[parrStack->pos];\n    parrStack->pos--;\n\n    return data;\n}\n/*入栈*/\nint arrayStack_push(stArrayStack *parrStack,int data)\n{\n    if(arrayStack_is_full(parrStack)) {\n        return -1;\n    }\n\n    parrStack->pos++;\n    parrStack->array[parrStack->pos] = data;\n\n    return 0;\n}\n\nint arrayStack_push_new(stArrayStack*parrStack,int data)\n{\n    int *ptmp = NULL;\n\n    /*如果栈不满，直接插入*/\n    if(!arrayStack_is_full(parrStack)) {\n        return arrayStack_push(parrStack,data);\n    }\n\n    /*如果栈已经满，申请内存*/\n    ptmp = (int *)malloc(2*parrStack->size*sizeof(int));\n    if (ptmp == NULL) {\n        return -1;\n    }\n\n    memcpy(ptmp,parrStack->array,parrStack->size*sizeof(int));\n\n    free(parrStack->array);\n\n    parrStack->array = ptmp;\n    parrStack->size = 2*parrStack->size;\n    parrStack->pos++;\n    parrStack->array[parrStack->pos] = data;\n\n    return ;\n}\n\nvoid arrayStack_dump(stArrayStack *parrStack)\n{\n    int i = 0;\n\n    if (arrayStack_is_empty(parrStack)) {\n        printf(\"\\r\\n arrayStack is empty.\");\n        return;\n    }\n    printf(\"\\r\\narrayStack size = %d,pos= %d,\",\n    parrStack->size,parrStack->pos);\n    for(i = 0; i <= parrStack->pos; i++) {\n        printf(\"\\r\\narry[%d] = %d\",i,parrStack->array[i]);\n    }\n}\n\nint main()\n{\n    int i = 0;\n    int ret = 0;\n    stArrayStack * parrStack = NULL;\n\n    printf(\"\\r\\n create size = 4 arrayStack.\");\n\n    parrStack = arrayStack_create(4);\n    if (parrStack == NULL) {\n        printf(\"\\r\\n create size = 4 arrayStack faided.\");\n        return 0;\n    }\n\n    for (i = 0; i < 5; i++) {\n        ret = arrayStack_push(parrStack,i);\n        if(ret != 0) {\n            printf(\"\\r\\n push size = %d arrayStack faided.\",i);\n        }\n    }\n    arrayStack_dump(parrStack);\n    \n    ret = arrayStack_push_new(parrStack,4);\n    if(ret != 0) {\n        printf(\"\\r\\n push size = %d arrayStack faided.\",4);\n    }\n    arrayStack_dump(parrStack);\n    arrayStack_destory(parrStack);\n    \n    return;\n}\n```\n</details>\n\n\n&emsp;链栈\n```c\ntypedef struct lineStack {\n    char data;\n    struct lineStack *next;\n}lineStack;\n\nlineStack* push(lineStack * stack, char a){\n    lineStack * line=(lineStack*)malloc(sizeof(lineStack));\n    line->data=a;\n    line->next=stack;\n    stack=line;\n    return stack;\n}\n\nlineStack * pop(lineStack * stack){\n    if (stack) {\n        lineStack * p=stack;\n        stack=stack->next;\n        printf(\"弹栈元素：%c \",p->data);\n        if (stack) {\n            printf(\"栈顶元素：%c\\n\",stack->data);\n        } else {\n            printf(\"栈已空\\n\");\n        }\n        free(p);\n    } else {\n        printf(\"栈内没有元素\");\n        return stack;\n    }\n    return stack;\n}\n```\n\n<details>\n<summary>linklist_stack</summary>\n\n```c\n/*************************************************************************\n > File Name: linklist_stack\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-10-12\n > Desc:    \n ************************************************************************/\n\n#ifndef STACK_LINK_LIST_H\n#define STACK_LINK_LIST_H\n\ntypedef struct _linkliststack {\n    int data;\n    struct _linkliststack *next;\n}linklist_stack;\n\n\n#define stack_is_empty(liststack) (liststack->next == NULL)\n\n#endif\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include \"./linklist_stack.h\"\n\nlinklist_stack * stack_create()\n{\n    linklist_stack * stack = NULL;\n    stack = (linklist_stack *)malloc(sizeof(linklist_stack));\n    if (stack == NULL) {\n        return NULL;\n    }\n    stack->next = NULL;\n\n    return stack;\n}\n\nvoid stack_destory(linklist_stack* stack)\n{\n    linklist_stack * ptmp = NULL;\n\n    while(!stack_is_empty(stack)) {\n        ptmp = stack->next;\n        stack->next = stack->next->next;\n        free(ptmp);\n    }\n\n    free(stack);\n\n    return;\n}\n\nint stack_push(linklist_stack *stack,int data)\n{\n    linklist_stack * ptmp = NULL;\n\n    ptmp = (linklist_stack *)malloc(sizeof(linklist_stack));\n    if (ptmp == NULL) {\n        return -1;\n    }\n\n    ptmp->data = data;\n    ptmp->next = stack->next;\n    stack->next = ptmp;\n\n    return 0;\n}\n\nint stack_pop(linklist_stack*stack,int *data)\n{\n    linklist_stack *ptmp = NULL;\n    if (data == NULL) {\n        return -1;\n    }\n    if(stack_is_empty(stack)) {\n        return -1;    \n    }\n    *data = stack->next->data;\n    ptmp = stack->next;\n    stack->next = ptmp->next;\n    free(ptmp);\n\n    return 0;\n}\n\nvoid stack_dump(linklist_stack *stack)\n{\n    linklist_stack * ptmp = stack->next;\n    \n    while(ptmp != NULL) {\n        printf(\"\\r\\n data = %d\",ptmp->data);\n        ptmp = ptmp->next;\n    }\n    return;\n}\n\nint main()\n{\n    int i = 0;\n    int ret = 0;\n    int data = 0;\n    linklist_stack * stack = NULL;\n\n    stack = stack_create();\n    if (stack == NULL) {\n        printf(\"\\r\\n stack create falied.\");\n        return 0;    \n    }\n    \n    for (i = 0; i < 4; i++) {\n        ret = stack_push(stack,i);\n        if(ret != 0) {\n            printf(\"\\r\\n stack push %d falied.\",i);\n        }\n    }\n\n    stack_dump(stack);\n\n    for (i = 0; i < 5; i++) {\n        ret = stack_pop(stack,&data);\n        if(ret != 0) {\n            printf(\"\\r\\n stack pop%d falied.\", i);\n        } else {\n            printf(\"\\r\\n data = %d,\",data);\n        }\n    }\n\n    stack_destory(stack);\n\n    return 0;\n\n}\n```\n</details>\n\n\n#### 2.1.6 队列\n&emsp;队列，在前端(`front`)进行删除操作，后端(`rear`)进行插入操作; 按照先进先出(`FIFO`)的顺序存储和检索数据的高效数据结构，按照元素的存储顺序检索元素。\n&emsp;队列也可通过数组和链表实现。\n```c\ntypedef List Queue;\n\n#define queue_init list_init;\n#define queue_destroy list_destroy;\nint queue_enqueue(Queue *queue, const void *data);\nint queue_dequeue(Queue *queue, void **data);\n#define queue_peek(queue) ((queue)->head == NULL ? NULL : (queue)->head->data);\n#define queue_size list_size;\n```\n\n<details>\n<summary>array_queue</summary>\n\n```c\n/*************************************************************************\n > File Name: array_queue\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-10-12\n > Desc:    \n ************************************************************************/\n#ifndef ARRAY_QUEUE_H\n#define ARRAY_QUEUE_H\n\ntypedef struct _array_queue {\n    int size;/*队列的大小*/\n    int num; /*当前存储数据的大小*/\n    int head;/*队列的头*/\n    int tail;/*队列的尾*/\n    int *array;/*数据存储区*/\n}array_queue;\n\n#define array_queue_is_empty(array_queue) (array_queue->num == 0)\n#define array_queue_is_full(array_queue)  ((array_queue->num) == (array_queue->size))\n\n#endif\n\n\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include\"./array_queue.h\"\n\n\narray_queue * array_queue_create(int size)\n{\n    array_queue * queue = NULL;\n\n    queue = (array_queue*)malloc(sizeof(array_queue));\n    if (queue == NULL) {\n        return NULL;\n    }\n    queue->array = (int *)malloc(sizeof(int)*size);\n    if (queue->array == NULL) {\n        free(queue);\n        return NULL;\n    }\n    queue->size  = size;\n    queue->num   = 0;\n    queue->head  = 0;\n    queue->tail  = 0;\n\n    return queue;\n}\n\nvoid array_queue_destory(array_queue *queue)\n{\n    if (queue == NULL) {\n        return;\n    }\n\n    if (queue->array != NULL) {\n        free(queue->array);\n    }\n\n    free(queue);\n    return;\n}\n\n/*入队列 */\nint array_queue_enqueue(array_queue *queue,int data)\n{\n    /*队列为空，或者队列满时，返回-1*/\n    if ((queue == NULL) || (array_queue_is_full(queue))) {\n        return -1;\n    }\n\n    queue->num++;\n    queue->array[queue->tail] = data;\n    queue->tail = (queue->tail + 1) % queue->size;\n\n    return 0;\n}\n\n/*出队列*/\nint array_queue_dequeue(array_queue * queue,int *data)\n{\n    /*队列为空，数据存储为空，队列为空时返回-1*/\n    if ((queue == NULL) || (data == NULL) || (array_queue_is_empty(queue))) {\n        return -1;\n    }\n    *data = queue->array[queue->head];\n    queue->num--;\n    queue->head = (queue->head + 1) % queue->size;\n\n    return 0;\n}\n\nvoid array_queue_dump(array_queue *queue)\n{\n    int i = 0;\n    int pos = 0;\n\n    if ((queue == NULL) || (array_queue_is_empty(queue))) {\n        printf(\"\\r\\n queue is empty\");\n        return;\n    }\n\n    printf(\"\\r\\n size:%d,num:%d,head:%d,tali:%d\",\n    queue->size,queue->num,queue->head,queue->tail);\n    for (i = 0; i < queue->num; i ++) {\n        pos = (queue->head + i) %queue->size;\n        printf(\"\\r\\n array[%d] = %d\",pos,queue->array[pos]);\n    }\n    return;\n}\n\nint main()\n{\n    int i = 0;\n    int ret = 0;\n    int data = 0;\n    array_queue * queue = NULL;\n\n    queue = array_queue_create(4);\n    if (queue == NULL) {\n        printf(\"\\r\\n queue is create failed.\");\n        return 0;\n    }\n    /*队列时空时，出队返回错误*/\n    ret = array_queue_dequeue(queue, &data);\n    if (ret != 0) {\n        printf(\"\\r\\n queue %d dequeue failed.\",ret);\n    }\n\n    /*队列大小是4，入队5个，最后一个报错*/\n    for (i = 0; i < 5; i++) {\n        ret = array_queue_enqueue(queue,i);\n        if (ret != 0) {\n            printf(\"\\r\\n queue %d enqueue failed.\",i);\n        }\n    }\n\n    array_queue_dump(queue);\n    \n    ret = array_queue_dequeue(queue, &data);\n    if (ret != 0) {\n        printf(\"\\r\\n queue %d dequeue failed.\",i);\n    }\n    printf(\"\\r\\n queue %d dequue.\",data);\n    array_queue_dump(queue);\n    data = 5;\n    printf(\"\\r\\n queue %d enqueue.\",data);\n    ret = array_queue_enqueue(queue,data);\n    if (ret != 0) {\n        printf(\"\\r\\n queue %d enqueue failed.\",data);\n    }\n    array_queue_dump(queue);\n    \n    array_queue_destory(queue);\n    return 0;\n\n}\n```\n</details>\n\n<details>\n<summary>list_queue</summary>\n\n```c\n#ifndef LINK_LIST_QUEUE_H\n#define LINK_LIST_QUEUE_H\n\ntypedef struct _list_queue_node {\n    void *data;\n    struct _list_queue_node *next;\n}queue_node;\n\ntypedef struct _list_queue {\n    int num;\n    queue_node *head;\n    queue_node *tail;\n}list_queue;\n\n#define list_queue_is_empty(queue) ((queue->num) == 0)\nlist_queue *list_queue_create();\nint list_queue_enqueue(list_queue *queue,void *data);\nint list_queue_dequeue(list_queue *queue,void **data);\n\n#endif\n//\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include\"./list_queue.h\"\n\n/*创建队列头*/\nlist_queue *list_queue_create()\n{\n    list_queue * queue = NULL;\n\n    queue = (list_queue *)malloc(sizeof(list_queue));\n    if(queue == NULL) {\n        return NULL;\n    }\n    queue->num  = 0;\n    queue->head = NULL;\n    queue->tail = NULL;\n\n    return queue;\n}\n/*入队*/\nint list_queue_enqueue(list_queue *queue,void *data)\n{\n    queue_node *ptmp = NULL;\n    if(queue == NULL) {\n        return -1;\n    }\n    ptmp = (queue_node *)malloc(sizeof(queue_node));\n    if (ptmp == NULL) {\n        return -1;\n    }\n\n    ptmp->data = data;\n    ptmp->next = NULL;\n    if (queue->head == NULL) {\n        queue->head = ptmp;\n    } else {\n        queue->tail->next = ptmp;\n    }\n    queue->tail = ptmp;\n    queue->num++;\n\n    return 0;\n}\n\n/*出队*/\nint list_queue_dequeue(list_queue *queue,void **data)\n{\n    queue_node * ptmp = NULL;\n    if ((queue == NULL) || (data == NULL) || list_queue_is_empty(queue)) {\n        return -1;\n    }\n    *data = queue->head->data;\n    ptmp = queue->head;\n    queue->head = queue->head->next;\n    queue->num--;\n    if (queue->head == NULL) {\n        queue->tail = NULL;\n    }\n\n    free(ptmp);\n    return 0;\n}\n```\n</details>\n\n\n<details>\n<summary>ring_queue</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nstruct ring_queue {\n    int cap;\n    int head, tail;\n    int *_q;\n};\n\nint alloc_queue(struct ring_queue* queue, int cap)\n{\n    if (!queue || cap < 0)\n    return -1;\n    if (queue->_q)\n    return -1;\n\n    queue->_q = (int *)malloc(cap * sizeof(int));\n    if (!queue->_q)\n    return -1;\n\n    queue->head = queue->tail = 0;\n    queue->cap = cap;\n    return 0;\n}\n\nvoid free_queue(struct ring_queue *queue)\n{\n    queue->cap = 0;\n    queue->head = queue->tail = 0;\n    free(queue->_q);\n}\n\nint _valid_index(int curr, int step, int cap)\n{\n    return (curr + step) % cap;\n}\n\nint _next(int curr, int cap)\n{\n    return _valid_index(curr, 1, cap);\n}\n\nbool is_empty(struct ring_queue *queue)\n{\n    return (queue->head == queue->tail);\n}\n\nbool is_full(struct ring_queue *queue)\n{\n    int next_tail = _next(queue->tail, queue->cap);\n    return (next_tail == queue->head);\n}\n\nint enqueue(struct ring_queue* queue, int elem)\n{\n    if (is_full(queue))\n    return -1;\n\n    queue->_q[queue->tail] = elem;\n    queue->tail = _next(queue->tail, queue->cap);\n    return 0;\n}\n\nint dequeue(struct ring_queue* queue, int *elem)\n{\n    if (is_empty(queue))\n    return -1;\n\n    if (elem)\n    *elem = queue->_q[queue->head];\n    queue->head = _next(queue->head, queue->cap);\n    return 0;\n}\n\nint size(struct ring_queue* queue)\n{\n    int size = queue->tail - queue->head;\n\n    if (size < 0)\n    size += queue->cap;\n    return size;\n}\n\nvoid dump(struct ring_queue* queue)\n{\n    int i, idx;\n\n    printf(\"Queue has %d elements with %d capacity\\n\",\n    size(queue), queue->cap);\n    for (i = 0; i < size(queue); i++) {\n        idx = _valid_index(queue->head, i, queue->cap);\n        printf(\"[%02d]: %08d\\n\", idx, queue->_q[idx]);\n    }\n}\n\nint main()\n{\n    struct ring_queue queue = {0, 0, 0, NULL};\n    int i;\n\n    if (alloc_queue(&queue, 8)) {\n        printf(\"Failed to allocate a queue\\n\");\n        return -1;\n    }\n\n    printf(\"A new queue is %s\\n\", is_empty(&queue)?\"empty\":\"not empty\");\n\n    enqueue(&queue, 1);\n    printf(\"After enqueue 1 element, queue is %s\\n\", is_empty(&queue)?\"empty\":\"not empty\");\n    dequeue(&queue, NULL);\n    printf(\"After dequeue 1 element, queue is %s\\n\", is_empty(&queue)?\"empty\":\"not empty\");\n\n    for (i = 0; i < 7; i++)\n    enqueue(&queue, i);\n    printf(\"After enqueue 7 element, queue is %s\\n\", is_full(&queue)?\"full\":\"not full\");\n\n    for (i = 0; i < 4; i++) {\n        dequeue(&queue, NULL);\n        enqueue(&queue, i);\n    }\n    printf(\"After enqueue/dequeue 4 element, queue is %s\\n\",\n    is_full(&queue)?\"full\":\"not full\");\n    printf(\"Head is %d, Tail is %d\\n\", queue.head, queue.tail);\n\n    dump(&queue);\n    free_queue(&queue);\n    return 0;\n}\n```\n</details>\n\n&ensp;队列应用：进程通信\n&emsp;消息队列提供了从一个进程向另一个进程发送一个数据块的方法.每个数据库都认为含有一个类型,接收进程可以独立地接收含有不同类型的数据结构.\n\n&emsp;linux内核 <sys/msg.h> 头文件中定义了消息队列结构\n```c\nstruct msqid_ds {\n    struct ipc_perm msg_perm;\n    struct msg* msg_first; // 指向队列中第一个消息\n    struct msg* msg_last; // 队列中最后一个消息\n    ...\n}\n```\n&emsp;Linux消息队列函数接口\n```c\n// 创建和访问一个消息队列\nint msgget(key_t key, int msgflg);\n// 把消息添加到消息队列中\nint msgsnd(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);\n// 从一个消息对立获取消息\nint msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg);\n// 控制消息队列\nint msgctl(int msgid, int command, struct msgid_ds *buf);\n```\n\n#### 2.1.7 leetcode题目\n- 重复N次的元素<数组>\n\n- 两数相加<链表>\n\n- 基本计算器<栈>\n\n- 设计循环队列<队列>\n\n### 2.2 哈希表\n&ensp;哈希表是一种最有效的检索方法，散列，从本质上看，一个哈希表包含一个数组，通过特殊的索引（键）来访问数组中的元素。哈希表主要思想是通过一个哈希函数，在所有可能的键和值直接建立映射表。\n&ensp;每个记录的关键字k通过一种函数H(k)计算出函数值.此函数为哈希函数或散列函数.\n\n#### 2.2.1 哈希函数设计\n- 直接地址法\n关键字是整数类型的数据,直接地址的哈希函数H直接利用关键字求得哈希地址.\nH(k) = aK*i + b\n\n- 数字分析法\n取关键字数中分布均匀的若干作为哈希地址\n\n- 平方取中法\n取关键字平方中间几位作为散列地址\n\n- 折叠法\n把关键字分割成位数相同的几段，段的位数取决于哈希地址的位数，然后将它们叠加和作为哈希地址\n\n- 除留取余法\n关键字K除以一个合适的不大于哈希表长度的正整数P,所得余数作为哈希地址.\nH(K) = K MOD P\n\n<details>\n<summary>uthash用法</summary>\n\n```c\n/*************************************************************************\n > File Name: listhash.h\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-11-06\n > Desc: 根据linux内核模块hashtab编写用户层hashtab接口\n         linux-4.19.1\\security\\selinux\\ss\\hashtab.c\n     linux-4.19.1\\security\\selinux\\ss\\hashtab.h\n ************************************************************************/\n#ifndef __HASHTAB_H__\n#define __HASHTAB_H__\n\n\ntypedef struct _hashtab_node {\n    void * key;\n    void * data;\n    struct _hashtab_node *next;\n}hashtab_node;\n\ntypedef struct _hashtab {\n    hashtab_node **htables; /*哈希桶*/\n    int size;              /*哈希桶的最大数量*/\n    int nel;               /*哈希桶中元素的个数*/\n    int (*hash_value)(struct _hashtab *h,const void *key); /*哈希函数*/\n    int (*keycmp)(struct _hashtab *h,const void *key1,const void *key2);/*哈希key比较函数，当哈希数值一致时使用*/\n    void (*hash_node_free)(hashtab_node *node);\n}hashtab;\n\n\n#define HASHTAB_MAX_NODES  (0xffffffff)\n\ntypedef int (*hash_key_func)(struct _hashtab *h,const void *key); /*哈希函数*/\ntypedef int (*keycmp_func)(struct _hashtab *h,const void *key1,const void *key2);/*哈希key比较函数，当哈希数值一致时使用*/\ntypedef void (*hash_node_free_func)(hashtab_node *node);\n/*根据当前结构体元素的地址，获取到结构体首地址*/\n#define offsetof(TYPE,MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#define container(ptr,type,member) ({\\\n  const typeof( ((type *)0)->member) *__mptr = (ptr);\\\n  (type *) ( (char *)__mptr - offsetof(type,member));})\n\n\nhashtab * hashtab_create(int size,hash_key_func hash_value,\n        keycmp_func keycmp,hash_node_free_func hash_node_free);\nvoid hashtab_destory(hashtab *h);\nint hashtab_insert(hashtab * h,void *key,void *data);\nhashtab_node *hashtab_delete(hashtab *h, void *key);\nvoid *hashtab_search(hashtab*h,void *key);\n\n#endif\n\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#include\"listhash.h\"\n\n#ifdef MEMORY_TEST\n#include<mcheck.h>\n#endif\n\nhashtab * hashtab_create(int size,hash_key_func hash_value,\n    keycmp_func keycmp,hash_node_free_func hash_node_free)\n{\n    hashtab * h = NULL;\n    int i = 0;\n\n    if ((size < 0) || (hash_value == NULL) || (keycmp == NULL)) {\n    return NULL;\n    }\n\n    h = (hashtab *)malloc(sizeof(hashtab));\n    if (h == NULL) {\n        return NULL;\n    }\n\n    h->htables = (hashtab_node **)malloc(size * sizeof(hashtab_node*));\n    if (h->htables == NULL) {\n        return NULL;\n    }\n\n    h->size = size;\n    h->nel = 0;\n    h->hash_value = hash_value;\n    h->keycmp = keycmp;\n    h->hash_node_free = hash_node_free;\n    \n    for (i = 0; i < size; i++) {\n        h->htables[i] = NULL;\n    }\n\n    return h;\n}\n\nvoid hashtab_destory(hashtab *h)\n{\n    int i = 0;\n    hashtab_node * cur = NULL;\n    hashtab_node * tmp = NULL;\n\n    if (h == NULL) {\n        return;\n    }\n\n    for (i = 0; i <h->size; i++) {\n        cur = h->htables[i];\n        while (cur != NULL) {\n            tmp = cur;\n            cur = cur->next;\n            h->hash_node_free(tmp);\n        }\n        h->htables[i] = NULL;\n    }\n    \n    free(h->htables);\n    free(h);\n    return;\n}\n\nint hashtab_insert(hashtab * h,void *key,void *data)\n{\n    unsigned int hvalue = 0;\n    int i = 0;\n    hashtab_node *cur = NULL; \n    hashtab_node *prev = NULL; \n    hashtab_node *newnode = NULL;\n\n    if ((h == NULL) || (key == NULL) || (data == NULL)) {\n        return 1;\n    }\n\n    /*获取hash 数值*/\n    hvalue = h->hash_value(h,key);\n    cur = h->htables[hvalue];\n\n    /*hash桶中元素是从小到大排列的，找到要插入的位置*/\n    while((cur != NULL) && (h->keycmp(h,key,cur->key) > 0)) {\n        prev = cur;\n        cur = cur->next;\n    }\n\n    /*如果key和当前key比对一致，直接返回，数据已经存在*/\n    if ((cur != NULL) && (h->keycmp(h,key,cur->key) == 0)) {\n        return 2;\n    }\n\n    newnode = (hashtab_node *)malloc(sizeof(hashtab_node));\n    if (newnode == NULL) {\n        return 3;\n    }\n\n    newnode->key = key;\n    newnode->data = data;\n    if (prev == NULL) {\n        newnode->next = h->htables[hvalue];\n        h->htables[hvalue] = newnode;\n    } else {\n        newnode->next = prev->next;\n        prev->next = newnode;\n    }\n\n    h->nel++;\n    return 0;\n}\n\nhashtab_node *hashtab_delete(hashtab *h, void *key)\n{\n    int hvalue = 0;\n    int i = 0;\n    hashtab_node *cur = NULL; \n    hashtab_node *prev = NULL; \n    \n    if ((h == NULL) || (key == NULL)) {\n        return NULL;\n    }\n\n    /*获取hash 数值*/\n    hvalue = h->hash_value(h,key);\n    cur = h->htables[hvalue];\n    /*hash桶中元素是从小到大排列的，找到要插入的位置*/\n    while((cur != NULL) && (h->keycmp(h,key,cur->key) >= 0)) {\n        if (h->keycmp(h,key,cur->key) == 0) {\n            if (prev == NULL) {\n                        h->htables[hvalue] = cur->next;\n            } else {\n                        prev->next = cur->next;\n            }\n            return cur;\n        }\n        prev = cur;\n        cur = cur->next;\n    }\n\n    return NULL;\n}\n\nvoid *hashtab_search(hashtab*h,void *key)\n{\n    int hvalue = 0;\n    int i = 0;\n    hashtab_node *cur = NULL; \n    \n    if ((h == NULL) || (key == NULL)) {\n        return NULL;\n    }\n\n    /*获取hash 数值*/\n    hvalue = h->hash_value(h,key);\n    cur = h->htables[hvalue];\n    /*hash桶中元素是从小到大排列的，找到要插入的位置*/\n    while((cur != NULL) && (h->keycmp(h,key,cur->key) >= 0)) {\n        if (h->keycmp(h,key,cur->key) == 0) {\n            return cur->data;\n        }\n        cur = cur->next;\n    }\n\n    return NULL;\n}\n\nvoid hashtab_dump(hashtab *h)\n{\n    int i = 0;\n    hashtab_node * cur = NULL;\n\n    if (h == NULL) {\n        return ;\n    }\n\n    printf(\"\\r\\n----开始--size[%d],nel[%d]------------\",h->size,h->nel);\n    for( i = 0; i < h->size; i ++) {\n        printf(\"\\r\\n htables[%d]:\",i);\n        cur = h->htables[i];\n        while((cur != NULL)) {\n            printf(\"key[%s],data[%s] \",cur->key,cur->data);    \n            cur = cur->next;\n        }\n    }\n\n    printf(\"\\r\\n----结束--size[%d],nel[%d]------------\",h->size,h->nel);\n}\n\nstruct test_node\n{\n    char key[80];\n    char data[80];\n};\n\nunsigned int siample_hash(const char *str)\n{\n    register unsigned int hash = 0;\n    register unsigned int seed = 131;\n\n    while(*str) {\n        hash = hash*seed + *str++;\n    }\n\n    return hash & (0x7FFFFFFF);\n}\n\nint hashtab_hvalue(hashtab *h,const void *key)\n{\n    return (siample_hash(key) % h->size);\n}\n\nint hashtab_keycmp(hashtab *h,const void *key1,const void *key2)\n{\n    return strcmp(key1,key2);\n}\n\nvoid hashtab_node_free(hashtab_node*node)\n{\n    struct test_node * ptmp = NULL;\n    ptmp = container(node->key,struct test_node,key);\n\n    free(ptmp);\n    free(node);\n}\n\nint main ()\n{\n    \n    int i = 0;\n    int res = 0;\n    char *pres = NULL;\n    hashtab_node * node = NULL;\n    struct test_node *p = NULL;\n    hashtab *h = NULL;\n    #ifdef MEMORY_TEST\n    setenv(\"MALLOC_TRACE\",\"1.txt\",1);\n    mtrace();\n    #endif\n\n    h = hashtab_create(5,hashtab_hvalue,hashtab_keycmp,hashtab_node_free);\n    assert(h!= NULL);\n    while(1) {\n        p = (struct test_node*)malloc(sizeof(struct test_node));\n        assert(p != NULL);\n        printf(\"\\r\\n 请输入key 和value，当可以等于\\\"quit\\\"时退出\");\n            scanf(\"%s\",p->key);\n        scanf(\"%s\",p->data);\n\n        if(strcmp(p->key,\"quit\") == 0) {\n            free(p);\n            break;\n        }\n\n        res = hashtab_insert(h,p->key,p->data);\n        if (res != 0) {\n            free(p);\n            printf(\"\\r\\n key[%s],data[%s] insert failed %d\",p->key,p->data,res);\n        } else {\n            printf(\"\\r\\n key[%s],data[%s] insert success %d\",p->key,p->data,res);\n        }\n    }\n\n    hashtab_dump(h);\n\n    while(1) {\n        p = (struct test_node*)malloc(sizeof(struct test_node));\n        assert(p != NULL);\n        printf(\"\\r\\n 请输入key 查询value的数值，当可以等于\\\"quit\\\"时退出\");\n            scanf(\"%s\",p->key);\n\n        if(strcmp(p->key,\"quit\") == 0) {\n            free(p);\n            break;\n        }\n        pres = hashtab_search(h,p->key);\n        if (pres == NULL) {\n            printf(\"\\r\\n key[%s] search data failed\",p->key);\n        } else {\n            printf(\"\\r\\n key[%s],search data[%s] success\",p->key,pres);\n        }\n        free(p);\n    }\n    hashtab_dump(h);\n    while(1) {\n        p = (struct test_node*)malloc(sizeof(struct test_node));\n        assert(p != NULL);\n        printf(\"\\r\\n 请输入key 删除节点的数值，当可以等于\\\"quit\\\"时退出\");\n            scanf(\"%s\",p->key);\n\n        if(strcmp(p->key,\"quit\") == 0) {\n            free(p);\n            break;\n        }\n        node = hashtab_delete(h,p->key);\n        if (node == NULL) {\n            printf(\"\\r\\n key[%s] delete node failed \",p->key);\n        } else {\n            printf(\"\\r\\n key[%s],delete data[%s] success\",node->key,node->data);\n            h->hash_node_free(node);\n        }\n        free(p);\n        hashtab_dump(h);\n    }\n\n    hashtab_destory(h);\n    #ifdef MEMORY_TEST\n        muntrace();\n    #endif\n    return 0;\n}\n```\n</details>\n\n\n<details>\n<summary>hash_table</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n\n/* One implementation of hash table with linear probing. */\n\n#define HASH_SHIFT 4\n#define HASH_SIZE (1 << HASH_SHIFT)\n#define HASH_MASK (HASH_SIZE - 1)\n\nstruct hash_table {\n    unsigned int  used;\n    unsigned long entry[HASH_SIZE];\n};\n\nvoid hash_table_reset(struct hash_table *table)\n{\n    int i;\n\n    table->used = 0;\n    for (i = 0; i < HASH_SIZE; i++)\n    table->entry[i] = ~0;\n}\n\nunsigned int hash_function(unsigned long value)\n{\n    return value & HASH_MASK;\n}\n\nvoid dump_hash_table(struct hash_table *table)\n{\n    int i;\n\n    for (i = 0; i < HASH_SIZE; i++) {\n        if (table->entry[i] == ~0)\n            printf(\"%2u:       nil \\n\", i);\n        else\n            printf(\"%2u:%10lu -> %2u\\n\",\n        i, table->entry[i],\n        hash_function(table->entry[i]));\n    }\n}\n\nvoid hash_function_test()\n{\n    int i;\n\n    srandom(time(NULL));\n\n    for (i = 0; i < 10; i++) {\n        unsigned long val = random();\n        printf(\"%10lu -> %2u\\n\", val, hash_function(val));;\n    }\n}\n\nunsigned int next_probe(unsigned int prev_key)\n{\n    return (prev_key + 1) & HASH_MASK;\n}\n\nvoid next_probe_test()\n{\n    int i;\n    unsigned int key1, key2;\n\n    key1 = 0;\n    for (i = 0; i < HASH_SIZE; i++) {\n        key2 = next_probe(key1);\n        printf(\"%2u -> %2u\\n\", key1, key2);\n        key1 = key2;\n    }\n}\n\nvoid hash_table_add(struct hash_table *table, unsigned long value)\n{\n    unsigned int key = hash_function(value);\n\n    if (table->used >= HASH_SIZE)\n        return;\n\n    while (table->entry[key] != ~0)\n        key = next_probe(key);\n\n    table->entry[key] = value;\n    table->used++;\n}\n\nunsigned int hash_table_slot(struct hash_table *table, unsigned long value)\n{\n    int i;\n    unsigned int key = hash_function(value);\n\n    for (i = 0; i < HASH_SIZE; i++) {\n        if (table->entry[key] == value || table->entry[key] == ~0)\n            break;\n        key = next_probe(key);\n    }\n\n    return key;\n}\n\nbool hash_table_find(struct hash_table *table, unsigned long value)\n{\n    return table->entry[hash_table_slot(table, value)] == value;\n}\n\nvoid hash_table_del(struct hash_table *table, unsigned long value)\n{\n    unsigned int i, j, k;\n\n    if (!hash_table_find(table, value))\n    return;\n\n    i = j = hash_table_slot(table, value);\n\n    while (true) {\n        table->entry[i] = ~0;\n\n        do {\n            j = next_probe(j);\n            if (table->entry[j] == ~0)\n                return;\n            k = hash_function(table->entry[j]);\n        } while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\n        table->entry[i] = table->entry[j];\n        i = j;\n    }\n    table->used++;\n}\n\nvoid hash_table_add_test()\n{\n    struct hash_table table;\n\n    hash_table_reset(&table);\n    hash_table_add(&table, 87645);\n\n    printf(\"Table has%s 87645\\n\",\n    hash_table_find(&table, 87645) ? \"\":\"n't\");\n    printf(\"Table has%s 87647\\n\",\n    hash_table_find(&table, 87647) ? \"\":\"n't\");\n}\n\nvoid hash_table_del_test1()\n{\n    struct hash_table table;\n\n    hash_table_reset(&table);\n    hash_table_add(&table, 0x1ff0);\n    hash_table_add(&table, 0x2ff0);\n    hash_table_add(&table, 0x3ff0);\n    dump_hash_table(&table);\n\n    printf(\"=== Remove 0x1ff0\\n\");\n    hash_table_del(&table, 0x1ff0);\n    dump_hash_table(&table);\n}\n\nvoid hash_table_del_test2()\n{\n    struct hash_table table;\n\n    hash_table_reset(&table);\n    hash_table_add(&table, 0x1ff0);\n    hash_table_add(&table, 0x1ff1);\n    hash_table_add(&table, 0x1ff2);\n    hash_table_add(&table, 0x2ff0);\n    dump_hash_table(&table);\n\n    printf(\"=== Remove 0x1ff0\\n\");\n    hash_table_del(&table, 0x1ff0);\n    dump_hash_table(&table);\n}\n\nint main()\n{\n    //hash_function_test();\n    //next_probe_test();\n    //hash_table_add_test();\n    hash_table_del_test2();\n\n    return 0;\n}\n```\n</details>\n\n\n#### 2.2.2 哈希冲突\n&ensp;理想情况下,哈希函数在关键字和地址之间建立一对一关系.但H(k1) = H(k2),即为冲突.\n\n&emsp;解决哈希冲突常用方法:\n- 链地址法\n将哈希值相同的元素构成一个同义词的单链表,并将单链表头指针存放在哈希表的地i个单元中,查找,插入和删除主要在同义词链表中.\n- 线性探测\n- 二次探测\n\n#### 2.2.3 uthash\n\n&ensp;uthash的插入、查找、删除的操作时间都是常量\n\n```c\n#include \"uthash.h\"\n\nstruct my_struct {\n    int id;            /* we'll use this field as the key */\n    char name[10];\n    UT_hash_handle hh; /* makes this structure hashable */\n};\n\nstruct my_struct *users = NULL;\n\nvoid add_user(struct my_struct *s) {\n    HASH_ADD_INT(users, id, s);\n}\n```\n\n<details>\n<summary>uthash用法</summary>\n\n```c\n#include <stdio.h>   /* gets */\n#include <stdlib.h>  /* atoi, malloc */\n#include <string.h>  /* strcpy */\n#include \"uthash.h\"\n\nstruct my_struct {\n    int id;                    /* key */\n    char name[10];\n    UT_hash_handle hh;         /* makes this structure hashable */\n};\n\nstruct my_struct *users = NULL;\n\nvoid add_user(int user_id, char *name) {\n    struct my_struct *s;\n\n    HASH_FIND_INT(users, &user_id, s);  /* id already in the hash? */\n    if (s==NULL) {\n        s = (struct my_struct *)malloc(sizeof *s);\n        s->id = user_id;\n        HASH_ADD_INT( users, id, s );  /* id: name of key field */\n    }\n    strcpy(s->name, name);\n}\n\nstruct my_struct *find_user(int user_id) {\n    struct my_struct *s;\n\n    HASH_FIND_INT(users, &user_id, s);  /* s: output pointer */\n    return s;\n}\n\nvoid delete_user(struct my_struct *user) {\n    HASH_DEL(users, user);  /* user: pointer to deletee */\n    free(user);\n}\n\nvoid delete_all() {\n    struct my_struct *current_user, *tmp;\n\n    HASH_ITER(hh, users, current_user, tmp) {\n        HASH_DEL(users, current_user);  /* delete it (users advances to next) */\n        free(current_user);             /* free it */\n    }\n}\n\nvoid print_users() {\n    struct my_struct *s;\n\n    for(s=users; s != NULL; s=(struct my_struct*)(s->hh.next)) {\n        printf(\"user id %d: name %s\\n\", s->id, s->name);\n    }\n}\n\nint name_sort(struct my_struct *a, struct my_struct *b) {\n    return strcmp(a->name,b->name);\n}\n\nint id_sort(struct my_struct *a, struct my_struct *b) {\n    return (a->id - b->id);\n}\n\nvoid sort_by_name() {\n    HASH_SORT(users, name_sort);\n}\n\nvoid sort_by_id() {\n    HASH_SORT(users, id_sort);\n}\n\nint main(int argc, char *argv[]) {\n    char in[10];\n    int id=1, running=1;\n    struct my_struct *s;\n    unsigned num_users;\n\n    while (running) {\n        printf(\" 1. add user\\n\");\n        printf(\" 2. add/rename user by id\\n\");\n        printf(\" 3. find user\\n\");\n        printf(\" 4. delete user\\n\");\n        printf(\" 5. delete all users\\n\");\n        printf(\" 6. sort items by name\\n\");\n        printf(\" 7. sort items by id\\n\");\n        printf(\" 8. print users\\n\");\n        printf(\" 9. count users\\n\");\n        printf(\"10. quit\\n\");\n        gets(in);\n        switch(atoi(in)) {\n            case 1:\n                printf(\"name?\\n\");\n                add_user(id++, gets(in));\n                break;\n            case 2:\n                printf(\"id?\\n\");\n                gets(in); id = atoi(in);\n                printf(\"name?\\n\");\n                add_user(id, gets(in));\n                break;\n            case 3:\n                printf(\"id?\\n\");\n                s = find_user(atoi(gets(in)));\n                printf(\"user: %s\\n\", s ? s->name : \"unknown\");\n                break;\n            case 4:\n                printf(\"id?\\n\");\n                s = find_user(atoi(gets(in)));\n                if (s) delete_user(s);\n                else printf(\"id unknown\\n\");\n                break;\n            case 5:\n                delete_all();\n                break;\n            case 6:\n                sort_by_name();\n                break;\n            case 7:\n                sort_by_id();\n                break;\n            case 8:\n                print_users();\n                break;\n            case 9:\n                num_users=HASH_COUNT(users);\n                printf(\"there are %u users\\n\", num_users);\n                break;\n            case 10:\n                running=0;\n                break;\n        }\n    }\n\n    delete_all();  /* free any structures */\n    return 0;\n}\n```\n\n</details>\n\n- 参考链接\n官网:https://troydhanson.github.io/uthash/\nhttps://blog.csdn.net/fan_h_l/article/details/107241520\nhttps://blog.csdn.net/whatday/article/details/95926766\nhttps://www.cnblogs.com/pam-sh/p/12827658.html\n\n#### 2.2.4 leetcode题目\n- 设计哈希集合 \n\n- 设计哈希映射\n\n- 根据字符出现频率排序\n\n### 2.3 树与二叉树\n&emsp;树(tree)是一种用来模拟树状结构的抽象数据结构(ADT);\n\n&emsp;树的特点:\n- 没有父节点的节点称为根节点\n- 每个非根节点有且只有一个父节点\n- 除了根结点外,每个子节点可分为多个不相交的子树\n- 树中没有环路\n\n#### 2.3.1 概述\n- 节点的度: 一个节点含有子树的个数\n- 树的度: 树中最大的节点度\n- 叶节点: 度为零的节点\n- 父节点\n- 子节点\n- 兄弟节点\n- 节点的层次\n- 深度: 任意节点n,n的深度为从n到一片树叶的最长路径长,根的深度为0\n- 高度: 对任意节点n,n的高度为从n到一片树叶的最长路径长,所有树叶的高度为0.\n- 森林\n\n&emsp;树由称为结点的元素按照层次结构的方式组织而成。最顶端称为根。与根直接相连的结点称为根的子结点。子节点本身也可以有子结点。除根结点外，每个结点都有唯一的父结点。\n\n#### 2.3.2 树的种类\n- 无序树\n- 有序树\n   - 二叉树: 每个节点最多含有两个子树的树.\n      - 完全二叉树: 对于一颗深度为d的二叉树,除第d层外,其他各层节点数目均达最大值,且第d层所有节点从左向右连续紧密排列.\n         - 满二叉树:所有叶节点都最底层的完全二叉树.\n      - 平衡二叉树(AVL):当且仅当任何节点的两颗子树的高度差不大于1的二叉树.\n      - 排序二叉树:二叉查找树\n\n    - 霍夫曼树:带权路径最短的二叉树(又称最优二叉树).\n    - B树:一种堆读写操作进行优化的自平衡二叉查找树,能够保持数据有序,拥有多余两个子树.\n\n<br>\n\n|||\n|---|---|\n|二叉树|二叉查找树(BST) 笛卡尔树 MVP树 Top tree T树|\n|自平衡二叉查找树|AVL树 红黑树 加权平衡树 AA树 |\n|B树|B树 B+树|\n|堆| 二项堆 斐波那契堆|\n|Trie|后缀树 基数树 三叉查找树|\n\n&emsp;树有多种结构形式，包括二叉树、。\n\n#### 2.3.3 二叉树\n\n&ensp;二叉树两个条件:\n- 本身是有序树\n- 树中包含的各个节点的度不能超过2,即只能是0,1或者2\n\n&emsp;二叉树中结点包含三部分：一个数据成员两个左右指针。\n\n```c\ntypedef struct BiTreeNode_ {\n    void *data;\n    struct BiTreeNode_ *left;\n    struct BiTreeNode_ *right;\n}BiTreeNode;\n\ntypedef struct BiTree_ {\n    int size;\n    int (*compare)(const void *key1, const void *key2);\n    void (*destroy)(void *data);\n    BiTreeNode *root;\n}BiTree;\n\n/*树根*/\ntypedef struct tree{\n    Node * root;\n}Tree;\n```\n\n<details>\n<summary>二叉树</summary>\n\n```c\n#include<assert.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#include\"list_queue.h\"\n\ntypedef struct _treenode {\n    int data;\n    struct _treenode *lchild;\n    struct _treenode *rchild;\n}Tnode,Tree;\n\nvoid binarytree_create(Tree **Root)\n{\n    int a = 0;\n    printf(\"\\r\\n输入节点数值((当输入为100时，当前节点创建完成))):\");\n    scanf(\"%d\",&a);\n\n    if (a == 100) {\n        *Root = NULL;\n    } else {\n        *Root = (Tnode *)malloc(sizeof(Tnode));\n        if (*Root == NULL) {\n            return;\n        }\n\n        (*Root)->data = a;\n        printf(\"\\r\\n create %d 的左孩子:\",a);\n        binarytree_create(&((*Root)->lchild));\n        printf(\"\\r\\n create %d 的右孩子:\",a);\n        binarytree_create(&((*Root)->rchild));\n    }\n\n    return ;\n}\n\nvoid binarytree_destory(Tree *root)\n{\n    if (root == NULL) {\n        return;\n    }\n\n    binarytree_destory(root->lchild);\n    binarytree_destory(root->rchild);\n    free(root);\n}\n\n/*先序遍历:根结点--》左子树---》右子树*/\nvoid binarytree_preorder(Tree *root)\n{\n    if (root == NULL) {\n        return;\n    }\n    printf(\" %d \",root->data);\n    binarytree_preorder(root->lchild);\n    binarytree_preorder(root->rchild);\n    return;\n}\n/*中序遍历:左子树--》跟节点---》右子树*/\nvoid binarytree_inorder(Tree *root)\n{\n    if (root == NULL) {\n        return;\n    }\n    binarytree_inorder(root->lchild);\n    printf(\" %d \",root->data);\n    binarytree_inorder(root->rchild);\n    return;\n}\n/*后序遍历:左子树---》右子树-》根节点*/\nvoid binarytree_postorder(Tree *root)\n{\n    if (root == NULL) {\n        return;\n    }\n    binarytree_postorder(root->lchild);\n    binarytree_postorder(root->rchild);\n    printf(\" %d \",root->data);\n    return;\n}\n\nvoid binarytree_levelorder(Tree * root)\n{\n    list_queue *queue = NULL;\n    Tnode * node = NULL;\n    if(root == NULL) {\n        return;\n    }\n\n    queue = list_queue_create();\n\n    /*根节点先入队*/\n    list_queue_enqueue(queue,(void *)root);\n\n    while(!list_queue_is_empty(queue)) {\n        list_queue_dequeue(queue,(void *)&node);\n        printf(\" %d \",node->data);\n\n        if(node->lchild != NULL) {\n            list_queue_enqueue(queue,(void *)node->lchild);\n        }\n\n        if(node->rchild != NULL) {\n            list_queue_enqueue(queue,(void *)node->rchild);\n        }\n    }\n\n    free(queue);\n}\n/*打印叶子节点*/\nvoid binarytree_printfleaf(Tree *root)\n{\n    if (root == NULL) {\n        return;\n    }\n\n    if ((root->lchild == NULL) && (root->rchild == NULL)) {\n        printf(\" %d \",root->data);\n    } else {\n        binarytree_printfleaf(root->lchild);\n        binarytree_printfleaf(root->rchild);\n    }\n}\n/*打印叶子的个数*/\nint binarytree_getleafnum(Tree*root)\n{\n    if (root == NULL) {\n        return 0;\n    }\n\n    if ((root->lchild == NULL) && (root->rchild == NULL)) {\n        return 1;\n    }\n    \n    return binarytree_getleafnum(root->lchild) + binarytree_getleafnum(root->rchild);\n\n}\n/*打印数的高度*/\nint binarytree_gethigh(Tree *root)\n{\n    int lhigh = 0;\n    int rhigh = 0;\n    \n    if (root == NULL) {\n        return 0;\n    }\n\n    lhigh = binarytree_gethigh(root->lchild);\n    rhigh = binarytree_gethigh(root->rchild);\n\n    return ((lhigh > rhigh)?(lhigh + 1):(rhigh + 1));\n}\n\nint main()\n{\n    Tree *root = NULL;\n\n    setenv(\"MALLOC_TRACE\",\"1.txt\",1);\n    mtrace();\n    \n    printf(\"\\r\\n创建二叉树:\");\n    binarytree_create(&root);\n    printf(\"\\r\\n先序遍历二叉树:\");\n    binarytree_preorder(root);\n    printf(\"\\r\\n中序遍历二叉树:\");\n    binarytree_inorder(root);\n    printf(\"\\r\\n后序遍历二叉树:\");\n    binarytree_postorder(root);\n    printf(\"\\r\\n层次遍历二叉树:\");\n    binarytree_levelorder(root);\n\n    printf(\"\\r\\n打印二叉树叶子节点:\");\n    binarytree_printfleaf(root);\n    printf(\"\\r\\n打印二叉树叶子节点个数:%d\",binarytree_getleafnum(root));\n    printf(\"\\r\\n打印二叉树高度:%d\",binarytree_gethigh(root));\n\n    binarytree_destory(root);\n\n    muntrace();\n    return 0;\n}\n```\n</details>\n\n<details>\n<summary>binarytree</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n\n/* Implement binary tree in array */\n\n#define MAX_TREE_NODES (1 << 8)\n\nstruct node {\n    int data;\n};\n\nstruct binary_tree {\n    union {\n    unsigned long nodes;\n    struct node *n[MAX_TREE_NODES];\n    };\n};\n\nvoid init_binary_tree(struct binary_tree *tree)\n{\n    int i;\n\n    for(i = 0; i < MAX_TREE_NODES; i++) {\n        tree->n[i] = NULL;\n    }\n}\n\nstruct node* create_node(int data)\n{\n    struct node* n;\n\n    n = malloc(sizeof(struct node));\n\n    if (n)\n        n->data = data;\n\n    return n;\n}\n\nvoid fake_a_tree(struct binary_tree* tree)\n{\n    /* data is in ordered */\n    int i, data[10] = {7, 4, 9, 2, 6, 8, 10, 1, 3, 5};\n\n    init_binary_tree(tree);\n\n    /* root start at 1 */\n    for (i = 0; i < 10; i++)\n        tree->n[i+1] = create_node(data[i]);\n\n    tree->nodes = 10;\n}\n\nvoid _in_order(struct binary_tree* tree, int index)\n{\n    if (!tree->n[index])\n    return;\n\n    /* left child at (index << 1) */\n    _in_order(tree, index << 1);\n\n    printf(\"[%2d]: %4d\\n\", index, tree->n[index]->data);\n\n    /* right child at (index << 1) + 1 */\n    _in_order(tree, (index << 1) + 1);\n}\n\nvoid in_order(struct binary_tree* tree)\n{\n    _in_order(tree, 1);\n}\n\nint main()\n{\n    struct binary_tree tree;\n\n    fake_a_tree(&tree);\n    in_order(&tree);\n    return 0;\n}\n```\n</details>\n\n&ensp;二叉树性质:\n- 二叉树中,第i层最多有 2^(i-1)个节点\n- 如果二叉树的深度为K,则二叉树最多有`2^K - 1`个节点\n- 二叉树中，终端结点树(叶子节点树)为n0，度为2的节点树为n1，则 n0=n1+1\n\n**满二叉树**\n&emsp;如果二叉树中除了叶子节点，每个节点的度都为2，则此二叉树为满二叉树。\n\n\n**完全二叉树**\n&emsp;如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。\n\n\n&emsp;树的周游算法包含先序遍历、中序遍历、后序遍历和层序遍历。\n- 先序遍历：先访问根结点，然后左子树，最后右子结点。深度优先思想。\n- 中序遍历：先访问左子结点，然后根结点，最后右子结点。\n- 后序遍历：先访问左子结点，然后右子结点，最后根结点。\n- 层序遍历：先访问树的根结点，然后依次向下层处理，按照从左向右的顺序访问每层结点。广度优先的策略。\n\n\n#### 2.3.4 二叉查找树(BST)\n\n&ensp;二叉查找树也称二叉搜索树,有序二叉树或排序二叉树,具有性质:\n- 若任意节点左子树不为空,则左子树上所有节点的值均小于它的根节点的值\n- 若任意节点的右子树不为空,则右子树所有节点的值均大于根节点的值\n- 任意节点的左,右子树也分别为二叉查找树\n- 没有键值相等的节点\n\n\n&emsp;一颗二叉搜索树要插入一个结点，要从根结点开始，一层一层往下，适当地移动左或右子结点上，当到达树的分支尽头时，执行插入操作。\n&emsp;二叉搜索树是一种用于查找操作的高效数据结构，在最坏情况下，只需查找一个分支上的数据即可。**查找,插入**操作的复杂度是 `O(logn)`，**搜索,插入,删除**复杂度等于树高,期望`O(logn)`,最坏为`O(n)`,(树退化为线性表)n为树中结点数。\n&emsp;保持一棵树的平衡是指对于给定数量的结点，要使得树的高度尽可能短。\n\n\n&emsp;二叉查找树是由二叉树组成的专用于查找和搜索目的的一种数据结构。二叉搜索树中查找一个结点，从根结点开始一层一层向下查找，当遇到一个比目标结点值大的结点时，顺着该结点左子树继续查找，如果遇到的结点值小于目标结点，则顺着该结点的右子树查找，直到找到目标结点为止。\n\n&ensp;**查找算法**\n&emsp;&emsp;1.若b是空树,则搜索失败,否则;\n&emsp;&emsp;2.若x等于b的根节点的数据域之值,则查找成功;\n&emsp;&emsp;3.若x小于b的根节点的数据域之值,则搜索左子树\n&emsp;&emsp;4.查找右子树\n\n&ensp;**插入算法**\n&emsp;&emsp;1.若b是空树,则将s所指节点作为根节点插入;否则\n&emsp;&emsp;2.若`s->data`等于b的根节点的数据域值,则返回,否则;\n&emsp;&emsp;3.若`s->data`小于b的根节点的数据域之值,则把s所值节点插入到左子树中,否则\n&emsp;&emsp;4.把s所指节点插入到右子树中,(新插入节点总是叶子节点)\n\n&ensp;**删除算法**\n&emsp;&emsp;1.若*p节点为叶子节点,即PL(左子树)和PR(右子树)均为空树.由于删去叶子节点不破坏整棵树的结构,则只需修改其双亲节点的指针即可.\n\n<details>\n<summary>binarysearch</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define OK 1\n#define ERROR 0\n#define TRUE 1\n#define FALSE 0\ntypedef int Status;\ntypedef char ElemType;\n\ntypedef struct node {\n    ElemType data;\n    struct node *lchild, *rchild;\n} BTree, *BTreePtr;\n\n/**************** 插入 **********************/\nStatus Insert(BTreePtr *T, ElemType e) {\n\n    BTreePtr p;\n\n    if (*T == NULL) {\n        *T = (BTreePtr)malloc(sizeof(BTree));\n        (*T)->data = e;\n\n        return TRUE;\n    } else {\n        p = *T;\n        while ( p != NULL) {\n\n            if (e > p->data) {\n                if (p->rchild == NULL) {\n                    p->rchild = (BTreePtr) malloc (sizeof(BTree));\n                    p->rchild->data = e;\n                    return TRUE;\n                }\n                p = p->rchild;\n            } else {\n                if (p->lchild == NULL) {\n                    p->lchild = (BTreePtr) malloc (sizeof(BTree));\n                    p->lchild->data = e;\n                    return TRUE;\n                }\n                p = p->lchild;\n            }\n        }\n    }\n\n    return FALSE;\n}\n/**************** 删除 **********************/\nStatus Delete(BTreePtr T, ElemType e) {\n    BTreePtr p, pp, minP, minPP, child;\n    child = NULL;\n    p = T;\n    pp = NULL;\n\n    while ( (p != NULL) && (p->data != e) ) {\n        pp = p;\n\n        if (e > p->data) {\n            p = p->rchild;\n        } else {\n            p = p->lchild;\n        }\n    }\n\n    if (p == NULL) return FALSE;\n\n    //双节点\n    if ((p->lchild != NULL) && (p->rchild != NULL) {\n        minPP = p;\n        minP = p->rchild;\n\n        while (minP->lchild != NULL) {\n            minPP = minP;\n            minP = minP->lchild;\n        }\n        p->data = minP->data;\n        minPP->lchild = minP->rchild;\n        free(minP);\n\n        return TRUE;\n    }\n\n    //有一个节点\n    if ((p->lchild != NULL) || (p->rchild != NULL)) { //应该将原有的pp同child连接在一起\n\n        if (p->lchild) {\n            child = p->lchild;\n        } else {\n           child = p->rchild;\n        }\n        if(pp->data>p->data) {\n            pp->lchild=child;\n        } else {\n            pp->rchild=child;\n        }\n        free(p);\n        return TRUE;\n    }\n\n    //没有节点\n    if (pp->lchild == p) {//这里面临pp除p以外的节点为null的情况\n        pp->lchild = child;\n    } else {\n        pp->rchild = child;\n    }\n\n    return TRUE;\n}\n/**************** 查找 **********************/\nStatus Find(BTreePtr T, ElemType e) {\n\n    if (T == NULL) return FALSE;\n\n    while ((T != NULL) && (T->data != e)) {\n        if (e > T->data) {\n            T = T->rchild;\n        } else {\n            T = T->lchild;\n        }\n    }\n\n    if (T) {\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\n/**************** 最大值 **********************/\nElemType FindMax(BTreePtr T) {\n    ElemType max;\n    while(T != NULL) {\n        max = T->data;\n        T = T->rchild;\n    }\n    return max;\n}\n\n/**************** 最小值 **********************/\nElemType FindMin(BTreePtr T) {\n    ElemType min;\n    while(T != NULL) {\n        min = T->data;\n        T = T->lchild;\n    }\n    return min;\n}\n\nvoid PreOrderTraverse(BTreePtr T)//前序遍历二叉树\n{\n    if (T == NULL) return;\n\n    if(T) {\n        printf(\"%d \",T->data);\n        PreOrderTraverse(T->lchild);\n        PreOrderTraverse(T->rchild);\n    }\n}\n\nvoid DestroyTree(BTreePtr T) {\n    if (T) {\n        if (T->lchild) {\n            DestroyTree(T->lchild);\n        }\n\n        if(T->rchild) {\n            DestroyTree(T->rchild);\n        }\n\n        free(T);\n        T = NULL;\n    }\n}\n\n/***************** 执行测试 *************************/\nint main(int argc, char const *argv[])\n{\n    BTreePtr T;\n    T = NULL;\n    int a[] = {33, 16, 50, 13, 18, 34, 58, 15, 17, 25, 51, 66, 19, 27, 55};\n    int i;\n    for (i = 0; i < 15; i++) {\n        Insert(&T, a[i]);\n    }\n    printf(\"Max is %d\\n\", FindMax(T));\n    printf(\"Min is %d\\n\", FindMin(T));\n    Delete(T, 18);\n    Delete(T, 13);\n    PreOrderTraverse(T);\n    DestroyTree(T);\n\n    return 0;\n}\n```\n</details>\n\n<details>\n<summary>bst</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n\nenum child_dir {\n    left_child,\n    right_child,\n    root,\n};\n\nstruct node {\n    unsigned long data; \n    struct node *left;\n    struct node *right;\n};\n\nstruct root {\n    struct node *r;\n};\n\nvoid dump(struct node *node, int level, enum child_dir dir)\n{\n    if (!node)\n        return;\n\n    dump(node->right, level + 1, right_child);\n\n    if (dir == left_child)\n        printf(\"%*s\\n\", level*3, \"|\");\n\n    printf(\"%*s - %05lu\\n\", level*3, \" \", node->data);\n\n    if (dir == right_child)\n        printf(\"%*s\\n\", level*3, \"|\");\n\n    dump(node->left, level + 1, left_child);\n}\n\nstruct node* find(struct root *root, unsigned long data)\n{\n    struct node* n = root->r;\n\n    while (n) {\n        if (n->data == data)\n            return n;\n        if (data < n->data)\n            n = n->left;\n        else\n            n = n->right;\n    }\n\n    return NULL;\n}\n\nstruct node* new_node(unsigned long data)\n{\n    struct node *n;\n\n    n = malloc(sizeof(struct node));\n\n    n->data = data;\n    n->left = n->right = NULL;\n    return n;\n}\n\nvoid insert(struct root *root, struct node *new)\n{\n    struct node *parent;\n\n    if (!root->r) {\n        root->r = new;\n        return;\n    }\n\n    parent = root->r;\n\n    while (true) {\n    /* Don't support duplicate data */\n    if (new->data == parent->data)\n    break;\n\n    if (new->data < parent->data) {\n        if (!parent->left) {\n            parent->left = new;\n            break;\n        }\n        parent = parent->left;\n        } else {\n            if (!parent->right) {\n                parent->right = new;\n                break;\n            }\n            parent = parent->right;\n        }\n    }\n}\n\nstruct node* delete(struct root *root, unsigned long data)\n{\n    struct node *n = root->r, **p = &root->r;\n    struct node *child;\n\n    while (n && n->data != data) {\n        if (data < n->data) {\n            p = &n->left;\n            n = n->left;\n        } else {\n            p = &n->right;\n            n = n->right;\n        }\n    }\n\n    if (!n)\n    return NULL;\n    \n    if (n->left && n->right) {\n        struct node *rn = n->right, **rp = &n->right;\n\n        while (rn->left) {\n            rp = &rn->left;\n            rn = rn->left;\n        }\n\n        n->data = rn->data;\n        n = rn;\n        p = rp;\n    }\n\n    child = n->left ? n->left : n->right;\n    *p = child;\n\n    return NULL;\n}\n\nvoid insert_test()\n{\n    struct root tree;\n    struct node* n;\n\n    tree.r = NULL;\n\n    insert(&tree, new_node(9));\n\n    insert(&tree, new_node(5));\n    insert(&tree, new_node(2));\n    insert(&tree, new_node(8));\n\n    insert(&tree, new_node(18));\n    insert(&tree, new_node(13));\n    insert(&tree, new_node(21));\n    insert(&tree, new_node(20));\n\n    dump(tree.r, 0, root);\n\n    n = find(&tree, 18);\n    if (n && n->data == 18)\n        printf(\"Get 18\\n\");\n}\n\nvoid delete_test()\n{\n    struct root tree;\n    struct node* n;\n\n    tree.r = NULL;\n\n    insert(&tree, new_node(9));\n\n    insert(&tree, new_node(5));\n    insert(&tree, new_node(2));\n    insert(&tree, new_node(8));\n\n    insert(&tree, new_node(18));\n    insert(&tree, new_node(13));\n    insert(&tree, new_node(21));\n    insert(&tree, new_node(20));\n\n    dump(tree.r, 0, root);\n\n    delete(&tree, 20);\n    printf(\"Delete 20\\n\");\n    dump(tree.r, 0, root);\n\n    delete(&tree, 9);\n    printf(\"Delete 9\\n\");\n    dump(tree.r, 0, root);\n}\n\nint main()\n{\n    //insert_test();\n    delete_test();\n    return 0;\n}\n```\n</details>\n\n#### 2.3.5 平衡树\n\n&ensp;平衡树是一类改进的二叉查找树,一般二叉查找树的查询复杂度与目标节点到树根的距离(深度)有关,因此当深度较大时,查询均摊复杂度会上升.\n&ensp;**平衡指所有叶子的深度趋于平衡**,更广义指树上所有可能查找的均摊复杂度偏低.**平衡树的操作时基于树旋转操作,通过旋转可使树趋于平衡**.\n&ensp;对一颗查找树进行查询,新增,删除等操作,所花的时间与树的高度h成比例,并不与树的容量n成比例.\n\n- **AVL树**\n\n&emsp;在**AVL树中,任一节点对于的两颗子树的最大高度差为1,因此也称为高度平衡树**.查找,插入和删除的平均和最坏时间复杂度是O(logn),增加和删除元素的操作则可能需要借由一层或多次旋转,以实现树的重新平衡.\n&emsp;**高度为h的AVL树,总节点数最多为2^h-1**; 当前节点数为N时,高度h最多为:\n> log(5*0.5 * (N + 1)) - 2\n\n<br>\n\n- **红黑树**\n\n&ensp;红黑树是一种自平衡二叉查找树,典型的用途是实现关联数组.红黑树实现复制,查找,插入和删除时间复杂度为O(logn)\n&ensp;红黑树相对于AVL树,牺牲了部分平衡性以换取插入\\删除操作时少量的旋转操作,整体性能优于AVL树.\n\n&emsp;红黑树与AVL树的相比:\n&emsp;&emsp;AVL树在插入,删除节点时要把树调整到完全平衡,红黑树只要调整到大致平衡,因此通常红黑树的插入,删除节点性能稍好.\n&emsp;&emsp;AVL的查找性能通常比红黑树好\n&emsp;&emsp;如果节点的增删操作远小于查找操作,则应选择AVL;反之,红黑树可能更好.\n\n&ensp;红黑树是每个节点都带有颜色属性的二叉树,颜色为红色或黑色.在二叉查找树强制一般要求以外,对于任何有效的红黑树我们怎讲了弱小额外要求:\n&emsp;&emsp;1.节点是红或黑色\n&emsp;&emsp;2.根是黑色\n&emsp;&emsp;3.所有叶子都是黑色(叶子是NIL节点)\n&emsp;&emsp;4.每个红色节点必须右两个黑色的子节点.(从每个叶子到根的所有路径上不能右两个连续的红色节点.)\n&emsp;&emsp;5.从任一节点到其每个叶子的所有简单路径都包含相同苏后面的黑色节点.\n&ensp;红黑树关键特性:**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**.红黑树是大致平衡的.插入,删除和查找某个值最坏情况下与树的高度成比例.\n\n- **B+树**\n\n&ensp;B+树通常用于数据库和操作系统的文件系统中.**B+树的特点是能够保持数据稳定有序,其插入与修改拥有较文档的对数时间复杂度**.B+树元素自底向上插入,与二叉树相反.\n&ensp;B+树是内部节点可右在预定范围内的可变量目的子节点.因此,B+树不需要像其他自平衡二叉查找树那样重新平衡.\n\n- **字典树**\n\n<details>\n<summary>Trie</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define OK 1\n#define ERROR 0\n#define TRUE 1\n#define FALSE 0\n\ntypedef int Status;\n\ntypedef struct Node {\n    char data;\n    struct Node *children[26];\n    Status end;\n} Trie, *TriePtr;\n\nvoid Init(TriePtr *T)\n{\n    (*T) = (TriePtr)malloc(sizeof(Trie));\n    (*T)->data = '/';\n    (*T)->end = FALSE;\n}\n\nvoid Insert(TriePtr T, char *str) {\n\n    int index;\n    char c;\n\n    while(c = *str++) {\n        index = c - 'a';\n        if (T->children[index] == NULL) {\n            TriePtr Node;\n            Node = (TriePtr)malloc(sizeof(Trie));\n            Node->data = c;\n            Node->end = FALSE;\n            T->children[index] = Node;\n        }\n\n        T = T->children[index];\n    }\n\n    T->end = TRUE;\n}\n\nStatus Search(TriePtr T, char *str) {\n\n    int index;\n    char c;\n\n    while(c = *str++) {\n        index = c - 'a';\n        if (T->children[index] == NULL) {\n            return FALSE;\n        }\n\n        T = T->children[index];\n    }\n\n    if (T->end) {\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\nint main(int argc, char const *argv[])\n{\n    TriePtr T;\n    Init(&T);\n    char *str = \"hello\";\n    char *str2 = \"hi\";\n\n    Insert(T, str);\n\n    printf(\"str is search %d\\n\", Search(T, str));\n    printf(\"str2 is search %d\\n\", Search(T, str2));\n    return 0;\n}\n```\n</details>\n\n#### 2.3.6 堆树和优先队列\n\n&ensp;堆(heap)也称为优先队列,堆遵守队列操作模式,在堆底插入元素,在堆顶取出元素,但堆中元素的排列不是按照到来的先后顺序,而是按照一定的有序顺序排列的.\n&ensp;堆的本质是一个完全二叉树,可使用二叉树表示堆,也可使用数组来表示.\n&ensp;堆的特性:\n&emsp;&emsp;必须是完全二叉树\n&emsp;&emsp;用数组实现\n&emsp;&emsp;任一节点的值是其子树所有节点的最大值或最小值\n&emsp;&emsp;&emsp;最大值时,称为最大堆,也称大顶堆\n&emsp;&emsp;&emsp;最小时,称为最小堆,也称小顶堆.\n&emsp;**堆不能保证整棵树都是有序的,堆中的插入和删除操作时时间复杂度为O(log2n)**\n\n\n&emsp;堆是一颗二叉树，通常其子结点存储的值比父结点的值小，所以，根结点为树中最大的结点(大顶堆)。同样，根结点也可以是树中最小的结点(小顶堆)。能够快速确定包含最大(小)值的特点。\n&emsp;堆时左平衡的树，随着结点增加，树会逐级从左至右增长。一个较好地表示左平衡二叉树的方式是，将结点通过层序遍历方式连续存储到一个数组中。\n\n```c\ntypedef struct Heap_ {\n    int size;\n    int (*compare)(const void *key1, const void *key2);\n    void (*destroy)(void *data);\n    void **tree;\n}\n```\n\n<details>\n<summary>heap</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n\n/* Implement heap */\n\n#define MAX_HEAP_SIZE (1 << 8)\n\nstruct element {\n    int data;\n};\n\nstruct heap {\n    union {\n        unsigned long elements;\n        struct element *elem[MAX_HEAP_SIZE];\n    };\n};\n\nvoid init_heap(struct heap *heap)\n{\n    int i;\n\n    for(i = 0; i < MAX_HEAP_SIZE; i++) {\n        heap->elem[i] = NULL;\n    }\n}\n\nvoid dump_heap(struct heap *heap, int index)\n{\n    struct element *elem;\n    int level;\n\n    if (index > heap->elements)\n        return;\n\n    elem = heap->elem[index];\n    level = fls(index);\n\n    dump_heap(heap, index * 2 + 1);\n\n    if (!(index % 2) && index != 1)\n        printf(\"%*s\\n\", level*3, \"|\");\n\n    printf(\"%*s - %05d\\n\", level*3, \" \", elem->data);\n\n    if (index % 2 && index != 1)\n        printf(\"%*s\\n\", level*3, \"|\");\n\n    dump_heap(heap, index * 2);\n}\n\nvoid dump(struct heap *heap, int elements)\n{\n    int i;\n\n    for (i = 1; i <= elements; i++)\n        printf(\"[%02d]: %4d\\n\", i, heap->elem[i]->data);\n\n}\n\nstruct element* create_element(int data)\n{\n    struct element *elem;\n\n    elem = malloc(sizeof(struct element));\n\n    if (elem)\n        elem->data = data;\n\n    return elem;\n}\n\nvoid fake_a_heap(struct heap *heap)\n{\n    /* data is in ordered */\n    int i, data[10] = {7, 4, 9, 2, 6, 8, 10, 1, 3, 5};\n\n    init_heap(heap);\n\n    /* root start at 1 */\n    for (i = 0; i < 10; i++)\n        heap->elem[i+1] = create_element(data[i]);\n\n    heap->elements = 10;\n}\n\nvoid swap(struct heap *heap, int i, int j)\n{\n    struct element *tmp;\n\n    tmp = heap->elem[j];\n    heap->elem[j] = heap->elem[i];\n    heap->elem[i] = tmp;\n}\n\nvoid heapify(struct heap *heap, int parent)\n{\n    struct element **elem = heap->elem;\n    int elements = heap->elements;\n    int left, right, max;\n\n    while (true) {\n        left = parent * 2;\n        right = left + 1;\n        \n        max = parent;\n        if (left <= elements && elem[max]->data < elem[left]->data)\n            max = left;\n        if (right <= elements && elem[max]->data < elem[right]->data)\n            max = right;\n\n        if (max == parent)\n            break;\n\n        swap(heap, max, parent);\n        parent = max;\n    }\n}\n\nvoid build_heap(struct heap *heap)\n{\n    int i;\n\n    for (i = heap->elements / 2; i >= 1; i--)\n        heapify(heap, i);\n}\n\nint heap_sort(struct heap *heap)\n{\n    int elements = heap->elements;\n\n    while (heap->elements) {\n        swap(heap, 1, heap->elements);\n        heap->elements--;\n        heapify(heap, 1);\n    }\n    \n    return elements;\n}\n\nint main()\n{\n    struct heap heap;\n    int elements;\n\n    fake_a_heap(&heap);\n    dump_heap(&heap, 1);\n\n    printf(\"After Heapify:\\n\");\n    build_heap(&heap);\n    dump_heap(&heap, 1);\n\n    printf(\"After Heap sort:\\n\");\n    elements = heap_sort(&heap);\n    dump(&heap, elements);\n    return 0;\n}\n```\n</details>\n\n\n&emsp;堆排序，要排序的数据首先存储在一个堆中。从堆中一次取出一个结点。放置到有序数据集的尾部。当取出每个结点时，它的下一个结点就会浮现到堆的顶部。\n\n\n&emsp;优先队列是从堆衍生的数据结构。在优先队列中，数据保存在一个堆中，可快速确定下一个最高优先级的结点。\n\n&emsp;优先队列将数据按照优先级顺序排列。一个优先队列由许多有序元素构成，所以优先级最高的元素可以有效而快速的确定。\n\n```c\ntypedef Heap PQueue;\n```\n\n\n#### 2.3.7 leetcode题目\n\n- 先序遍历构造二叉树\n- 从中序与后序遍历构造二叉树\n- 二叉树的层次遍历\n- 从二叉搜索树到更大和树\n- 二叉搜索树的最近公共祖先\n- 前K个高频单词<堆>\n\n### 2.4 图\n\n&ensp;图(Graph)是由顶点的有穷非空集合和顶点之间的边的集合组成,通常表示为:`G(V,E)`.其中,G表示一个图,V是入G中顶点的集合,E是图G中的集合.\n\n&emsp;图是一种灵活的数据结构，用来定义对象之间关联或联系的模型。对象由顶点表示，而对象直接的关系或关联则通过顶点之间的边来表示。\n&emsp;图的访问方式：广度优先和深度优先。\n\n#### 2.4.1 基础知识\n&emsp;图由两种类型的元素组成：顶点和边，顶点代表对象，边则建立起对象之间的关系或关联。图的边可关联值或权重信息。\n- 一组顶点：用V(vertex)表示顶点集合\n- 一组边：用E(edge)表示边的集合\n&emsp;图分为有向图和无向图。有向图，边是由两个顶点组成的有序对，具有特定的方向。边也可称为弧。无向图中，边是没有方向的。\n- (v, w)表示无向边，即v和w是互通的\n- < v, w >表示有向边，该边始于v，终于w\n&ensp;图可分为连通图和非连通图\n- 连通图：所有的点都右路径相连\n- 非连通图：存在某两个点没有路径相连\n- 强连通图： \n\n&emsp;图中的顶点度\n- 度\n- 入度\n- 出度\n\n#### 2.4.2 图表示\n&emsp;图的表示方法是G=(V, E)，V代表顶点的集合，而E和V之间是二元关系。\n&emsp;图中由两个重要关系邻接(adjacency)和关联(incidence)。邻接是两个顶点之间的关系。关联是顶点和边之间的关系。\n邻接矩阵表示\n\n邻接链表表示\n\n\n\n```c\ntypedef struct AdjList_ {\n    void *vertex;\n    Set adjacent;\n}AdjList;\n\ntypedef struct Graph_ {\n    int vcount;\n    int ecount;\n    int (*match)(const void *key1, const void *key2);\n    List adjlists;\n}\n```\n\n<details>\n<summary>graph</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n\nstruct vertex;\nstruct vertex_adjs {\n    struct vertex *v;\n    struct vertex_adjs *next;\n};\n\nstruct vertex {\n    int data;\n    struct vertex_adjs *adj;\n};\n\n#define MAX_GRAPH_VERTEX (1 << 8)\nstruct graph {\n    struct vertex *vxs[MAX_GRAPH_VERTEX];\n};\n\nvoid init_graph(struct graph *graph)\n{\n    int i;\n\n    for (i = 0; i < MAX_GRAPH_VERTEX; i++)\n        graph->vxs[i] = NULL;\n}\n\nstruct vertex *create_vertex(int data)\n{\n    struct vertex *v;\n\n    v = malloc(sizeof(struct vertex));\n\n    if (v) {\n        v->data = data;\n        v->adj = NULL;\n    }\n\n    return v;\n}\n\nstruct vertex_adjs *create_vertex_adj(struct vertex *v)\n{\n    struct vertex_adjs *v_adj;\n\n    v_adj = malloc(sizeof(struct vertex_adjs));\n\n    if (!v_adj)\n        return NULL;\n\n    v_adj->v = v;\n    v_adj->next = NULL;\n    return v_adj;\n}\n\nvoid insert_adj(struct vertex *v, struct vertex *adj)\n{\n    struct vertex_adjs **v_adj;\n\n    v_adj = &v->adj;\n\n    while (*v_adj)\n    v_adj = &(*v_adj)->next;\n\n    *v_adj = create_vertex_adj(adj);\n}\n\nvoid dump_raw(struct graph *graph)\n{\n    int i;\n\n    for (i = 0; i < MAX_GRAPH_VERTEX; i++) {\n        struct vertex *v = graph->vxs[i];\n        struct vertex_adjs *adj;\n        if (v == NULL)\n            continue;\n\n        printf(\"Vertex[%02d]: %8d ->\", i, v->data);\n\n        adj = v->adj;\n        while (adj) {\n            printf(\" %8d,\", adj->v->data);\n            adj = adj->next;\n        }\n        printf(\"\\n\");\n    }\n}\n\n/* \n  1 ----- 2 ----- 3\n  |     / |     /\n  |    /  |    / \n  |   /   |   /  \n  |  /    |  /   \n  | /     | /    \n  4 ----- 5\n*/\nvoid fake_a_graph(struct graph *graph)\n{\n    int i;\n\n    init_graph(graph);\n\n    for (i = 0; i < 5; i++)\n    graph->vxs[i] = create_vertex(i+1);\n\n    /* connect 1 -> 2, 1 -> 4 */\n    insert_adj(graph->vxs[0], graph->vxs[1]);\n    insert_adj(graph->vxs[0], graph->vxs[3]);\n    /* connect 2 -> 1, 2 -> 3, 2 -> 5, 2 -> 4 */\n    insert_adj(graph->vxs[1], graph->vxs[0]);\n    insert_adj(graph->vxs[1], graph->vxs[2]);\n    insert_adj(graph->vxs[1], graph->vxs[4]);\n    insert_adj(graph->vxs[1], graph->vxs[3]);\n    /* connect 3 -> 2, 3 -> 5 */\n    insert_adj(graph->vxs[2], graph->vxs[1]);\n    insert_adj(graph->vxs[2], graph->vxs[4]);\n    /* connect 4 -> 1, 4 -> 2, 4 -> 5 */\n    insert_adj(graph->vxs[3], graph->vxs[0]);\n    insert_adj(graph->vxs[3], graph->vxs[1]);\n    insert_adj(graph->vxs[3], graph->vxs[4]);\n    /* connect 5 -> 4, 5 -> 2, 5 -> 3 */\n    insert_adj(graph->vxs[4], graph->vxs[3]);\n    insert_adj(graph->vxs[4], graph->vxs[1]);\n    insert_adj(graph->vxs[4], graph->vxs[3]);\n}\n\nint main()\n{\n    struct graph g;\n\n    fake_a_graph(&g);\n    dump_raw(&g);\n    return 0;\n}\n```\n</details>\n\n#### 2.4.3 图遍历\n&ensp;图的搜索方法：深度优先搜索和广度优先搜索。\n&emsp;深度优先遍历(DFS)\n&emsp;思路: 从图中某点v出发:\n&emsp;&emsp;&emsp;1.访问顶点v\n&emsp;&emsp;&emsp;2.从v的未被访问的邻接点中选取一个顶点w,从w出发进行深度优先遍历.\n&emsp;&emsp;&emsp;3.重复上述两步,直到图中所有和v有路径相通的顶点都被访问.\n&emsp;伪代码: \n```c\n// \nvoid DFS(Vertex v) {\n    vistied[v] = true;\n    for (v 的每个邻接点 w) {\n        if (!visited[w]) {\n            DFS(w);\n        }\n    }\n}\n```\n\n\n<details>\n<summary>dfs</summary>\n\n```c\n#include <stdbool.h>\n#include <stdio.h>\n#include \"Graph.h\"\n\n#define MAX_NODES 1000\n\nint visited[MAX_NODES];  // array to store visiting order\n                         // indexed by vertex 0..nV-1\n\nbool dfsPathCheck(Graph g, int nV, Vertex v, Vertex dest)\n{\n    Vertex w;\n    for (w = 0; w < nV; w++)\n        if (adjacent(g, v, w) && visited[w] == -1)\n        {\n            visited[w] = v;\n            if (w == dest)\n                return true;\n            else if (dfsPathCheck(g, nV, w, dest))\n                return true;\n        }\n    return false;\n}\n\nbool findPathDFS(Graph g, int nV, Vertex src, Vertex dest)\n{\n    Vertex v;\n    for (v = 0; v < nV; v++) visited[v] = -1;\n    visited[src] = src;\n    return dfsPathCheck(g, nV, src, dest);\n}\n\nint main(void)\n{\n    int V = 6;\n    Graph g = newGraph(V);\n\n    Edge e;\n    e.v = 0;\n    e.w = 1;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 4;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 5;\n    e.w = 4;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 2;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 3;\n    insertEdge(g, e);\n    e.v = 5;\n    e.w = 3;\n    insertEdge(g, e);\n    e.v = 1;\n    e.w = 2;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 2;\n    insertEdge(g, e);\n\n    int src = 0, dest = 5;\n    if (findPathDFS(g, V, src, dest)) {\n        Vertex v = dest;\n        while (v != src) {\n            printf(\"%d - \", v);\n            v = visited[v];\n        }\n        printf(\"%d\\n\", src);\n    }\n    return 0;\n}\n```\n</details>\n\n\n&ensp;广度优先遍历(BFS)\n&emsp;思路: \n&emsp;&emsp;&emsp;1.顶点v入队列\n&emsp;&emsp;&emsp;2.当队列非空时则继续执行,否则算法结束.\n&emsp;&emsp;&emsp;3.出队列取得队头顶点v',访问顶点v 并标记顶点v已被访问.\n&emsp;&emsp;&emsp;4.查找顶点v的第一个邻接顶点col\n&emsp;&emsp;&emsp;5.若v的邻接顶点col未被访问过的,则col继续.\n&emsp;&emsp;&emsp;6.查找顶点v的另一个新的邻接顶点col,转到步骤5入队列,直到顶点v的所有未被访问过的邻接点处理完,转到步骤2.\n\n<details>\n<summary>bfs_queue</summary>\n\n```c\n#include <stdbool.h>\n#include <stdio.h>\n#include \"Graph.h\"\n#include \"queue.h\"\n\n#define MAX_NODES 1000\n\nint visited[MAX_NODES];  // array to store visiting order\n                         // indexed by vertex 0..nV-1\n\nbool findPathBFS(Graph g, int nV, Vertex src, Vertex dest)\n{\n    Vertex v;\n    for (v = 0; v < nV; v++) visited[v] = -1;\n\n    visited[src] = src;\n    queue Q = newQueue();\n    QueueEnqueue(Q, src);\n    while (!QueueIsEmpty(Q)) {\n        v = QueueDequeue(Q);\n        Vertex w;\n        for (w = 0; w < nV; w++) (\n            if (adjacent(g, v, w) && visited[w] == -1) {\n                visited[w] = v;\n                if (w == dest)\n                    return true;\n                else\n                    QueueEnqueue(Q, w);\n            }\n        )\n    }\n    return false;\n}\n\nint main(void)\n{\n    int V = 10;\n    Graph g = newGraph(V);\n\n    Edge e;\n    e.v = 0;\n    e.w = 1;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 2;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 1;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 2;\n    e.w = 3;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 4;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 8;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 7;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 8;\n    insertEdge(g, e);\n    e.v = 5;\n    e.w = 6;\n    insertEdge(g, e);\n    e.v = 7;\n    e.w = 8;\n    insertEdge(g, e);\n    e.v = 7;\n    e.w = 9;\n    insertEdge(g, e);\n    e.v = 8;\n    e.w = 9;\n    insertEdge(g, e);\n\n    int src = 0, dest = 6;\n    if (findPathBFS(g, V, src, dest)) {\n        Vertex v = dest;\n        while (v != src) {\n            printf(\"%d - \", v);\n            v = visited[v];\n        }\n        printf(\"%d\\n\", src);\n    }\n    return 0;\n}\n```\n</details>\n\n&ensp;深度优先搜索和广度优先搜索,时间复杂度都为O(n^2)\n\n深度优先:从初始点出发,不断向前走,如果碰到死路,就往回走一步,尝试另一条路,直到发现目标位置.\n广度优先:从初始点出发,把所有可能的路径都走一遍,如果里面没有目标位置,则尝试把所有两步能够到的位置都走一遍,看有没有目标位置.\n\n\n\n#### 2.4.4 最短路径\n**迪杰斯特拉Dijkstra算法**\n&ensp;Dijkstra算法适用于权值为正的图.\n&ensp;Dijkstra算法属于单源算法,即只能求出某点到其它点最短距离,并不能得出任意两点之间的最短距离.\n&ensp;在源点可达的情况下,Dijkstra算法的时间复杂度时 `O(ElogV)`\n&ensp;算法步骤:\n&emsp;&emsp;1.将所有边初始化为无穷大\n&emsp;&emsp;2.旋转一个开始的顶点,添加到优先队列中.\n&emsp;&emsp;3.对于该点的所有邻接顶点进行判断,如果到该点的距离小于原先的值,则该值进行更新.\n&emsp;&emsp;4.将该点所有邻接顶点添加到优先队列中.\n&emsp;&emsp;5.从优先队列中挑选除一个路径值最小的顶点,将其弹出,作为新的顶点,重复步骤3,4,5\n&emsp;&emsp;6.直到所有点都被处理过一次.\n\n<detials>\n<summary>迪杰斯特拉</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 20\n#define INF 999\n\nint mat[MAX][MAX];\nint V;\n\nint dist[MAX];\n\nint q[MAX];\nint qp = 0;\n\nvoid enqueue(int v) { q[qp++] = v; }\n\nint cf(void *a, void *b)\n{\n    int *x = (int *)a;\n    int *y = (int *)b;\n    return *y - *x;\n}\n\nint dequeue()\n{\n    qsort(q, qp, sizeof(int), cf);\n    return q[--qp];\n}\n\nint queue_has_something() { return (qp > 0); }\n\nint visited[MAX];\nint vp = 0;\n\nvoid dijkstra(int s)\n{\n    dist[s] = 0;\n    int i;\n    for (i = 0; i < V; ++i) {\n        if (i != s) {\n            dist[i] = INF;\n        }\n        enqueue(i);\n    }\n    while (queue_has_something()) {\n        int u = dequeue();\n        visited[vp++] = u;\n        for (i = 0; i < V; ++i) {\n            if (mat[u][i]) {\n                if (dist[i] > dist[u] + mat[u][i]) {\n                    dist[i] = dist[u] + mat[u][i];\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char const *argv[])\n{\n    printf(\"Enter the number of vertices: \");\n    scanf(\" %d\", &V);\n    printf(\"Enter the adj matrix: \");\n    int i, j;\n    for (i = 0; i < V; ++i) {\n        for (j = 0; j < V; ++j) {\n            scanf(\" %d\", &mat[i][j]);\n        }\n    }\n\n    dijkstra(0);\n\n    printf(\"\\nNode\\tDist\\n\");\n    for (i = 0; i < V; ++i) {\n        printf(\"%d\\t%d\\n\", i, dist[i]);\n    }\n\n    return 0;\n}\n```\n</detials>\n\n**弗洛伊德Floyd算法**\n&ensp;Floyd算法是一个经典的动态规划算法.首先目标是寻找从点`i`到`j`的最短路径.\n&ensp;**Floyd算法可以求出任意两点的最短距离.时间复杂度:**`O(你^3)`\n&ensp;从任意节点i到任意节点j的最短路径不外乎2种可能:\n&emsp;&emsp;1.是之间从i到j\n&emsp;&emsp;2是从i到经过若干个节点k到j\n&emsp;设Dist(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，检查Dis(i,k) + Dis(k,j) < Dis(i,j) 是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，则设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。\n\n```c\nfor (int k = 0; k < n; k++) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (A[i][j] > (A[i][k] + A[k][j])) {\n                A[i][j] = A[i][k] + A[k][j];\n                path[i][j] = k;\n            }\n        }\n    }\n}\n```\n\n\n#### 2.4.5 拓扑排序\n&ensp;拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列.且该序列必须满足下面两个条件:\n- 每个顶点出现且只出现一次\n- 若存在一条顶点A到顶点B的路径,那么在序列中顶点A出现在顶点B的前面.\n&emsp;有向无环图(DAG)才有拓扑排序，非DAG图没有拓扑排序。\n&ensp;拓扑排序步骤：\n- 从DAG图中选择一个 没有前缀(即入度为0)的顶点并输出\n- 从图中删除该顶点和所有以它为起点的有向边\n- 重复1和2直到当前的DAG图为空或当前图中不存在无前缀的顶点为止。后一种情况说明有向图中必然存在环。\n\n#### 2.4.6 leetcode题目\n- 判断二分图\n- 克隆图\n- 找到小镇的法官\n- 钥匙和房间\n- 最短路径访问所有节点\n\n<br>\n\n## 3 常见算法\n\n### 3.1 递归思想\n#### 3.1.1 递归思想\n&ensp;递归思想是:将大问题分解为小问题来求解,然后再将小问题分解为更小的问题.逐层分解,直到问题规模被分解到可以直接计算结果.\n&ensp;如果把一层一层分解过程画成图,它其实就是一棵树,称为递归树.\n\n<!--more-->\n\n&ensp;斐波那契数列\n```c\nint fib(int N)\n{\n    if (N < = 1) {\n        return N;\n    }\n    \n    return fib(N-1) + fib(N-2);\n}\n```\n&ensp;递归的过程中,符合**后进先出**规则,所以用一个堆栈的数据结构.函数递归过程中会自动产生栈帧,当函数栈帧的深度越来越大,栈也也越来越大,如果递归没有终止条件,则会爆栈.递归算法第一步要思考的就是**递归终止条件**.\n&ensp;递归思想的两个延申算法:分治算法和动态规划.\n&ensp;递归的一般结构:\n```c\nvoid func()\n{\n    if (符合边界条件) {\n        ...\n        return ..;\n    }\n    // 某种形式的调用\n    func();\n}\n```\n&ensp;阶乘函数:\n```c\nint factorial(int n)\n{\n    if (n <= 1) {\n        return 1;\n    }\n\n    return n * factorial(n-1);\n}\n```\n\n- 参考链接:https://www.jianshu.com/p/b2d2edb4ba5b\n\n#### 3.1.2 递归基本步骤:\n&ensp;&emsp;1.定义一个函数,明确函数功能\n&ensp;&emsp;2.寻找问题与子问题之间的关系(递推公式)\n&ensp;&emsp;3.将递推公式在定义的函数中实现\n&ensp;&emsp;4.推导时间复杂度,判定是否可以接受,无法接受更换算法.\n\n#### 3.1.3 代表题目\n- 爬楼梯 70\n\n```c\nint climbStairs(int n)\n{\n    int *mem = (int *)malloc(sizeof(int) * (n+1));\n    int mem[n] = {};\n    return climb(n, mem);\n}\n\nint climb(int n, int *mem)\n{\n    if (n == 1) {\n        return 1;\n    }\n    if (n == 2) {\n        return 2;\n    }\n    if (mem[n] > 0) {\n        return mem[n];\n    }\n    mem[0] = climb(n-1, mem) + climb(n-2, mem);\n\n    return mem[n];\n}\n```\n\n- 青蛙跳台阶 10-II\n\n```c\nint numWays(int n)\n{\n    int num[n+1] = {-1};\n    return jump(n, num);\n}\n\nint jump(int n, int *num)\n{\n    if (num[n] != -1) {\n        return num[n];\n    }\n    if (n == 1 || n == 0) {\n        return 1;\n    }\n\n    num[n] = (jump(n-1, num) + jump(n-2, num) % 1e9+7);\n    return num[n];\n}\n```\n\n#### 3.1.4 触类旁通\n- 反转二叉树 226\n&emsp;1).对于根节点`1`来说,假设`2,3`节点下的节点都已经翻转,那么只要翻转`2,2`节点即满足需求.\n&emsp;2).对于`2,3`节点来说,也是翻转其左右节点即可.\n&emsp;依此类推,对每一个节点,依次翻转其左右节点,所以我们可知问题与子问题的关系是翻转(根节点) = 翻转(根节点的左节点) + 翻转(根节点的右节点),即\n> invert(root) = invert(root->left) + invert(root->right)\n&emsp;加号是追加到root上的意思\n\n```c\ntypedef struct TreeNode {\n    int data;\n    TreeNode *left;\n    TreeNode *right;\n}\n\nTreeNode invertTree(TreeNode *root)\n{\n    if (root == NULL) {\n        return NULL;\n    }\n\n    TreeNode *left = (struct TreeNode *)malloc(sizeof(TreeNode));\n    TreeNode *right = (struct TreeNode *)malloc(sizeof(TreeNode));\n    left = invertTree(root.left);\n    rgith = invertTree(root.right);\n    root.left = right;\n    root.right = left;\n    return root;\n}\n\n```\n\n- 路径总和 112\n&emsp;给定一个二叉树和一个目标和,判断该树中是否存在根节点到叶子节点的路径,这条路径上所有节点值相加等于目标和.\n```c\ntypedef struct TreeNode {\n    int data;\n    struct TreeNode *left;\n    struct TreeNode *right;\n}\nbool hasPathSum(TreeNode *root, int sum)\n{\n    if (root == NULL) {\n        return false;\n    }\n    if (root.left == NULL && root.right == NULL) {\n        return root.data == sum;\n    }\n\n    int remain = sum - root.data;\n    return hasPathSum(root.left, remain) || hashPashSum(root.right, remain);\n}\n```\n\n- 细胞分裂\n\nhttps://www.jianshu.com/p/b2d2edb4ba5b\n\n\n\n\n### 3.2 分治法\n&emsp;把复杂问题分成两个或者更多相同或相似的子问题，再把子问题分成更小的子问题...，直到可以直接求解，原问题的解为子问题解的合并。\n&emsp;分治法应用：排序算法(快速排序、归并排序);傅里叶变换()。\n#### 3.2.1 概述\n&ensp;分治法思想:将一个难以直接解决的大问题,分割成一些规模小的相同问题,分而治之.\n\n&emsp;分治法:把一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题...,直到最后子问题可以简单的直接求解,原问题的解即子问题的解的**合并**.分治法思想:排序(快速排序,归并排序),傅里叶变换(快速傅里叶变换\n&emsp;1):数学归纳是使用分治思想.\n&emsp;2):分治思想不一定使用递归结构.\n&ensp;递归结构是循环结构的一种,也是分治思想应用最多的一种程序结构,但不一定使用它.分治法的核心是**如何分**\n\n\n\n#### 3.2.2 策略\n&ensp;分治策略:对于一个规模为n的问题,若该问题可以容易解决则直接解决,否则将其分解为k个规模较小的子问题,子问题之间相互独立且与原问题形式相同,可递归求解.分治通常用递归实现.\n#### 3.2.3 应用场景\n&ensp;分治法特征:\n- 问题缩小到一定程度可容易解决.\n- 问题可分解为若干个规模较小的相同问题,即问题具有最优子结构性质.\n- 子问题的解可合并为该问题的解.\n- 问题分解的子问题相互独立,子问题之间不包含公告子问题.\n\n#### 3.2.4 步骤\n&ensp;分治法一层递归步骤:\n- 1) **分解**:将原问题分解为若干规模较小,相互独立,与原问题形式相同的子问题.\n- 2) **解决**:若子问题可直接求解,则直接求解,否则递归解各个子问题.\n- 3) **合并**:将各个子问题的解合并为原问题的解.\n\n&ensp;\n\n```c\n\n\n```\n<br>\n\n#### 3.2.5 应用\n> 分治思维方式：二分搜索;大整数乘法;合并排序;快速排序。\n\n&ensp;求x的n次幂\n&emsp;对数复杂度O(logn)\n```c\nint power(int x, int n)\n{\n    int result;\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        result = power(x, n/2) * power(x, n / 2);\n    } else {\n        result = power(x, (n + 1) / 2) * power(x, (n - 1) / 2);\n    }\n    return result;\n}\n```\n\n#### 3.2.6 leetcode题目\n- 搜索二维矩阵II\n- 求众数\n- 合并k个排序链表\n\n\n### 3.3 排序算法\n&emsp;各种排序算法，主要包括：插入排序、快速排序、归并排序、计数排序和技术排序。二分查找，\n\n#### 3.3.1 冒泡排序\n&ensp;重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。\n&ensp;**冒泡排序算法复杂度是O(n^2)**\n```c\nstatic void bubleSort(int[] arr)\n{\n    int size = arr.length;\n    // \n    for (int out = size - 1; out > 0; out--) {\n        // \n        for (int in = 0; in < out; in++) {\n            if (arr[in] > arr[in + 1]) {\n                swap(arr, in, in + 1);\n            }\n        }\n    }\n}\n#define SWAP(a,b) \\\ndo{\\\n    (a) ^= (b);\\\n    (b) ^= (a);\\\n    (a) ^= (b);\\\n}while(0)\n\n/*冒泡排序*/\nvoid bubble_sort(int a[],int size)\n{\n    int i = 0;\n    int j = 0;\n    int swap_flg = 0;\n\n    if (size < 1) {\n        return;\n    }\n\n    for (i = size - 1; i > 0; i--) {/*排序的趟数*/ \n        swap_flg = 0;/*每次设置交换标识为0*/\n        for (j = 0; j < i; j++) {          /*本趟排序的遍历元素个数*/\n            if (a[j] > a[j + 1]) {\n                SWAP(a[j],a[j+1]);\n                swap_flg = 1;\n            }\n        }\n        /*本趟数，无数据交换的话，说明已经有序，直接退出*/\n        if (swap_flg == 0) {\n            break;\n        }\n    }\n    return;\n}\n```\n<br>\n\n```c++\n#include <iostream>\nusing namespace std;\ntemplate<typename T>\n//整数或浮点数皆可使用\nvoid bubble_sort(T arr[], int len)\n{\n    int i, j; T temp;\n    for (i = 0; i < len - 1; i++) {\n        for (j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n```\n\n#### 3.3.2 选择排序\n&emsp;选择排序算法时间复杂度为O(n^2)\n\n```c\nstatic void selectSort(int[] arr)\n{\n    int size = arr.lenght;\n    //\n    for (int out = 0; out < size; out++) {\n        int mixIndex = out;\n        //\n        for (int in = out - 1; in < size; in++) {\n            if (arr[mixIndex] > arr[in]) {\n                mixIndex = in;\n            }\n        }\n\n        if (mixIndex != out) {\n            swap(arr, mixIndex, out);\n        }\n    }\n}\n\n/*选择排序*/\nvoid select_sort(int a[],int size)\n{\n    int i = 0;\n    int j = 0;\n    int min = 0;\n\n    for (i = 0; i < size - 1; i++)  {\n        min = i;\n        for (j = i + 1; j < size; j++) {\n            if (a[j] < a[min]) {\n                min = j;\n            }\n        }\n\n        if (min != i) {\n            SWAP(a[i],a[min]);\n        }\n    }\n    return;\n}\n```\n\n#### 3.3.3 插入排序\n&emsp;插入排序每次从无序数据集合中取出一个元素，插入到已经排好序的数据集中适当位置，使数据集仍然有序。插入排序不需要额外空间。时间复杂度O(n2)\n\n```c\nstatic void insertSort(int[] arr)\n{\n    int size = arr.lenght;\n    // \n    for (int out = 1; out < size; out++) {\n        //\n        int temp = arr[out];\n        int in = out;\n        //\n        // \n        while (in - 1 >= 0 && arr[in - 1] > temp) {\n            arr[in] = arr[in - 1];\n            in--;\n        }\n        if (in != out) {\n            arr[in] = temp;\n        }\n    }\n}\n\n/*插入排序*/\nvoid insert_sort(int a[],int size)\n{\n    for (int i = 1; i < size; i ++)/*需要插入的元素个数*/\n    {\n        int key = a[i];/*保存插入的元素数据*/\n        int j = i - 1;\n            /* i 之前的元素都是有序的，找到比key小的插入到他后面，\n        * 比key大的，需要往后挪一个位置*/\n        while((j >= 0) && (a[j] > key)) {\n            a[j + 1] = a[j];\n            j--;\n        }\n        a[j + 1] = key;\n    }\n\n    return;\n}\n```\n\n```c\nint issort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2))\n{\n    char *a = data;\n    void *key;\n    int i, j;\n\n    if ((key = (char *)malloc(esize)) == NULL) {\n        return -1;\n    }\n\n    for (j = 1; j < size; j++) {\n        i = j - 1;\n\n        while (i >= 0 && compare(&a[i * esize], key) > 0) {\n            mamcpy(&a[(i + 1) * esize], &a[i * esize], esize);\n            i--;\n        }\n        memcpy(&a[(i + 1) * esize], key, esize);\n    }\n\n    free(key);\n\n    return 0;\n}\n```\n#### 3.3.4 希尔排序\n\n&ensp;希尔排序时间复杂度O(n*(logn)^2)\n```c\nstatic void shellSort(int[] arr)\n{\n    int size = arr.lenght;\n    int h = 1;\n    while (h <= size / 3) {\n        //\n        h = h * 3 + 1;\n    }\n    while (h > 0) {\n        for (int out = h; out < size; out++) {\n            int temp = arr[out];\n            int in = out;\n            //\n            while (in - h >= 0 && arr[in - h] > temp) {\n                arr[in] = arr[in - h];\n                in = in - h;\n            }\n            if (in != out) {\n                arr[in] = temp;\n            }\n        }\n        h = (h - 1) / 3;\n    }\n}\n```\n#### 3.3.5 归并排序\n&emsp;归并排序是一种分支排序算法。归并排序需要额外存储空间来完成排序。\n```c\nint min(int x, int y)\n{\n    return  x < y ? x : y;\n}\n\nvoid merge_sort(int arr[], int len)\n{\n    int *a = arr;\n    int *b = (int *)malloc(len * sizeof(int));\n    int seg, start;\n    for (seg = 1; seg < len; seg += seg) {\n        for (start )\n    }\n}\n```\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\nvoid dump(int *arr, int size)\n{\n    int idx;\n\n    for (idx = 0; idx < size; idx++)\n        printf(\"%08d\\n\", arr[idx]);\n}\n\nvoid __merge(int *arr, int p, int q, int r)\n{\n    int *tmp;\n    int i, j, k;\n\n    tmp = (int*)malloc((r - p + 1) * sizeof(int));\n\n    if (!tmp)\n        abort();\n\n    for (i = p, j = q + 1, k = 0; i <= q && j <= r;) {\n        if (arr[i] <= arr[j])\n            tmp[k++] = arr[i++];\n        else\n            tmp[k++] = arr[j++];\n    }\n\n    if (i == q + 1) {\n        for (; j <= r;)\n            tmp[k++] = arr[j++];\n    } else {\n        for (; i <= q;)\n            tmp[k++] = arr[i++];\n    }\n\n    memcpy(arr + p, tmp, (r - p + 1) * sizeof(int));\n    free(tmp);\n}\n\nvoid __merge_sort(int *arr, int p, int r)\n{\n    int q;\n\n    if (p >= r)\n    return;\n\n    q = (p + r) / 2;\n    __merge_sort(arr, p, q);\n    __merge_sort(arr, q + 1, r);\n    __merge(arr, p, q, r);\n}\n\nvoid merge_sort(int *arr, int size)\n{\n    __merge_sort(arr, 0, size - 1);\n}\n\nvoid merge_verify()\n{\n    int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56};\n\n    __merge(test, 0, 4, 9);\n\n    dump(test, 10);\n}\n\nvoid merge_sort_test()\n{\n    int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56};\n\n    merge_sort(test, 10);\n    dump(test, 10);\n}\n\nint main()\n{\n    //merge_verify();\n    merge_sort_test();\n    return 0;\n}\n```\n#### 3.3.6 快速排序\n&emsp;快速排序是一种分治排序算法。不需要额外存储空间，时间复杂度O(nlgn)\n\n&emsp;快速排序三个步骤：\n- 分：设定一个分割值并将数据分为两部分。\n- 治：分别在两部分使用递归方式继续使用快速排序方法。\n- 和：对分割部分排序直至完成。\n\n```c\ntypedef struct _Range {\n    int start;\n    int end;\n} Range;\n\nRange now_Range(int s, int e)\n{\n    Range r;\n    r.start = s;\n    r.end = e;\n    return r;\n}\n\nvoid swap(int *x, int *y)\n{\n    int t = *x;\n    *x = *y;\n    *y = t;\n}\n\nvoid quick_sort(int arr[], const int len)\n{\n    if (len <= 0) {\n        return;\n    }\n    Range r[len];\n    int p = 0;\n    r[p++] = new_Range(0, len - 1);\n    while (p) {\n        Range range = r[--p];\n        if (range.start >= range.end) {\n            continue;\n        }\n        int mid = arr[(range.start + range.end) / 2];\n        int left = range.start;\n        int right = range.end;\n        do {\n            while (arr[left] < mid) {\n                ++left;\n            }\n            while (arr[right] > mid) {\n                --right;\n            }\n            if (left <= right) {\n                swap(&arr[left], &arr[right]);\n                left++;\n                right--;\n            }\n        } while (left <= right);\n        if (range.start < right) {\n            r[p++] = new_Range(range.start, right);\n        }\n        if (range.end > left) {\n            r[p++] = new_Range(left, range.end);\n        }\n    }\n}\n```\n\n```c\nvoid QuickSort(int *arr, int low, int high)\n{\n    if (low < high) {\n        int i = low;\n        int j = high;\n        int k = arr[low];\n        while (i < j) {\n            // 从右向左找第一个小于k的数\n            while (i < j && arr[j] >= k) {\n                j--;\n            }\n\n            if (i < j) {\n                arr[i++] = arr[j];\n            }\n            // 从左向右找第一个大于等于k的数\n            while (i < j && arr[i] < k) {\n                i++;\n            }\n\n            if (i < j) {\n                arr[j--] = arr[i];\n            }\n        }\n        arr[i] = k;\n\n        // 递归调用\n        QuickSort(arr, low, i - 1); // 排序k左边\n        QuickSort(arr, i + 1, high); // 排序k右边\n    }\n}\n\nvoid quick_sort( int *a, int n)\n{\n    int i, j, p, tmp;\n    if (n < 2)  return;\n\n    p = a[n / 2];   // Get the middle element as pivot ..\n\n    for ( i = 0, j = n -1;; i++, j--) {\n        while (a[i] < p)\n            i++;\n        while (p < a[j])\n            j--;\n        if ( i >= j)\n            break;\n        tmp = a[i]; a[i] = a[j]; a[j] = tmp;    //swap both ..\n    }   \n\n    quick_sort( a, i); \n    quick_sort( a + i, n - i); \n}\n```\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\nvoid dump(int *arr, int size)\n{\n    int idx;\n\n    for (idx = 0; idx < size; idx++)\n        printf(\"%08d\\n\", arr[idx]);\n}\n\nvoid swap(int *a, int *b)\n{\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint partition(int *arr, int p, int r)\n{\n    //int pivot = arr[r];\n    int i, j;\n\n    i = j = p;\n\n    for (; j < r; j++) {\n        if (arr[j] < arr[r]) {\n            if(i != j) {\n                swap(arr + i, arr + j);\n\n            }\n            i++;\n        }\n    }\n    \n    swap(arr + i, arr + r);\n    return i;\n}\n\nvoid __quick_sort(int *arr, int p, int r)\n{\n    int q;\n\n    if (p >= r)\n    return;\n\n    q = partition(arr, p, r);\n    __quick_sort(arr, p, q-1);\n    __quick_sort(arr, q+1, r);\n}\n\nvoid quick_sort(int *arr, int size)\n{\n    __quick_sort(arr, 0, size - 1);\n}\n\nvoid quick_sort_test()\n{\n    int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56};\n\n    quick_sort(test, 10);\n\n    dump(test, 10);\n}\n\nint main()\n{\n    quick_sort_test();\n    return 0;\n}\n```\n\n```c++\n#include <iostream>\nusing namespace std;\n \nvoid Qsort(int arr[], int low, int high){\n    if (high <= low) return;\n    int i = low;\n    int j = high + 1;\n    int key = arr[low];\n    while (true) {\n        /*从左向右找比key大的值*/\n        while (arr[++i] < key) {\n            if (i == high) {\n                break;\n            }\n        }\n\n        /*从右向左找比key小的值*/\n        while (arr[--j] > key)\n        {\n            if (j == low) {\n                break;\n            }\n        }\n\n        if (i >= j) break;\n        /*交换i,j对应的值*/\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    /*中枢值与j对应值交换*/\n    int temp = arr[low];\n    arr[low] = arr[j];\n    arr[j] = temp;\n    Qsort(arr, low, j - 1);\n    Qsort(arr, j + 1, high);\n}\n```\n\n**qsort/sort函数**\n&ensp;在c语言库函数中已经实现了qsort函数,\n&emsp;qsort函数用法:\n```c\nvoid qsort(void *base, int nelem, int width, int (*fcmp)(const void *, const void *));\n// 参数:1 带排序数组首地址, nelem 数组中待排元素数量  width 各元素所在空间大小  *fcmp 指向函数的指针\n```\n\n```c\n// int 数组\nint cmp(const void *a, const void *b)\n{\n    return (*(int *)a - *(int *)b);\n}\nqsort(arr, n, sizeof(arr[0]), cmp);\n\n// char 数组\nint com(const void *a, const void *b)\n{\n    return *(char *)a - *(char *)b;\n}\nchar word[100];\nqsort(word, 100, sizeof(word[0]), cmp);\n\n// double 类型\nint cmp(const void *a, const void *b)\n{\n    return *(double *)a > *(double*)b ? 1 : -1;\n}\ndouble in[100];\nqsort(in, 100, sizeof(in[00]), cmp);\n\n// struct 结构体\nstruct Sample {\n    double data;\n    int num;\n}st[100];\n\nint cmp(const void *a, const void *b)\n{\n    return (*(Sample *)a).data > (*(Sampel *)b).data ? 1 : -1;\n}\nqsort(s, 100, sizeof(s[0]), cmp);\n// \nint cmp(const void *a, const void *b)\n{\n    struct Sample *c = (Sample *)a;\n    struct Sample *d = (Sample *)b;\n    if(c->x != d->x) {\n        return c->x - d->x;\n    } else {\n        return d->y - c->y;\n    }\n}\n\nqsort(s,100,sizeof(s[0]),cmp);\n\ntruct Sample\n{\n    int data;\n    char str[100];\n}s[100];\n\n//按照结构体中字符串str的字典顺序排序\n\nint cmp (const void *a, const void *b)\n{\n    return strcmp((*(Sample *)a)->str , (*(Sample *)b)->str);\n}\n\nqsort(s,100,sizeof(s[0]),cmp);\n```\n#### 3.3.7 堆排序\n&emsp;桶排序算法基本原理：把数组中的所有元素分为若干个数据块，也就是若干个桶，然后对每个桶里的数据进行排序，最后将所有桶里的数据依次排列。\n&emsp;存在两个问题：\n&emsp;(1)怎样划分数据块，也就是分几个桶，每个桶放哪几个数据。\n&emsp;(2)对每个数据块里的数据怎样排序。\n&ensp;堆排序使利用堆这种数据结构设计的一种选择排序算法。堆是一种近似完全二叉树的结构(通常堆用一维数组实现),并满足性质；最大堆(大顶堆)为例，其父节点的值总是大于它的孩子节点。\n&ensp;堆排序的过程：\n&emsp;1.由输入的无序数组构造一个最大堆，作为初始的无序区\n&emsp;2.把堆顶元素(最大值)和堆尾元素互换\n&emsp;3.把堆(无序区)的尺寸缩小1，并调用heapify(A,0)从新的堆顶元素开始进行堆调整。\n&emsp;4.重复步骤2，直到堆的尺寸为1\n&ensp;因为每次插入数据效率是O(logN)，而我们需要进行n次循环，将数组中每个值插入到堆中，所以它的执行时间是O(N*logN)级。\n\n\n```c\n#include<sdtio.h>\n#include<stdlib.h>\n\ntypedef struct node {\n    int key;\n    struct node *next;\n} KeyNode;\n\nvoid bucket_sort(int keys[], int size, int bucket_size) {\n    int i, j;\n    KeyNode **bucket_table = (KeyNode **)mallov(bucket_size * sizeof(KeyNode*));\n    for(i = 0;i < bucket_size;i++) {\n        bucket_table[i] = (KeyNode*)malloc(sizeof(KeyNode));\n        bucket_table[i]->key = 0;\n        bucket_table[i]->next = NULL;\n    }\n    for(j = 0;j < size;j++) {\n        KeyNode *node = (KeyNode *)malloc(sizeof(KeyNode));\n        node->key = keys[j];\n        node->next = NULL;\n        int index = keys[j]/10;\n        KeyNode *p = bucket_table[index];\n        if(p->key == 0) {\n            bucket_table[index]->next = node;\n            (bucket_table[index]->key)++;\n        } else {\n            while(p->next != NULL && p->next->key <= node->key)\n            p = p->next;\n            node->next = p->next;\n            p->next = node;\n            (bucket_table[index]->key)++;\n        }\n    }\n    //print result\n    KeyNode * k = NULL;\n    for(i = 0;i < bucket_size;i++)\n    for(k = bucket_table[i]->next;k!=NULL;k=k->next)\n    printf(\"%d \",k->key);\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int raw[] = {49,38,65,97,76,13,27,49};\n    int size = sizeof(raw)/sizeof(int);\n    bucket_sort(raw,size,10);\n}\n```\n\n```c\nvoid Heapify(int A[], int i, int size)\n{\n    int lef_child = 2 * i + 1;\n    int right_child = 2 * i + 2;\n    int max = i;\n    if (lef_child < size && A[lef_child] > A[max]) {\n        max = lef_child;\n    }\n    if (right_child < size && A[right_child] > A[max]) {\n        max = right_child;\n    }\n    if (max != i) {\n        Swap(A, i max);\n        Heapify(A, max, size);\n    }\n}\n\nint BuildHeap(int A[], int n)\n{\n    int heap_size = n;\n    for (int i = heap_size / w - 1; i >= 0; i--) {\n        Heapify(A, i, heap_size);\n        return heap_size;\n    }\n}\n\nvoid HeapSort(int A[], int n)\n{\n    int heap_size = BuildHeap(A, n);\n    while (heap_size > 1) {\n        Swap(A, 0, heap_size);\n        Heap(A, 0, heap_size);\n    }\n}\n```\n\n#### 3.3.8 leetcode排序\n\n- 按奇偶排序数组\n- 对链表进行插入排序\n- 合并区间\n- 最大数\n- 最接近原点的K个点\n\n### 3.4 贪心算法\n\n#### 3.4.1 基本概念\n&ensp;贪心算法:在对问题求解时,总是做出在当前是最好的选择,即不考虑整体最优,仅考虑局部最优解.\n&ensp;贪心算法没有固定算法框架,算法关键是贪心策略的选择.他想算法不是所有问题都得到最优解,选择贪心策略必须具备无后效性,即某个状态以后的过程不会影响一起的状态,只与当前状态有关.\n#### 3.4.2 描述\n&ensp;贪心算法实现步骤:\n&emsp;1.建立数学模型描述问题\n&emsp;2.把求解的问题分成若干个子问题\n&emsp;3.对每个子问题求解,得到子问题的局部最优解\n&emsp;4.把子问题的解局部最优解合成原来问题的一个解.\n&ensp;实现算法过程:\n```c\nwhile (能朝给定总目标前进一步)\n{\n    利用可行的决策,求出可行解的一个解元素;\n}\n由所有解元素组合成问题的一个可行解\n```\n#### 3.4.3 应用\n\n**最小生成树算法**\n&ensp;贪心算法经典实践:最小生成树算法\n&emsp;设`G=(V, E)`是无向连通带权图,即一个网络,E中的每一条边`(v,w)` 的全为 `c[v][w]`.如果G的字体 G' 是一颗包含 G 的所有顶点的数,则称 G' 为 G 的生成树.生成树上各边权的总和称为生成树的耗费.在 G 的所有生成树中,耗费最小的生成树称为 G 的最小生成树.\n&ensp;最小生成树的性质:\n&emsp;&emsp;设`G=(V, E)`是连通带权图, U是V的真子集.如果(u,v)属于E,且u属于E,v属于V-U,且在所有这样的边中,(u,v)的权c[u][v]最小,那么一定存在G的一颗最小生成树,它亦是(u,v)为其中一条边,这个性质有时也称为MST性质.\n\n\n**Prim算法**\n&emsp;&emsp;设`G=(V, E)`是连通带权图, V={1,2,...,n}.构造G的最小生成树Prim算法的基本思想是:**首先置S={1},然后,只有S是V的真子集,就进行如下的贪心选择:选取满足添加i属于S,j属于V-S,且c[i][j]最小的边,将顶点j添加到S中.这个过程一直进行到S=V时为止.在这个过程中选取到的所有边恰好构成G的一颗最小生成树.\n\n<details>\n<summary>Prim</summary>\n\n```c\n/**\n * @file\n * @author [Timothy Maloney](https://github.com/sl1mb0)\n * @brief [Prim's algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)\n * implementation in C to find the MST of a weighted, connected graph.\n * @details Prim's algorithm uses a greedy approach to generate the MST of a\n *weighted connected graph. The algorithm begins at an arbitrary vertex v, and\n *selects a next vertex u, where v and u are connected by a weighted edge whose\n *weight is the minimum of all edges connected to v.\n * @references Page 319 \"Introduction to the Design and Analysis of Algorithms\"\n *- Anany Levitin\n *\n * To test - run './prim -test'\n * prim() will find the MST of the following adj. matrix:\n *\n *\t  0  1  2  3\n *        1  0  4  6\n *        2  4  0  5\n *        3  6  5  0\n *\n * The minimum spanning tree for the above weighted connected graph is given by\n *the following adj matrix:\n *\n *\t  0  1  2  3\n *\t  1  0  0  0\n *\t  2  0  0  0\n *\t  3  0  0  0\n *\n *\n * The following [link](https://visualgo.net/en/mst) provides a visual\n *representation of graphs that can be used to test/verify the algorithm for\n *different adj matrices and their weighted, connected graphs.\n */\n\n#include <assert.h>    /// for assert()\n#include <inttypes.h>  /// for uint16_t\n#include <stdio.h>     /// for IO operations\n#include <string.h>    /// for string comparison\n\n#define MAX 20\n#define INF 999\n\n/**\n * @brief Finds index of minimum element in edge list for an arbitrary vertex\n * @param arr graph row\n * @param N number of elements in arr\n * @returns index of minimum element in arr\n */\nuint16_t minimum(uint16_t arr[], uint16_t N)\n{\n    uint16_t index = 0;\n    uint16_t min = INF;\n\n    for (uint16_t i = 0; i < N; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n            index = i;\n        }\n    }\n    return index;\n}\n\n/**\n * @brief Used to find MST of user-generated adj matrix G\n * @returns void\n */\nvoid prim(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)\n{\n    uint16_t u, v;\n    uint16_t E_t[MAX], path[MAX];\n    uint16_t V_t[MAX], no_of_edges;\n\n    E_t[0] = 0;  // edges for current vertex\n    V_t[0] = 1;  // list of visited vertices\n\n    for (uint16_t i = 1; i < V; i++) {\n        E_t[i] = G[i][0];\n        path[i] = 0;\n        V_t[i] = 0;\n    }\n\n    no_of_edges = V - 1;\n\n    while (no_of_edges > 0) {\n        u = minimum(E_t, V);\n        while (V_t[u] == 1) {\n            E_t[u] = INF;\n            u = minimum(E_t, V);\n        }\n\n        v = path[u];\n        MST[v][u] = E_t[u];\n        MST[u][v] = E_t[u];\n        no_of_edges--;\n        V_t[u] = 1;\n\n        for (uint16_t i = 1; i < V; i++) {\n            if (V_t[i] == 0 && G[u][i] < E_t[i]) {\n                E_t[i] = G[u][i];\n                path[i] = v;\n            }\n        }\n    }\n}\n\n/**\n * @brief Self-test implementations\n * @returns void\n */\nstatic void test(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)\n{\n    uint16_t test[4][4] = {\n        {0, 1, 2, 3}, {1, 0, 4, 6}, {2, 4, 0, 5}, {3, 6, 5, 0}};\n    uint16_t solution[4][4] = {\n        {0, 1, 2, 3}, {1, 0, 0, 0}, {2, 0, 0, 0}, {3, 0, 0, 0}};\n\n    V = 4;\n\n    for (uint16_t i = 0; i < V; ++i) {\n        for (uint16_t j = 0; j < V; ++j) {\n            G[i][j] = test[i][j];\n        }\n    }\n\n    prim(&(*G), &(*MST), V);\n\n    for (uint16_t i = 0; i < V; ++i) {\n        for (uint16_t j = 0; j < V; ++j) {\n            assert(MST[i][j] == solution[i][j]);\n        }\n    }\n}\n\n/**\n * @brief Function user_graph();\n * gets user input adj. matrix and finds MST of that graph\n * @returns void\n */\nvoid user_graph(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)\n{\n    printf(\"Enter the number of vertices: \");\n    scanf(\" %hd\", &V);\n\n    assert(V <= MAX);\n\n    printf(\"Enter the adj matrix\\n\");\n    uint16_t i, j;\n    for (i = 0; i < V; ++i) {\n        for (j = 0; j < V; ++j) {\n            printf(\"G[%d][%d]: \", i, j);\n            scanf(\" %hd\", &G[i][j]);\n            if (G[i][j] == 0)\n                G[i][j] = INF;\n        }\n    }\n\n    prim(&(*G), &(*MST), V);\n\n    printf(\"minimum spanning tree:\\n\");\n    for (i = 0; i < V; ++i) {\n        printf(\"\\n\");\n        for (j = 0; j < V; ++j) {\n            printf(\"%d\\t\", MST[i][j]);\n        }\n    }\n}\n\n/**\n * @brief Main function\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n * @returns 0 on exit\n */\nint main(int argc, char const *argv[])\n{\n    uint16_t G[MAX][MAX];    ///< weighted, connected graph G\n    uint16_t MST[MAX][MAX];  ///< adj matrix to hold minimum spanning tree of G\n    uint16_t V;              ///< number of vertices in V in G\n\n    if (argc == 2 && strcmp(argv[1], \"-test\") == 0) {\n        test(&(*G), &(*MST), V);\n    } else {\n        user_graph(&(*G), &(*MST), V);\n    }\n\n    return 0;\n}\n```\n</details>\n\n#### 3.4.4 leetcode题目\n- 柠檬水找零\n- 分发饼干\n\n### 3.5 动态规划\n&ensp;动态规划(`DP`):是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.常用于重叠子问题和最优子结构性质的问题,动态规划时间通常远小于朴素解法.\n#### 3.5.1 基本概念\n&ensp;动态规划:要解一个给定问题,需要解其不同部分(即子问题),再根据子问题的解以得出原问题的解.通常子问题非常相似,子问题解算出后,将其记录.\n&ensp;动态规划过程是:每次决策依赖于当前状态,又随即引起状态转移.一个决策序列就是在变化的状态中产生除留的,这种多阶段最优化决策解决过程称为动态规划.\n&ensp;动态规划与分治法的区别是子问题通常不是独立的.\n\n#### 3.5.2 描述算法\n&ensp;可采用动态规划的问题3个性质:\n&emsp;1) **最优化原理**:如果问题的最优解所包含的子问题的解也是最优的,则称该问题具有最优子结构,即满足最优化原理.\n&emsp;2) **无后效性**:即某阶段状态确定后,就不受之后的决策影响,即某状态以后过程不影响以前的状态,只与当前状态有关.\n&emsp;3) **有重叠子问题**:\n\n<br>\n&ensp;动态规划所处理的问题是一个多阶段决策问题,由初始状态开始,通过中间阶段决策的选择,达到结束状态.形成一个决策序列.\n\n&ensp;动态规划求解三要素:\n> (1) 问题的节点\n> (2) 每个阶段的状态\n> (3) 从前一个阶段转化到后一个阶段之间的递推关系\n\n&ensp;**最优决策表**\n> f(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}\n\n#### 3.5.3 背包问题\n\n&ensp;问题描述:\n&emsp;有N件物品和一个体积为V的背包.(每种物品只有一件)第i件物品的体积是volume[i],价值是value[i],求解哪些物品装入背包可使这些物品的体积综合不超过背包体积,且价值总和最大.\n&ensp;解题思路:\n&emsp;p[i][j]代表前i件物品组合在容量为j的背包的最优解.将前i件物品放入容量为v的背包中这个子问题,若只考虑第i件物品的策略(放或不放),那么可以转化为一个只牵扯前i-1物品的问题.如果不放第i件物品,那么问题就转化为\"前i-1件物品放入容量为v的背包中,价值为p[i-1][v];如果放第i件物品,那么问题就转化为\"前i-1物品放入剩下的容量为v-volume[i]的背包中\",此时能获得的最大价值就是p[i-1][j-volume]再加上通过放入第i件物品获得的价值value[i].\n\n\n&ensp;**状态转移方程:**\n> p[i][j] = max{p[i-1][j-vol] + value[i], p[i-1][j]}\n&ensp;伪代码描述:\n```c\nfor i = 1...N\n    for j = V...0\n        p[j] = max{p[j-volume[i]] + value[i], p[j]};\n```\n\n\n<details>\n<summary>dp</summary>\n\n```c\n#include<stdio.h>\nint v[]={6,3,5,4,6};\nint w[]={2,2,6,5,4};\nint dp[100][100];\n \nint Max(int a,int b){\n\tif(a>=b){\n\t\treturn a;\n\t}else{\n\t\treturn b;\n\t}\n}\n \nint getAns(int i,int wi) {\n\t\n\tfor(int x=0;x<=i;x++) {\n\t\tdp[x][0]=0;\n\t}\n\tfor(int x = 0; x <= wi; x++) {\n\t\tdp[0][x]=0;\n\t}\n\t\n\tfor(int x = 1; x <= i; x++) {\n\t\tfor(int y=1;y<=wi;y++) {\n\t\t\tif(y>=w[x-1]) {\n\t\t\t\tdp[x][y]=Max(dp[x-1][y],v[x-1]+dp[x-1][y-w[x-1]]);\n\t\t\t} else {\n\t\t\t\tdp[x][y]=dp[x-1][y];\n\t\t\t}\n\t\t\tprintf(\"%4d\",dp[x][y]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn dp[i][wi];\n}\n \n \nint main() {\n\tint max=getAns(5,10);\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n} \n```\n</details>\n\n#### 3.5.4 最长公共子序列\n&ensp;问题描述:\n&emsp;一个散列S,如果分别是两个或多个已知数列的子序列,且是所有匹配此条件序列中最长的,则S称为已知序列的最长公共子序列(LCS)\n&ensp;给定两个序列X,Y,求两个序列的最长公共子序列.\n&ensp;解题思路:\n&emsp;最长公共子序列问题存在最优子结构；这个问题可分解成更小，更简单的“子问题”，这个子问题可以分成更多的子问题，因此整个问题就变得简单了。\n&emsp;最长公共子序列问题的子问题的解是可以重复使用的，即，更高级别的子问题通常会重用低级子问题的解。拥有这个两个属性的问题可以使用动态规划算法来解决，这样子问题的解就可以存储起来，而不用重复计算。这个过程需要在一个表中存储同一级别的子问题的解，因此这个解可被更高级的子问题使用。设有二维数组f[i][j]表示X的i位和Y的j位之前的最长公共子序列的长度，则有：\n>f[1][1] = same(1,1)\n>f[i][j] = max{f[i-1][j-1] + same(i, j), f[i-1][j], f[i][j-1]}\n&emsp;其中，`same(a,b)`当X的第a位与Y的第b位完全相同是\"1\"，否则位\"1\"。\n&emsp;此时，f[i][j]中最大的数便是X和Y的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。\n&emsp;该算法的空间、时间复杂度位O(n^2)，经过优化后，空间复杂度位O(n)。\n\n\n&ensp;伪代码:\n```c\nfunction LCSLength(X[1..m], Y[1..n])\n    C = array(0..m, 0..n)\n    for i := 0..m\n        C[i, 0] = 0;\n    for j := 0..n\n        C[0, j] = 0\n    for i := 1..m\n        for j := 1..n\n            if X[i] = Y[j]\n                C[i, j] := C[i-1, j-1] + 1\n            else\n                C[i, j] := max(C[i, j-1], C[i-1,j])\n    \n    return C[m, n]\n```\n\n<details>\n<summary>最长公共序列数</summary>\n\n```c\n#include<stdio.h>\n#include<string.h>\nint dp[100][100];\n \nint Max(int a,int b,int c){\n\tint max=a;\n\tif(b>max){\n\t\tmax=b;\n\t}\n\tif(c>max){\n\t\tmax=c;\n\t}\n\treturn max;\n}\n \nint getMax(char s1[],char s2[],int m,int n){\n\tint i,j;\n\t\n\tfor(i=0;i<m;i++){       //当 s2取 1个的时候 ,s1为可变长度 \n\t\tif(s1[i]==s2[0]){\n\t\t\tdp[i][0]=1;\n\t\t\tfor(j=i+1;j<m;j++){\n\t\t\t\tdp[j][0]=1;\n\t\t\t}\n\t\t\tbreak;\n\t\t} \n\t}\n\tfor(i=0;i<n;i++){      //当 s1取 1个的时候 ,s2为可变长度 \n\t\tif(s2[i]==s1[0]){\n\t\t\tdp[0][i]=1;\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tdp[0][j]=1;\n\t\t\t}\n\t\t\tbreak;\n\t\t} \n\t} \n\t\n\tfor(i=1;i<m;i++){\n\t\tfor(j=1;j<n;j++){\n\t\t\tif(s1[i]==s2[j]){\n\t\t\t\tdp[i][j]=Max(dp[i-1][j-1]+1,dp[i-1][j],dp[i][j-1]);\n\t\t\t}else{\n\t\t\t\tdp[i][j]=dp[i-1][j]>=dp[i][j-1]?dp[i-1][j]:dp[i][j-1];\n\t\t\t}\n\t\t}\n\t} \n\treturn dp[m-1][n-1];\n}\n \nint main() {\n\tint m,n;\n\tchar s1[100];\n\tchar s2[100];\n\tgets(s1);\n\tgets(s2);\n\tm=strlen(s1);\n\tn=strlen(s2);\n\t\n\tprintf(\"%d\\n\",getMax(s1,s2,m,n));\n \n\treturn 0;\n}\n```\n</details>\n\n\n<details>\n<summary>Fibonacci_dp</summary>\n\n```c\n// Fibonacci Series using Dynamic Programming\n\n/* Author: Moinak Banerjee(moinak878)\n   Date : 1 October ,2019\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n)\n{\n    // Out of Range checking\n    if (n < 0) {\n        printf(\"\\nNo Such term !\\n\");\n        exit(0);\n    }\n    // declaring array to store fibonacci numbers -- memoization\n    int *f = (int *)malloc((n + 2) * sizeof(int));  //  one extra to handle edge case, n = 0\n    int i;\n\n    /* let 0th and 1st number of the series be 0 and 1*/\n    f[0] = 0;\n    f[1] = 1;\n\n    for (i = 2; i <= n; i++) {\n        // Adding the previous 2 terms to make the 3rd term\n        f[i] = f[i - 1] + f[i - 2];\n    }\n\n    int out = f[n];\n    free(f);\n    return out;\n}\n\nint main(int argc, char *argv[])\n{\n    int number;\n\n    // Asks for the number/position of term in Fibonnacci sequence\n    if (argc == 2) {\n        number = atoi(argv[1]);\n    } else {\n        printf(\"Enter the value of n(n starts from 0 ): \");\n        scanf(\"%d\", &number);\n    }\n\n    printf(\"The nth term is : %d \\n\", fib(number));\n\n    return 0;\n}\n```\n</details>\n\n#### 3.5.5 leetcode题目\n\n- 最大子序和\n- 编辑距离\n- 大礼包\n- 最长上升子序列\n\n\n### 3.6 回溯法\n\n#### 3.6.1 基本概念\n\n&ensp;回溯算法实际上一个类似枚举的搜索尝试过程,主要是在**搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就\"回溯\"返回,尝试别的路径**.\n&ensp;回溯法是一种迭代搜索法,按选优条件详情搜索,以达到目标.但当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择,这种走不通就退回再走的技术为回溯法,而满足回溯条件的某个状态的点称为\"回溯法\".\n&ensp;许多复杂度,规模较大的问题都看看而已使用回溯法,有\"通用解题方法\"的美称.\n\n&ensp;在包含问题的所有解的解空间树中,按照深度优先的策略,从根节点出发深度探索解空间树.当探索到某一节点时,要先判断该节点是否包含问题的解,如果包含,就从该节点出发继续探索下去,如果该节点不包含问题的解,则逐层向其足协节点回溯.(其实回溯法就是堆隐式图的深度优先搜索算法).\n&ensp;若用回溯法求问题的所有解时,要回溯的根,且根节点的所有可行的子树都要已被搜索遍才结束,而若使用回溯法求任一个解时,只要搜索到问题的一个解就可以结束.\n&ensp;回溯法一般解题步骤:\n&emsp;1.**针对所给问题,确定问题的解空间**;首先应明确定义问题的解空间,解空间应至少包含问题的一个(最优)解.\n&emsp;2.**确定节点的扩展搜索规则**\n&emsp;3.**以深度优先方式搜索解空间,并在搜索过程中用剪枝函数避免无效搜索**\n\n&ensp;伪代码:\n```c\n//\nvoid iterativeBacktrack()\n{\n    int t = 1;\n    while (t > 0) {\n        if (f(n, t) <= g(n, t)) {\n            for (int i = f(n,t); i <= g(n,t); i++) {\n                x[t] = h(i);\n                if (constraint(t) && bound(t)) {\n                    //\n                    if (solution(t)) {\n                        output(x);\n                    } else {\n                        t++;\n                    }\n                } else {\n                    t--;\n                }\n            }\n        }\n    }\n}\n```\n\n#### 3.6.2 八皇后问题\n&ensp;问题描述\n&emsp;八皇后问题使一个以国际象棋为背景的问题:如何能够在 8x8 的国际象棋棋盘上放着八个皇后,使得任何一个皇后都无法直接吃掉其他的皇后?为了达到此目的,任两个皇后都不能处于同一条横行,纵行或斜线上.\n&ensp;转化规则:其实八皇后问题可以推广为更一般的n皇后摆放问题;这时棋盘大小变为nxn,而皇后个数也变成n.当且仅当n = 1 或 n >= 4 时间问题有解。令一个一维数组a[n]保存所得解，其中a[i]表示把第i个皇后放在第i行的列数(注意i的值都是从0开始计算的),下面就八皇后问题的约束条件。\n（1）因为所有的皇后都不能放在同一列，因为任意两个a[0]...a[7]的值不能存在相同的两个值\n（2）所有的皇后都不能在堆角线上，那么该如何检测两个皇后是否在同一个对角线上？我们将棋盘的方格成一个二维数组，如下：\n&ensp;假设有两个皇后被放置在(i,j)和(k,l)的位置上，明显，当且仅当|i-k|=|j-l|时，两个皇后才在同一条对角线上。\n\n&ensp;伪代码描述\n```c\nint queens(int Queens) {\n    int i, k, flag, not_finish = 1, count = 0,\n    // 正在处理的元素下标，表示前i-1个元素已符合要求，在处理第i个元素\n    int a[Queeens+1]; // 八皇后问题的皇后所在的行列位置，从1开始算起，所以加1\n    i = 1;\n    a[1] = 1; // 为数组的第一个元素赋初值\n    while (not_finish) { // not_finish=1 处理尚未结束\n        while(not_finish && i <= Queens) { // 处理尚未结束且还没处理到第Queeens个元素\n        for (flag=1, k=1; flag && k < i; k++) {\n            // 判断是否有多个皇后在同一行\n            if (a[k] == a[i]) {\n                flag = 0;\n            }\n        }\n        // 判断是否有多个皇后在同一个对角线\n        for (k=1; flag && k < i; k++) {\n            if ((a[i] == a[k] - (k-i)) || (a]i] == a[k] + [k-i])) {\n                flag = 0;\n            }\n        }\n\n\n        }\n    }\n}\n```\n\n#### 3.6.3 leetcode题目\n- N皇后\n- 括号生成\n- 单词搜索\n- 解数独\n\n\n## 4 参考链接\n\n- 复杂度速查表\nhttps://liam.page/2016/06/20/big-O-cheat-sheet/\n- 线性表\nhttps://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8\n    - 单链表\nhttps://www.jianshu.com/p/73f0d8f807aa\n\nhttp://cocofe.cn/\n\n- 数据结构\nhttps://github.com/wangzheng0822/algo/\n","source":"_posts/数据结构与算法基础.md","raw":"---\ntitle: 数据结构与算法基础\ndate: 2021-10-27 00:47:53\nupdated: 2021-10-27 00:53:53\npassword: liuz0000\nabstract: 这是一篇加密博文，请输入密码后查看\nmessage: 这里需要密码才能访问。\nwrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.\ncategories: \n    - tool\ntags: \n    - 实用教程\n    - Another Tag\n---\n\n## 1 程序性能\n\n<!--more-->\n\n&ensp;程序性能是指运行程序所需要的**内存大小(空间复杂度)和时间(时间复杂度)**,运行时间和占用空间是算法性能最关键的指标。\n&ensp;软件程序性能衡量指标:\n&emsp;响应时间、启动时间、执行时间、执行速度、计算资源分配、内存分配、磁盘吞吐量、网络吞吐量、负载承受能力\n\n\n### 1.1 空间复杂度\n&ensp;空间复杂度(Space complexity)，算法完全运行所需存储空间。表示算法的存储空间与数据规模之间的增长关系：常量空间、线性空间、二维空间。\n&ensp;算法在计算机存储器上所占用的存储空间，包括**存储程序本身占用的存储空间，算法输入输出数据所占的存储空间和算法在运行过程中临时占用的存储空间**。\n\n\n### 1.2 时间复杂度\n&ensp;时间复杂度(Time complexity)，算法完全运行所需运算时间。时间复杂度通常用大O符合表示。\n\n![20211027233029](https://i.loli.net/2021/10/27/UxWCvnRQLYz5eiG.png)\n\n#### 1.2.1 常见算法大O\n&emsp; 常量阶O(1); 对数阶O(logn); 线性阶O(n); 线性对数阶O(nlogn); k次方阶O(n^k)\n![20211028010721](https://i.loli.net/2021/10/28/GWOFcUi3qdVIlmf.png)\n\n#### 1.2.2 常见数据结构\n\n{% pullquote mindmap mindmap-md %}\n- 数据结构与算法\n    - 线性表\n        - 数组\n        - 链表\n            - 单链表\n            - 双链表\n            - 循环链表\n            - 双向循环链表\n            - 静态链表\n        - 栈\n            - 顺序栈\n            - 链式栈\n        - 队列\n            - 普通队列\n            - 双端队列\n            - 阻塞队列\n            - 并发队列\n            - 阻塞并发队列\n    - 散列表\n        - 散列函数\n        - 冲突解决\n            - 链表法\n            - 开放地址\n            - 其他\n        - 动态扩容\n        - 位置\n    - 树\n        - 二叉树\n            - 二叉查找树\n            - 平衡二叉树\n            - 平衡二叉查找树\n                - AVL树\n                - 红黑树\n            - 完全二叉树\n            - 满二叉树\n        - 多路查找树\n            - B树\n            - B+树\n            - 2-3树\n            - 2-3-4树\n        - 堆\n            - 小顶堆\n            - 大顶堆\n            - 优先级队列\n            - 斐波那契堆\n            - 二项堆\n        - 其他\n            - 树状数组\n            - 线段树\n    - 图\n        - 图的存储\n            - 邻接矩阵\n            - 邻接表\n        - 拓扑排序\n        - 最短路径\n        - 关键路径\n        - 最小生成树\n        - 二分图\n        - 最大流\n    - 复杂度分析\n        - 空间复杂度\n        - 时间复杂度\n    - 基本算法思想\n        - 分治法\n        - 递归算法\n        - 贪心算法\n        - 动态规划\n        - 回溯法\n        - 枚举法\n    - 排序\n        - O(n^2)\n            - 冒泡排序\n            - 插入排序\n            - 选择排序\n            - 希尔排序\n        - O(nlogn)\n            - 归并排序\n            - 快速排序\n            - 堆排序\n        - O(n)\n            - 计数排序\n            - 基数排序\n            - 桶排序\n    - 搜索\n        - 深度优先搜索\n        - 广度优先搜索\n        - A*启发式搜索\n    - 查找\n        - 线性表查找\n        - 树结构查找\n        - 散列表查找\n    - 字符串匹配\n        - 朴素\n        - KMP\n        - Robin-Karp\n        - Boyer-Moore\n        - AC自动机\n        - Trie\n        - 后缀数组\n    - 其他\n        - 数论\n        - 计算几何\n        - 概率分析\n        - 并查集\n        - 拓扑网络\n        - 矩阵运算\n{% endpullquote %}\n\n### 本章参考：\n- 复杂度速查表\nhttps://liam.page/2016/06/20/big-O-cheat-sheet/\n\n## 2 基本数据结构\n### 2.1 线性表\n&ensp;线性表是n个具有相同特性的数据元素的有序序列。线性表除第一个和最后一个数据元素之外，其他数据元素都是首尾相接的。\n&ensp;数据在实际的物理存储中有两种形式：分散存储和集中存储,常见数据结构有栈、队列、字符串、链表等。\n&ensp;两种情况下数据的存储问题：\n&emsp; 数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；\n&emsp; 数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”\n\n#### 2.1.1 数组\n&emsp;数组是一批相同数据的集合。数组的三部分：`地址 大小 和 空间`。数组的保存形式为线性表。\n```c\nint arr[10]; // /[]内必须是常量/常量表达式(3+8)，不能是一个变量(x...)\n// 数组初始化\nint arr1[3] = {1, 2, 3};\nchar arr6[] = \"abcdef\";\n// 指针\nint *ptr = NULL;//定义一个整型的指针变量，初始化为NULL\nchar *ptr = NULL;//定义一个字符的指针变量，初始化为NULL\n// 二维数组\nint arr[3][5] = { 0 };\n// C 传递数组给函数\n// \nvoid myFunction(int *param)\nvoid myFunction(int param[10])\nvoid myFunction(int param[])\n// C 从函数返回数组\nint * myFunction()\n{\n...\n}\n```\n\n<details>\n<summary>array</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct array {\n    int size;\n    int used;\n    int *arr;\n};\n\nvoid dump(struct array *array)\n{\n    for (int idx = 0; idx < array->used; idx++) {\n        printf(\"[%02d]: %08d\\n\", idx, array->arr[idx]);\n    }\n}\n\nvoid alloc(struct array *array)\n{\n    array->arr = (int *)malloc(array->size * sizeof(int));\n}\n\nint insert(struct array *array, int elem)\n{\n    int idx;\n    if (array->used >= array->size)\n        return -1;\n\n    for (idx = 0; idx < array->used; idx++) {\n        if (array->arr[idx] > elem)\n            break;\n    }\n\n    if (idx < array->used)\n        memmove(&array->arr[idx+1], &array->arr[idx],\n            (array->used - idx) * sizeof(int));\n\n    array->arr[idx] = elem;\n    array->used++;\n    return idx;\n}\n\nint delete(struct array *array, int idx)\n{\n    if (idx < 0 || idx >= array->used)\n        return -1;\n\n    memmove(&array->arr[idx], &array->arr[idx+1],\n        (array->used - idx - 1) * sizeof(int));\n    array->used--;\n    return 0;\n}\n\nint search(struct array *array, int elem)\n{\n    for (int idx = 0; idx < array->used; idx++) {\n        if (array->arr[idx] == elem)\n            return idx;\n        if (array->arr[idx] > elem)\n            return -1;\n    }\n\n    return -1;\n}\n\nint main()\n{\n    struct array ten_int = {10, 0, NULL};\n\n    alloc(&ten_int);\n    if (!ten_int.arr) {\n        return -1;\n    }\n    insert(&ten_int, 1);\n    insert(&ten_int, 3);\n    insert(&ten_int, 2);\n    printf(\"=== insert 1, 3, 2\\n\");\n    dump(&ten_int);\n\n    int idx = search(&ten_int, 2);\n    printf(\"2 is at position %d\\n\", idx);\n    idx = search(&ten_int, 9);\n    printf(\"9 is at position %d\\n\", idx);\n\n    printf(\"=== delete [6] element \\n\");\n    delete(&ten_int, 6);\n    dump(&ten_int);\n    printf(\"=== delete [0] element \\n\");\n    delete(&ten_int, 0);\n    dump(&ten_int);\n    return 0;\n}\n```\n</details>\n\n\n<br>\n\n**二分搜索**\n&emsp;基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）\n&emsp;二分搜索的时间复杂度为 ***对数时间O(logn)***\n```c\nint binary_search(int key, int a[], int n)\n{\n    int low = 0;\n    int high = n - 1;\n    int mid, count = 0, count1 = 0;\n\n    while(low < high) {\n        count++;\n        mid = (low + high) / 2;\n        if (key < a[mid]) {\n            high = mid - 1;\n        } else if (key > a[mid]) {\n            low = mid + 1;\n        } else if (key == a[mid]) {\n            count1++;\n            break;\n        }\n    }\n\n    if (count1 == 0) {\n        return 1;\n    }\n    return 0;\n}\n```\n\n#### 2.1.2 单链表\n&emsp; 单链表元素之间有一个单独的指针链接。这种结构的链表可以使得从第一个元素遍历到最后一个元素\n```c\ntypedef struct ListElmt_ {\n    void *data;  // 数据成员\n    struct ListElmt_ * next; // next指针\n} ListElmt;\n\ntypedef struct List_ {\n    int size;\n    int (*match)(const void *key1, const void *key2);\n    void (*destroy)(void *data);\n    ListElmt *head;\n    ListElmt *tail;\n} List;\n```\n&emsp;单链表操作：插入、删除、\n&emsp;如何判断单链表存在回环？\n&emsp;&emsp;设有两个指针p1，p2。在美学循环的时候，p1先走一步，p2走两步，直到p2碰到空指针或者两者相等时循环结束，如果两个指针相等则说明存在回环。\n\n<details>\n<summary>singleList</summary>\n\n```c\n#ifndef __SINGLELIST_H__\n#define __SINGLELIST_H__\n\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct listNode {\n    struct listNode *next;\n    void *value;\n}listNode;\n\ntypedef struct linkedList {\n    listNode *head;\n    size_t len;\n    size_t typesize;\n\n    void(*dup)(void*, void*);\n    int(*match)(void*, void*);\n    void(*free)(void*);\n}linkedList;\n\n#define listSetDupMethod(l,m) ((l)->dup = (m))\n#define listSetFreeMethod(l,m) ((l)->free = (m))\n#define listSetMatchMethod(l,m) ((l)->match = (m))\n\n#define listGetDupMethod(l) ((l)->dup)\n#define listGetFree(l) ((l)->free)\n#define listGetMatchMethod(l) ((l)->match)\n\nlinkedList *listCreate();\nvoid listRelease(linkedList *list);\nvoid listEmpty(linkedList *list);\nlinkedList *listAddNodeHead(linkedList *list, void *value);\nlinkedList *listAddNodeTail(linkedList *list, void *value);\nlinkedList *listInsertNode(linkedList *list, listNode *old_node, void *value, bool after);\nvoid listDelNode(linkedList *list, listNode *node);\n\nlistNode *listSearchKey(linkedList *list, void *key);\nlistNode *listIndex(linkedList *list, long index);\nlinkedList* listRewind(linkedList *list);\n\nsize_t listLength(linkedList *list);\n\n#endif // !__SINGLELIST_H__\n\n//\n#include \"singleList.h\"\n#include <string.h>\n\nlinkedList * listCreate()\n{\n    linkedList *list = NULL;\n    list = malloc(sizeof(*list));\n    if (NULL == list) {\n        return NULL;\n    }\n\n    list->dup = NULL;\n    list->free = NULL;\n    list->match = NULL;\n\n    list->head = NULL;\n    list->len = 0;\n\n    return list;\n}\n\n// \nvoid listRelease(linkedList *list)\n{\n    if (NULL == list) {\n        return;\n    }\n\n    listEmpty(list);\n\n    free(list);\n    list = NULL;\n}\n\nvoid listEmpty(linkedList *list)\n{\n    if (NULL == list) {\n        return;\n    }\n\n    while (NULL != list->head) {\n        listNode *pNode = list->head;\n        list->head = pNode->next;\n        if (NULL != list->free) {\n            list->free(pNode->value);\n        } else {\n            free(pNode->value);\n        }\n\n        pNode->next = NULL;\n        free(pNode);\n        pNode = NULL;\n    }\n}\n\nlinkedList * listAddNodeHead(linkedList *list, void * value)\n{\n    if (NULL == list || NULL == value) {\n        return list;\n    }\n\n    listNode *node = NULL;\n    node = malloc(sizeof(*node));\n    if (NULL == node) {\n        return list;\n    }\n\n    node->value = value;\n    node->next = list->head;\n    list->head = node;\n\n    ++list->len;\n    return list;\n}\n\nlinkedList * listAddNodeTail(linkedList *list, void *value)\n{\n    if (NULL == list || NULL == value) {\n        return list;\n    }\n\n    listNode *node = NULL;\n    node = malloc(sizeof(*node));\n    if (NULL == node) {\n        return list;\n    }\n\n    node->value = value;\n    node->next = NULL;\n\n    if (NULL == list->head && list->len == 0) {\n        list->head = node;\n    } else {\n        listNode *tail = list->head;\n        listNode *pre = list->head;\n        while (NULL != tail) {\n            pre = tail;\n            tail = tail->next;\n        }\n\n        pre->next = node;\n    }\n\n    ++list->len;\n    return list;\n}\n\nlinkedList * listInsertNode(linkedList *list, listNode *old_node, void *value, bool after)\n{\n    if (NULL == list || NULL == old_node) {\n        return list;\n    }\n\n    listNode *pNode = NULL;\n    pNode = malloc(sizeof(*pNode));\n    if (NULL == pNode) {\n        return list;\n    }\n\n    pNode->value = value;\n    if (after) {\n        pNode->next = old_node->next;\n        old_node->next = pNode;\n    } else {\n        listNode *pre = list->head;\n        while (pre->next != old_node) {\n            pre = pre->next;\n        }\n\n        if (NULL != pre) {\n            pre->next = pNode;\n            pNode->next = old_node;\n        }\n    }\n\n    ++list->len;\n    return list;\n}\n\n// \nvoid listDelNode(linkedList *list, listNode *node)\n{\n    if (NULL == list || NULL == node) {\n        return;\n    }\n\n    listNode *pre = list->head;\n    listNode *cur = list->head;\n    while (NULL != cur && cur != node) {\n        pre = cur;\n        cur = cur->next;\n    }\n\n    // \n    if (NULL == pre) {\n        return;\n    }\n\n    pre->next = node->next;\n    node->next = NULL;\n    --list->len;\n\n    if (NULL != list->free) {\n        list->free(node->value);\n        free(node);\n        node = NULL;\n    }\n}\n\nlistNode * listSearchKey(linkedList *list, void *key)\n{\n    if (NULL == list) {\n        return NULL;\n    }\n\n    listNode *node = list->head;\n    while (NULL != node) {\n        if (NULL != list->match) {\n            if (list->match(key, node->value) == 0) {\n                return node;\n            }\n        } else {\n            if (key == node->value) {\n                return node;\n            }\n        }\n\n        node = node->next;\n    }\n\n    return NULL;\n}\n\nlistNode * listIndex(linkedList *list, long index)\n{\n    if (NULL == list) {\n        return NULL;\n    }\n\n    if (index <= 0 || index > list->len) {\n        return NULL;\n    }\n\n    listNode *pNode = list->head;\n    for (long i = 0; i < index; ++i) {\n        pNode = pNode->next;\n    }\n\n    return pNode;\n}\n\nlinkedList* listRewind(linkedList *list)\n{\n    if (NULL == list) {\n        return NULL;\n    }\n\n    listNode *head = list->head;\n    listNode *pre = NULL;\n    listNode *next = NULL;\n    while (NULL != head) {\n        next = head->next;\n        head->next = pre;\n        pre = head;\n        head = next;\n    }\n\n    list->head = pre;\n    return list;\n}\n\nsize_t listLength(linkedList *list)\n{\n    if (NULL == list) {\n        return 0;\n    }\n\n    return list->len;\n}\n```\n</details>\n\n\n<details>\n<summary>single_list</summary>\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n\nstruct single_list {\n    struct single_list *next;\n    int val;\n};\n\nstruct single_list_head {\n    struct single_list *head;\n};\n\nbool is_empty(struct single_list_head *head)\n{\n    return head->head == NULL;\n}\n\nvoid dump(struct single_list_head *head)\n{\n    struct single_list *tmp = head->head;\n    int idx = 0;\n\n    while (tmp) {\n        printf(\"[%02d]: %08d\\n\", idx++, tmp->val);\n        tmp = tmp->next;\n    }\n}\n\nvoid insert(struct single_list **prev, struct single_list *elem)\n{\n    if (!prev)\n        return;\n\n    elem->next = *prev;\n    *prev = elem;\n}\n\nvoid insert_head(struct single_list_head *head, struct single_list *elem)\n{\n    insert(&head->head, elem);\n}\n\nstruct single_list* del(struct single_list **prev)\n{\n    struct single_list *tmp;\n\n    if (!prev)\n        return NULL;\n    if (*prev == NULL)\n        return NULL;\n    tmp = *prev;\n    *prev = (*prev)->next;\n    tmp->next = NULL;\n\n    return tmp;\n};\n\nstruct single_list* delete_head(struct single_list_head* head)\n{\n    return del(&head->head);\n};\n\nstruct single_list** search(struct single_list_head* head, int target)\n{\n    struct single_list **prev, *tmp;\n\n    for (prev = &head->head, tmp = *prev; tmp && (tmp->val < target);\n    prev = &tmp->next, tmp = *prev);\n\n    return prev;\n};\n\nvoid reverse(struct single_list_head* head)\n{\n    struct single_list_head tmp = {NULL};\n    struct single_list *elem;\n\n    while (!is_empty(head)) {\n        elem = delete_head(head);\n        insert_head(&tmp, elem);\n    }\n\n    head->head = tmp.head;\n}\n\nbool is_cyclic(struct single_list_head* head)\n{\n    struct single_list *s1, *s2;\n\n    s1 = s2 = head->head;\n\n    while(s1 && s2) {\n        s1 = s1->next;\n        s2 = s2->next ? s2->next->next:s2->next;\n\n        if (s1 == s2)\n            return true;\n    }\n    return false;\n}\n\nstruct single_list* middle(struct single_list_head* head)\n{\n    struct single_list *s1, *s2;\n    struct single_list pseudo_head;\n\n    pseudo_head.next = head->head;\n    s1 = s2 = &pseudo_head;\n\n    while (true) {\n        if (!s2 || !s2->next)\n            return s1;\n        s1 = s1->next;\n        s2 = s2->next->next;\n    }\n\n    return NULL;\n};\n\nint main()\n{\n    struct single_list_head head = {NULL};\n    struct single_list lists[10];\n    struct single_list **prev;\n    int idx;\n\n    for (idx = 0; idx < 10; idx++) {\n        lists[idx].val = idx;\n        lists[idx].next = NULL;\n    }\n\n    insert_head(&head, &lists[6]);\n    insert_head(&head, &lists[5]);\n    insert_head(&head, &lists[4]);\n    insert_head(&head, &lists[1]);\n    insert_head(&head, &lists[0]);\n\n    printf(\"=== insert 0, 1, 4, 5, 6\\n\");\n    dump(&head);\n\n    prev = search(&head, 2);\n    insert(prev, &lists[2]);\n    printf(\"=== insert 2\\n\");\n    dump(&head);\n\n    printf(\"middle elem is %d\\n\", middle(&head)->val);\n\n    prev = search(&head, 2);\n    if ((*prev) && ((*prev)->val == 2))\n        printf(\"The list contains 2\\n\");\n    else\n        printf(\"The list not contains 2\\n\");\n\n    del(prev);\n    prev = search(&head, 2);\n    printf(\"After remove 2\\n\");\n    if ((*prev) && ((*prev)->val == 2))\n        printf(\"The list contains 2\\n\");\n    else\n        printf(\"The list not contains 2\\n\");\n    dump(&head);\n\n    printf(\"After reverse \\n\");\n    reverse(&head);\n    dump(&head);\n\n    printf(\"middle elem is %d\\n\", middle(&head)->val);\n\n    lists[0].next = &lists[6];\n    printf(\"list is%s cyclic\\n\", is_cyclic(&head)?\"\":\" not\");\n\n    return 0;\n}\n```\n</details>\n\n\n<details>\n<summary>LinkedListAlgo</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * 1) 单链表反转\n * 2) 链表中环的检测\n * 3) 两个有序的链表合并\n * 4) 删除链表倒数第 n 个结点\n * 5) 求链表的中间结点\n *\n * Author: Smallfly\n */\n\ntypedef struct SinglyLinkedNode {\n    int data;\n    struct SinglyLinkedNode* next;\n} SinglyLinkedNode;\n\nvoid insertNode(SinglyLinkedNode** head_ref, int data);\nvoid printLinkedList(SinglyLinkedNode* head);\n\n/** 反转单链表 */\nvoid reverse(SinglyLinkedNode** head_ref) {\n    if (*head_ref == NULL) return;\n    \n    SinglyLinkedNode *prev = NULL;\n    SinglyLinkedNode *current = *head_ref;\n    while (current) {\n        SinglyLinkedNode *next = current->next;\n        if (!next) {\n            // 到达尾结点时，将地址存入 head_ref\n            *head_ref = current;\n        }\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n}\n\nvoid test_reverse() {\n    SinglyLinkedNode* head = NULL;\n    insertNode(&head, 3);\n    insertNode(&head, 2);\n    insertNode(&head, 1);\n    \n    reverse(&head);\n    printLinkedList(head);\n}\n\n/** 检测单链表是否有环 */\n// 这里使用一级指针也可以\nint checkCircle(SinglyLinkedNode** head_ref) {\n    if (*head_ref == NULL) return 0;\n    SinglyLinkedNode *slow = *head_ref, *fast = *head_ref;\n    while (fast != NULL && fast->next != NULL) {\n        fast = fast->next->next;\n        slow = slow->next;\n        if (slow == fast) return 1;\n    }\n    return 0;\n}\n\nvoid test_checkCircle() {\n    SinglyLinkedNode* head = NULL;\n    insertNode(&head, 3);\n    insertNode(&head, 2);\n    insertNode(&head, 1);\n    \n    int result1 = checkCircle(&head);\n    printf(\"has circle: %d\\n\", result1);\n    \n    // make circle linklist\n    SinglyLinkedNode* current = malloc(sizeof(SinglyLinkedNode));\n    current->data = 0;\n    SinglyLinkedNode* h = current;\n    for (int i = 1; i < 4; ++i) {\n        SinglyLinkedNode* node = malloc(sizeof(SinglyLinkedNode));\n        node->data = i;\n        current->next = node;\n        //reset current node\n        current = node;\n    }\n    current->next = h;\n    \n    int result2 = checkCircle(&h);\n    printf(\"has circle: %d\\n\", result2);\n}\n\n/** 有序链表合并 */\nvoid moveNode(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref);\n\nSinglyLinkedNode* mergeSortedLinkedList(SinglyLinkedNode* la, SinglyLinkedNode* lb) {\n    // 辅助结点，next 指针持有合并后的有序链表\n    SinglyLinkedNode dummy;\n    \n    // 有序链表的尾结点\n    SinglyLinkedNode* tail = &dummy;\n    \n    while (1) {\n        // 如果有一个链表为空，直接与另一个链表接起来\n        if (!la) {\n            tail->next = lb;\n            break;\n        } else if (!lb) {\n            tail->next = la;\n            break;\n        }\n        \n        // 将头结点较小的优先添加到 tail\n        if (la->data <= lb->data) {\n            moveNode(&(tail->next), &la);\n        } else {\n            moveNode(&(tail->next), &lb);\n        }\n        tail = tail->next;\n    }\n    \n    return dummy.next;\n}\n\n// 将 src_ref 的头结点，添加到 dest_ref 的头部。\nvoid moveNode(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref) {\n    if (*src_ref == NULL) return;\n    SinglyLinkedNode* new_node = *src_ref;\n    \n    *src_ref = new_node->next;\n    \n    new_node->next = *dest_ref;\n    *dest_ref = new_node;\n}\n\nvoid test_mergeSortedLinkedList() {\n    SinglyLinkedNode* a = NULL;\n    insertNode(&a, 10);\n    insertNode(&a, 5);\n    insertNode(&a, 0);\n    \n    SinglyLinkedNode* b = NULL;\n    insertNode(&b, 8);\n    insertNode(&b, 6);\n    insertNode(&b, 3);\n    \n    SinglyLinkedNode* result = mergeSortedLinkedList(a, b);\n    printLinkedList(result);\n    \n    SinglyLinkedNode* result2 = mergeSortedLinkedList(a, NULL);\n    printLinkedList(result2);\n}\n\n/** 删除倒数第 K 个结点 */\nvoid deleteLastKth(SinglyLinkedNode** head_ref, int k) {\n    if (*head_ref == NULL || k == 0) return;\n    \n    // 快指针向前移动 k-1\n    SinglyLinkedNode* fast = *head_ref;\n    int i = 1;\n    while (i < k && fast != NULL) {\n        fast = fast->next;\n        ++i;\n    }\n    \n    // 如果快指针为空，说明结点个数小于 k\n    if (fast == NULL) return;\n    \n    SinglyLinkedNode* slow = *head_ref;\n    SinglyLinkedNode* prev = NULL;\n    while (fast->next != NULL) {\n        fast = fast->next;\n        prev = slow;\n        slow = slow->next;\n    }\n    \n    // 如果 prev 为空，头结点刚好是第 k 个结点\n    if (!prev) {\n        (*head_ref) = (*head_ref)->next;\n    } else {\n        prev->next = slow->next;\n    }\n    free(slow);\n}\n\nvoid test_deleteLastKth() {\n    SinglyLinkedNode* head = NULL;\n    insertNode(&head, 1);\n    insertNode(&head, 2);\n    insertNode(&head, 3);\n    insertNode(&head, 4);\n    insertNode(&head, 5);\n    \n    // 1. 删除头结点\n    deleteLastKth(&head, 5);\n    printLinkedList(head);\n    \n    // 2. 删除中间结点\n    deleteLastKth(&head, 2);\n    printLinkedList(head);\n    \n}\n\n/** 求中间结点  */\nSinglyLinkedNode* findMiddleNode(SinglyLinkedNode* head) {\n    if (!head) return NULL;\n    SinglyLinkedNode* slow = head;\n    SinglyLinkedNode* fast = head;\n    \n    // 1. 慢指针走一步，快指针两步\n    while (fast->next != NULL && fast->next->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    \n    return slow;\n}\n\nvoid test_findMiddleNode() {\n    SinglyLinkedNode* head = NULL;\n    insertNode(&head, 1);\n    insertNode(&head, 2);\n    insertNode(&head, 3);\n    insertNode(&head, 4);\n    insertNode(&head, 5);\n    \n    SinglyLinkedNode* middleNode = findMiddleNode(head);\n    printf(\"%d\\n\", middleNode->data);\n    printLinkedList(head);\n}\n\n/** 工具方法 */\n// 插入新结点到链表头部\nvoid insertNode(SinglyLinkedNode** head_ref, int data) {\n    SinglyLinkedNode* new_node = malloc(sizeof(SinglyLinkedNode));\n    new_node->data = data;\n    new_node->next = *head_ref;\n    *head_ref = new_node;\n}\n\n// 打印链表\nvoid printLinkedList(SinglyLinkedNode* node) {\n    printf(\"--- start ---\\n\");\n    while (node) {\n        printf(\"data: %d\\n\", node->data);\n        node = node->next;\n    }\n    printf(\"--- end ---\\n\");\n}\n\n// 跑测试\nvoid test() {\n    \n    test_reverse();  \n//    test_checkCircle();\n//    test_mergeSortedLinkedList();\n//    test_deleteLastKth();  \n//    test_findMiddleNode();\n}\n```\n</details>\n\n\n<details>\n<summary>linklist_jinshaohui</summary>\n\n```c\n/*************************************************************************\n > File Name: lisklist.c\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-10-07  \n ************************************************************************/\n#include<stdio.h>\n\nstruct stlistNode\n{\n    int val;\n    struct listNode *next;\n}listNode;\n\n/*反转链表*/\nlistNode reverseList(listNode *head)\n{\n    listNode *prev = NULL;\n    listNode *next = NULL;\n\n    while(head != NULL) {\n        next = head->next;\n        head->next = prev;\n        prev = head;\n        head = next;\n    }\n\n    return prev;\n}\n\n/*判断链表是否有环*/\nint hasCycle(listNode *head)\n{\n    listNode * fast = head;\n    listNode * low = head;\n\n    while(fast != NULL && fast->next != NULL) {\n        low = low->next;\n        fast = fast->next->next;\n        if (low == fast) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n/*合并有序链表*/\nlistNode *mergeTwoLists(listNode *l1,listNode *l2)\n{\n    listNode head = {0};\n    listNode *pRes = &head;\n\n    while(1) {\n        if(l1 == NULL) {\n            pRes->next = l2;\n        }\n\n        if (l2 == NULL) {\n            pRes->next = l1;\n        }\n\n        if(l1->val < l2->val) {\n            pRes->next = l1;\n            l1 = l1->next;\n        } else {\n            pRes->next = l2;\n            l2 = l2->next;\n        }\n        pRes = pRes->next;\n    }\n\n    return head;\n}\n/*\n *删除链表倒数第n个节点，并返回链表头节点 */\nlistNode * removeNthFromEnd(listNode*headi,int n)\n{\n    listNode *fast = head;\n    listNode *prev = NULL;\n    listNpde *next = head;\n    int k = n;\n    \n    /*快指针往后移动k-1*/\n    while((k > 1) && (fast != NULL)) {\n        fast = fast->next;\n        k--;\n    }\n    \n    /*说明链表数目不足n个*/\n    if (fast == NULL) {\n        return head;\n    }\n\n    while (fast->next != NULL) {\n        fast = fast->next;\n        prev = next;\n        next = next->next;\n    }\n\n    if(prev == NULL) {\n        head = head->next;\n    } else {\n        prev->next = prev->next->next;\n    }\n\n    return head;\n}\n/*求链表的中间节点*/\nlistNode *middleNode(listNode *head)\n{\n    listNode * fast = head;\n    listNode * low = head;\n\n    while(fast != NULL && fast->next != NULL) {\n        low = low->next;\n        fast = fast->next->next;\n    }\n\n    return low;\n}\n```\n</details>\n\n\n#### 2.1.3 双链表\n&emsp; 双向链表的元素通过两个指针链接，一个指向直接后继，一个指向直接前驱。双向链表可以正向遍历，也可反向遍历。\n```c\ntypedef struct DListElmt_ {\n    void *data;\n    struct DListElmt_ *prev;\n    struct DListElmt_ *next;\n} DListElmt;\n\ntypedef struct DList_ {\n    int size;\n    int (*match)(const void *key1, const void *key2);\n    void (*destroy)(void *data);\n    DListElmt *head;\n    DListElmt *tail;\n} DList;\n```\n\n<details>\n<summary>Dlist</summary>\n\n```c\n// Dlist.h\n#include<stdio.h>\n\ntypedef struct DlistNode {    //双向链表中每一个节点\n    struct DlistNode *prev;   //节点前项指针\n    struct DlistNode *next;   //节点后项指针\n    int    data;              //数据\n}stDlistNode;\n\ntypedef struct Dlisthead {    //定义链表总体\n    int size;                 //链表长度\n    stDlistNode *head;        //头指针\n    stDlistNode *tail;        //尾部指针\n}stDlistHead;\n\n// Dlist.c\n#include<stdio.h>\n#include <stdbool.h>\n#include \"./Dlist.h\"\n\nvoid dlist_init(stDlistHead *dlist)    //链表初始化\n{\n    dlist->size = 0;\n    dlist->head = NULL;\n    dlist->tail = NULL;\n    return;\n}\n\nvoid dlist_destory(stDlistHead *dlist)    //删除链表\n{\n    stDlistNode *pNode = NULL;\n\n    while(dlist->size > 0) {\n        pNode = dlist->head;\n        dlist->head = dlist->head->next;\n        free(pNode);\n        dlist->size--;\n    }\n\n    memset(dlist,0,sizeof(stDlistHead));\n\n    return;\n}\n\nint dlist_insert_head(stDlistHead *dlist,stDlistNode *pNode,int data)    //插入头结点，操作的链表，操作的节点，数据\n{\n    if(pNode == NULL) {   //当只传递一个数据时\n        pNode = (stDlistNode *)malloc(sizeof(stDlistNode));    //新建节点，为节点分配空间（malloc（）可能需要#include<malloc.h>）\n        if (pNode == NULL) {\n            return -1;\n        }\n    }\n\n    pNode->data = data;    \n    pNode->prev = NULL;\n    pNode->next = NULL;\n\n    if (dlist->size == 0) {  //如果链表长度为0，即链表当前无节点，\n        dlist->head = pNode;\n        dlist->tail = pNode;\n    } else {                 //如果链表已有节点，则令新插入节点为头节点\n        pNode->next = dlist->head;\n        dlist->head->prev = pNode;\n        dlist->head = pNode;    \n    }\n\n    dlist->size++;    //每成功调用一次，链表长度+1\n    return 0;\n}\n\nstDlistNode * dlist_remove_tail(stDlistHead *dlist)    //删除尾部节点,并返回删除节点\n{\n    stDlistNode *pNode = NULL;\n\n    if(dlist->size == 0) {\n        return NULL;\n    }\n\n    pNode = dlist->tail;\n    if(dlist->size > 1) {\n        dlist->tail = dlist->tail->prev;\n        dlist->tail->next = NULL;\n    } else {\n        dlist->head = NULL;\n        dlist->tail = NULL;\n    }\n    dlist->size--;\n    return pNode;\n}\n\nvoid dlist_remove_node(stDlistHead * dlist,stDlistNode *pNode)     //删除指定节点\n{\n    if ((dlist == NULL)||(pNode == NULL)) {\n        return;\n    }\n\n    if (dlist->head == pNode) {\n        dlist->head = dlist->head->next;\n    } else if (dlist->tail == pNode) {\n        dlist->tail = pNode->prev;\n        dlist->tail->next = NULL;\n    } else {\n        pNode->prev->next = pNode->next;\n        pNode->next->prev = pNode->prev;\n    }\n    dlist->size--;\n    pNode->prev = NULL;\n    pNode->next = NULL;\n\n    if (dlist->size == 0) {\n        memset(dlist,0,sizeof(stDlistHead));     //将dlist占用内存块的所有值置为0，也就是清空head,tail指针内容\n    }\n\n    return;\n}\nstDlistNode * dlist_search(stDlistHead * dlist,int data)     //根据值搜索节点，并返回\n{\n    stDlistNode *pNode = dlist->head;\n    while(pNode != NULL) {\n        if (pNode->data == data) {\n            return pNode;\n        }\n        pNode = pNode->next;\n    }\n    return NULL;\n}\n\nvoid dlist_dump(stDlistHead *dlist)    //显示链表中的数据\n{\n    int no = 0;\n    stDlistNode *pNode = dlist->head;\n    while(pNode != NULL) {\n        printf(\"\\r\\n [%d] = %d\",no++,pNode->data);\n        pNode = pNode->next;    //将pNode的下一个节点赋值给pNode，推进循环\n    }\n\n    return;\n}\n\n\nvoid Lru_dlist(stDlistHead *dlist,int data)     //LRU（最近最少使用）缓存淘汰算法\n{\n    stDlistNode *pNode = NULL;\n\n    pNode = dlist_search(dlist,data);    \n    if (pNode != NULL) {    //如果在链表中找到这个值，则删除储存这个值的节点，之后吧这个节点放在头部\n        dlist_remove_node(dlist,pNode);\n    } else if(dlist->size >= 4)    {    //没在链表中找到，且链表长度大于4，则从链表中删除尾部节点，将新数据放在头部\n        pNode = dlist_remove_tail(dlist);\n    }\n\n    dlist_insert_head(dlist ,pNode,data);\n\n    return;\n}\n\nint main()\n{\n    stDlistHead dlist = {0};\n    stDlistNode * pNode = NULL;\n\n    dlist_init(&dlist);\n\n    printf(\"\\r\\n inset 1,2,3\");\n    dlist_insert_head(&dlist,NULL,1);\n    dlist_insert_head(&dlist,NULL,2);\n    dlist_insert_head(&dlist,NULL,3);\n\n    dlist_dump(&dlist);\n\n    pNode = dlist_remove_tail(&dlist);\n    if(pNode != NULL) {\n        printf(\"\\r\\n remove %d\",pNode->data);\n    }\n    dlist_insert_head(&dlist,pNode,4);\n    dlist_dump(&dlist);\n\n    Lru_dlist(&dlist,5);\n    dlist_dump(&dlist);\n    Lru_dlist(&dlist,6);\n    dlist_dump(&dlist);\n    Lru_dlist(&dlist,7);\n    dlist_dump(&dlist);\n    Lru_dlist(&dlist,5);\n    dlist_dump(&dlist);\n\n    while(dlist.size > 0) {\n        pNode = dlist_remove_tail(&dlist);\n        if(pNode != NULL) { \n            printf(\"\\r\\n remove %d\",pNode->data);\n            free (pNode);\n        }\n    }\n\n    return 0;\n}\n```\n</details>\n\n<details>\n<summary>linux/list</summary>\n\n```c\n// linux内核源码双向链表实现include/linux/list.h\n#ifndef _LIST_HEAD_H\n#define _LIST_HEAD_H\n\n// 双向链表节点\nstruct list_head {\n    struct list_head *next, *prev;\n};\n\n// 初始化节点：设置name节点的前继节点和后继节点都是指向name本身。\n#define LIST_HEAD_INIT(name) { &(name), &(name) }\n\n// 定义表头(节点)：新建双向链表表头name，并设置name的前继节点和后继节点都是指向name本身。\n#define LIST_HEAD(name) \\\n    struct list_head name = LIST_HEAD_INIT(name)\n\n// 初始化节点：将list节点的前继节点和后继节点都是指向list本身。\nstatic inline void INIT_LIST_HEAD(struct list_head *list)\n{\n    list->next = list;\n    list->prev = list;\n}\n\n// 添加节点：将new插入到prev和next之间。\nstatic inline void __list_add(struct list_head *new,\n                  struct list_head *prev,\n                  struct list_head *next)\n{\n    next->prev = new;\n    new->next = next;\n    new->prev = prev;\n    prev->next = new;\n}\n\n// 添加new节点：将new添加到head之后，是new称为head的后继节点。\nstatic inline void list_add(struct list_head *new, struct list_head *head)\n{\n    __list_add(new, head, head->next);\n}\n\n// 添加new节点：将new添加到head之前，即将new添加到双链表的末尾。\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head)\n{\n    __list_add(new, head->prev, head);\n}\n\n// 从双链表中删除entry节点。\nstatic inline void __list_del(struct list_head * prev, struct list_head * next)\n{\n    next->prev = prev;\n    prev->next = next;\n}\n\n// 从双链表中删除entry节点。\nstatic inline void list_del(struct list_head *entry)\n{\n    __list_del(entry->prev, entry->next);\n}\n\n// 从双链表中删除entry节点。\nstatic inline void __list_del_entry(struct list_head *entry)\n{\n    __list_del(entry->prev, entry->next);\n}\n\n// 从双链表中删除entry节点，并将entry节点的前继节点和后继节点都指向entry本身。\nstatic inline void list_del_init(struct list_head *entry)\n{\n    __list_del_entry(entry);\n    INIT_LIST_HEAD(entry);\n}\n\n// 用new节点取代old节点\nstatic inline void list_replace(struct list_head *old,\n                struct list_head *new)\n{\n    new->next = old->next;\n    new->next->prev = new;\n    new->prev = old->prev;\n    new->prev->next = new;\n}\n\n// 双链表是否为空\nstatic inline int list_empty(const struct list_head *head)\n{\n    return head->next == head;\n}\n\n// 获取\"MEMBER成员\"在\"结构体TYPE\"中的位置偏移\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n\n// 根据\"结构体(type)变量\"中的\"域成员变量(member)的指针(ptr)\"来获取指向整个结构体变量的指针\n#define container_of(ptr, type, member) ({          \\\n    const typeof( ((type *)0)->member ) *__mptr = (ptr);    \\\n    (type *)( (char *)__mptr - offsetof(type,member) );})\n\n// 遍历双向链表\n#define list_for_each(pos, head) \\\n    for (pos = (head)->next; pos != (head); pos = pos->next)\n\n#define list_for_each_safe(pos, n, head) \\\n    for (pos = (head)->next, n = pos->next; pos != (head); \\\n        pos = n, n = pos->next)\n\n#define list_entry(ptr, type, member) \\\n    container_of(ptr, type, member)\n\n#endif\n```\n</details>\n\n#### 2.1.4 跳表\n&emsp;跳表对标的是平衡树(AVL Tree), 插入/删除/搜索都是 O(logn)的数据结构。\n\n<details>\n<summary>skiplist</summary>\n\n```c\n/*************************************************************************\n > File Name: skiplist.h\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-10-31\n > Desc:    \n ************************************************************************/\n#ifndef __SKIP_LIST_H__\n#define __SKIP_LIST_H__\n\ntypedef struct _node {\n    int key;    /*key是唯一的*/\n    int value;  /*存储的内容*/\n    int max_level; /*当前节点最大层数*/\n    struct _node *next[0];/*level层链表结构*/\n}node;\n\ntypedef struct _skiplist {\n    int level;\n    int count;\n    node *head;\n}skiplist;\n\n/*根据当前结构体元素的地址，获取到结构体首地址*/\n#define offsetof(TYPE,MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#define container(ptr,type,member) ({\\\n  const typeof( ((type *)0)->member) *__mptr = (ptr);\\\n  (type *) ( (char *)__mptr - offsetof(type,member));})\n\n#endif\n\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#include\"./skiplist.h\"\n\n/*创建node节点*/\nnode* skip_list_create_node(int level,int key,int value)\n{\n    node * tmp = NULL;\n    tmp =(node *)malloc(sizeof(node) + level*sizeof(node *));\n    assert(tmp != NULL);\n\n    memset(tmp,0,sizeof(node) + level*sizeof(node*));\n    tmp->key = key;\n    tmp->value = value;\n    tmp->max_level = level;\n    \n    return tmp;\n}\n\n/*创建跳表的表头，max_level层数*/\nskiplist * skip_list_create(int max_level)\n{\n    int i = 0;\n    skiplist * list = NULL;\n\n    list = (skiplist *)malloc (sizeof(skiplist));\n    assert(list != NULL);\n\n    list->level = 1;\n    list->count = 0;\n    list->head = skip_list_create_node(max_level,0,0);\n    if(list->head == NULL) {\n        free(list);\n        return NULL;\n    }\n    \n    return list;\n}\n\n/*skiplist 销毁*/\nvoid skip_list_destory(skiplist * list)\n{\n    int i = 0;\n    node * tmp = NULL;\n\n    if((list == NULL) || (list->head == NULL)) {\n        return;\n    }\n    while(list->head->next[0] != NULL) {\n        tmp = list->head->next[0];\n        list->head->next[0] = tmp->next[0];\n        free(tmp);\n    }\n\n    free(list->head);\n    free(list);\n    return;\n}\n\n/*插入元素获得层数，是随机产生的*/\nint skip_list_level(skiplist * list)\n{\n    int i = 0;\n    int level = 1;\n    for (i = 1; i < list->head->max_level; i++) {\n        if ((rand()%2) == 1) {\n            level++;\n        }\n    }\n\n    return level;\n}\nint skip_list_insert(skiplist *list,int key,int value)\n{\n    int i = 0;\n    int level = 0;\n    node **update = NULL;/*用来更新每层的指针*/\n    node *tmp = NULL;\n    node *prev = NULL;\n\n    if (list == NULL) {\n        return 1;\n    }\n\n    /*申请update空间用于保存每层的指针*/\n    update = (node **)malloc(sizeof(node *)*list->head->max_level);\n    if (update == NULL) {\n        return 2;\n    }\n\n    /*逐层查询节点的*/\n    prev = list->head;\n    for (i = (list->level -1); i >= 0; i--) {\n        /*初始化每level层的头指针*/\n        while(((tmp = prev->next[i]) != NULL) && (tmp->key < key)) {\n            prev  = tmp;\n        }\n        update[i] = prev;\n    }\n\n    /*当前key已经存在，返回错误*/\n    if ((tmp!= NULL) && (tmp->key == key)) {\n        return 3;\n    }\n    /*获取插入元素的随机层数，并更新跳表的最大层数*/\n    level = skip_list_level(list);\n    /*创建当前数据节点*/\n    tmp = skip_list_create_node(level,key,value);\n        if (tmp == NULL) {\n        return 4;\n    }\n\n    /*更新最大层数*/\n    if (level > list->level) {\n        for (i = list->level;i < level; i ++) {\n            update[i] = list->head;\n        }\n        list->level = level;\n    }\n\n    /*逐层更新节点的指针*/\n    for(i = 0; i < level; i++) {\n        tmp->next[i] = update[i]->next[i];\n        update[i]->next[i] = tmp; \n    }\n\n    list->count++;\n    return 0;\n}\n\nint skip_list_delete(skiplist * list, int key ,int *value)\n{\n    int i = 0;\n    node **update = NULL;/*用来更新每层的指针*/\n    node *tmp = NULL;\n    node *prev = NULL;\n\n    if ((list == NULL) && (value == NULL)&& (list->count == 0)) {\n        return 1;\n    }\n    /*申请update空间用于保存每层的指针*/\n    update = (node **)malloc(sizeof(node *)*list->level);\n    if (update == NULL) {\n        return 2;\n    }\n    /*逐层查询节点的*/\n    prev = list->head;\n    for (i = (list->level -1); i >= 0; i--) {\n        /*初始化每level层的头指针*/\n        while(((tmp = prev->next[i]) != NULL) && (tmp->key < key)) {\n            prev = tmp;\n        }\n        update[i] = prev;\n    }\n\n    if ((tmp != NULL) && (tmp->key == key)) {\n        *value = tmp->value;\n        /*逐层删除*/\n        for(i = 0; i < list->level; i++) {\n            if(update[i]->next[i] == tmp) {\n                update[i]->next[i] = tmp->next[i];       \n            }    \n        }\n\n        free(tmp);\n        tmp = NULL;\n        \n        /*更新level的层数*/\n        for (i = list->level - 1; i >= 0; i++) {\n            if (list->head->next[i] == NULL ) {\n                list->level--;\n            } else {\n                break;\n            }\n        }\n\n        list->count--;\n    } else {\n        return 3;/*未找到节点*/\n    }\n\n    return 0 ;\n}\n\n/*查询当前key是否在跳表中，如果存在返回查询的value数值，不存在返回-1*/\nint skip_list_search(skiplist *list,int key,int *value)\n{\n    int i = 0;\n    node *prev = NULL;\n    node *tmp = NULL;\n\n    if((list == NULL) || (list->count == 0) || (value == NULL)) {\n        return 1;\n    }\n    prev = list->head;\n    for(i = list->level - 1; i >= 0; i--) {\n        while(((tmp = prev->next[i]) != NULL) && (tmp->key <= key)) {\n            if (tmp->key == key) {\n                    *value = tmp->value;\n                    return 0;\n            }\n            prev = tmp;\n        }\n    }\n\n    return -1;\n}\n\nvoid skip_list_dump(skiplist *list)\n{\n    int i = 0;\n    node *ptmp = NULL;\n    printf(\"\\r\\n----------------------------------------------\");\n    printf(\"\\r\\n skip list level[%d],count[%d]\",list->level,list->count);\n    for(i = list->level - 1; i >= 0; i --) {\n        ptmp = list->head->next[i];\n        printf(\"\\r\\n level[%d]:\",i);\n        while(ptmp != NULL) {\n            printf(\"%d-%d \",ptmp->key,ptmp->value);\n            ptmp = ptmp->next[i];\n        }\n    }\n    printf(\"\\r\\n----------------------------------------------\");\n    return;\n}\n\nint main()\n{\n    int res = 0;\n    int key = 0;\n    int value = 0;\n    skiplist *list = NULL;\n\n\n    list = skip_list_create(5);\n    assert(list != NULL);\n\n    while(1) {\n        printf(\"\\r\\n 请输入key 和 value，当key = 1000时，退出输入：\");\n        scanf(\"%d%d\",&key,&value);\n        if (key == 1000) {\n            break;\n        }\n        res = skip_list_insert(list,key,value);\n        if (res != 0) {\n            printf(\"\\r\\n skip list insert %d,failed,res=%d.\",key,res);\n        }\n    }\n    skip_list_dump(list);\n\n    while(1) {\n        printf(\"\\r\\n 通过key 查询value的数值，当key = 1000时，退出查询\");\n        scanf(\"%d\",&key);\n        if(key == 1000) {\n            break;\n        }\n        res = skip_list_search(list,key,&value);\n        if (res != 0) {\n            printf(\"\\r\\n skip list search %d,failed,res=%d.\",key,res);\n        } else {\n            printf(\"\\r\\n skip list search %d,sucessful,value=%d.\",key,value);\n        }\n    }\n    skip_list_dump(list);\n    while(1) {\n        printf(\"\\r\\n 通过key 删除节点，当key = 1000时，退出删除\");\n        scanf(\"%d\",&key);\n        if(key == 1000) {\n            break;\n        }\n        res = skip_list_delete(list,key,&value);\n        if (res != 0) {\n            printf(\"\\r\\n skip list search %d,failed,res=%d.\",key,res);\n        } else {\n            printf(\"\\r\\n skip list search %d,sucessful,value=%d.\",key,value);\n        }\n    }\n\n    skip_list_dump(list);\n    skip_list_destory(list);\n\n    return 0;\n}\n```\n</details>\n\n\n#### 2.1.5 栈\n&emsp;栈按照后进先出(LIFO)的顺序存储和检索数据的数据结构，检索元素的顺序和存储元素顺序相反。\n&emsp;可通过链表来实现栈stack,允许插入和删除的为栈顶(`top`),另一端为栈底(`bottom`),栈中每个元素为`frame`,栈只支持三个操作:`pop`,`top`,`push`.\n```c\ntypedef List Stack;\n\n#define stack_init list_init;\nint stack_push(Stack *stack, const void *data);\nint stack_pop(Stack *stack, void **data);\n#define stack_peek(stack) ((stack)->head == NULL ? NULL : (stack)->head->data);\n#define stack_size list_size;\n```\n&emsp;c语言顺序栈\n```c\n// 元素elem进栈\nint push(char *a, int top, char elem) {\n    a[++top] = elem;\n    return top;\n}\n// 数据元素出栈\nint pop(char *a, int top)\n{\n    if (top == -1) {\n        return -1;\n    }\n\n    top--;\n    return top;\n}\n```\n\n\n<details>\n<summary>arrayStack</summary>\n\n```c\n/*************************************************************************\n > File Name: arrayStack\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-10-12\n > Desc:   数组实现顺序栈 \n ************************************************************************/\n#ifndef ARRAY_STACJ_H\n#define ARRAY_STACJ_H\n\ntypedef struct _array_stack {\n    int size;/*栈的大小*/\n    int pos;/*当前存储元素的个数，即栈顶元素下表*/\n    int *array;/*数据存储区*/\n}stArrayStack;\n\n#define arrayStack_size(arrayStack) (arrayStack->size)\n#define arrayStack_is_empty(arrayStack) (arrayStack->pos == -1)\n#define arrayStack_is_full(arrayStack)  (arrayStack->pos == (arrayStack->size-1))\n\n#endif\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include\"./arrayStack.h\"\n\n/*创建并初始化顺序栈*/\nstArrayStack * arrayStack_create(int size)\n{\n    stArrayStack *parrStack = NULL;\n\n    parrStack = (stArrayStack *)malloc(sizeof(stArrayStack));\n    if (parrStack == NULL) {\n        return NULL;\n    }\n    \n    parrStack->size = size;\n    parrStack->pos = -1;\n    parrStack->array = (int *)malloc(sizeof(int)*size);\n    if(parrStack->array == NULL) {\n        free(parrStack);\n        return NULL;\n    }\n\n    return parrStack;\n}\n/*销毁顺序栈*/\nvoid arrayStack_destory(stArrayStack * parrStack)\n{\n    if(parrStack == NULL) {\n        return;\n    }\n\n    if (parrStack->array != NULL) {\n        free(parrStack->array);\n    }\n\n    free(parrStack);\n    return;\n}\n/*出栈*/\nint arrayStack_pop(stArrayStack *parrStack)\n{\n    int data = 0;\n\n    if(arrayStack_is_empty(parrStack)) {\n        return -1;\n    }\n    data = parrStack->array[parrStack->pos];\n    parrStack->pos--;\n\n    return data;\n}\n/*入栈*/\nint arrayStack_push(stArrayStack *parrStack,int data)\n{\n    if(arrayStack_is_full(parrStack)) {\n        return -1;\n    }\n\n    parrStack->pos++;\n    parrStack->array[parrStack->pos] = data;\n\n    return 0;\n}\n\nint arrayStack_push_new(stArrayStack*parrStack,int data)\n{\n    int *ptmp = NULL;\n\n    /*如果栈不满，直接插入*/\n    if(!arrayStack_is_full(parrStack)) {\n        return arrayStack_push(parrStack,data);\n    }\n\n    /*如果栈已经满，申请内存*/\n    ptmp = (int *)malloc(2*parrStack->size*sizeof(int));\n    if (ptmp == NULL) {\n        return -1;\n    }\n\n    memcpy(ptmp,parrStack->array,parrStack->size*sizeof(int));\n\n    free(parrStack->array);\n\n    parrStack->array = ptmp;\n    parrStack->size = 2*parrStack->size;\n    parrStack->pos++;\n    parrStack->array[parrStack->pos] = data;\n\n    return ;\n}\n\nvoid arrayStack_dump(stArrayStack *parrStack)\n{\n    int i = 0;\n\n    if (arrayStack_is_empty(parrStack)) {\n        printf(\"\\r\\n arrayStack is empty.\");\n        return;\n    }\n    printf(\"\\r\\narrayStack size = %d,pos= %d,\",\n    parrStack->size,parrStack->pos);\n    for(i = 0; i <= parrStack->pos; i++) {\n        printf(\"\\r\\narry[%d] = %d\",i,parrStack->array[i]);\n    }\n}\n\nint main()\n{\n    int i = 0;\n    int ret = 0;\n    stArrayStack * parrStack = NULL;\n\n    printf(\"\\r\\n create size = 4 arrayStack.\");\n\n    parrStack = arrayStack_create(4);\n    if (parrStack == NULL) {\n        printf(\"\\r\\n create size = 4 arrayStack faided.\");\n        return 0;\n    }\n\n    for (i = 0; i < 5; i++) {\n        ret = arrayStack_push(parrStack,i);\n        if(ret != 0) {\n            printf(\"\\r\\n push size = %d arrayStack faided.\",i);\n        }\n    }\n    arrayStack_dump(parrStack);\n    \n    ret = arrayStack_push_new(parrStack,4);\n    if(ret != 0) {\n        printf(\"\\r\\n push size = %d arrayStack faided.\",4);\n    }\n    arrayStack_dump(parrStack);\n    arrayStack_destory(parrStack);\n    \n    return;\n}\n```\n</details>\n\n\n&emsp;链栈\n```c\ntypedef struct lineStack {\n    char data;\n    struct lineStack *next;\n}lineStack;\n\nlineStack* push(lineStack * stack, char a){\n    lineStack * line=(lineStack*)malloc(sizeof(lineStack));\n    line->data=a;\n    line->next=stack;\n    stack=line;\n    return stack;\n}\n\nlineStack * pop(lineStack * stack){\n    if (stack) {\n        lineStack * p=stack;\n        stack=stack->next;\n        printf(\"弹栈元素：%c \",p->data);\n        if (stack) {\n            printf(\"栈顶元素：%c\\n\",stack->data);\n        } else {\n            printf(\"栈已空\\n\");\n        }\n        free(p);\n    } else {\n        printf(\"栈内没有元素\");\n        return stack;\n    }\n    return stack;\n}\n```\n\n<details>\n<summary>linklist_stack</summary>\n\n```c\n/*************************************************************************\n > File Name: linklist_stack\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-10-12\n > Desc:    \n ************************************************************************/\n\n#ifndef STACK_LINK_LIST_H\n#define STACK_LINK_LIST_H\n\ntypedef struct _linkliststack {\n    int data;\n    struct _linkliststack *next;\n}linklist_stack;\n\n\n#define stack_is_empty(liststack) (liststack->next == NULL)\n\n#endif\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include \"./linklist_stack.h\"\n\nlinklist_stack * stack_create()\n{\n    linklist_stack * stack = NULL;\n    stack = (linklist_stack *)malloc(sizeof(linklist_stack));\n    if (stack == NULL) {\n        return NULL;\n    }\n    stack->next = NULL;\n\n    return stack;\n}\n\nvoid stack_destory(linklist_stack* stack)\n{\n    linklist_stack * ptmp = NULL;\n\n    while(!stack_is_empty(stack)) {\n        ptmp = stack->next;\n        stack->next = stack->next->next;\n        free(ptmp);\n    }\n\n    free(stack);\n\n    return;\n}\n\nint stack_push(linklist_stack *stack,int data)\n{\n    linklist_stack * ptmp = NULL;\n\n    ptmp = (linklist_stack *)malloc(sizeof(linklist_stack));\n    if (ptmp == NULL) {\n        return -1;\n    }\n\n    ptmp->data = data;\n    ptmp->next = stack->next;\n    stack->next = ptmp;\n\n    return 0;\n}\n\nint stack_pop(linklist_stack*stack,int *data)\n{\n    linklist_stack *ptmp = NULL;\n    if (data == NULL) {\n        return -1;\n    }\n    if(stack_is_empty(stack)) {\n        return -1;    \n    }\n    *data = stack->next->data;\n    ptmp = stack->next;\n    stack->next = ptmp->next;\n    free(ptmp);\n\n    return 0;\n}\n\nvoid stack_dump(linklist_stack *stack)\n{\n    linklist_stack * ptmp = stack->next;\n    \n    while(ptmp != NULL) {\n        printf(\"\\r\\n data = %d\",ptmp->data);\n        ptmp = ptmp->next;\n    }\n    return;\n}\n\nint main()\n{\n    int i = 0;\n    int ret = 0;\n    int data = 0;\n    linklist_stack * stack = NULL;\n\n    stack = stack_create();\n    if (stack == NULL) {\n        printf(\"\\r\\n stack create falied.\");\n        return 0;    \n    }\n    \n    for (i = 0; i < 4; i++) {\n        ret = stack_push(stack,i);\n        if(ret != 0) {\n            printf(\"\\r\\n stack push %d falied.\",i);\n        }\n    }\n\n    stack_dump(stack);\n\n    for (i = 0; i < 5; i++) {\n        ret = stack_pop(stack,&data);\n        if(ret != 0) {\n            printf(\"\\r\\n stack pop%d falied.\", i);\n        } else {\n            printf(\"\\r\\n data = %d,\",data);\n        }\n    }\n\n    stack_destory(stack);\n\n    return 0;\n\n}\n```\n</details>\n\n\n#### 2.1.6 队列\n&emsp;队列，在前端(`front`)进行删除操作，后端(`rear`)进行插入操作; 按照先进先出(`FIFO`)的顺序存储和检索数据的高效数据结构，按照元素的存储顺序检索元素。\n&emsp;队列也可通过数组和链表实现。\n```c\ntypedef List Queue;\n\n#define queue_init list_init;\n#define queue_destroy list_destroy;\nint queue_enqueue(Queue *queue, const void *data);\nint queue_dequeue(Queue *queue, void **data);\n#define queue_peek(queue) ((queue)->head == NULL ? NULL : (queue)->head->data);\n#define queue_size list_size;\n```\n\n<details>\n<summary>array_queue</summary>\n\n```c\n/*************************************************************************\n > File Name: array_queue\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-10-12\n > Desc:    \n ************************************************************************/\n#ifndef ARRAY_QUEUE_H\n#define ARRAY_QUEUE_H\n\ntypedef struct _array_queue {\n    int size;/*队列的大小*/\n    int num; /*当前存储数据的大小*/\n    int head;/*队列的头*/\n    int tail;/*队列的尾*/\n    int *array;/*数据存储区*/\n}array_queue;\n\n#define array_queue_is_empty(array_queue) (array_queue->num == 0)\n#define array_queue_is_full(array_queue)  ((array_queue->num) == (array_queue->size))\n\n#endif\n\n\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include\"./array_queue.h\"\n\n\narray_queue * array_queue_create(int size)\n{\n    array_queue * queue = NULL;\n\n    queue = (array_queue*)malloc(sizeof(array_queue));\n    if (queue == NULL) {\n        return NULL;\n    }\n    queue->array = (int *)malloc(sizeof(int)*size);\n    if (queue->array == NULL) {\n        free(queue);\n        return NULL;\n    }\n    queue->size  = size;\n    queue->num   = 0;\n    queue->head  = 0;\n    queue->tail  = 0;\n\n    return queue;\n}\n\nvoid array_queue_destory(array_queue *queue)\n{\n    if (queue == NULL) {\n        return;\n    }\n\n    if (queue->array != NULL) {\n        free(queue->array);\n    }\n\n    free(queue);\n    return;\n}\n\n/*入队列 */\nint array_queue_enqueue(array_queue *queue,int data)\n{\n    /*队列为空，或者队列满时，返回-1*/\n    if ((queue == NULL) || (array_queue_is_full(queue))) {\n        return -1;\n    }\n\n    queue->num++;\n    queue->array[queue->tail] = data;\n    queue->tail = (queue->tail + 1) % queue->size;\n\n    return 0;\n}\n\n/*出队列*/\nint array_queue_dequeue(array_queue * queue,int *data)\n{\n    /*队列为空，数据存储为空，队列为空时返回-1*/\n    if ((queue == NULL) || (data == NULL) || (array_queue_is_empty(queue))) {\n        return -1;\n    }\n    *data = queue->array[queue->head];\n    queue->num--;\n    queue->head = (queue->head + 1) % queue->size;\n\n    return 0;\n}\n\nvoid array_queue_dump(array_queue *queue)\n{\n    int i = 0;\n    int pos = 0;\n\n    if ((queue == NULL) || (array_queue_is_empty(queue))) {\n        printf(\"\\r\\n queue is empty\");\n        return;\n    }\n\n    printf(\"\\r\\n size:%d,num:%d,head:%d,tali:%d\",\n    queue->size,queue->num,queue->head,queue->tail);\n    for (i = 0; i < queue->num; i ++) {\n        pos = (queue->head + i) %queue->size;\n        printf(\"\\r\\n array[%d] = %d\",pos,queue->array[pos]);\n    }\n    return;\n}\n\nint main()\n{\n    int i = 0;\n    int ret = 0;\n    int data = 0;\n    array_queue * queue = NULL;\n\n    queue = array_queue_create(4);\n    if (queue == NULL) {\n        printf(\"\\r\\n queue is create failed.\");\n        return 0;\n    }\n    /*队列时空时，出队返回错误*/\n    ret = array_queue_dequeue(queue, &data);\n    if (ret != 0) {\n        printf(\"\\r\\n queue %d dequeue failed.\",ret);\n    }\n\n    /*队列大小是4，入队5个，最后一个报错*/\n    for (i = 0; i < 5; i++) {\n        ret = array_queue_enqueue(queue,i);\n        if (ret != 0) {\n            printf(\"\\r\\n queue %d enqueue failed.\",i);\n        }\n    }\n\n    array_queue_dump(queue);\n    \n    ret = array_queue_dequeue(queue, &data);\n    if (ret != 0) {\n        printf(\"\\r\\n queue %d dequeue failed.\",i);\n    }\n    printf(\"\\r\\n queue %d dequue.\",data);\n    array_queue_dump(queue);\n    data = 5;\n    printf(\"\\r\\n queue %d enqueue.\",data);\n    ret = array_queue_enqueue(queue,data);\n    if (ret != 0) {\n        printf(\"\\r\\n queue %d enqueue failed.\",data);\n    }\n    array_queue_dump(queue);\n    \n    array_queue_destory(queue);\n    return 0;\n\n}\n```\n</details>\n\n<details>\n<summary>list_queue</summary>\n\n```c\n#ifndef LINK_LIST_QUEUE_H\n#define LINK_LIST_QUEUE_H\n\ntypedef struct _list_queue_node {\n    void *data;\n    struct _list_queue_node *next;\n}queue_node;\n\ntypedef struct _list_queue {\n    int num;\n    queue_node *head;\n    queue_node *tail;\n}list_queue;\n\n#define list_queue_is_empty(queue) ((queue->num) == 0)\nlist_queue *list_queue_create();\nint list_queue_enqueue(list_queue *queue,void *data);\nint list_queue_dequeue(list_queue *queue,void **data);\n\n#endif\n//\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include\"./list_queue.h\"\n\n/*创建队列头*/\nlist_queue *list_queue_create()\n{\n    list_queue * queue = NULL;\n\n    queue = (list_queue *)malloc(sizeof(list_queue));\n    if(queue == NULL) {\n        return NULL;\n    }\n    queue->num  = 0;\n    queue->head = NULL;\n    queue->tail = NULL;\n\n    return queue;\n}\n/*入队*/\nint list_queue_enqueue(list_queue *queue,void *data)\n{\n    queue_node *ptmp = NULL;\n    if(queue == NULL) {\n        return -1;\n    }\n    ptmp = (queue_node *)malloc(sizeof(queue_node));\n    if (ptmp == NULL) {\n        return -1;\n    }\n\n    ptmp->data = data;\n    ptmp->next = NULL;\n    if (queue->head == NULL) {\n        queue->head = ptmp;\n    } else {\n        queue->tail->next = ptmp;\n    }\n    queue->tail = ptmp;\n    queue->num++;\n\n    return 0;\n}\n\n/*出队*/\nint list_queue_dequeue(list_queue *queue,void **data)\n{\n    queue_node * ptmp = NULL;\n    if ((queue == NULL) || (data == NULL) || list_queue_is_empty(queue)) {\n        return -1;\n    }\n    *data = queue->head->data;\n    ptmp = queue->head;\n    queue->head = queue->head->next;\n    queue->num--;\n    if (queue->head == NULL) {\n        queue->tail = NULL;\n    }\n\n    free(ptmp);\n    return 0;\n}\n```\n</details>\n\n\n<details>\n<summary>ring_queue</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nstruct ring_queue {\n    int cap;\n    int head, tail;\n    int *_q;\n};\n\nint alloc_queue(struct ring_queue* queue, int cap)\n{\n    if (!queue || cap < 0)\n    return -1;\n    if (queue->_q)\n    return -1;\n\n    queue->_q = (int *)malloc(cap * sizeof(int));\n    if (!queue->_q)\n    return -1;\n\n    queue->head = queue->tail = 0;\n    queue->cap = cap;\n    return 0;\n}\n\nvoid free_queue(struct ring_queue *queue)\n{\n    queue->cap = 0;\n    queue->head = queue->tail = 0;\n    free(queue->_q);\n}\n\nint _valid_index(int curr, int step, int cap)\n{\n    return (curr + step) % cap;\n}\n\nint _next(int curr, int cap)\n{\n    return _valid_index(curr, 1, cap);\n}\n\nbool is_empty(struct ring_queue *queue)\n{\n    return (queue->head == queue->tail);\n}\n\nbool is_full(struct ring_queue *queue)\n{\n    int next_tail = _next(queue->tail, queue->cap);\n    return (next_tail == queue->head);\n}\n\nint enqueue(struct ring_queue* queue, int elem)\n{\n    if (is_full(queue))\n    return -1;\n\n    queue->_q[queue->tail] = elem;\n    queue->tail = _next(queue->tail, queue->cap);\n    return 0;\n}\n\nint dequeue(struct ring_queue* queue, int *elem)\n{\n    if (is_empty(queue))\n    return -1;\n\n    if (elem)\n    *elem = queue->_q[queue->head];\n    queue->head = _next(queue->head, queue->cap);\n    return 0;\n}\n\nint size(struct ring_queue* queue)\n{\n    int size = queue->tail - queue->head;\n\n    if (size < 0)\n    size += queue->cap;\n    return size;\n}\n\nvoid dump(struct ring_queue* queue)\n{\n    int i, idx;\n\n    printf(\"Queue has %d elements with %d capacity\\n\",\n    size(queue), queue->cap);\n    for (i = 0; i < size(queue); i++) {\n        idx = _valid_index(queue->head, i, queue->cap);\n        printf(\"[%02d]: %08d\\n\", idx, queue->_q[idx]);\n    }\n}\n\nint main()\n{\n    struct ring_queue queue = {0, 0, 0, NULL};\n    int i;\n\n    if (alloc_queue(&queue, 8)) {\n        printf(\"Failed to allocate a queue\\n\");\n        return -1;\n    }\n\n    printf(\"A new queue is %s\\n\", is_empty(&queue)?\"empty\":\"not empty\");\n\n    enqueue(&queue, 1);\n    printf(\"After enqueue 1 element, queue is %s\\n\", is_empty(&queue)?\"empty\":\"not empty\");\n    dequeue(&queue, NULL);\n    printf(\"After dequeue 1 element, queue is %s\\n\", is_empty(&queue)?\"empty\":\"not empty\");\n\n    for (i = 0; i < 7; i++)\n    enqueue(&queue, i);\n    printf(\"After enqueue 7 element, queue is %s\\n\", is_full(&queue)?\"full\":\"not full\");\n\n    for (i = 0; i < 4; i++) {\n        dequeue(&queue, NULL);\n        enqueue(&queue, i);\n    }\n    printf(\"After enqueue/dequeue 4 element, queue is %s\\n\",\n    is_full(&queue)?\"full\":\"not full\");\n    printf(\"Head is %d, Tail is %d\\n\", queue.head, queue.tail);\n\n    dump(&queue);\n    free_queue(&queue);\n    return 0;\n}\n```\n</details>\n\n&ensp;队列应用：进程通信\n&emsp;消息队列提供了从一个进程向另一个进程发送一个数据块的方法.每个数据库都认为含有一个类型,接收进程可以独立地接收含有不同类型的数据结构.\n\n&emsp;linux内核 <sys/msg.h> 头文件中定义了消息队列结构\n```c\nstruct msqid_ds {\n    struct ipc_perm msg_perm;\n    struct msg* msg_first; // 指向队列中第一个消息\n    struct msg* msg_last; // 队列中最后一个消息\n    ...\n}\n```\n&emsp;Linux消息队列函数接口\n```c\n// 创建和访问一个消息队列\nint msgget(key_t key, int msgflg);\n// 把消息添加到消息队列中\nint msgsnd(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);\n// 从一个消息对立获取消息\nint msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg);\n// 控制消息队列\nint msgctl(int msgid, int command, struct msgid_ds *buf);\n```\n\n#### 2.1.7 leetcode题目\n- 重复N次的元素<数组>\n\n- 两数相加<链表>\n\n- 基本计算器<栈>\n\n- 设计循环队列<队列>\n\n### 2.2 哈希表\n&ensp;哈希表是一种最有效的检索方法，散列，从本质上看，一个哈希表包含一个数组，通过特殊的索引（键）来访问数组中的元素。哈希表主要思想是通过一个哈希函数，在所有可能的键和值直接建立映射表。\n&ensp;每个记录的关键字k通过一种函数H(k)计算出函数值.此函数为哈希函数或散列函数.\n\n#### 2.2.1 哈希函数设计\n- 直接地址法\n关键字是整数类型的数据,直接地址的哈希函数H直接利用关键字求得哈希地址.\nH(k) = aK*i + b\n\n- 数字分析法\n取关键字数中分布均匀的若干作为哈希地址\n\n- 平方取中法\n取关键字平方中间几位作为散列地址\n\n- 折叠法\n把关键字分割成位数相同的几段，段的位数取决于哈希地址的位数，然后将它们叠加和作为哈希地址\n\n- 除留取余法\n关键字K除以一个合适的不大于哈希表长度的正整数P,所得余数作为哈希地址.\nH(K) = K MOD P\n\n<details>\n<summary>uthash用法</summary>\n\n```c\n/*************************************************************************\n > File Name: listhash.h\n > Author:  jinshaohui\n > Mail:    jinshaohui789@163.com\n > Time:    18-11-06\n > Desc: 根据linux内核模块hashtab编写用户层hashtab接口\n         linux-4.19.1\\security\\selinux\\ss\\hashtab.c\n     linux-4.19.1\\security\\selinux\\ss\\hashtab.h\n ************************************************************************/\n#ifndef __HASHTAB_H__\n#define __HASHTAB_H__\n\n\ntypedef struct _hashtab_node {\n    void * key;\n    void * data;\n    struct _hashtab_node *next;\n}hashtab_node;\n\ntypedef struct _hashtab {\n    hashtab_node **htables; /*哈希桶*/\n    int size;              /*哈希桶的最大数量*/\n    int nel;               /*哈希桶中元素的个数*/\n    int (*hash_value)(struct _hashtab *h,const void *key); /*哈希函数*/\n    int (*keycmp)(struct _hashtab *h,const void *key1,const void *key2);/*哈希key比较函数，当哈希数值一致时使用*/\n    void (*hash_node_free)(hashtab_node *node);\n}hashtab;\n\n\n#define HASHTAB_MAX_NODES  (0xffffffff)\n\ntypedef int (*hash_key_func)(struct _hashtab *h,const void *key); /*哈希函数*/\ntypedef int (*keycmp_func)(struct _hashtab *h,const void *key1,const void *key2);/*哈希key比较函数，当哈希数值一致时使用*/\ntypedef void (*hash_node_free_func)(hashtab_node *node);\n/*根据当前结构体元素的地址，获取到结构体首地址*/\n#define offsetof(TYPE,MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#define container(ptr,type,member) ({\\\n  const typeof( ((type *)0)->member) *__mptr = (ptr);\\\n  (type *) ( (char *)__mptr - offsetof(type,member));})\n\n\nhashtab * hashtab_create(int size,hash_key_func hash_value,\n        keycmp_func keycmp,hash_node_free_func hash_node_free);\nvoid hashtab_destory(hashtab *h);\nint hashtab_insert(hashtab * h,void *key,void *data);\nhashtab_node *hashtab_delete(hashtab *h, void *key);\nvoid *hashtab_search(hashtab*h,void *key);\n\n#endif\n\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#include\"listhash.h\"\n\n#ifdef MEMORY_TEST\n#include<mcheck.h>\n#endif\n\nhashtab * hashtab_create(int size,hash_key_func hash_value,\n    keycmp_func keycmp,hash_node_free_func hash_node_free)\n{\n    hashtab * h = NULL;\n    int i = 0;\n\n    if ((size < 0) || (hash_value == NULL) || (keycmp == NULL)) {\n    return NULL;\n    }\n\n    h = (hashtab *)malloc(sizeof(hashtab));\n    if (h == NULL) {\n        return NULL;\n    }\n\n    h->htables = (hashtab_node **)malloc(size * sizeof(hashtab_node*));\n    if (h->htables == NULL) {\n        return NULL;\n    }\n\n    h->size = size;\n    h->nel = 0;\n    h->hash_value = hash_value;\n    h->keycmp = keycmp;\n    h->hash_node_free = hash_node_free;\n    \n    for (i = 0; i < size; i++) {\n        h->htables[i] = NULL;\n    }\n\n    return h;\n}\n\nvoid hashtab_destory(hashtab *h)\n{\n    int i = 0;\n    hashtab_node * cur = NULL;\n    hashtab_node * tmp = NULL;\n\n    if (h == NULL) {\n        return;\n    }\n\n    for (i = 0; i <h->size; i++) {\n        cur = h->htables[i];\n        while (cur != NULL) {\n            tmp = cur;\n            cur = cur->next;\n            h->hash_node_free(tmp);\n        }\n        h->htables[i] = NULL;\n    }\n    \n    free(h->htables);\n    free(h);\n    return;\n}\n\nint hashtab_insert(hashtab * h,void *key,void *data)\n{\n    unsigned int hvalue = 0;\n    int i = 0;\n    hashtab_node *cur = NULL; \n    hashtab_node *prev = NULL; \n    hashtab_node *newnode = NULL;\n\n    if ((h == NULL) || (key == NULL) || (data == NULL)) {\n        return 1;\n    }\n\n    /*获取hash 数值*/\n    hvalue = h->hash_value(h,key);\n    cur = h->htables[hvalue];\n\n    /*hash桶中元素是从小到大排列的，找到要插入的位置*/\n    while((cur != NULL) && (h->keycmp(h,key,cur->key) > 0)) {\n        prev = cur;\n        cur = cur->next;\n    }\n\n    /*如果key和当前key比对一致，直接返回，数据已经存在*/\n    if ((cur != NULL) && (h->keycmp(h,key,cur->key) == 0)) {\n        return 2;\n    }\n\n    newnode = (hashtab_node *)malloc(sizeof(hashtab_node));\n    if (newnode == NULL) {\n        return 3;\n    }\n\n    newnode->key = key;\n    newnode->data = data;\n    if (prev == NULL) {\n        newnode->next = h->htables[hvalue];\n        h->htables[hvalue] = newnode;\n    } else {\n        newnode->next = prev->next;\n        prev->next = newnode;\n    }\n\n    h->nel++;\n    return 0;\n}\n\nhashtab_node *hashtab_delete(hashtab *h, void *key)\n{\n    int hvalue = 0;\n    int i = 0;\n    hashtab_node *cur = NULL; \n    hashtab_node *prev = NULL; \n    \n    if ((h == NULL) || (key == NULL)) {\n        return NULL;\n    }\n\n    /*获取hash 数值*/\n    hvalue = h->hash_value(h,key);\n    cur = h->htables[hvalue];\n    /*hash桶中元素是从小到大排列的，找到要插入的位置*/\n    while((cur != NULL) && (h->keycmp(h,key,cur->key) >= 0)) {\n        if (h->keycmp(h,key,cur->key) == 0) {\n            if (prev == NULL) {\n                        h->htables[hvalue] = cur->next;\n            } else {\n                        prev->next = cur->next;\n            }\n            return cur;\n        }\n        prev = cur;\n        cur = cur->next;\n    }\n\n    return NULL;\n}\n\nvoid *hashtab_search(hashtab*h,void *key)\n{\n    int hvalue = 0;\n    int i = 0;\n    hashtab_node *cur = NULL; \n    \n    if ((h == NULL) || (key == NULL)) {\n        return NULL;\n    }\n\n    /*获取hash 数值*/\n    hvalue = h->hash_value(h,key);\n    cur = h->htables[hvalue];\n    /*hash桶中元素是从小到大排列的，找到要插入的位置*/\n    while((cur != NULL) && (h->keycmp(h,key,cur->key) >= 0)) {\n        if (h->keycmp(h,key,cur->key) == 0) {\n            return cur->data;\n        }\n        cur = cur->next;\n    }\n\n    return NULL;\n}\n\nvoid hashtab_dump(hashtab *h)\n{\n    int i = 0;\n    hashtab_node * cur = NULL;\n\n    if (h == NULL) {\n        return ;\n    }\n\n    printf(\"\\r\\n----开始--size[%d],nel[%d]------------\",h->size,h->nel);\n    for( i = 0; i < h->size; i ++) {\n        printf(\"\\r\\n htables[%d]:\",i);\n        cur = h->htables[i];\n        while((cur != NULL)) {\n            printf(\"key[%s],data[%s] \",cur->key,cur->data);    \n            cur = cur->next;\n        }\n    }\n\n    printf(\"\\r\\n----结束--size[%d],nel[%d]------------\",h->size,h->nel);\n}\n\nstruct test_node\n{\n    char key[80];\n    char data[80];\n};\n\nunsigned int siample_hash(const char *str)\n{\n    register unsigned int hash = 0;\n    register unsigned int seed = 131;\n\n    while(*str) {\n        hash = hash*seed + *str++;\n    }\n\n    return hash & (0x7FFFFFFF);\n}\n\nint hashtab_hvalue(hashtab *h,const void *key)\n{\n    return (siample_hash(key) % h->size);\n}\n\nint hashtab_keycmp(hashtab *h,const void *key1,const void *key2)\n{\n    return strcmp(key1,key2);\n}\n\nvoid hashtab_node_free(hashtab_node*node)\n{\n    struct test_node * ptmp = NULL;\n    ptmp = container(node->key,struct test_node,key);\n\n    free(ptmp);\n    free(node);\n}\n\nint main ()\n{\n    \n    int i = 0;\n    int res = 0;\n    char *pres = NULL;\n    hashtab_node * node = NULL;\n    struct test_node *p = NULL;\n    hashtab *h = NULL;\n    #ifdef MEMORY_TEST\n    setenv(\"MALLOC_TRACE\",\"1.txt\",1);\n    mtrace();\n    #endif\n\n    h = hashtab_create(5,hashtab_hvalue,hashtab_keycmp,hashtab_node_free);\n    assert(h!= NULL);\n    while(1) {\n        p = (struct test_node*)malloc(sizeof(struct test_node));\n        assert(p != NULL);\n        printf(\"\\r\\n 请输入key 和value，当可以等于\\\"quit\\\"时退出\");\n            scanf(\"%s\",p->key);\n        scanf(\"%s\",p->data);\n\n        if(strcmp(p->key,\"quit\") == 0) {\n            free(p);\n            break;\n        }\n\n        res = hashtab_insert(h,p->key,p->data);\n        if (res != 0) {\n            free(p);\n            printf(\"\\r\\n key[%s],data[%s] insert failed %d\",p->key,p->data,res);\n        } else {\n            printf(\"\\r\\n key[%s],data[%s] insert success %d\",p->key,p->data,res);\n        }\n    }\n\n    hashtab_dump(h);\n\n    while(1) {\n        p = (struct test_node*)malloc(sizeof(struct test_node));\n        assert(p != NULL);\n        printf(\"\\r\\n 请输入key 查询value的数值，当可以等于\\\"quit\\\"时退出\");\n            scanf(\"%s\",p->key);\n\n        if(strcmp(p->key,\"quit\") == 0) {\n            free(p);\n            break;\n        }\n        pres = hashtab_search(h,p->key);\n        if (pres == NULL) {\n            printf(\"\\r\\n key[%s] search data failed\",p->key);\n        } else {\n            printf(\"\\r\\n key[%s],search data[%s] success\",p->key,pres);\n        }\n        free(p);\n    }\n    hashtab_dump(h);\n    while(1) {\n        p = (struct test_node*)malloc(sizeof(struct test_node));\n        assert(p != NULL);\n        printf(\"\\r\\n 请输入key 删除节点的数值，当可以等于\\\"quit\\\"时退出\");\n            scanf(\"%s\",p->key);\n\n        if(strcmp(p->key,\"quit\") == 0) {\n            free(p);\n            break;\n        }\n        node = hashtab_delete(h,p->key);\n        if (node == NULL) {\n            printf(\"\\r\\n key[%s] delete node failed \",p->key);\n        } else {\n            printf(\"\\r\\n key[%s],delete data[%s] success\",node->key,node->data);\n            h->hash_node_free(node);\n        }\n        free(p);\n        hashtab_dump(h);\n    }\n\n    hashtab_destory(h);\n    #ifdef MEMORY_TEST\n        muntrace();\n    #endif\n    return 0;\n}\n```\n</details>\n\n\n<details>\n<summary>hash_table</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n\n/* One implementation of hash table with linear probing. */\n\n#define HASH_SHIFT 4\n#define HASH_SIZE (1 << HASH_SHIFT)\n#define HASH_MASK (HASH_SIZE - 1)\n\nstruct hash_table {\n    unsigned int  used;\n    unsigned long entry[HASH_SIZE];\n};\n\nvoid hash_table_reset(struct hash_table *table)\n{\n    int i;\n\n    table->used = 0;\n    for (i = 0; i < HASH_SIZE; i++)\n    table->entry[i] = ~0;\n}\n\nunsigned int hash_function(unsigned long value)\n{\n    return value & HASH_MASK;\n}\n\nvoid dump_hash_table(struct hash_table *table)\n{\n    int i;\n\n    for (i = 0; i < HASH_SIZE; i++) {\n        if (table->entry[i] == ~0)\n            printf(\"%2u:       nil \\n\", i);\n        else\n            printf(\"%2u:%10lu -> %2u\\n\",\n        i, table->entry[i],\n        hash_function(table->entry[i]));\n    }\n}\n\nvoid hash_function_test()\n{\n    int i;\n\n    srandom(time(NULL));\n\n    for (i = 0; i < 10; i++) {\n        unsigned long val = random();\n        printf(\"%10lu -> %2u\\n\", val, hash_function(val));;\n    }\n}\n\nunsigned int next_probe(unsigned int prev_key)\n{\n    return (prev_key + 1) & HASH_MASK;\n}\n\nvoid next_probe_test()\n{\n    int i;\n    unsigned int key1, key2;\n\n    key1 = 0;\n    for (i = 0; i < HASH_SIZE; i++) {\n        key2 = next_probe(key1);\n        printf(\"%2u -> %2u\\n\", key1, key2);\n        key1 = key2;\n    }\n}\n\nvoid hash_table_add(struct hash_table *table, unsigned long value)\n{\n    unsigned int key = hash_function(value);\n\n    if (table->used >= HASH_SIZE)\n        return;\n\n    while (table->entry[key] != ~0)\n        key = next_probe(key);\n\n    table->entry[key] = value;\n    table->used++;\n}\n\nunsigned int hash_table_slot(struct hash_table *table, unsigned long value)\n{\n    int i;\n    unsigned int key = hash_function(value);\n\n    for (i = 0; i < HASH_SIZE; i++) {\n        if (table->entry[key] == value || table->entry[key] == ~0)\n            break;\n        key = next_probe(key);\n    }\n\n    return key;\n}\n\nbool hash_table_find(struct hash_table *table, unsigned long value)\n{\n    return table->entry[hash_table_slot(table, value)] == value;\n}\n\nvoid hash_table_del(struct hash_table *table, unsigned long value)\n{\n    unsigned int i, j, k;\n\n    if (!hash_table_find(table, value))\n    return;\n\n    i = j = hash_table_slot(table, value);\n\n    while (true) {\n        table->entry[i] = ~0;\n\n        do {\n            j = next_probe(j);\n            if (table->entry[j] == ~0)\n                return;\n            k = hash_function(table->entry[j]);\n        } while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\n        table->entry[i] = table->entry[j];\n        i = j;\n    }\n    table->used++;\n}\n\nvoid hash_table_add_test()\n{\n    struct hash_table table;\n\n    hash_table_reset(&table);\n    hash_table_add(&table, 87645);\n\n    printf(\"Table has%s 87645\\n\",\n    hash_table_find(&table, 87645) ? \"\":\"n't\");\n    printf(\"Table has%s 87647\\n\",\n    hash_table_find(&table, 87647) ? \"\":\"n't\");\n}\n\nvoid hash_table_del_test1()\n{\n    struct hash_table table;\n\n    hash_table_reset(&table);\n    hash_table_add(&table, 0x1ff0);\n    hash_table_add(&table, 0x2ff0);\n    hash_table_add(&table, 0x3ff0);\n    dump_hash_table(&table);\n\n    printf(\"=== Remove 0x1ff0\\n\");\n    hash_table_del(&table, 0x1ff0);\n    dump_hash_table(&table);\n}\n\nvoid hash_table_del_test2()\n{\n    struct hash_table table;\n\n    hash_table_reset(&table);\n    hash_table_add(&table, 0x1ff0);\n    hash_table_add(&table, 0x1ff1);\n    hash_table_add(&table, 0x1ff2);\n    hash_table_add(&table, 0x2ff0);\n    dump_hash_table(&table);\n\n    printf(\"=== Remove 0x1ff0\\n\");\n    hash_table_del(&table, 0x1ff0);\n    dump_hash_table(&table);\n}\n\nint main()\n{\n    //hash_function_test();\n    //next_probe_test();\n    //hash_table_add_test();\n    hash_table_del_test2();\n\n    return 0;\n}\n```\n</details>\n\n\n#### 2.2.2 哈希冲突\n&ensp;理想情况下,哈希函数在关键字和地址之间建立一对一关系.但H(k1) = H(k2),即为冲突.\n\n&emsp;解决哈希冲突常用方法:\n- 链地址法\n将哈希值相同的元素构成一个同义词的单链表,并将单链表头指针存放在哈希表的地i个单元中,查找,插入和删除主要在同义词链表中.\n- 线性探测\n- 二次探测\n\n#### 2.2.3 uthash\n\n&ensp;uthash的插入、查找、删除的操作时间都是常量\n\n```c\n#include \"uthash.h\"\n\nstruct my_struct {\n    int id;            /* we'll use this field as the key */\n    char name[10];\n    UT_hash_handle hh; /* makes this structure hashable */\n};\n\nstruct my_struct *users = NULL;\n\nvoid add_user(struct my_struct *s) {\n    HASH_ADD_INT(users, id, s);\n}\n```\n\n<details>\n<summary>uthash用法</summary>\n\n```c\n#include <stdio.h>   /* gets */\n#include <stdlib.h>  /* atoi, malloc */\n#include <string.h>  /* strcpy */\n#include \"uthash.h\"\n\nstruct my_struct {\n    int id;                    /* key */\n    char name[10];\n    UT_hash_handle hh;         /* makes this structure hashable */\n};\n\nstruct my_struct *users = NULL;\n\nvoid add_user(int user_id, char *name) {\n    struct my_struct *s;\n\n    HASH_FIND_INT(users, &user_id, s);  /* id already in the hash? */\n    if (s==NULL) {\n        s = (struct my_struct *)malloc(sizeof *s);\n        s->id = user_id;\n        HASH_ADD_INT( users, id, s );  /* id: name of key field */\n    }\n    strcpy(s->name, name);\n}\n\nstruct my_struct *find_user(int user_id) {\n    struct my_struct *s;\n\n    HASH_FIND_INT(users, &user_id, s);  /* s: output pointer */\n    return s;\n}\n\nvoid delete_user(struct my_struct *user) {\n    HASH_DEL(users, user);  /* user: pointer to deletee */\n    free(user);\n}\n\nvoid delete_all() {\n    struct my_struct *current_user, *tmp;\n\n    HASH_ITER(hh, users, current_user, tmp) {\n        HASH_DEL(users, current_user);  /* delete it (users advances to next) */\n        free(current_user);             /* free it */\n    }\n}\n\nvoid print_users() {\n    struct my_struct *s;\n\n    for(s=users; s != NULL; s=(struct my_struct*)(s->hh.next)) {\n        printf(\"user id %d: name %s\\n\", s->id, s->name);\n    }\n}\n\nint name_sort(struct my_struct *a, struct my_struct *b) {\n    return strcmp(a->name,b->name);\n}\n\nint id_sort(struct my_struct *a, struct my_struct *b) {\n    return (a->id - b->id);\n}\n\nvoid sort_by_name() {\n    HASH_SORT(users, name_sort);\n}\n\nvoid sort_by_id() {\n    HASH_SORT(users, id_sort);\n}\n\nint main(int argc, char *argv[]) {\n    char in[10];\n    int id=1, running=1;\n    struct my_struct *s;\n    unsigned num_users;\n\n    while (running) {\n        printf(\" 1. add user\\n\");\n        printf(\" 2. add/rename user by id\\n\");\n        printf(\" 3. find user\\n\");\n        printf(\" 4. delete user\\n\");\n        printf(\" 5. delete all users\\n\");\n        printf(\" 6. sort items by name\\n\");\n        printf(\" 7. sort items by id\\n\");\n        printf(\" 8. print users\\n\");\n        printf(\" 9. count users\\n\");\n        printf(\"10. quit\\n\");\n        gets(in);\n        switch(atoi(in)) {\n            case 1:\n                printf(\"name?\\n\");\n                add_user(id++, gets(in));\n                break;\n            case 2:\n                printf(\"id?\\n\");\n                gets(in); id = atoi(in);\n                printf(\"name?\\n\");\n                add_user(id, gets(in));\n                break;\n            case 3:\n                printf(\"id?\\n\");\n                s = find_user(atoi(gets(in)));\n                printf(\"user: %s\\n\", s ? s->name : \"unknown\");\n                break;\n            case 4:\n                printf(\"id?\\n\");\n                s = find_user(atoi(gets(in)));\n                if (s) delete_user(s);\n                else printf(\"id unknown\\n\");\n                break;\n            case 5:\n                delete_all();\n                break;\n            case 6:\n                sort_by_name();\n                break;\n            case 7:\n                sort_by_id();\n                break;\n            case 8:\n                print_users();\n                break;\n            case 9:\n                num_users=HASH_COUNT(users);\n                printf(\"there are %u users\\n\", num_users);\n                break;\n            case 10:\n                running=0;\n                break;\n        }\n    }\n\n    delete_all();  /* free any structures */\n    return 0;\n}\n```\n\n</details>\n\n- 参考链接\n官网:https://troydhanson.github.io/uthash/\nhttps://blog.csdn.net/fan_h_l/article/details/107241520\nhttps://blog.csdn.net/whatday/article/details/95926766\nhttps://www.cnblogs.com/pam-sh/p/12827658.html\n\n#### 2.2.4 leetcode题目\n- 设计哈希集合 \n\n- 设计哈希映射\n\n- 根据字符出现频率排序\n\n### 2.3 树与二叉树\n&emsp;树(tree)是一种用来模拟树状结构的抽象数据结构(ADT);\n\n&emsp;树的特点:\n- 没有父节点的节点称为根节点\n- 每个非根节点有且只有一个父节点\n- 除了根结点外,每个子节点可分为多个不相交的子树\n- 树中没有环路\n\n#### 2.3.1 概述\n- 节点的度: 一个节点含有子树的个数\n- 树的度: 树中最大的节点度\n- 叶节点: 度为零的节点\n- 父节点\n- 子节点\n- 兄弟节点\n- 节点的层次\n- 深度: 任意节点n,n的深度为从n到一片树叶的最长路径长,根的深度为0\n- 高度: 对任意节点n,n的高度为从n到一片树叶的最长路径长,所有树叶的高度为0.\n- 森林\n\n&emsp;树由称为结点的元素按照层次结构的方式组织而成。最顶端称为根。与根直接相连的结点称为根的子结点。子节点本身也可以有子结点。除根结点外，每个结点都有唯一的父结点。\n\n#### 2.3.2 树的种类\n- 无序树\n- 有序树\n   - 二叉树: 每个节点最多含有两个子树的树.\n      - 完全二叉树: 对于一颗深度为d的二叉树,除第d层外,其他各层节点数目均达最大值,且第d层所有节点从左向右连续紧密排列.\n         - 满二叉树:所有叶节点都最底层的完全二叉树.\n      - 平衡二叉树(AVL):当且仅当任何节点的两颗子树的高度差不大于1的二叉树.\n      - 排序二叉树:二叉查找树\n\n    - 霍夫曼树:带权路径最短的二叉树(又称最优二叉树).\n    - B树:一种堆读写操作进行优化的自平衡二叉查找树,能够保持数据有序,拥有多余两个子树.\n\n<br>\n\n|||\n|---|---|\n|二叉树|二叉查找树(BST) 笛卡尔树 MVP树 Top tree T树|\n|自平衡二叉查找树|AVL树 红黑树 加权平衡树 AA树 |\n|B树|B树 B+树|\n|堆| 二项堆 斐波那契堆|\n|Trie|后缀树 基数树 三叉查找树|\n\n&emsp;树有多种结构形式，包括二叉树、。\n\n#### 2.3.3 二叉树\n\n&ensp;二叉树两个条件:\n- 本身是有序树\n- 树中包含的各个节点的度不能超过2,即只能是0,1或者2\n\n&emsp;二叉树中结点包含三部分：一个数据成员两个左右指针。\n\n```c\ntypedef struct BiTreeNode_ {\n    void *data;\n    struct BiTreeNode_ *left;\n    struct BiTreeNode_ *right;\n}BiTreeNode;\n\ntypedef struct BiTree_ {\n    int size;\n    int (*compare)(const void *key1, const void *key2);\n    void (*destroy)(void *data);\n    BiTreeNode *root;\n}BiTree;\n\n/*树根*/\ntypedef struct tree{\n    Node * root;\n}Tree;\n```\n\n<details>\n<summary>二叉树</summary>\n\n```c\n#include<assert.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#include\"list_queue.h\"\n\ntypedef struct _treenode {\n    int data;\n    struct _treenode *lchild;\n    struct _treenode *rchild;\n}Tnode,Tree;\n\nvoid binarytree_create(Tree **Root)\n{\n    int a = 0;\n    printf(\"\\r\\n输入节点数值((当输入为100时，当前节点创建完成))):\");\n    scanf(\"%d\",&a);\n\n    if (a == 100) {\n        *Root = NULL;\n    } else {\n        *Root = (Tnode *)malloc(sizeof(Tnode));\n        if (*Root == NULL) {\n            return;\n        }\n\n        (*Root)->data = a;\n        printf(\"\\r\\n create %d 的左孩子:\",a);\n        binarytree_create(&((*Root)->lchild));\n        printf(\"\\r\\n create %d 的右孩子:\",a);\n        binarytree_create(&((*Root)->rchild));\n    }\n\n    return ;\n}\n\nvoid binarytree_destory(Tree *root)\n{\n    if (root == NULL) {\n        return;\n    }\n\n    binarytree_destory(root->lchild);\n    binarytree_destory(root->rchild);\n    free(root);\n}\n\n/*先序遍历:根结点--》左子树---》右子树*/\nvoid binarytree_preorder(Tree *root)\n{\n    if (root == NULL) {\n        return;\n    }\n    printf(\" %d \",root->data);\n    binarytree_preorder(root->lchild);\n    binarytree_preorder(root->rchild);\n    return;\n}\n/*中序遍历:左子树--》跟节点---》右子树*/\nvoid binarytree_inorder(Tree *root)\n{\n    if (root == NULL) {\n        return;\n    }\n    binarytree_inorder(root->lchild);\n    printf(\" %d \",root->data);\n    binarytree_inorder(root->rchild);\n    return;\n}\n/*后序遍历:左子树---》右子树-》根节点*/\nvoid binarytree_postorder(Tree *root)\n{\n    if (root == NULL) {\n        return;\n    }\n    binarytree_postorder(root->lchild);\n    binarytree_postorder(root->rchild);\n    printf(\" %d \",root->data);\n    return;\n}\n\nvoid binarytree_levelorder(Tree * root)\n{\n    list_queue *queue = NULL;\n    Tnode * node = NULL;\n    if(root == NULL) {\n        return;\n    }\n\n    queue = list_queue_create();\n\n    /*根节点先入队*/\n    list_queue_enqueue(queue,(void *)root);\n\n    while(!list_queue_is_empty(queue)) {\n        list_queue_dequeue(queue,(void *)&node);\n        printf(\" %d \",node->data);\n\n        if(node->lchild != NULL) {\n            list_queue_enqueue(queue,(void *)node->lchild);\n        }\n\n        if(node->rchild != NULL) {\n            list_queue_enqueue(queue,(void *)node->rchild);\n        }\n    }\n\n    free(queue);\n}\n/*打印叶子节点*/\nvoid binarytree_printfleaf(Tree *root)\n{\n    if (root == NULL) {\n        return;\n    }\n\n    if ((root->lchild == NULL) && (root->rchild == NULL)) {\n        printf(\" %d \",root->data);\n    } else {\n        binarytree_printfleaf(root->lchild);\n        binarytree_printfleaf(root->rchild);\n    }\n}\n/*打印叶子的个数*/\nint binarytree_getleafnum(Tree*root)\n{\n    if (root == NULL) {\n        return 0;\n    }\n\n    if ((root->lchild == NULL) && (root->rchild == NULL)) {\n        return 1;\n    }\n    \n    return binarytree_getleafnum(root->lchild) + binarytree_getleafnum(root->rchild);\n\n}\n/*打印数的高度*/\nint binarytree_gethigh(Tree *root)\n{\n    int lhigh = 0;\n    int rhigh = 0;\n    \n    if (root == NULL) {\n        return 0;\n    }\n\n    lhigh = binarytree_gethigh(root->lchild);\n    rhigh = binarytree_gethigh(root->rchild);\n\n    return ((lhigh > rhigh)?(lhigh + 1):(rhigh + 1));\n}\n\nint main()\n{\n    Tree *root = NULL;\n\n    setenv(\"MALLOC_TRACE\",\"1.txt\",1);\n    mtrace();\n    \n    printf(\"\\r\\n创建二叉树:\");\n    binarytree_create(&root);\n    printf(\"\\r\\n先序遍历二叉树:\");\n    binarytree_preorder(root);\n    printf(\"\\r\\n中序遍历二叉树:\");\n    binarytree_inorder(root);\n    printf(\"\\r\\n后序遍历二叉树:\");\n    binarytree_postorder(root);\n    printf(\"\\r\\n层次遍历二叉树:\");\n    binarytree_levelorder(root);\n\n    printf(\"\\r\\n打印二叉树叶子节点:\");\n    binarytree_printfleaf(root);\n    printf(\"\\r\\n打印二叉树叶子节点个数:%d\",binarytree_getleafnum(root));\n    printf(\"\\r\\n打印二叉树高度:%d\",binarytree_gethigh(root));\n\n    binarytree_destory(root);\n\n    muntrace();\n    return 0;\n}\n```\n</details>\n\n<details>\n<summary>binarytree</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n\n/* Implement binary tree in array */\n\n#define MAX_TREE_NODES (1 << 8)\n\nstruct node {\n    int data;\n};\n\nstruct binary_tree {\n    union {\n    unsigned long nodes;\n    struct node *n[MAX_TREE_NODES];\n    };\n};\n\nvoid init_binary_tree(struct binary_tree *tree)\n{\n    int i;\n\n    for(i = 0; i < MAX_TREE_NODES; i++) {\n        tree->n[i] = NULL;\n    }\n}\n\nstruct node* create_node(int data)\n{\n    struct node* n;\n\n    n = malloc(sizeof(struct node));\n\n    if (n)\n        n->data = data;\n\n    return n;\n}\n\nvoid fake_a_tree(struct binary_tree* tree)\n{\n    /* data is in ordered */\n    int i, data[10] = {7, 4, 9, 2, 6, 8, 10, 1, 3, 5};\n\n    init_binary_tree(tree);\n\n    /* root start at 1 */\n    for (i = 0; i < 10; i++)\n        tree->n[i+1] = create_node(data[i]);\n\n    tree->nodes = 10;\n}\n\nvoid _in_order(struct binary_tree* tree, int index)\n{\n    if (!tree->n[index])\n    return;\n\n    /* left child at (index << 1) */\n    _in_order(tree, index << 1);\n\n    printf(\"[%2d]: %4d\\n\", index, tree->n[index]->data);\n\n    /* right child at (index << 1) + 1 */\n    _in_order(tree, (index << 1) + 1);\n}\n\nvoid in_order(struct binary_tree* tree)\n{\n    _in_order(tree, 1);\n}\n\nint main()\n{\n    struct binary_tree tree;\n\n    fake_a_tree(&tree);\n    in_order(&tree);\n    return 0;\n}\n```\n</details>\n\n&ensp;二叉树性质:\n- 二叉树中,第i层最多有 2^(i-1)个节点\n- 如果二叉树的深度为K,则二叉树最多有`2^K - 1`个节点\n- 二叉树中，终端结点树(叶子节点树)为n0，度为2的节点树为n1，则 n0=n1+1\n\n**满二叉树**\n&emsp;如果二叉树中除了叶子节点，每个节点的度都为2，则此二叉树为满二叉树。\n\n\n**完全二叉树**\n&emsp;如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。\n\n\n&emsp;树的周游算法包含先序遍历、中序遍历、后序遍历和层序遍历。\n- 先序遍历：先访问根结点，然后左子树，最后右子结点。深度优先思想。\n- 中序遍历：先访问左子结点，然后根结点，最后右子结点。\n- 后序遍历：先访问左子结点，然后右子结点，最后根结点。\n- 层序遍历：先访问树的根结点，然后依次向下层处理，按照从左向右的顺序访问每层结点。广度优先的策略。\n\n\n#### 2.3.4 二叉查找树(BST)\n\n&ensp;二叉查找树也称二叉搜索树,有序二叉树或排序二叉树,具有性质:\n- 若任意节点左子树不为空,则左子树上所有节点的值均小于它的根节点的值\n- 若任意节点的右子树不为空,则右子树所有节点的值均大于根节点的值\n- 任意节点的左,右子树也分别为二叉查找树\n- 没有键值相等的节点\n\n\n&emsp;一颗二叉搜索树要插入一个结点，要从根结点开始，一层一层往下，适当地移动左或右子结点上，当到达树的分支尽头时，执行插入操作。\n&emsp;二叉搜索树是一种用于查找操作的高效数据结构，在最坏情况下，只需查找一个分支上的数据即可。**查找,插入**操作的复杂度是 `O(logn)`，**搜索,插入,删除**复杂度等于树高,期望`O(logn)`,最坏为`O(n)`,(树退化为线性表)n为树中结点数。\n&emsp;保持一棵树的平衡是指对于给定数量的结点，要使得树的高度尽可能短。\n\n\n&emsp;二叉查找树是由二叉树组成的专用于查找和搜索目的的一种数据结构。二叉搜索树中查找一个结点，从根结点开始一层一层向下查找，当遇到一个比目标结点值大的结点时，顺着该结点左子树继续查找，如果遇到的结点值小于目标结点，则顺着该结点的右子树查找，直到找到目标结点为止。\n\n&ensp;**查找算法**\n&emsp;&emsp;1.若b是空树,则搜索失败,否则;\n&emsp;&emsp;2.若x等于b的根节点的数据域之值,则查找成功;\n&emsp;&emsp;3.若x小于b的根节点的数据域之值,则搜索左子树\n&emsp;&emsp;4.查找右子树\n\n&ensp;**插入算法**\n&emsp;&emsp;1.若b是空树,则将s所指节点作为根节点插入;否则\n&emsp;&emsp;2.若`s->data`等于b的根节点的数据域值,则返回,否则;\n&emsp;&emsp;3.若`s->data`小于b的根节点的数据域之值,则把s所值节点插入到左子树中,否则\n&emsp;&emsp;4.把s所指节点插入到右子树中,(新插入节点总是叶子节点)\n\n&ensp;**删除算法**\n&emsp;&emsp;1.若*p节点为叶子节点,即PL(左子树)和PR(右子树)均为空树.由于删去叶子节点不破坏整棵树的结构,则只需修改其双亲节点的指针即可.\n\n<details>\n<summary>binarysearch</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define OK 1\n#define ERROR 0\n#define TRUE 1\n#define FALSE 0\ntypedef int Status;\ntypedef char ElemType;\n\ntypedef struct node {\n    ElemType data;\n    struct node *lchild, *rchild;\n} BTree, *BTreePtr;\n\n/**************** 插入 **********************/\nStatus Insert(BTreePtr *T, ElemType e) {\n\n    BTreePtr p;\n\n    if (*T == NULL) {\n        *T = (BTreePtr)malloc(sizeof(BTree));\n        (*T)->data = e;\n\n        return TRUE;\n    } else {\n        p = *T;\n        while ( p != NULL) {\n\n            if (e > p->data) {\n                if (p->rchild == NULL) {\n                    p->rchild = (BTreePtr) malloc (sizeof(BTree));\n                    p->rchild->data = e;\n                    return TRUE;\n                }\n                p = p->rchild;\n            } else {\n                if (p->lchild == NULL) {\n                    p->lchild = (BTreePtr) malloc (sizeof(BTree));\n                    p->lchild->data = e;\n                    return TRUE;\n                }\n                p = p->lchild;\n            }\n        }\n    }\n\n    return FALSE;\n}\n/**************** 删除 **********************/\nStatus Delete(BTreePtr T, ElemType e) {\n    BTreePtr p, pp, minP, minPP, child;\n    child = NULL;\n    p = T;\n    pp = NULL;\n\n    while ( (p != NULL) && (p->data != e) ) {\n        pp = p;\n\n        if (e > p->data) {\n            p = p->rchild;\n        } else {\n            p = p->lchild;\n        }\n    }\n\n    if (p == NULL) return FALSE;\n\n    //双节点\n    if ((p->lchild != NULL) && (p->rchild != NULL) {\n        minPP = p;\n        minP = p->rchild;\n\n        while (minP->lchild != NULL) {\n            minPP = minP;\n            minP = minP->lchild;\n        }\n        p->data = minP->data;\n        minPP->lchild = minP->rchild;\n        free(minP);\n\n        return TRUE;\n    }\n\n    //有一个节点\n    if ((p->lchild != NULL) || (p->rchild != NULL)) { //应该将原有的pp同child连接在一起\n\n        if (p->lchild) {\n            child = p->lchild;\n        } else {\n           child = p->rchild;\n        }\n        if(pp->data>p->data) {\n            pp->lchild=child;\n        } else {\n            pp->rchild=child;\n        }\n        free(p);\n        return TRUE;\n    }\n\n    //没有节点\n    if (pp->lchild == p) {//这里面临pp除p以外的节点为null的情况\n        pp->lchild = child;\n    } else {\n        pp->rchild = child;\n    }\n\n    return TRUE;\n}\n/**************** 查找 **********************/\nStatus Find(BTreePtr T, ElemType e) {\n\n    if (T == NULL) return FALSE;\n\n    while ((T != NULL) && (T->data != e)) {\n        if (e > T->data) {\n            T = T->rchild;\n        } else {\n            T = T->lchild;\n        }\n    }\n\n    if (T) {\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\n/**************** 最大值 **********************/\nElemType FindMax(BTreePtr T) {\n    ElemType max;\n    while(T != NULL) {\n        max = T->data;\n        T = T->rchild;\n    }\n    return max;\n}\n\n/**************** 最小值 **********************/\nElemType FindMin(BTreePtr T) {\n    ElemType min;\n    while(T != NULL) {\n        min = T->data;\n        T = T->lchild;\n    }\n    return min;\n}\n\nvoid PreOrderTraverse(BTreePtr T)//前序遍历二叉树\n{\n    if (T == NULL) return;\n\n    if(T) {\n        printf(\"%d \",T->data);\n        PreOrderTraverse(T->lchild);\n        PreOrderTraverse(T->rchild);\n    }\n}\n\nvoid DestroyTree(BTreePtr T) {\n    if (T) {\n        if (T->lchild) {\n            DestroyTree(T->lchild);\n        }\n\n        if(T->rchild) {\n            DestroyTree(T->rchild);\n        }\n\n        free(T);\n        T = NULL;\n    }\n}\n\n/***************** 执行测试 *************************/\nint main(int argc, char const *argv[])\n{\n    BTreePtr T;\n    T = NULL;\n    int a[] = {33, 16, 50, 13, 18, 34, 58, 15, 17, 25, 51, 66, 19, 27, 55};\n    int i;\n    for (i = 0; i < 15; i++) {\n        Insert(&T, a[i]);\n    }\n    printf(\"Max is %d\\n\", FindMax(T));\n    printf(\"Min is %d\\n\", FindMin(T));\n    Delete(T, 18);\n    Delete(T, 13);\n    PreOrderTraverse(T);\n    DestroyTree(T);\n\n    return 0;\n}\n```\n</details>\n\n<details>\n<summary>bst</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n\nenum child_dir {\n    left_child,\n    right_child,\n    root,\n};\n\nstruct node {\n    unsigned long data; \n    struct node *left;\n    struct node *right;\n};\n\nstruct root {\n    struct node *r;\n};\n\nvoid dump(struct node *node, int level, enum child_dir dir)\n{\n    if (!node)\n        return;\n\n    dump(node->right, level + 1, right_child);\n\n    if (dir == left_child)\n        printf(\"%*s\\n\", level*3, \"|\");\n\n    printf(\"%*s - %05lu\\n\", level*3, \" \", node->data);\n\n    if (dir == right_child)\n        printf(\"%*s\\n\", level*3, \"|\");\n\n    dump(node->left, level + 1, left_child);\n}\n\nstruct node* find(struct root *root, unsigned long data)\n{\n    struct node* n = root->r;\n\n    while (n) {\n        if (n->data == data)\n            return n;\n        if (data < n->data)\n            n = n->left;\n        else\n            n = n->right;\n    }\n\n    return NULL;\n}\n\nstruct node* new_node(unsigned long data)\n{\n    struct node *n;\n\n    n = malloc(sizeof(struct node));\n\n    n->data = data;\n    n->left = n->right = NULL;\n    return n;\n}\n\nvoid insert(struct root *root, struct node *new)\n{\n    struct node *parent;\n\n    if (!root->r) {\n        root->r = new;\n        return;\n    }\n\n    parent = root->r;\n\n    while (true) {\n    /* Don't support duplicate data */\n    if (new->data == parent->data)\n    break;\n\n    if (new->data < parent->data) {\n        if (!parent->left) {\n            parent->left = new;\n            break;\n        }\n        parent = parent->left;\n        } else {\n            if (!parent->right) {\n                parent->right = new;\n                break;\n            }\n            parent = parent->right;\n        }\n    }\n}\n\nstruct node* delete(struct root *root, unsigned long data)\n{\n    struct node *n = root->r, **p = &root->r;\n    struct node *child;\n\n    while (n && n->data != data) {\n        if (data < n->data) {\n            p = &n->left;\n            n = n->left;\n        } else {\n            p = &n->right;\n            n = n->right;\n        }\n    }\n\n    if (!n)\n    return NULL;\n    \n    if (n->left && n->right) {\n        struct node *rn = n->right, **rp = &n->right;\n\n        while (rn->left) {\n            rp = &rn->left;\n            rn = rn->left;\n        }\n\n        n->data = rn->data;\n        n = rn;\n        p = rp;\n    }\n\n    child = n->left ? n->left : n->right;\n    *p = child;\n\n    return NULL;\n}\n\nvoid insert_test()\n{\n    struct root tree;\n    struct node* n;\n\n    tree.r = NULL;\n\n    insert(&tree, new_node(9));\n\n    insert(&tree, new_node(5));\n    insert(&tree, new_node(2));\n    insert(&tree, new_node(8));\n\n    insert(&tree, new_node(18));\n    insert(&tree, new_node(13));\n    insert(&tree, new_node(21));\n    insert(&tree, new_node(20));\n\n    dump(tree.r, 0, root);\n\n    n = find(&tree, 18);\n    if (n && n->data == 18)\n        printf(\"Get 18\\n\");\n}\n\nvoid delete_test()\n{\n    struct root tree;\n    struct node* n;\n\n    tree.r = NULL;\n\n    insert(&tree, new_node(9));\n\n    insert(&tree, new_node(5));\n    insert(&tree, new_node(2));\n    insert(&tree, new_node(8));\n\n    insert(&tree, new_node(18));\n    insert(&tree, new_node(13));\n    insert(&tree, new_node(21));\n    insert(&tree, new_node(20));\n\n    dump(tree.r, 0, root);\n\n    delete(&tree, 20);\n    printf(\"Delete 20\\n\");\n    dump(tree.r, 0, root);\n\n    delete(&tree, 9);\n    printf(\"Delete 9\\n\");\n    dump(tree.r, 0, root);\n}\n\nint main()\n{\n    //insert_test();\n    delete_test();\n    return 0;\n}\n```\n</details>\n\n#### 2.3.5 平衡树\n\n&ensp;平衡树是一类改进的二叉查找树,一般二叉查找树的查询复杂度与目标节点到树根的距离(深度)有关,因此当深度较大时,查询均摊复杂度会上升.\n&ensp;**平衡指所有叶子的深度趋于平衡**,更广义指树上所有可能查找的均摊复杂度偏低.**平衡树的操作时基于树旋转操作,通过旋转可使树趋于平衡**.\n&ensp;对一颗查找树进行查询,新增,删除等操作,所花的时间与树的高度h成比例,并不与树的容量n成比例.\n\n- **AVL树**\n\n&emsp;在**AVL树中,任一节点对于的两颗子树的最大高度差为1,因此也称为高度平衡树**.查找,插入和删除的平均和最坏时间复杂度是O(logn),增加和删除元素的操作则可能需要借由一层或多次旋转,以实现树的重新平衡.\n&emsp;**高度为h的AVL树,总节点数最多为2^h-1**; 当前节点数为N时,高度h最多为:\n> log(5*0.5 * (N + 1)) - 2\n\n<br>\n\n- **红黑树**\n\n&ensp;红黑树是一种自平衡二叉查找树,典型的用途是实现关联数组.红黑树实现复制,查找,插入和删除时间复杂度为O(logn)\n&ensp;红黑树相对于AVL树,牺牲了部分平衡性以换取插入\\删除操作时少量的旋转操作,整体性能优于AVL树.\n\n&emsp;红黑树与AVL树的相比:\n&emsp;&emsp;AVL树在插入,删除节点时要把树调整到完全平衡,红黑树只要调整到大致平衡,因此通常红黑树的插入,删除节点性能稍好.\n&emsp;&emsp;AVL的查找性能通常比红黑树好\n&emsp;&emsp;如果节点的增删操作远小于查找操作,则应选择AVL;反之,红黑树可能更好.\n\n&ensp;红黑树是每个节点都带有颜色属性的二叉树,颜色为红色或黑色.在二叉查找树强制一般要求以外,对于任何有效的红黑树我们怎讲了弱小额外要求:\n&emsp;&emsp;1.节点是红或黑色\n&emsp;&emsp;2.根是黑色\n&emsp;&emsp;3.所有叶子都是黑色(叶子是NIL节点)\n&emsp;&emsp;4.每个红色节点必须右两个黑色的子节点.(从每个叶子到根的所有路径上不能右两个连续的红色节点.)\n&emsp;&emsp;5.从任一节点到其每个叶子的所有简单路径都包含相同苏后面的黑色节点.\n&ensp;红黑树关键特性:**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**.红黑树是大致平衡的.插入,删除和查找某个值最坏情况下与树的高度成比例.\n\n- **B+树**\n\n&ensp;B+树通常用于数据库和操作系统的文件系统中.**B+树的特点是能够保持数据稳定有序,其插入与修改拥有较文档的对数时间复杂度**.B+树元素自底向上插入,与二叉树相反.\n&ensp;B+树是内部节点可右在预定范围内的可变量目的子节点.因此,B+树不需要像其他自平衡二叉查找树那样重新平衡.\n\n- **字典树**\n\n<details>\n<summary>Trie</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define OK 1\n#define ERROR 0\n#define TRUE 1\n#define FALSE 0\n\ntypedef int Status;\n\ntypedef struct Node {\n    char data;\n    struct Node *children[26];\n    Status end;\n} Trie, *TriePtr;\n\nvoid Init(TriePtr *T)\n{\n    (*T) = (TriePtr)malloc(sizeof(Trie));\n    (*T)->data = '/';\n    (*T)->end = FALSE;\n}\n\nvoid Insert(TriePtr T, char *str) {\n\n    int index;\n    char c;\n\n    while(c = *str++) {\n        index = c - 'a';\n        if (T->children[index] == NULL) {\n            TriePtr Node;\n            Node = (TriePtr)malloc(sizeof(Trie));\n            Node->data = c;\n            Node->end = FALSE;\n            T->children[index] = Node;\n        }\n\n        T = T->children[index];\n    }\n\n    T->end = TRUE;\n}\n\nStatus Search(TriePtr T, char *str) {\n\n    int index;\n    char c;\n\n    while(c = *str++) {\n        index = c - 'a';\n        if (T->children[index] == NULL) {\n            return FALSE;\n        }\n\n        T = T->children[index];\n    }\n\n    if (T->end) {\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\nint main(int argc, char const *argv[])\n{\n    TriePtr T;\n    Init(&T);\n    char *str = \"hello\";\n    char *str2 = \"hi\";\n\n    Insert(T, str);\n\n    printf(\"str is search %d\\n\", Search(T, str));\n    printf(\"str2 is search %d\\n\", Search(T, str2));\n    return 0;\n}\n```\n</details>\n\n#### 2.3.6 堆树和优先队列\n\n&ensp;堆(heap)也称为优先队列,堆遵守队列操作模式,在堆底插入元素,在堆顶取出元素,但堆中元素的排列不是按照到来的先后顺序,而是按照一定的有序顺序排列的.\n&ensp;堆的本质是一个完全二叉树,可使用二叉树表示堆,也可使用数组来表示.\n&ensp;堆的特性:\n&emsp;&emsp;必须是完全二叉树\n&emsp;&emsp;用数组实现\n&emsp;&emsp;任一节点的值是其子树所有节点的最大值或最小值\n&emsp;&emsp;&emsp;最大值时,称为最大堆,也称大顶堆\n&emsp;&emsp;&emsp;最小时,称为最小堆,也称小顶堆.\n&emsp;**堆不能保证整棵树都是有序的,堆中的插入和删除操作时时间复杂度为O(log2n)**\n\n\n&emsp;堆是一颗二叉树，通常其子结点存储的值比父结点的值小，所以，根结点为树中最大的结点(大顶堆)。同样，根结点也可以是树中最小的结点(小顶堆)。能够快速确定包含最大(小)值的特点。\n&emsp;堆时左平衡的树，随着结点增加，树会逐级从左至右增长。一个较好地表示左平衡二叉树的方式是，将结点通过层序遍历方式连续存储到一个数组中。\n\n```c\ntypedef struct Heap_ {\n    int size;\n    int (*compare)(const void *key1, const void *key2);\n    void (*destroy)(void *data);\n    void **tree;\n}\n```\n\n<details>\n<summary>heap</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n\n/* Implement heap */\n\n#define MAX_HEAP_SIZE (1 << 8)\n\nstruct element {\n    int data;\n};\n\nstruct heap {\n    union {\n        unsigned long elements;\n        struct element *elem[MAX_HEAP_SIZE];\n    };\n};\n\nvoid init_heap(struct heap *heap)\n{\n    int i;\n\n    for(i = 0; i < MAX_HEAP_SIZE; i++) {\n        heap->elem[i] = NULL;\n    }\n}\n\nvoid dump_heap(struct heap *heap, int index)\n{\n    struct element *elem;\n    int level;\n\n    if (index > heap->elements)\n        return;\n\n    elem = heap->elem[index];\n    level = fls(index);\n\n    dump_heap(heap, index * 2 + 1);\n\n    if (!(index % 2) && index != 1)\n        printf(\"%*s\\n\", level*3, \"|\");\n\n    printf(\"%*s - %05d\\n\", level*3, \" \", elem->data);\n\n    if (index % 2 && index != 1)\n        printf(\"%*s\\n\", level*3, \"|\");\n\n    dump_heap(heap, index * 2);\n}\n\nvoid dump(struct heap *heap, int elements)\n{\n    int i;\n\n    for (i = 1; i <= elements; i++)\n        printf(\"[%02d]: %4d\\n\", i, heap->elem[i]->data);\n\n}\n\nstruct element* create_element(int data)\n{\n    struct element *elem;\n\n    elem = malloc(sizeof(struct element));\n\n    if (elem)\n        elem->data = data;\n\n    return elem;\n}\n\nvoid fake_a_heap(struct heap *heap)\n{\n    /* data is in ordered */\n    int i, data[10] = {7, 4, 9, 2, 6, 8, 10, 1, 3, 5};\n\n    init_heap(heap);\n\n    /* root start at 1 */\n    for (i = 0; i < 10; i++)\n        heap->elem[i+1] = create_element(data[i]);\n\n    heap->elements = 10;\n}\n\nvoid swap(struct heap *heap, int i, int j)\n{\n    struct element *tmp;\n\n    tmp = heap->elem[j];\n    heap->elem[j] = heap->elem[i];\n    heap->elem[i] = tmp;\n}\n\nvoid heapify(struct heap *heap, int parent)\n{\n    struct element **elem = heap->elem;\n    int elements = heap->elements;\n    int left, right, max;\n\n    while (true) {\n        left = parent * 2;\n        right = left + 1;\n        \n        max = parent;\n        if (left <= elements && elem[max]->data < elem[left]->data)\n            max = left;\n        if (right <= elements && elem[max]->data < elem[right]->data)\n            max = right;\n\n        if (max == parent)\n            break;\n\n        swap(heap, max, parent);\n        parent = max;\n    }\n}\n\nvoid build_heap(struct heap *heap)\n{\n    int i;\n\n    for (i = heap->elements / 2; i >= 1; i--)\n        heapify(heap, i);\n}\n\nint heap_sort(struct heap *heap)\n{\n    int elements = heap->elements;\n\n    while (heap->elements) {\n        swap(heap, 1, heap->elements);\n        heap->elements--;\n        heapify(heap, 1);\n    }\n    \n    return elements;\n}\n\nint main()\n{\n    struct heap heap;\n    int elements;\n\n    fake_a_heap(&heap);\n    dump_heap(&heap, 1);\n\n    printf(\"After Heapify:\\n\");\n    build_heap(&heap);\n    dump_heap(&heap, 1);\n\n    printf(\"After Heap sort:\\n\");\n    elements = heap_sort(&heap);\n    dump(&heap, elements);\n    return 0;\n}\n```\n</details>\n\n\n&emsp;堆排序，要排序的数据首先存储在一个堆中。从堆中一次取出一个结点。放置到有序数据集的尾部。当取出每个结点时，它的下一个结点就会浮现到堆的顶部。\n\n\n&emsp;优先队列是从堆衍生的数据结构。在优先队列中，数据保存在一个堆中，可快速确定下一个最高优先级的结点。\n\n&emsp;优先队列将数据按照优先级顺序排列。一个优先队列由许多有序元素构成，所以优先级最高的元素可以有效而快速的确定。\n\n```c\ntypedef Heap PQueue;\n```\n\n\n#### 2.3.7 leetcode题目\n\n- 先序遍历构造二叉树\n- 从中序与后序遍历构造二叉树\n- 二叉树的层次遍历\n- 从二叉搜索树到更大和树\n- 二叉搜索树的最近公共祖先\n- 前K个高频单词<堆>\n\n### 2.4 图\n\n&ensp;图(Graph)是由顶点的有穷非空集合和顶点之间的边的集合组成,通常表示为:`G(V,E)`.其中,G表示一个图,V是入G中顶点的集合,E是图G中的集合.\n\n&emsp;图是一种灵活的数据结构，用来定义对象之间关联或联系的模型。对象由顶点表示，而对象直接的关系或关联则通过顶点之间的边来表示。\n&emsp;图的访问方式：广度优先和深度优先。\n\n#### 2.4.1 基础知识\n&emsp;图由两种类型的元素组成：顶点和边，顶点代表对象，边则建立起对象之间的关系或关联。图的边可关联值或权重信息。\n- 一组顶点：用V(vertex)表示顶点集合\n- 一组边：用E(edge)表示边的集合\n&emsp;图分为有向图和无向图。有向图，边是由两个顶点组成的有序对，具有特定的方向。边也可称为弧。无向图中，边是没有方向的。\n- (v, w)表示无向边，即v和w是互通的\n- < v, w >表示有向边，该边始于v，终于w\n&ensp;图可分为连通图和非连通图\n- 连通图：所有的点都右路径相连\n- 非连通图：存在某两个点没有路径相连\n- 强连通图： \n\n&emsp;图中的顶点度\n- 度\n- 入度\n- 出度\n\n#### 2.4.2 图表示\n&emsp;图的表示方法是G=(V, E)，V代表顶点的集合，而E和V之间是二元关系。\n&emsp;图中由两个重要关系邻接(adjacency)和关联(incidence)。邻接是两个顶点之间的关系。关联是顶点和边之间的关系。\n邻接矩阵表示\n\n邻接链表表示\n\n\n\n```c\ntypedef struct AdjList_ {\n    void *vertex;\n    Set adjacent;\n}AdjList;\n\ntypedef struct Graph_ {\n    int vcount;\n    int ecount;\n    int (*match)(const void *key1, const void *key2);\n    List adjlists;\n}\n```\n\n<details>\n<summary>graph</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n\nstruct vertex;\nstruct vertex_adjs {\n    struct vertex *v;\n    struct vertex_adjs *next;\n};\n\nstruct vertex {\n    int data;\n    struct vertex_adjs *adj;\n};\n\n#define MAX_GRAPH_VERTEX (1 << 8)\nstruct graph {\n    struct vertex *vxs[MAX_GRAPH_VERTEX];\n};\n\nvoid init_graph(struct graph *graph)\n{\n    int i;\n\n    for (i = 0; i < MAX_GRAPH_VERTEX; i++)\n        graph->vxs[i] = NULL;\n}\n\nstruct vertex *create_vertex(int data)\n{\n    struct vertex *v;\n\n    v = malloc(sizeof(struct vertex));\n\n    if (v) {\n        v->data = data;\n        v->adj = NULL;\n    }\n\n    return v;\n}\n\nstruct vertex_adjs *create_vertex_adj(struct vertex *v)\n{\n    struct vertex_adjs *v_adj;\n\n    v_adj = malloc(sizeof(struct vertex_adjs));\n\n    if (!v_adj)\n        return NULL;\n\n    v_adj->v = v;\n    v_adj->next = NULL;\n    return v_adj;\n}\n\nvoid insert_adj(struct vertex *v, struct vertex *adj)\n{\n    struct vertex_adjs **v_adj;\n\n    v_adj = &v->adj;\n\n    while (*v_adj)\n    v_adj = &(*v_adj)->next;\n\n    *v_adj = create_vertex_adj(adj);\n}\n\nvoid dump_raw(struct graph *graph)\n{\n    int i;\n\n    for (i = 0; i < MAX_GRAPH_VERTEX; i++) {\n        struct vertex *v = graph->vxs[i];\n        struct vertex_adjs *adj;\n        if (v == NULL)\n            continue;\n\n        printf(\"Vertex[%02d]: %8d ->\", i, v->data);\n\n        adj = v->adj;\n        while (adj) {\n            printf(\" %8d,\", adj->v->data);\n            adj = adj->next;\n        }\n        printf(\"\\n\");\n    }\n}\n\n/* \n  1 ----- 2 ----- 3\n  |     / |     /\n  |    /  |    / \n  |   /   |   /  \n  |  /    |  /   \n  | /     | /    \n  4 ----- 5\n*/\nvoid fake_a_graph(struct graph *graph)\n{\n    int i;\n\n    init_graph(graph);\n\n    for (i = 0; i < 5; i++)\n    graph->vxs[i] = create_vertex(i+1);\n\n    /* connect 1 -> 2, 1 -> 4 */\n    insert_adj(graph->vxs[0], graph->vxs[1]);\n    insert_adj(graph->vxs[0], graph->vxs[3]);\n    /* connect 2 -> 1, 2 -> 3, 2 -> 5, 2 -> 4 */\n    insert_adj(graph->vxs[1], graph->vxs[0]);\n    insert_adj(graph->vxs[1], graph->vxs[2]);\n    insert_adj(graph->vxs[1], graph->vxs[4]);\n    insert_adj(graph->vxs[1], graph->vxs[3]);\n    /* connect 3 -> 2, 3 -> 5 */\n    insert_adj(graph->vxs[2], graph->vxs[1]);\n    insert_adj(graph->vxs[2], graph->vxs[4]);\n    /* connect 4 -> 1, 4 -> 2, 4 -> 5 */\n    insert_adj(graph->vxs[3], graph->vxs[0]);\n    insert_adj(graph->vxs[3], graph->vxs[1]);\n    insert_adj(graph->vxs[3], graph->vxs[4]);\n    /* connect 5 -> 4, 5 -> 2, 5 -> 3 */\n    insert_adj(graph->vxs[4], graph->vxs[3]);\n    insert_adj(graph->vxs[4], graph->vxs[1]);\n    insert_adj(graph->vxs[4], graph->vxs[3]);\n}\n\nint main()\n{\n    struct graph g;\n\n    fake_a_graph(&g);\n    dump_raw(&g);\n    return 0;\n}\n```\n</details>\n\n#### 2.4.3 图遍历\n&ensp;图的搜索方法：深度优先搜索和广度优先搜索。\n&emsp;深度优先遍历(DFS)\n&emsp;思路: 从图中某点v出发:\n&emsp;&emsp;&emsp;1.访问顶点v\n&emsp;&emsp;&emsp;2.从v的未被访问的邻接点中选取一个顶点w,从w出发进行深度优先遍历.\n&emsp;&emsp;&emsp;3.重复上述两步,直到图中所有和v有路径相通的顶点都被访问.\n&emsp;伪代码: \n```c\n// \nvoid DFS(Vertex v) {\n    vistied[v] = true;\n    for (v 的每个邻接点 w) {\n        if (!visited[w]) {\n            DFS(w);\n        }\n    }\n}\n```\n\n\n<details>\n<summary>dfs</summary>\n\n```c\n#include <stdbool.h>\n#include <stdio.h>\n#include \"Graph.h\"\n\n#define MAX_NODES 1000\n\nint visited[MAX_NODES];  // array to store visiting order\n                         // indexed by vertex 0..nV-1\n\nbool dfsPathCheck(Graph g, int nV, Vertex v, Vertex dest)\n{\n    Vertex w;\n    for (w = 0; w < nV; w++)\n        if (adjacent(g, v, w) && visited[w] == -1)\n        {\n            visited[w] = v;\n            if (w == dest)\n                return true;\n            else if (dfsPathCheck(g, nV, w, dest))\n                return true;\n        }\n    return false;\n}\n\nbool findPathDFS(Graph g, int nV, Vertex src, Vertex dest)\n{\n    Vertex v;\n    for (v = 0; v < nV; v++) visited[v] = -1;\n    visited[src] = src;\n    return dfsPathCheck(g, nV, src, dest);\n}\n\nint main(void)\n{\n    int V = 6;\n    Graph g = newGraph(V);\n\n    Edge e;\n    e.v = 0;\n    e.w = 1;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 4;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 5;\n    e.w = 4;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 2;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 3;\n    insertEdge(g, e);\n    e.v = 5;\n    e.w = 3;\n    insertEdge(g, e);\n    e.v = 1;\n    e.w = 2;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 2;\n    insertEdge(g, e);\n\n    int src = 0, dest = 5;\n    if (findPathDFS(g, V, src, dest)) {\n        Vertex v = dest;\n        while (v != src) {\n            printf(\"%d - \", v);\n            v = visited[v];\n        }\n        printf(\"%d\\n\", src);\n    }\n    return 0;\n}\n```\n</details>\n\n\n&ensp;广度优先遍历(BFS)\n&emsp;思路: \n&emsp;&emsp;&emsp;1.顶点v入队列\n&emsp;&emsp;&emsp;2.当队列非空时则继续执行,否则算法结束.\n&emsp;&emsp;&emsp;3.出队列取得队头顶点v',访问顶点v 并标记顶点v已被访问.\n&emsp;&emsp;&emsp;4.查找顶点v的第一个邻接顶点col\n&emsp;&emsp;&emsp;5.若v的邻接顶点col未被访问过的,则col继续.\n&emsp;&emsp;&emsp;6.查找顶点v的另一个新的邻接顶点col,转到步骤5入队列,直到顶点v的所有未被访问过的邻接点处理完,转到步骤2.\n\n<details>\n<summary>bfs_queue</summary>\n\n```c\n#include <stdbool.h>\n#include <stdio.h>\n#include \"Graph.h\"\n#include \"queue.h\"\n\n#define MAX_NODES 1000\n\nint visited[MAX_NODES];  // array to store visiting order\n                         // indexed by vertex 0..nV-1\n\nbool findPathBFS(Graph g, int nV, Vertex src, Vertex dest)\n{\n    Vertex v;\n    for (v = 0; v < nV; v++) visited[v] = -1;\n\n    visited[src] = src;\n    queue Q = newQueue();\n    QueueEnqueue(Q, src);\n    while (!QueueIsEmpty(Q)) {\n        v = QueueDequeue(Q);\n        Vertex w;\n        for (w = 0; w < nV; w++) (\n            if (adjacent(g, v, w) && visited[w] == -1) {\n                visited[w] = v;\n                if (w == dest)\n                    return true;\n                else\n                    QueueEnqueue(Q, w);\n            }\n        )\n    }\n    return false;\n}\n\nint main(void)\n{\n    int V = 10;\n    Graph g = newGraph(V);\n\n    Edge e;\n    e.v = 0;\n    e.w = 1;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 2;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 1;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 2;\n    e.w = 3;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 4;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 8;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 7;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 8;\n    insertEdge(g, e);\n    e.v = 5;\n    e.w = 6;\n    insertEdge(g, e);\n    e.v = 7;\n    e.w = 8;\n    insertEdge(g, e);\n    e.v = 7;\n    e.w = 9;\n    insertEdge(g, e);\n    e.v = 8;\n    e.w = 9;\n    insertEdge(g, e);\n\n    int src = 0, dest = 6;\n    if (findPathBFS(g, V, src, dest)) {\n        Vertex v = dest;\n        while (v != src) {\n            printf(\"%d - \", v);\n            v = visited[v];\n        }\n        printf(\"%d\\n\", src);\n    }\n    return 0;\n}\n```\n</details>\n\n&ensp;深度优先搜索和广度优先搜索,时间复杂度都为O(n^2)\n\n深度优先:从初始点出发,不断向前走,如果碰到死路,就往回走一步,尝试另一条路,直到发现目标位置.\n广度优先:从初始点出发,把所有可能的路径都走一遍,如果里面没有目标位置,则尝试把所有两步能够到的位置都走一遍,看有没有目标位置.\n\n\n\n#### 2.4.4 最短路径\n**迪杰斯特拉Dijkstra算法**\n&ensp;Dijkstra算法适用于权值为正的图.\n&ensp;Dijkstra算法属于单源算法,即只能求出某点到其它点最短距离,并不能得出任意两点之间的最短距离.\n&ensp;在源点可达的情况下,Dijkstra算法的时间复杂度时 `O(ElogV)`\n&ensp;算法步骤:\n&emsp;&emsp;1.将所有边初始化为无穷大\n&emsp;&emsp;2.旋转一个开始的顶点,添加到优先队列中.\n&emsp;&emsp;3.对于该点的所有邻接顶点进行判断,如果到该点的距离小于原先的值,则该值进行更新.\n&emsp;&emsp;4.将该点所有邻接顶点添加到优先队列中.\n&emsp;&emsp;5.从优先队列中挑选除一个路径值最小的顶点,将其弹出,作为新的顶点,重复步骤3,4,5\n&emsp;&emsp;6.直到所有点都被处理过一次.\n\n<detials>\n<summary>迪杰斯特拉</summary>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 20\n#define INF 999\n\nint mat[MAX][MAX];\nint V;\n\nint dist[MAX];\n\nint q[MAX];\nint qp = 0;\n\nvoid enqueue(int v) { q[qp++] = v; }\n\nint cf(void *a, void *b)\n{\n    int *x = (int *)a;\n    int *y = (int *)b;\n    return *y - *x;\n}\n\nint dequeue()\n{\n    qsort(q, qp, sizeof(int), cf);\n    return q[--qp];\n}\n\nint queue_has_something() { return (qp > 0); }\n\nint visited[MAX];\nint vp = 0;\n\nvoid dijkstra(int s)\n{\n    dist[s] = 0;\n    int i;\n    for (i = 0; i < V; ++i) {\n        if (i != s) {\n            dist[i] = INF;\n        }\n        enqueue(i);\n    }\n    while (queue_has_something()) {\n        int u = dequeue();\n        visited[vp++] = u;\n        for (i = 0; i < V; ++i) {\n            if (mat[u][i]) {\n                if (dist[i] > dist[u] + mat[u][i]) {\n                    dist[i] = dist[u] + mat[u][i];\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char const *argv[])\n{\n    printf(\"Enter the number of vertices: \");\n    scanf(\" %d\", &V);\n    printf(\"Enter the adj matrix: \");\n    int i, j;\n    for (i = 0; i < V; ++i) {\n        for (j = 0; j < V; ++j) {\n            scanf(\" %d\", &mat[i][j]);\n        }\n    }\n\n    dijkstra(0);\n\n    printf(\"\\nNode\\tDist\\n\");\n    for (i = 0; i < V; ++i) {\n        printf(\"%d\\t%d\\n\", i, dist[i]);\n    }\n\n    return 0;\n}\n```\n</detials>\n\n**弗洛伊德Floyd算法**\n&ensp;Floyd算法是一个经典的动态规划算法.首先目标是寻找从点`i`到`j`的最短路径.\n&ensp;**Floyd算法可以求出任意两点的最短距离.时间复杂度:**`O(你^3)`\n&ensp;从任意节点i到任意节点j的最短路径不外乎2种可能:\n&emsp;&emsp;1.是之间从i到j\n&emsp;&emsp;2是从i到经过若干个节点k到j\n&emsp;设Dist(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，检查Dis(i,k) + Dis(k,j) < Dis(i,j) 是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，则设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。\n\n```c\nfor (int k = 0; k < n; k++) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (A[i][j] > (A[i][k] + A[k][j])) {\n                A[i][j] = A[i][k] + A[k][j];\n                path[i][j] = k;\n            }\n        }\n    }\n}\n```\n\n\n#### 2.4.5 拓扑排序\n&ensp;拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列.且该序列必须满足下面两个条件:\n- 每个顶点出现且只出现一次\n- 若存在一条顶点A到顶点B的路径,那么在序列中顶点A出现在顶点B的前面.\n&emsp;有向无环图(DAG)才有拓扑排序，非DAG图没有拓扑排序。\n&ensp;拓扑排序步骤：\n- 从DAG图中选择一个 没有前缀(即入度为0)的顶点并输出\n- 从图中删除该顶点和所有以它为起点的有向边\n- 重复1和2直到当前的DAG图为空或当前图中不存在无前缀的顶点为止。后一种情况说明有向图中必然存在环。\n\n#### 2.4.6 leetcode题目\n- 判断二分图\n- 克隆图\n- 找到小镇的法官\n- 钥匙和房间\n- 最短路径访问所有节点\n\n<br>\n\n## 3 常见算法\n\n### 3.1 递归思想\n#### 3.1.1 递归思想\n&ensp;递归思想是:将大问题分解为小问题来求解,然后再将小问题分解为更小的问题.逐层分解,直到问题规模被分解到可以直接计算结果.\n&ensp;如果把一层一层分解过程画成图,它其实就是一棵树,称为递归树.\n\n<!--more-->\n\n&ensp;斐波那契数列\n```c\nint fib(int N)\n{\n    if (N < = 1) {\n        return N;\n    }\n    \n    return fib(N-1) + fib(N-2);\n}\n```\n&ensp;递归的过程中,符合**后进先出**规则,所以用一个堆栈的数据结构.函数递归过程中会自动产生栈帧,当函数栈帧的深度越来越大,栈也也越来越大,如果递归没有终止条件,则会爆栈.递归算法第一步要思考的就是**递归终止条件**.\n&ensp;递归思想的两个延申算法:分治算法和动态规划.\n&ensp;递归的一般结构:\n```c\nvoid func()\n{\n    if (符合边界条件) {\n        ...\n        return ..;\n    }\n    // 某种形式的调用\n    func();\n}\n```\n&ensp;阶乘函数:\n```c\nint factorial(int n)\n{\n    if (n <= 1) {\n        return 1;\n    }\n\n    return n * factorial(n-1);\n}\n```\n\n- 参考链接:https://www.jianshu.com/p/b2d2edb4ba5b\n\n#### 3.1.2 递归基本步骤:\n&ensp;&emsp;1.定义一个函数,明确函数功能\n&ensp;&emsp;2.寻找问题与子问题之间的关系(递推公式)\n&ensp;&emsp;3.将递推公式在定义的函数中实现\n&ensp;&emsp;4.推导时间复杂度,判定是否可以接受,无法接受更换算法.\n\n#### 3.1.3 代表题目\n- 爬楼梯 70\n\n```c\nint climbStairs(int n)\n{\n    int *mem = (int *)malloc(sizeof(int) * (n+1));\n    int mem[n] = {};\n    return climb(n, mem);\n}\n\nint climb(int n, int *mem)\n{\n    if (n == 1) {\n        return 1;\n    }\n    if (n == 2) {\n        return 2;\n    }\n    if (mem[n] > 0) {\n        return mem[n];\n    }\n    mem[0] = climb(n-1, mem) + climb(n-2, mem);\n\n    return mem[n];\n}\n```\n\n- 青蛙跳台阶 10-II\n\n```c\nint numWays(int n)\n{\n    int num[n+1] = {-1};\n    return jump(n, num);\n}\n\nint jump(int n, int *num)\n{\n    if (num[n] != -1) {\n        return num[n];\n    }\n    if (n == 1 || n == 0) {\n        return 1;\n    }\n\n    num[n] = (jump(n-1, num) + jump(n-2, num) % 1e9+7);\n    return num[n];\n}\n```\n\n#### 3.1.4 触类旁通\n- 反转二叉树 226\n&emsp;1).对于根节点`1`来说,假设`2,3`节点下的节点都已经翻转,那么只要翻转`2,2`节点即满足需求.\n&emsp;2).对于`2,3`节点来说,也是翻转其左右节点即可.\n&emsp;依此类推,对每一个节点,依次翻转其左右节点,所以我们可知问题与子问题的关系是翻转(根节点) = 翻转(根节点的左节点) + 翻转(根节点的右节点),即\n> invert(root) = invert(root->left) + invert(root->right)\n&emsp;加号是追加到root上的意思\n\n```c\ntypedef struct TreeNode {\n    int data;\n    TreeNode *left;\n    TreeNode *right;\n}\n\nTreeNode invertTree(TreeNode *root)\n{\n    if (root == NULL) {\n        return NULL;\n    }\n\n    TreeNode *left = (struct TreeNode *)malloc(sizeof(TreeNode));\n    TreeNode *right = (struct TreeNode *)malloc(sizeof(TreeNode));\n    left = invertTree(root.left);\n    rgith = invertTree(root.right);\n    root.left = right;\n    root.right = left;\n    return root;\n}\n\n```\n\n- 路径总和 112\n&emsp;给定一个二叉树和一个目标和,判断该树中是否存在根节点到叶子节点的路径,这条路径上所有节点值相加等于目标和.\n```c\ntypedef struct TreeNode {\n    int data;\n    struct TreeNode *left;\n    struct TreeNode *right;\n}\nbool hasPathSum(TreeNode *root, int sum)\n{\n    if (root == NULL) {\n        return false;\n    }\n    if (root.left == NULL && root.right == NULL) {\n        return root.data == sum;\n    }\n\n    int remain = sum - root.data;\n    return hasPathSum(root.left, remain) || hashPashSum(root.right, remain);\n}\n```\n\n- 细胞分裂\n\nhttps://www.jianshu.com/p/b2d2edb4ba5b\n\n\n\n\n### 3.2 分治法\n&emsp;把复杂问题分成两个或者更多相同或相似的子问题，再把子问题分成更小的子问题...，直到可以直接求解，原问题的解为子问题解的合并。\n&emsp;分治法应用：排序算法(快速排序、归并排序);傅里叶变换()。\n#### 3.2.1 概述\n&ensp;分治法思想:将一个难以直接解决的大问题,分割成一些规模小的相同问题,分而治之.\n\n&emsp;分治法:把一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题...,直到最后子问题可以简单的直接求解,原问题的解即子问题的解的**合并**.分治法思想:排序(快速排序,归并排序),傅里叶变换(快速傅里叶变换\n&emsp;1):数学归纳是使用分治思想.\n&emsp;2):分治思想不一定使用递归结构.\n&ensp;递归结构是循环结构的一种,也是分治思想应用最多的一种程序结构,但不一定使用它.分治法的核心是**如何分**\n\n\n\n#### 3.2.2 策略\n&ensp;分治策略:对于一个规模为n的问题,若该问题可以容易解决则直接解决,否则将其分解为k个规模较小的子问题,子问题之间相互独立且与原问题形式相同,可递归求解.分治通常用递归实现.\n#### 3.2.3 应用场景\n&ensp;分治法特征:\n- 问题缩小到一定程度可容易解决.\n- 问题可分解为若干个规模较小的相同问题,即问题具有最优子结构性质.\n- 子问题的解可合并为该问题的解.\n- 问题分解的子问题相互独立,子问题之间不包含公告子问题.\n\n#### 3.2.4 步骤\n&ensp;分治法一层递归步骤:\n- 1) **分解**:将原问题分解为若干规模较小,相互独立,与原问题形式相同的子问题.\n- 2) **解决**:若子问题可直接求解,则直接求解,否则递归解各个子问题.\n- 3) **合并**:将各个子问题的解合并为原问题的解.\n\n&ensp;\n\n```c\n\n\n```\n<br>\n\n#### 3.2.5 应用\n> 分治思维方式：二分搜索;大整数乘法;合并排序;快速排序。\n\n&ensp;求x的n次幂\n&emsp;对数复杂度O(logn)\n```c\nint power(int x, int n)\n{\n    int result;\n    if (n == 1) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        result = power(x, n/2) * power(x, n / 2);\n    } else {\n        result = power(x, (n + 1) / 2) * power(x, (n - 1) / 2);\n    }\n    return result;\n}\n```\n\n#### 3.2.6 leetcode题目\n- 搜索二维矩阵II\n- 求众数\n- 合并k个排序链表\n\n\n### 3.3 排序算法\n&emsp;各种排序算法，主要包括：插入排序、快速排序、归并排序、计数排序和技术排序。二分查找，\n\n#### 3.3.1 冒泡排序\n&ensp;重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。\n&ensp;**冒泡排序算法复杂度是O(n^2)**\n```c\nstatic void bubleSort(int[] arr)\n{\n    int size = arr.length;\n    // \n    for (int out = size - 1; out > 0; out--) {\n        // \n        for (int in = 0; in < out; in++) {\n            if (arr[in] > arr[in + 1]) {\n                swap(arr, in, in + 1);\n            }\n        }\n    }\n}\n#define SWAP(a,b) \\\ndo{\\\n    (a) ^= (b);\\\n    (b) ^= (a);\\\n    (a) ^= (b);\\\n}while(0)\n\n/*冒泡排序*/\nvoid bubble_sort(int a[],int size)\n{\n    int i = 0;\n    int j = 0;\n    int swap_flg = 0;\n\n    if (size < 1) {\n        return;\n    }\n\n    for (i = size - 1; i > 0; i--) {/*排序的趟数*/ \n        swap_flg = 0;/*每次设置交换标识为0*/\n        for (j = 0; j < i; j++) {          /*本趟排序的遍历元素个数*/\n            if (a[j] > a[j + 1]) {\n                SWAP(a[j],a[j+1]);\n                swap_flg = 1;\n            }\n        }\n        /*本趟数，无数据交换的话，说明已经有序，直接退出*/\n        if (swap_flg == 0) {\n            break;\n        }\n    }\n    return;\n}\n```\n<br>\n\n```c++\n#include <iostream>\nusing namespace std;\ntemplate<typename T>\n//整数或浮点数皆可使用\nvoid bubble_sort(T arr[], int len)\n{\n    int i, j; T temp;\n    for (i = 0; i < len - 1; i++) {\n        for (j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n```\n\n#### 3.3.2 选择排序\n&emsp;选择排序算法时间复杂度为O(n^2)\n\n```c\nstatic void selectSort(int[] arr)\n{\n    int size = arr.lenght;\n    //\n    for (int out = 0; out < size; out++) {\n        int mixIndex = out;\n        //\n        for (int in = out - 1; in < size; in++) {\n            if (arr[mixIndex] > arr[in]) {\n                mixIndex = in;\n            }\n        }\n\n        if (mixIndex != out) {\n            swap(arr, mixIndex, out);\n        }\n    }\n}\n\n/*选择排序*/\nvoid select_sort(int a[],int size)\n{\n    int i = 0;\n    int j = 0;\n    int min = 0;\n\n    for (i = 0; i < size - 1; i++)  {\n        min = i;\n        for (j = i + 1; j < size; j++) {\n            if (a[j] < a[min]) {\n                min = j;\n            }\n        }\n\n        if (min != i) {\n            SWAP(a[i],a[min]);\n        }\n    }\n    return;\n}\n```\n\n#### 3.3.3 插入排序\n&emsp;插入排序每次从无序数据集合中取出一个元素，插入到已经排好序的数据集中适当位置，使数据集仍然有序。插入排序不需要额外空间。时间复杂度O(n2)\n\n```c\nstatic void insertSort(int[] arr)\n{\n    int size = arr.lenght;\n    // \n    for (int out = 1; out < size; out++) {\n        //\n        int temp = arr[out];\n        int in = out;\n        //\n        // \n        while (in - 1 >= 0 && arr[in - 1] > temp) {\n            arr[in] = arr[in - 1];\n            in--;\n        }\n        if (in != out) {\n            arr[in] = temp;\n        }\n    }\n}\n\n/*插入排序*/\nvoid insert_sort(int a[],int size)\n{\n    for (int i = 1; i < size; i ++)/*需要插入的元素个数*/\n    {\n        int key = a[i];/*保存插入的元素数据*/\n        int j = i - 1;\n            /* i 之前的元素都是有序的，找到比key小的插入到他后面，\n        * 比key大的，需要往后挪一个位置*/\n        while((j >= 0) && (a[j] > key)) {\n            a[j + 1] = a[j];\n            j--;\n        }\n        a[j + 1] = key;\n    }\n\n    return;\n}\n```\n\n```c\nint issort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2))\n{\n    char *a = data;\n    void *key;\n    int i, j;\n\n    if ((key = (char *)malloc(esize)) == NULL) {\n        return -1;\n    }\n\n    for (j = 1; j < size; j++) {\n        i = j - 1;\n\n        while (i >= 0 && compare(&a[i * esize], key) > 0) {\n            mamcpy(&a[(i + 1) * esize], &a[i * esize], esize);\n            i--;\n        }\n        memcpy(&a[(i + 1) * esize], key, esize);\n    }\n\n    free(key);\n\n    return 0;\n}\n```\n#### 3.3.4 希尔排序\n\n&ensp;希尔排序时间复杂度O(n*(logn)^2)\n```c\nstatic void shellSort(int[] arr)\n{\n    int size = arr.lenght;\n    int h = 1;\n    while (h <= size / 3) {\n        //\n        h = h * 3 + 1;\n    }\n    while (h > 0) {\n        for (int out = h; out < size; out++) {\n            int temp = arr[out];\n            int in = out;\n            //\n            while (in - h >= 0 && arr[in - h] > temp) {\n                arr[in] = arr[in - h];\n                in = in - h;\n            }\n            if (in != out) {\n                arr[in] = temp;\n            }\n        }\n        h = (h - 1) / 3;\n    }\n}\n```\n#### 3.3.5 归并排序\n&emsp;归并排序是一种分支排序算法。归并排序需要额外存储空间来完成排序。\n```c\nint min(int x, int y)\n{\n    return  x < y ? x : y;\n}\n\nvoid merge_sort(int arr[], int len)\n{\n    int *a = arr;\n    int *b = (int *)malloc(len * sizeof(int));\n    int seg, start;\n    for (seg = 1; seg < len; seg += seg) {\n        for (start )\n    }\n}\n```\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\nvoid dump(int *arr, int size)\n{\n    int idx;\n\n    for (idx = 0; idx < size; idx++)\n        printf(\"%08d\\n\", arr[idx]);\n}\n\nvoid __merge(int *arr, int p, int q, int r)\n{\n    int *tmp;\n    int i, j, k;\n\n    tmp = (int*)malloc((r - p + 1) * sizeof(int));\n\n    if (!tmp)\n        abort();\n\n    for (i = p, j = q + 1, k = 0; i <= q && j <= r;) {\n        if (arr[i] <= arr[j])\n            tmp[k++] = arr[i++];\n        else\n            tmp[k++] = arr[j++];\n    }\n\n    if (i == q + 1) {\n        for (; j <= r;)\n            tmp[k++] = arr[j++];\n    } else {\n        for (; i <= q;)\n            tmp[k++] = arr[i++];\n    }\n\n    memcpy(arr + p, tmp, (r - p + 1) * sizeof(int));\n    free(tmp);\n}\n\nvoid __merge_sort(int *arr, int p, int r)\n{\n    int q;\n\n    if (p >= r)\n    return;\n\n    q = (p + r) / 2;\n    __merge_sort(arr, p, q);\n    __merge_sort(arr, q + 1, r);\n    __merge(arr, p, q, r);\n}\n\nvoid merge_sort(int *arr, int size)\n{\n    __merge_sort(arr, 0, size - 1);\n}\n\nvoid merge_verify()\n{\n    int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56};\n\n    __merge(test, 0, 4, 9);\n\n    dump(test, 10);\n}\n\nvoid merge_sort_test()\n{\n    int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56};\n\n    merge_sort(test, 10);\n    dump(test, 10);\n}\n\nint main()\n{\n    //merge_verify();\n    merge_sort_test();\n    return 0;\n}\n```\n#### 3.3.6 快速排序\n&emsp;快速排序是一种分治排序算法。不需要额外存储空间，时间复杂度O(nlgn)\n\n&emsp;快速排序三个步骤：\n- 分：设定一个分割值并将数据分为两部分。\n- 治：分别在两部分使用递归方式继续使用快速排序方法。\n- 和：对分割部分排序直至完成。\n\n```c\ntypedef struct _Range {\n    int start;\n    int end;\n} Range;\n\nRange now_Range(int s, int e)\n{\n    Range r;\n    r.start = s;\n    r.end = e;\n    return r;\n}\n\nvoid swap(int *x, int *y)\n{\n    int t = *x;\n    *x = *y;\n    *y = t;\n}\n\nvoid quick_sort(int arr[], const int len)\n{\n    if (len <= 0) {\n        return;\n    }\n    Range r[len];\n    int p = 0;\n    r[p++] = new_Range(0, len - 1);\n    while (p) {\n        Range range = r[--p];\n        if (range.start >= range.end) {\n            continue;\n        }\n        int mid = arr[(range.start + range.end) / 2];\n        int left = range.start;\n        int right = range.end;\n        do {\n            while (arr[left] < mid) {\n                ++left;\n            }\n            while (arr[right] > mid) {\n                --right;\n            }\n            if (left <= right) {\n                swap(&arr[left], &arr[right]);\n                left++;\n                right--;\n            }\n        } while (left <= right);\n        if (range.start < right) {\n            r[p++] = new_Range(range.start, right);\n        }\n        if (range.end > left) {\n            r[p++] = new_Range(left, range.end);\n        }\n    }\n}\n```\n\n```c\nvoid QuickSort(int *arr, int low, int high)\n{\n    if (low < high) {\n        int i = low;\n        int j = high;\n        int k = arr[low];\n        while (i < j) {\n            // 从右向左找第一个小于k的数\n            while (i < j && arr[j] >= k) {\n                j--;\n            }\n\n            if (i < j) {\n                arr[i++] = arr[j];\n            }\n            // 从左向右找第一个大于等于k的数\n            while (i < j && arr[i] < k) {\n                i++;\n            }\n\n            if (i < j) {\n                arr[j--] = arr[i];\n            }\n        }\n        arr[i] = k;\n\n        // 递归调用\n        QuickSort(arr, low, i - 1); // 排序k左边\n        QuickSort(arr, i + 1, high); // 排序k右边\n    }\n}\n\nvoid quick_sort( int *a, int n)\n{\n    int i, j, p, tmp;\n    if (n < 2)  return;\n\n    p = a[n / 2];   // Get the middle element as pivot ..\n\n    for ( i = 0, j = n -1;; i++, j--) {\n        while (a[i] < p)\n            i++;\n        while (p < a[j])\n            j--;\n        if ( i >= j)\n            break;\n        tmp = a[i]; a[i] = a[j]; a[j] = tmp;    //swap both ..\n    }   \n\n    quick_sort( a, i); \n    quick_sort( a + i, n - i); \n}\n```\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\nvoid dump(int *arr, int size)\n{\n    int idx;\n\n    for (idx = 0; idx < size; idx++)\n        printf(\"%08d\\n\", arr[idx]);\n}\n\nvoid swap(int *a, int *b)\n{\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint partition(int *arr, int p, int r)\n{\n    //int pivot = arr[r];\n    int i, j;\n\n    i = j = p;\n\n    for (; j < r; j++) {\n        if (arr[j] < arr[r]) {\n            if(i != j) {\n                swap(arr + i, arr + j);\n\n            }\n            i++;\n        }\n    }\n    \n    swap(arr + i, arr + r);\n    return i;\n}\n\nvoid __quick_sort(int *arr, int p, int r)\n{\n    int q;\n\n    if (p >= r)\n    return;\n\n    q = partition(arr, p, r);\n    __quick_sort(arr, p, q-1);\n    __quick_sort(arr, q+1, r);\n}\n\nvoid quick_sort(int *arr, int size)\n{\n    __quick_sort(arr, 0, size - 1);\n}\n\nvoid quick_sort_test()\n{\n    int test[10] = {5, 8, 9, 23, 67, 1, 3, 7, 31, 56};\n\n    quick_sort(test, 10);\n\n    dump(test, 10);\n}\n\nint main()\n{\n    quick_sort_test();\n    return 0;\n}\n```\n\n```c++\n#include <iostream>\nusing namespace std;\n \nvoid Qsort(int arr[], int low, int high){\n    if (high <= low) return;\n    int i = low;\n    int j = high + 1;\n    int key = arr[low];\n    while (true) {\n        /*从左向右找比key大的值*/\n        while (arr[++i] < key) {\n            if (i == high) {\n                break;\n            }\n        }\n\n        /*从右向左找比key小的值*/\n        while (arr[--j] > key)\n        {\n            if (j == low) {\n                break;\n            }\n        }\n\n        if (i >= j) break;\n        /*交换i,j对应的值*/\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    /*中枢值与j对应值交换*/\n    int temp = arr[low];\n    arr[low] = arr[j];\n    arr[j] = temp;\n    Qsort(arr, low, j - 1);\n    Qsort(arr, j + 1, high);\n}\n```\n\n**qsort/sort函数**\n&ensp;在c语言库函数中已经实现了qsort函数,\n&emsp;qsort函数用法:\n```c\nvoid qsort(void *base, int nelem, int width, int (*fcmp)(const void *, const void *));\n// 参数:1 带排序数组首地址, nelem 数组中待排元素数量  width 各元素所在空间大小  *fcmp 指向函数的指针\n```\n\n```c\n// int 数组\nint cmp(const void *a, const void *b)\n{\n    return (*(int *)a - *(int *)b);\n}\nqsort(arr, n, sizeof(arr[0]), cmp);\n\n// char 数组\nint com(const void *a, const void *b)\n{\n    return *(char *)a - *(char *)b;\n}\nchar word[100];\nqsort(word, 100, sizeof(word[0]), cmp);\n\n// double 类型\nint cmp(const void *a, const void *b)\n{\n    return *(double *)a > *(double*)b ? 1 : -1;\n}\ndouble in[100];\nqsort(in, 100, sizeof(in[00]), cmp);\n\n// struct 结构体\nstruct Sample {\n    double data;\n    int num;\n}st[100];\n\nint cmp(const void *a, const void *b)\n{\n    return (*(Sample *)a).data > (*(Sampel *)b).data ? 1 : -1;\n}\nqsort(s, 100, sizeof(s[0]), cmp);\n// \nint cmp(const void *a, const void *b)\n{\n    struct Sample *c = (Sample *)a;\n    struct Sample *d = (Sample *)b;\n    if(c->x != d->x) {\n        return c->x - d->x;\n    } else {\n        return d->y - c->y;\n    }\n}\n\nqsort(s,100,sizeof(s[0]),cmp);\n\ntruct Sample\n{\n    int data;\n    char str[100];\n}s[100];\n\n//按照结构体中字符串str的字典顺序排序\n\nint cmp (const void *a, const void *b)\n{\n    return strcmp((*(Sample *)a)->str , (*(Sample *)b)->str);\n}\n\nqsort(s,100,sizeof(s[0]),cmp);\n```\n#### 3.3.7 堆排序\n&emsp;桶排序算法基本原理：把数组中的所有元素分为若干个数据块，也就是若干个桶，然后对每个桶里的数据进行排序，最后将所有桶里的数据依次排列。\n&emsp;存在两个问题：\n&emsp;(1)怎样划分数据块，也就是分几个桶，每个桶放哪几个数据。\n&emsp;(2)对每个数据块里的数据怎样排序。\n&ensp;堆排序使利用堆这种数据结构设计的一种选择排序算法。堆是一种近似完全二叉树的结构(通常堆用一维数组实现),并满足性质；最大堆(大顶堆)为例，其父节点的值总是大于它的孩子节点。\n&ensp;堆排序的过程：\n&emsp;1.由输入的无序数组构造一个最大堆，作为初始的无序区\n&emsp;2.把堆顶元素(最大值)和堆尾元素互换\n&emsp;3.把堆(无序区)的尺寸缩小1，并调用heapify(A,0)从新的堆顶元素开始进行堆调整。\n&emsp;4.重复步骤2，直到堆的尺寸为1\n&ensp;因为每次插入数据效率是O(logN)，而我们需要进行n次循环，将数组中每个值插入到堆中，所以它的执行时间是O(N*logN)级。\n\n\n```c\n#include<sdtio.h>\n#include<stdlib.h>\n\ntypedef struct node {\n    int key;\n    struct node *next;\n} KeyNode;\n\nvoid bucket_sort(int keys[], int size, int bucket_size) {\n    int i, j;\n    KeyNode **bucket_table = (KeyNode **)mallov(bucket_size * sizeof(KeyNode*));\n    for(i = 0;i < bucket_size;i++) {\n        bucket_table[i] = (KeyNode*)malloc(sizeof(KeyNode));\n        bucket_table[i]->key = 0;\n        bucket_table[i]->next = NULL;\n    }\n    for(j = 0;j < size;j++) {\n        KeyNode *node = (KeyNode *)malloc(sizeof(KeyNode));\n        node->key = keys[j];\n        node->next = NULL;\n        int index = keys[j]/10;\n        KeyNode *p = bucket_table[index];\n        if(p->key == 0) {\n            bucket_table[index]->next = node;\n            (bucket_table[index]->key)++;\n        } else {\n            while(p->next != NULL && p->next->key <= node->key)\n            p = p->next;\n            node->next = p->next;\n            p->next = node;\n            (bucket_table[index]->key)++;\n        }\n    }\n    //print result\n    KeyNode * k = NULL;\n    for(i = 0;i < bucket_size;i++)\n    for(k = bucket_table[i]->next;k!=NULL;k=k->next)\n    printf(\"%d \",k->key);\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int raw[] = {49,38,65,97,76,13,27,49};\n    int size = sizeof(raw)/sizeof(int);\n    bucket_sort(raw,size,10);\n}\n```\n\n```c\nvoid Heapify(int A[], int i, int size)\n{\n    int lef_child = 2 * i + 1;\n    int right_child = 2 * i + 2;\n    int max = i;\n    if (lef_child < size && A[lef_child] > A[max]) {\n        max = lef_child;\n    }\n    if (right_child < size && A[right_child] > A[max]) {\n        max = right_child;\n    }\n    if (max != i) {\n        Swap(A, i max);\n        Heapify(A, max, size);\n    }\n}\n\nint BuildHeap(int A[], int n)\n{\n    int heap_size = n;\n    for (int i = heap_size / w - 1; i >= 0; i--) {\n        Heapify(A, i, heap_size);\n        return heap_size;\n    }\n}\n\nvoid HeapSort(int A[], int n)\n{\n    int heap_size = BuildHeap(A, n);\n    while (heap_size > 1) {\n        Swap(A, 0, heap_size);\n        Heap(A, 0, heap_size);\n    }\n}\n```\n\n#### 3.3.8 leetcode排序\n\n- 按奇偶排序数组\n- 对链表进行插入排序\n- 合并区间\n- 最大数\n- 最接近原点的K个点\n\n### 3.4 贪心算法\n\n#### 3.4.1 基本概念\n&ensp;贪心算法:在对问题求解时,总是做出在当前是最好的选择,即不考虑整体最优,仅考虑局部最优解.\n&ensp;贪心算法没有固定算法框架,算法关键是贪心策略的选择.他想算法不是所有问题都得到最优解,选择贪心策略必须具备无后效性,即某个状态以后的过程不会影响一起的状态,只与当前状态有关.\n#### 3.4.2 描述\n&ensp;贪心算法实现步骤:\n&emsp;1.建立数学模型描述问题\n&emsp;2.把求解的问题分成若干个子问题\n&emsp;3.对每个子问题求解,得到子问题的局部最优解\n&emsp;4.把子问题的解局部最优解合成原来问题的一个解.\n&ensp;实现算法过程:\n```c\nwhile (能朝给定总目标前进一步)\n{\n    利用可行的决策,求出可行解的一个解元素;\n}\n由所有解元素组合成问题的一个可行解\n```\n#### 3.4.3 应用\n\n**最小生成树算法**\n&ensp;贪心算法经典实践:最小生成树算法\n&emsp;设`G=(V, E)`是无向连通带权图,即一个网络,E中的每一条边`(v,w)` 的全为 `c[v][w]`.如果G的字体 G' 是一颗包含 G 的所有顶点的数,则称 G' 为 G 的生成树.生成树上各边权的总和称为生成树的耗费.在 G 的所有生成树中,耗费最小的生成树称为 G 的最小生成树.\n&ensp;最小生成树的性质:\n&emsp;&emsp;设`G=(V, E)`是连通带权图, U是V的真子集.如果(u,v)属于E,且u属于E,v属于V-U,且在所有这样的边中,(u,v)的权c[u][v]最小,那么一定存在G的一颗最小生成树,它亦是(u,v)为其中一条边,这个性质有时也称为MST性质.\n\n\n**Prim算法**\n&emsp;&emsp;设`G=(V, E)`是连通带权图, V={1,2,...,n}.构造G的最小生成树Prim算法的基本思想是:**首先置S={1},然后,只有S是V的真子集,就进行如下的贪心选择:选取满足添加i属于S,j属于V-S,且c[i][j]最小的边,将顶点j添加到S中.这个过程一直进行到S=V时为止.在这个过程中选取到的所有边恰好构成G的一颗最小生成树.\n\n<details>\n<summary>Prim</summary>\n\n```c\n/**\n * @file\n * @author [Timothy Maloney](https://github.com/sl1mb0)\n * @brief [Prim's algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)\n * implementation in C to find the MST of a weighted, connected graph.\n * @details Prim's algorithm uses a greedy approach to generate the MST of a\n *weighted connected graph. The algorithm begins at an arbitrary vertex v, and\n *selects a next vertex u, where v and u are connected by a weighted edge whose\n *weight is the minimum of all edges connected to v.\n * @references Page 319 \"Introduction to the Design and Analysis of Algorithms\"\n *- Anany Levitin\n *\n * To test - run './prim -test'\n * prim() will find the MST of the following adj. matrix:\n *\n *\t  0  1  2  3\n *        1  0  4  6\n *        2  4  0  5\n *        3  6  5  0\n *\n * The minimum spanning tree for the above weighted connected graph is given by\n *the following adj matrix:\n *\n *\t  0  1  2  3\n *\t  1  0  0  0\n *\t  2  0  0  0\n *\t  3  0  0  0\n *\n *\n * The following [link](https://visualgo.net/en/mst) provides a visual\n *representation of graphs that can be used to test/verify the algorithm for\n *different adj matrices and their weighted, connected graphs.\n */\n\n#include <assert.h>    /// for assert()\n#include <inttypes.h>  /// for uint16_t\n#include <stdio.h>     /// for IO operations\n#include <string.h>    /// for string comparison\n\n#define MAX 20\n#define INF 999\n\n/**\n * @brief Finds index of minimum element in edge list for an arbitrary vertex\n * @param arr graph row\n * @param N number of elements in arr\n * @returns index of minimum element in arr\n */\nuint16_t minimum(uint16_t arr[], uint16_t N)\n{\n    uint16_t index = 0;\n    uint16_t min = INF;\n\n    for (uint16_t i = 0; i < N; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n            index = i;\n        }\n    }\n    return index;\n}\n\n/**\n * @brief Used to find MST of user-generated adj matrix G\n * @returns void\n */\nvoid prim(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)\n{\n    uint16_t u, v;\n    uint16_t E_t[MAX], path[MAX];\n    uint16_t V_t[MAX], no_of_edges;\n\n    E_t[0] = 0;  // edges for current vertex\n    V_t[0] = 1;  // list of visited vertices\n\n    for (uint16_t i = 1; i < V; i++) {\n        E_t[i] = G[i][0];\n        path[i] = 0;\n        V_t[i] = 0;\n    }\n\n    no_of_edges = V - 1;\n\n    while (no_of_edges > 0) {\n        u = minimum(E_t, V);\n        while (V_t[u] == 1) {\n            E_t[u] = INF;\n            u = minimum(E_t, V);\n        }\n\n        v = path[u];\n        MST[v][u] = E_t[u];\n        MST[u][v] = E_t[u];\n        no_of_edges--;\n        V_t[u] = 1;\n\n        for (uint16_t i = 1; i < V; i++) {\n            if (V_t[i] == 0 && G[u][i] < E_t[i]) {\n                E_t[i] = G[u][i];\n                path[i] = v;\n            }\n        }\n    }\n}\n\n/**\n * @brief Self-test implementations\n * @returns void\n */\nstatic void test(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)\n{\n    uint16_t test[4][4] = {\n        {0, 1, 2, 3}, {1, 0, 4, 6}, {2, 4, 0, 5}, {3, 6, 5, 0}};\n    uint16_t solution[4][4] = {\n        {0, 1, 2, 3}, {1, 0, 0, 0}, {2, 0, 0, 0}, {3, 0, 0, 0}};\n\n    V = 4;\n\n    for (uint16_t i = 0; i < V; ++i) {\n        for (uint16_t j = 0; j < V; ++j) {\n            G[i][j] = test[i][j];\n        }\n    }\n\n    prim(&(*G), &(*MST), V);\n\n    for (uint16_t i = 0; i < V; ++i) {\n        for (uint16_t j = 0; j < V; ++j) {\n            assert(MST[i][j] == solution[i][j]);\n        }\n    }\n}\n\n/**\n * @brief Function user_graph();\n * gets user input adj. matrix and finds MST of that graph\n * @returns void\n */\nvoid user_graph(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)\n{\n    printf(\"Enter the number of vertices: \");\n    scanf(\" %hd\", &V);\n\n    assert(V <= MAX);\n\n    printf(\"Enter the adj matrix\\n\");\n    uint16_t i, j;\n    for (i = 0; i < V; ++i) {\n        for (j = 0; j < V; ++j) {\n            printf(\"G[%d][%d]: \", i, j);\n            scanf(\" %hd\", &G[i][j]);\n            if (G[i][j] == 0)\n                G[i][j] = INF;\n        }\n    }\n\n    prim(&(*G), &(*MST), V);\n\n    printf(\"minimum spanning tree:\\n\");\n    for (i = 0; i < V; ++i) {\n        printf(\"\\n\");\n        for (j = 0; j < V; ++j) {\n            printf(\"%d\\t\", MST[i][j]);\n        }\n    }\n}\n\n/**\n * @brief Main function\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n * @returns 0 on exit\n */\nint main(int argc, char const *argv[])\n{\n    uint16_t G[MAX][MAX];    ///< weighted, connected graph G\n    uint16_t MST[MAX][MAX];  ///< adj matrix to hold minimum spanning tree of G\n    uint16_t V;              ///< number of vertices in V in G\n\n    if (argc == 2 && strcmp(argv[1], \"-test\") == 0) {\n        test(&(*G), &(*MST), V);\n    } else {\n        user_graph(&(*G), &(*MST), V);\n    }\n\n    return 0;\n}\n```\n</details>\n\n#### 3.4.4 leetcode题目\n- 柠檬水找零\n- 分发饼干\n\n### 3.5 动态规划\n&ensp;动态规划(`DP`):是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.常用于重叠子问题和最优子结构性质的问题,动态规划时间通常远小于朴素解法.\n#### 3.5.1 基本概念\n&ensp;动态规划:要解一个给定问题,需要解其不同部分(即子问题),再根据子问题的解以得出原问题的解.通常子问题非常相似,子问题解算出后,将其记录.\n&ensp;动态规划过程是:每次决策依赖于当前状态,又随即引起状态转移.一个决策序列就是在变化的状态中产生除留的,这种多阶段最优化决策解决过程称为动态规划.\n&ensp;动态规划与分治法的区别是子问题通常不是独立的.\n\n#### 3.5.2 描述算法\n&ensp;可采用动态规划的问题3个性质:\n&emsp;1) **最优化原理**:如果问题的最优解所包含的子问题的解也是最优的,则称该问题具有最优子结构,即满足最优化原理.\n&emsp;2) **无后效性**:即某阶段状态确定后,就不受之后的决策影响,即某状态以后过程不影响以前的状态,只与当前状态有关.\n&emsp;3) **有重叠子问题**:\n\n<br>\n&ensp;动态规划所处理的问题是一个多阶段决策问题,由初始状态开始,通过中间阶段决策的选择,达到结束状态.形成一个决策序列.\n\n&ensp;动态规划求解三要素:\n> (1) 问题的节点\n> (2) 每个阶段的状态\n> (3) 从前一个阶段转化到后一个阶段之间的递推关系\n\n&ensp;**最优决策表**\n> f(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}\n\n#### 3.5.3 背包问题\n\n&ensp;问题描述:\n&emsp;有N件物品和一个体积为V的背包.(每种物品只有一件)第i件物品的体积是volume[i],价值是value[i],求解哪些物品装入背包可使这些物品的体积综合不超过背包体积,且价值总和最大.\n&ensp;解题思路:\n&emsp;p[i][j]代表前i件物品组合在容量为j的背包的最优解.将前i件物品放入容量为v的背包中这个子问题,若只考虑第i件物品的策略(放或不放),那么可以转化为一个只牵扯前i-1物品的问题.如果不放第i件物品,那么问题就转化为\"前i-1件物品放入容量为v的背包中,价值为p[i-1][v];如果放第i件物品,那么问题就转化为\"前i-1物品放入剩下的容量为v-volume[i]的背包中\",此时能获得的最大价值就是p[i-1][j-volume]再加上通过放入第i件物品获得的价值value[i].\n\n\n&ensp;**状态转移方程:**\n> p[i][j] = max{p[i-1][j-vol] + value[i], p[i-1][j]}\n&ensp;伪代码描述:\n```c\nfor i = 1...N\n    for j = V...0\n        p[j] = max{p[j-volume[i]] + value[i], p[j]};\n```\n\n\n<details>\n<summary>dp</summary>\n\n```c\n#include<stdio.h>\nint v[]={6,3,5,4,6};\nint w[]={2,2,6,5,4};\nint dp[100][100];\n \nint Max(int a,int b){\n\tif(a>=b){\n\t\treturn a;\n\t}else{\n\t\treturn b;\n\t}\n}\n \nint getAns(int i,int wi) {\n\t\n\tfor(int x=0;x<=i;x++) {\n\t\tdp[x][0]=0;\n\t}\n\tfor(int x = 0; x <= wi; x++) {\n\t\tdp[0][x]=0;\n\t}\n\t\n\tfor(int x = 1; x <= i; x++) {\n\t\tfor(int y=1;y<=wi;y++) {\n\t\t\tif(y>=w[x-1]) {\n\t\t\t\tdp[x][y]=Max(dp[x-1][y],v[x-1]+dp[x-1][y-w[x-1]]);\n\t\t\t} else {\n\t\t\t\tdp[x][y]=dp[x-1][y];\n\t\t\t}\n\t\t\tprintf(\"%4d\",dp[x][y]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn dp[i][wi];\n}\n \n \nint main() {\n\tint max=getAns(5,10);\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n} \n```\n</details>\n\n#### 3.5.4 最长公共子序列\n&ensp;问题描述:\n&emsp;一个散列S,如果分别是两个或多个已知数列的子序列,且是所有匹配此条件序列中最长的,则S称为已知序列的最长公共子序列(LCS)\n&ensp;给定两个序列X,Y,求两个序列的最长公共子序列.\n&ensp;解题思路:\n&emsp;最长公共子序列问题存在最优子结构；这个问题可分解成更小，更简单的“子问题”，这个子问题可以分成更多的子问题，因此整个问题就变得简单了。\n&emsp;最长公共子序列问题的子问题的解是可以重复使用的，即，更高级别的子问题通常会重用低级子问题的解。拥有这个两个属性的问题可以使用动态规划算法来解决，这样子问题的解就可以存储起来，而不用重复计算。这个过程需要在一个表中存储同一级别的子问题的解，因此这个解可被更高级的子问题使用。设有二维数组f[i][j]表示X的i位和Y的j位之前的最长公共子序列的长度，则有：\n>f[1][1] = same(1,1)\n>f[i][j] = max{f[i-1][j-1] + same(i, j), f[i-1][j], f[i][j-1]}\n&emsp;其中，`same(a,b)`当X的第a位与Y的第b位完全相同是\"1\"，否则位\"1\"。\n&emsp;此时，f[i][j]中最大的数便是X和Y的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。\n&emsp;该算法的空间、时间复杂度位O(n^2)，经过优化后，空间复杂度位O(n)。\n\n\n&ensp;伪代码:\n```c\nfunction LCSLength(X[1..m], Y[1..n])\n    C = array(0..m, 0..n)\n    for i := 0..m\n        C[i, 0] = 0;\n    for j := 0..n\n        C[0, j] = 0\n    for i := 1..m\n        for j := 1..n\n            if X[i] = Y[j]\n                C[i, j] := C[i-1, j-1] + 1\n            else\n                C[i, j] := max(C[i, j-1], C[i-1,j])\n    \n    return C[m, n]\n```\n\n<details>\n<summary>最长公共序列数</summary>\n\n```c\n#include<stdio.h>\n#include<string.h>\nint dp[100][100];\n \nint Max(int a,int b,int c){\n\tint max=a;\n\tif(b>max){\n\t\tmax=b;\n\t}\n\tif(c>max){\n\t\tmax=c;\n\t}\n\treturn max;\n}\n \nint getMax(char s1[],char s2[],int m,int n){\n\tint i,j;\n\t\n\tfor(i=0;i<m;i++){       //当 s2取 1个的时候 ,s1为可变长度 \n\t\tif(s1[i]==s2[0]){\n\t\t\tdp[i][0]=1;\n\t\t\tfor(j=i+1;j<m;j++){\n\t\t\t\tdp[j][0]=1;\n\t\t\t}\n\t\t\tbreak;\n\t\t} \n\t}\n\tfor(i=0;i<n;i++){      //当 s1取 1个的时候 ,s2为可变长度 \n\t\tif(s2[i]==s1[0]){\n\t\t\tdp[0][i]=1;\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tdp[0][j]=1;\n\t\t\t}\n\t\t\tbreak;\n\t\t} \n\t} \n\t\n\tfor(i=1;i<m;i++){\n\t\tfor(j=1;j<n;j++){\n\t\t\tif(s1[i]==s2[j]){\n\t\t\t\tdp[i][j]=Max(dp[i-1][j-1]+1,dp[i-1][j],dp[i][j-1]);\n\t\t\t}else{\n\t\t\t\tdp[i][j]=dp[i-1][j]>=dp[i][j-1]?dp[i-1][j]:dp[i][j-1];\n\t\t\t}\n\t\t}\n\t} \n\treturn dp[m-1][n-1];\n}\n \nint main() {\n\tint m,n;\n\tchar s1[100];\n\tchar s2[100];\n\tgets(s1);\n\tgets(s2);\n\tm=strlen(s1);\n\tn=strlen(s2);\n\t\n\tprintf(\"%d\\n\",getMax(s1,s2,m,n));\n \n\treturn 0;\n}\n```\n</details>\n\n\n<details>\n<summary>Fibonacci_dp</summary>\n\n```c\n// Fibonacci Series using Dynamic Programming\n\n/* Author: Moinak Banerjee(moinak878)\n   Date : 1 October ,2019\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n)\n{\n    // Out of Range checking\n    if (n < 0) {\n        printf(\"\\nNo Such term !\\n\");\n        exit(0);\n    }\n    // declaring array to store fibonacci numbers -- memoization\n    int *f = (int *)malloc((n + 2) * sizeof(int));  //  one extra to handle edge case, n = 0\n    int i;\n\n    /* let 0th and 1st number of the series be 0 and 1*/\n    f[0] = 0;\n    f[1] = 1;\n\n    for (i = 2; i <= n; i++) {\n        // Adding the previous 2 terms to make the 3rd term\n        f[i] = f[i - 1] + f[i - 2];\n    }\n\n    int out = f[n];\n    free(f);\n    return out;\n}\n\nint main(int argc, char *argv[])\n{\n    int number;\n\n    // Asks for the number/position of term in Fibonnacci sequence\n    if (argc == 2) {\n        number = atoi(argv[1]);\n    } else {\n        printf(\"Enter the value of n(n starts from 0 ): \");\n        scanf(\"%d\", &number);\n    }\n\n    printf(\"The nth term is : %d \\n\", fib(number));\n\n    return 0;\n}\n```\n</details>\n\n#### 3.5.5 leetcode题目\n\n- 最大子序和\n- 编辑距离\n- 大礼包\n- 最长上升子序列\n\n\n### 3.6 回溯法\n\n#### 3.6.1 基本概念\n\n&ensp;回溯算法实际上一个类似枚举的搜索尝试过程,主要是在**搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就\"回溯\"返回,尝试别的路径**.\n&ensp;回溯法是一种迭代搜索法,按选优条件详情搜索,以达到目标.但当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择,这种走不通就退回再走的技术为回溯法,而满足回溯条件的某个状态的点称为\"回溯法\".\n&ensp;许多复杂度,规模较大的问题都看看而已使用回溯法,有\"通用解题方法\"的美称.\n\n&ensp;在包含问题的所有解的解空间树中,按照深度优先的策略,从根节点出发深度探索解空间树.当探索到某一节点时,要先判断该节点是否包含问题的解,如果包含,就从该节点出发继续探索下去,如果该节点不包含问题的解,则逐层向其足协节点回溯.(其实回溯法就是堆隐式图的深度优先搜索算法).\n&ensp;若用回溯法求问题的所有解时,要回溯的根,且根节点的所有可行的子树都要已被搜索遍才结束,而若使用回溯法求任一个解时,只要搜索到问题的一个解就可以结束.\n&ensp;回溯法一般解题步骤:\n&emsp;1.**针对所给问题,确定问题的解空间**;首先应明确定义问题的解空间,解空间应至少包含问题的一个(最优)解.\n&emsp;2.**确定节点的扩展搜索规则**\n&emsp;3.**以深度优先方式搜索解空间,并在搜索过程中用剪枝函数避免无效搜索**\n\n&ensp;伪代码:\n```c\n//\nvoid iterativeBacktrack()\n{\n    int t = 1;\n    while (t > 0) {\n        if (f(n, t) <= g(n, t)) {\n            for (int i = f(n,t); i <= g(n,t); i++) {\n                x[t] = h(i);\n                if (constraint(t) && bound(t)) {\n                    //\n                    if (solution(t)) {\n                        output(x);\n                    } else {\n                        t++;\n                    }\n                } else {\n                    t--;\n                }\n            }\n        }\n    }\n}\n```\n\n#### 3.6.2 八皇后问题\n&ensp;问题描述\n&emsp;八皇后问题使一个以国际象棋为背景的问题:如何能够在 8x8 的国际象棋棋盘上放着八个皇后,使得任何一个皇后都无法直接吃掉其他的皇后?为了达到此目的,任两个皇后都不能处于同一条横行,纵行或斜线上.\n&ensp;转化规则:其实八皇后问题可以推广为更一般的n皇后摆放问题;这时棋盘大小变为nxn,而皇后个数也变成n.当且仅当n = 1 或 n >= 4 时间问题有解。令一个一维数组a[n]保存所得解，其中a[i]表示把第i个皇后放在第i行的列数(注意i的值都是从0开始计算的),下面就八皇后问题的约束条件。\n（1）因为所有的皇后都不能放在同一列，因为任意两个a[0]...a[7]的值不能存在相同的两个值\n（2）所有的皇后都不能在堆角线上，那么该如何检测两个皇后是否在同一个对角线上？我们将棋盘的方格成一个二维数组，如下：\n&ensp;假设有两个皇后被放置在(i,j)和(k,l)的位置上，明显，当且仅当|i-k|=|j-l|时，两个皇后才在同一条对角线上。\n\n&ensp;伪代码描述\n```c\nint queens(int Queens) {\n    int i, k, flag, not_finish = 1, count = 0,\n    // 正在处理的元素下标，表示前i-1个元素已符合要求，在处理第i个元素\n    int a[Queeens+1]; // 八皇后问题的皇后所在的行列位置，从1开始算起，所以加1\n    i = 1;\n    a[1] = 1; // 为数组的第一个元素赋初值\n    while (not_finish) { // not_finish=1 处理尚未结束\n        while(not_finish && i <= Queens) { // 处理尚未结束且还没处理到第Queeens个元素\n        for (flag=1, k=1; flag && k < i; k++) {\n            // 判断是否有多个皇后在同一行\n            if (a[k] == a[i]) {\n                flag = 0;\n            }\n        }\n        // 判断是否有多个皇后在同一个对角线\n        for (k=1; flag && k < i; k++) {\n            if ((a[i] == a[k] - (k-i)) || (a]i] == a[k] + [k-i])) {\n                flag = 0;\n            }\n        }\n\n\n        }\n    }\n}\n```\n\n#### 3.6.3 leetcode题目\n- N皇后\n- 括号生成\n- 单词搜索\n- 解数独\n\n\n## 4 参考链接\n\n- 复杂度速查表\nhttps://liam.page/2016/06/20/big-O-cheat-sheet/\n- 线性表\nhttps://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8\n    - 单链表\nhttps://www.jianshu.com/p/73f0d8f807aa\n\nhttp://cocofe.cn/\n\n- 数据结构\nhttps://github.com/wangzheng0822/algo/\n","slug":"数据结构与算法基础","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8vq000t0guu41xb81dr","content":"<h2 id=\"1-程序性能\"><a href=\"#1-程序性能\" class=\"headerlink\" title=\"1 程序性能\"></a>1 程序性能</h2><span id=\"more\"></span>\n\n<p> 程序性能是指运行程序所需要的<strong>内存大小(空间复杂度)和时间(时间复杂度)</strong>,运行时间和占用空间是算法性能最关键的指标。<br> 软件程序性能衡量指标:<br> 响应时间、启动时间、执行时间、执行速度、计算资源分配、内存分配、磁盘吞吐量、网络吞吐量、负载承受能力</p>\n<h3 id=\"1-1-空间复杂度\"><a href=\"#1-1-空间复杂度\" class=\"headerlink\" title=\"1.1 空间复杂度\"></a>1.1 空间复杂度</h3><p> 空间复杂度(Space complexity)，算法完全运行所需存储空间。表示算法的存储空间与数据规模之间的增长关系：常量空间、线性空间、二维空间。<br> 算法在计算机存储器上所占用的存储空间，包括<strong>存储程序本身占用的存储空间，算法输入输出数据所占的存储空间和算法在运行过程中临时占用的存储空间</strong>。</p>\n<h3 id=\"1-2-时间复杂度\"><a href=\"#1-2-时间复杂度\" class=\"headerlink\" title=\"1.2 时间复杂度\"></a>1.2 时间复杂度</h3><p> 时间复杂度(Time complexity)，算法完全运行所需运算时间。时间复杂度通常用大O符合表示。</p>\n<p><img src=\"https://i.loli.net/2021/10/27/UxWCvnRQLYz5eiG.png\" alt=\"20211027233029\"></p>\n<h4 id=\"1-2-1-常见算法大O\"><a href=\"#1-2-1-常见算法大O\" class=\"headerlink\" title=\"1.2.1 常见算法大O\"></a>1.2.1 常见算法大O</h4><p>  常量阶O(1); 对数阶O(logn); 线性阶O(n); 线性对数阶O(nlogn); k次方阶O(n^k)<br><img src=\"https://i.loli.net/2021/10/28/GWOFcUi3qdVIlmf.png\" alt=\"20211028010721\"></p>\n<h4 id=\"1-2-2-常见数据结构\"><a href=\"#1-2-2-常见数据结构\" class=\"headerlink\" title=\"1.2.2 常见数据结构\"></a>1.2.2 常见数据结构</h4><blockquote class=\"pullquote mindmap mindmap-md\"><ul>\n<li>数据结构与算法<ul>\n<li>线性表<ul>\n<li>数组</li>\n<li>链表<ul>\n<li>单链表</li>\n<li>双链表</li>\n<li>循环链表</li>\n<li>双向循环链表</li>\n<li>静态链表</li>\n</ul>\n</li>\n<li>栈<ul>\n<li>顺序栈</li>\n<li>链式栈</li>\n</ul>\n</li>\n<li>队列<ul>\n<li>普通队列</li>\n<li>双端队列</li>\n<li>阻塞队列</li>\n<li>并发队列</li>\n<li>阻塞并发队列</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>散列表<ul>\n<li>散列函数</li>\n<li>冲突解决<ul>\n<li>链表法</li>\n<li>开放地址</li>\n<li>其他</li>\n</ul>\n</li>\n<li>动态扩容</li>\n<li>位置</li>\n</ul>\n</li>\n<li>树<ul>\n<li>二叉树<ul>\n<li>二叉查找树</li>\n<li>平衡二叉树</li>\n<li>平衡二叉查找树<ul>\n<li>AVL树</li>\n<li>红黑树</li>\n</ul>\n</li>\n<li>完全二叉树</li>\n<li>满二叉树</li>\n</ul>\n</li>\n<li>多路查找树<ul>\n<li>B树</li>\n<li>B+树</li>\n<li>2-3树</li>\n<li>2-3-4树</li>\n</ul>\n</li>\n<li>堆<ul>\n<li>小顶堆</li>\n<li>大顶堆</li>\n<li>优先级队列</li>\n<li>斐波那契堆</li>\n<li>二项堆</li>\n</ul>\n</li>\n<li>其他<ul>\n<li>树状数组</li>\n<li>线段树</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>图<ul>\n<li>图的存储<ul>\n<li>邻接矩阵</li>\n<li>邻接表</li>\n</ul>\n</li>\n<li>拓扑排序</li>\n<li>最短路径</li>\n<li>关键路径</li>\n<li>最小生成树</li>\n<li>二分图</li>\n<li>最大流</li>\n</ul>\n</li>\n<li>复杂度分析<ul>\n<li>空间复杂度</li>\n<li>时间复杂度</li>\n</ul>\n</li>\n<li>基本算法思想<ul>\n<li>分治法</li>\n<li>递归算法</li>\n<li>贪心算法</li>\n<li>动态规划</li>\n<li>回溯法</li>\n<li>枚举法</li>\n</ul>\n</li>\n<li>排序<ul>\n<li>O(n^2)<ul>\n<li>冒泡排序</li>\n<li>插入排序</li>\n<li>选择排序</li>\n<li>希尔排序</li>\n</ul>\n</li>\n<li>O(nlogn)<ul>\n<li>归并排序</li>\n<li>快速排序</li>\n<li>堆排序</li>\n</ul>\n</li>\n<li>O(n)<ul>\n<li>计数排序</li>\n<li>基数排序</li>\n<li>桶排序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>搜索<ul>\n<li>深度优先搜索</li>\n<li>广度优先搜索</li>\n<li>A*启发式搜索</li>\n</ul>\n</li>\n<li>查找<ul>\n<li>线性表查找</li>\n<li>树结构查找</li>\n<li>散列表查找</li>\n</ul>\n</li>\n<li>字符串匹配<ul>\n<li>朴素</li>\n<li>KMP</li>\n<li>Robin-Karp</li>\n<li>Boyer-Moore</li>\n<li>AC自动机</li>\n<li>Trie</li>\n<li>后缀数组</li>\n</ul>\n</li>\n<li>其他<ul>\n<li>数论</li>\n<li>计算几何</li>\n<li>概率分析</li>\n<li>并查集</li>\n<li>拓扑网络</li>\n<li>矩阵运算</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n\n<h3 id=\"本章参考：\"><a href=\"#本章参考：\" class=\"headerlink\" title=\"本章参考：\"></a>本章参考：</h3><ul>\n<li>复杂度速查表<br><a href=\"https://liam.page/2016/06/20/big-O-cheat-sheet/\">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></li>\n</ul>\n<h2 id=\"2-基本数据结构\"><a href=\"#2-基本数据结构\" class=\"headerlink\" title=\"2 基本数据结构\"></a>2 基本数据结构</h2><h3 id=\"2-1-线性表\"><a href=\"#2-1-线性表\" class=\"headerlink\" title=\"2.1 线性表\"></a>2.1 线性表</h3><p> 线性表是n个具有相同特性的数据元素的有序序列。线性表除第一个和最后一个数据元素之外，其他数据元素都是首尾相接的。<br> 数据在实际的物理存储中有两种形式：分散存储和集中存储,常见数据结构有栈、队列、字符串、链表等。<br> 两种情况下数据的存储问题：<br>  数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；<br>  数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”</p>\n<h4 id=\"2-1-1-数组\"><a href=\"#2-1-1-数组\" class=\"headerlink\" title=\"2.1.1 数组\"></a>2.1.1 数组</h4><p> 数组是一批相同数据的集合。数组的三部分：<code>地址 大小 和 空间</code>。数组的保存形式为线性表。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>]; <span class=\"comment\">// /[]内必须是常量/常量表达式(3+8)，不能是一个变量(x...)</span></span><br><span class=\"line\"><span class=\"comment\">// 数组初始化</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> arr1[<span class=\"number\">3</span>] = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>};</span><br><span class=\"line\"><span class=\"keyword\">char</span> arr6[] = <span class=\"string\">\"abcdef\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *ptr = <span class=\"literal\">NULL</span>;<span class=\"comment\">//定义一个整型的指针变量，初始化为NULL</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *ptr = <span class=\"literal\">NULL</span>;<span class=\"comment\">//定义一个字符的指针变量，初始化为NULL</span></span><br><span class=\"line\"><span class=\"comment\">// 二维数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>][<span class=\"number\">5</span>] = { <span class=\"number\">0</span> };</span><br><span class=\"line\"><span class=\"comment\">// C 传递数组给函数</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> *param)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> param[<span class=\"number\">10</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> param[])</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// C 从函数返回数组</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">myFunction</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">...</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<details>\n<summary>array</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">array</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> used;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *arr;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(struct <span class=\"built_in\">array</span> *<span class=\"built_in\">array</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>; idx &lt; <span class=\"built_in\">array</span>-&gt;used; idx++) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"[%02d]: %08d\\n\"</span>, idx, <span class=\"built_in\">array</span>-&gt;arr[idx]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alloc</span><span class=\"params\">(struct <span class=\"built_in\">array</span> *<span class=\"built_in\">array</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"built_in\">array</span>-&gt;arr = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">array</span>-&gt;size * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insert</span><span class=\"params\">(struct <span class=\"built_in\">array</span> *<span class=\"built_in\">array</span>, <span class=\"keyword\">int</span> elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>-&gt;used &gt;= <span class=\"built_in\">array</span>-&gt;size)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (idx = <span class=\"number\">0</span>; idx &lt; <span class=\"built_in\">array</span>-&gt;used; idx++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>-&gt;arr[idx] &gt; elem)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"built_in\">array</span>-&gt;used)</span><br><span class=\"line\">        memmove(&amp;<span class=\"built_in\">array</span>-&gt;arr[idx+<span class=\"number\">1</span>], &amp;<span class=\"built_in\">array</span>-&gt;arr[idx],</span><br><span class=\"line\">            (<span class=\"built_in\">array</span>-&gt;used - idx) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">array</span>-&gt;arr[idx] = elem;</span><br><span class=\"line\">    <span class=\"built_in\">array</span>-&gt;used++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> idx;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">delete</span><span class=\"params\">(struct <span class=\"built_in\">array</span> *<span class=\"built_in\">array</span>, <span class=\"keyword\">int</span> idx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span> || idx &gt;= <span class=\"built_in\">array</span>-&gt;used)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    memmove(&amp;<span class=\"built_in\">array</span>-&gt;arr[idx], &amp;<span class=\"built_in\">array</span>-&gt;arr[idx+<span class=\"number\">1</span>],</span><br><span class=\"line\">        (<span class=\"built_in\">array</span>-&gt;used - idx - <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"built_in\">array</span>-&gt;used--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(struct <span class=\"built_in\">array</span> *<span class=\"built_in\">array</span>, <span class=\"keyword\">int</span> elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>; idx &lt; <span class=\"built_in\">array</span>-&gt;used; idx++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>-&gt;arr[idx] == elem)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> idx;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>-&gt;arr[idx] &gt; elem)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">array</span> <span class=\"title\">ten_int</span> =</span> {<span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    alloc(&amp;ten_int);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ten_int.arr) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    insert(&amp;ten_int, <span class=\"number\">1</span>);</span><br><span class=\"line\">    insert(&amp;ten_int, <span class=\"number\">3</span>);</span><br><span class=\"line\">    insert(&amp;ten_int, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"=== insert 1, 3, 2\\n\"</span>);</span><br><span class=\"line\">    dump(&amp;ten_int);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = search(&amp;ten_int, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"2 is at position %d\\n\"</span>, idx);</span><br><span class=\"line\">    idx = search(&amp;ten_int, <span class=\"number\">9</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"9 is at position %d\\n\"</span>, idx);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"=== delete [6] element \\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>(&amp;ten_int, <span class=\"number\">6</span>);</span><br><span class=\"line\">    dump(&amp;ten_int);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"=== delete [0] element \\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>(&amp;ten_int, <span class=\"number\">0</span>);</span><br><span class=\"line\">    dump(&amp;ten_int);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<br>\n\n<p><strong>二分搜索</strong><br> 基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）<br> 二分搜索的时间复杂度为 <em><strong>对数时间O(logn)</strong></em></p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binary_search</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid, count = <span class=\"number\">0</span>, count1 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(low &lt; high) {</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        mid = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; a[mid]) {</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; a[mid]) {</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key == a[mid]) {</span><br><span class=\"line\">            count1++;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count1 == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"2-1-2-单链表\"><a href=\"#2-1-2-单链表\" class=\"headerlink\" title=\"2.1.2 单链表\"></a>2.1.2 单链表</h4><p>  单链表元素之间有一个单独的指针链接。这种结构的链表可以使得从第一个元素遍历到最后一个元素</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListElmt_</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data;  <span class=\"comment\">// 数据成员</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListElmt_</span> * <span class=\"title\">next</span>;</span> <span class=\"comment\">// next指针</span></span><br><span class=\"line\">} ListElmt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">List_</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destroy)(<span class=\"keyword\">void</span> *data);</span><br><span class=\"line\">    ListElmt *head;</span><br><span class=\"line\">    ListElmt *tail;</span><br><span class=\"line\">} List;</span><br></pre></td></tr></tbody></table></figure>\n<p> 单链表操作：插入、删除、<br> 如何判断单链表存在回环？<br>  设有两个指针p1，p2。在美学循环的时候，p1先走一步，p2走两步，直到p2碰到空指针或者两者相等时循环结束，如果两个指针相等则说明存在回环。</p>\n<details>\n<summary>singleList</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __SINGLELIST_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __SINGLELIST_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> {</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\">}listNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">linkedList</span> {</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> typesize;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>(*dup)(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>(*match)(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>(*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span>*);</span><br><span class=\"line\">}linkedList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList *<span class=\"title\">listCreate</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRelease</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listEmpty</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">linkedList *<span class=\"title\">listAddNodeHead</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span>;</span><br><span class=\"line\"><span class=\"function\">linkedList *<span class=\"title\">listAddNodeTail</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span>;</span><br><span class=\"line\"><span class=\"function\">linkedList *<span class=\"title\">listInsertNode</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, listNode *old_node, <span class=\"keyword\">void</span> *value, <span class=\"keyword\">bool</span> after)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listDelNode</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, listNode *node)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listSearchKey</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *key)</span></span>;</span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listIndex</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">long</span> index)</span></span>;</span><br><span class=\"line\"><span class=\"function\">linkedList* <span class=\"title\">listRewind</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">listLength</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// !__SINGLELIST_H__</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"singleList.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList * <span class=\"title\">listCreate</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    linkedList *<span class=\"built_in\">list</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span> = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(*<span class=\"built_in\">list</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;dup = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;match = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRelease</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    listEmpty(<span class=\"built_in\">list</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"built_in\">list</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listEmpty</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">NULL</span> != <span class=\"built_in\">list</span>-&gt;head) {</span><br><span class=\"line\">        listNode *pNode = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = pNode-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>(pNode-&gt;value);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(pNode-&gt;value);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        pNode-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(pNode);</span><br><span class=\"line\">        pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList * <span class=\"title\">listAddNodeHead</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> * value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span> || <span class=\"literal\">NULL</span> == value) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(*node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == node) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\">    node-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = node;</span><br><span class=\"line\"></span><br><span class=\"line\">    ++<span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList * <span class=\"title\">listAddNodeTail</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span> || <span class=\"literal\">NULL</span> == value) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(*node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == node) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>-&gt;head &amp;&amp; <span class=\"built_in\">list</span>-&gt;len == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = node;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        listNode *tail = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        listNode *pre = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">NULL</span> != tail) {</span><br><span class=\"line\">            pre = tail;</span><br><span class=\"line\">            tail = tail-&gt;next;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        pre-&gt;next = node;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    ++<span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList * <span class=\"title\">listInsertNode</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, listNode *old_node, <span class=\"keyword\">void</span> *value, <span class=\"keyword\">bool</span> after)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span> || <span class=\"literal\">NULL</span> == old_node) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    pNode = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(*pNode));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == pNode) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    pNode-&gt;value = value;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (after) {</span><br><span class=\"line\">        pNode-&gt;next = old_node-&gt;next;</span><br><span class=\"line\">        old_node-&gt;next = pNode;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        listNode *pre = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pre-&gt;next != old_node) {</span><br><span class=\"line\">            pre = pre-&gt;next;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != pre) {</span><br><span class=\"line\">            pre-&gt;next = pNode;</span><br><span class=\"line\">            pNode-&gt;next = old_node;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    ++<span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listDelNode</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, listNode *node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span> || <span class=\"literal\">NULL</span> == node) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *pre = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    listNode *cur = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">NULL</span> != cur &amp;&amp; cur != node) {</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        cur = cur-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == pre) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    pre-&gt;next = node-&gt;next;</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    --<span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>(node-&gt;value);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(node);</span><br><span class=\"line\">        node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">listNode * <span class=\"title\">listSearchKey</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *node = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">NULL</span> != node) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != <span class=\"built_in\">list</span>-&gt;match) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;match(key, node-&gt;value) == <span class=\"number\">0</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key == node-&gt;value) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        node = node-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">listNode * <span class=\"title\">listIndex</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">long</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt;= <span class=\"number\">0</span> || index &gt; <span class=\"built_in\">list</span>-&gt;len) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *pNode = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> i = <span class=\"number\">0</span>; i &lt; index; ++i) {</span><br><span class=\"line\">        pNode = pNode-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> pNode;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList* <span class=\"title\">listRewind</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *head = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    listNode *pre = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    listNode *next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">NULL</span> != head) {</span><br><span class=\"line\">        next = head-&gt;next;</span><br><span class=\"line\">        head-&gt;next = pre;</span><br><span class=\"line\">        pre = head;</span><br><span class=\"line\">        head = next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = pre;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">listLength</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<details>\n<summary>single_list</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> {</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list_head</span> {</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">head</span>;</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_empty</span><span class=\"params\">(struct single_list_head *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head-&gt;head == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(struct single_list_head *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">tmp</span> =</span> head-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"[%02d]: %08d\\n\"</span>, idx++, tmp-&gt;val);</span><br><span class=\"line\">        tmp = tmp-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(struct single_list **prev, struct single_list *elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!prev)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    elem-&gt;next = *prev;</span><br><span class=\"line\">    *prev = elem;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_head</span><span class=\"params\">(struct single_list_head *head, struct single_list *elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    insert(&amp;head-&gt;head, elem);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct single_list* <span class=\"title\">del</span><span class=\"params\">(struct single_list **prev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">tmp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!prev)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*prev == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    tmp = *prev;</span><br><span class=\"line\">    *prev = (*prev)-&gt;next;</span><br><span class=\"line\">    tmp-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct single_list* <span class=\"title\">delete_head</span><span class=\"params\">(struct single_list_head* head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> del(&amp;head-&gt;head);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct single_list** <span class=\"title\">search</span><span class=\"params\">(struct single_list_head* head, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> **<span class=\"title\">prev</span>, *<span class=\"title\">tmp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (prev = &amp;head-&gt;head, tmp = *prev; tmp &amp;&amp; (tmp-&gt;val &lt; target);</span><br><span class=\"line\">    prev = &amp;tmp-&gt;next, tmp = *prev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(struct single_list_head* head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list_head</span> <span class=\"title\">tmp</span> =</span> {<span class=\"literal\">NULL</span>};</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">elem</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!is_empty(head)) {</span><br><span class=\"line\">        elem = delete_head(head);</span><br><span class=\"line\">        insert_head(&amp;tmp, elem);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    head-&gt;head = tmp.head;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_cyclic</span><span class=\"params\">(struct single_list_head* head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">s1</span>, *<span class=\"title\">s2</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    s1 = s2 = head-&gt;head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(s1 &amp;&amp; s2) {</span><br><span class=\"line\">        s1 = s1-&gt;next;</span><br><span class=\"line\">        s2 = s2-&gt;next ? s2-&gt;next-&gt;next:s2-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1 == s2)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct single_list* <span class=\"title\">middle</span><span class=\"params\">(struct single_list_head* head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">s1</span>, *<span class=\"title\">s2</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> <span class=\"title\">pseudo_head</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    pseudo_head.next = head-&gt;head;</span><br><span class=\"line\">    s1 = s2 = &amp;pseudo_head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!s2 || !s2-&gt;next)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s1;</span><br><span class=\"line\">        s1 = s1-&gt;next;</span><br><span class=\"line\">        s2 = s2-&gt;next-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list_head</span> <span class=\"title\">head</span> =</span> {<span class=\"literal\">NULL</span>};</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> <span class=\"title\">lists</span>[10];</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> **<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (idx = <span class=\"number\">0</span>; idx &lt; <span class=\"number\">10</span>; idx++) {</span><br><span class=\"line\">        lists[idx].val = idx;</span><br><span class=\"line\">        lists[idx].next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    insert_head(&amp;head, &amp;lists[<span class=\"number\">6</span>]);</span><br><span class=\"line\">    insert_head(&amp;head, &amp;lists[<span class=\"number\">5</span>]);</span><br><span class=\"line\">    insert_head(&amp;head, &amp;lists[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    insert_head(&amp;head, &amp;lists[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    insert_head(&amp;head, &amp;lists[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"=== insert 0, 1, 4, 5, 6\\n\"</span>);</span><br><span class=\"line\">    dump(&amp;head);</span><br><span class=\"line\"></span><br><span class=\"line\">    prev = search(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    insert(prev, &amp;lists[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"=== insert 2\\n\"</span>);</span><br><span class=\"line\">    dump(&amp;head);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"middle elem is %d\\n\"</span>, middle(&amp;head)-&gt;val);</span><br><span class=\"line\"></span><br><span class=\"line\">    prev = search(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((*prev) &amp;&amp; ((*prev)-&gt;val == <span class=\"number\">2</span>))</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"The list contains 2\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"The list not contains 2\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    del(prev);</span><br><span class=\"line\">    prev = search(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"After remove 2\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((*prev) &amp;&amp; ((*prev)-&gt;val == <span class=\"number\">2</span>))</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"The list contains 2\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"The list not contains 2\\n\"</span>);</span><br><span class=\"line\">    dump(&amp;head);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"After reverse \\n\"</span>);</span><br><span class=\"line\">    reverse(&amp;head);</span><br><span class=\"line\">    dump(&amp;head);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"middle elem is %d\\n\"</span>, middle(&amp;head)-&gt;val);</span><br><span class=\"line\"></span><br><span class=\"line\">    lists[<span class=\"number\">0</span>].next = &amp;lists[<span class=\"number\">6</span>];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"list is%s cyclic\\n\"</span>, is_cyclic(&amp;head)?<span class=\"string\">\"\"</span>:<span class=\"string\">\" not\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<details>\n<summary>LinkedListAlgo</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 1) 单链表反转</span></span><br><span class=\"line\"><span class=\"comment\"> * 2) 链表中环的检测</span></span><br><span class=\"line\"><span class=\"comment\"> * 3) 两个有序的链表合并</span></span><br><span class=\"line\"><span class=\"comment\"> * 4) 删除链表倒数第 n 个结点</span></span><br><span class=\"line\"><span class=\"comment\"> * 5) 求链表的中间结点</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author: Smallfly</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SinglyLinkedNode</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SinglyLinkedNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">} SinglyLinkedNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insertNode</span><span class=\"params\">(SinglyLinkedNode** head_ref, <span class=\"keyword\">int</span> data)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printLinkedList</span><span class=\"params\">(SinglyLinkedNode* head)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 反转单链表 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(SinglyLinkedNode** head_ref)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*head_ref == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    SinglyLinkedNode *current = *head_ref;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current) {</span><br><span class=\"line\">        SinglyLinkedNode *next = current-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!next) {</span><br><span class=\"line\">            <span class=\"comment\">// 到达尾结点时，将地址存入 head_ref</span></span><br><span class=\"line\">            *head_ref = current;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        current-&gt;next = prev;</span><br><span class=\"line\">        prev = current;</span><br><span class=\"line\">        current = next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_reverse</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    SinglyLinkedNode* head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">3</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    reverse(&amp;head);</span><br><span class=\"line\">    printLinkedList(head);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 检测单链表是否有环 */</span></span><br><span class=\"line\"><span class=\"comment\">// 这里使用一级指针也可以</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">checkCircle</span><span class=\"params\">(SinglyLinkedNode** head_ref)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*head_ref == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    SinglyLinkedNode *slow = *head_ref, *fast = *head_ref;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slow == fast) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_checkCircle</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    SinglyLinkedNode* head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">3</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result1 = checkCircle(&amp;head);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"has circle: %d\\n\"</span>, result1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// make circle linklist</span></span><br><span class=\"line\">    SinglyLinkedNode* current = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(SinglyLinkedNode));</span><br><span class=\"line\">    current-&gt;data = <span class=\"number\">0</span>;</span><br><span class=\"line\">    SinglyLinkedNode* h = current;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">4</span>; ++i) {</span><br><span class=\"line\">        SinglyLinkedNode* node = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(SinglyLinkedNode));</span><br><span class=\"line\">        node-&gt;data = i;</span><br><span class=\"line\">        current-&gt;next = node;</span><br><span class=\"line\">        <span class=\"comment\">//reset current node</span></span><br><span class=\"line\">        current = node;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    current-&gt;next = h;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result2 = checkCircle(&amp;h);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"has circle: %d\\n\"</span>, result2);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 有序链表合并 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveNode</span><span class=\"params\">(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">SinglyLinkedNode* <span class=\"title\">mergeSortedLinkedList</span><span class=\"params\">(SinglyLinkedNode* la, SinglyLinkedNode* lb)</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 辅助结点，next 指针持有合并后的有序链表</span></span><br><span class=\"line\">    SinglyLinkedNode dummy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 有序链表的尾结点</span></span><br><span class=\"line\">    SinglyLinkedNode* tail = &amp;dummy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 如果有一个链表为空，直接与另一个链表接起来</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!la) {</span><br><span class=\"line\">            tail-&gt;next = lb;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!lb) {</span><br><span class=\"line\">            tail-&gt;next = la;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将头结点较小的优先添加到 tail</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (la-&gt;data &lt;= lb-&gt;data) {</span><br><span class=\"line\">            moveNode(&amp;(tail-&gt;next), &amp;la);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            moveNode(&amp;(tail-&gt;next), &amp;lb);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        tail = tail-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 src_ref 的头结点，添加到 dest_ref 的头部。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveNode</span><span class=\"params\">(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*src_ref == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    SinglyLinkedNode* new_node = *src_ref;</span><br><span class=\"line\">    </span><br><span class=\"line\">    *src_ref = new_node-&gt;next;</span><br><span class=\"line\">    </span><br><span class=\"line\">    new_node-&gt;next = *dest_ref;</span><br><span class=\"line\">    *dest_ref = new_node;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_mergeSortedLinkedList</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    SinglyLinkedNode* a = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;a, <span class=\"number\">10</span>);</span><br><span class=\"line\">    insertNode(&amp;a, <span class=\"number\">5</span>);</span><br><span class=\"line\">    insertNode(&amp;a, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode* b = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;b, <span class=\"number\">8</span>);</span><br><span class=\"line\">    insertNode(&amp;b, <span class=\"number\">6</span>);</span><br><span class=\"line\">    insertNode(&amp;b, <span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode* result = mergeSortedLinkedList(a, b);</span><br><span class=\"line\">    printLinkedList(result);</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode* result2 = mergeSortedLinkedList(a, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    printLinkedList(result2);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 删除倒数第 K 个结点 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteLastKth</span><span class=\"params\">(SinglyLinkedNode** head_ref, <span class=\"keyword\">int</span> k)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*head_ref == <span class=\"literal\">NULL</span> || k == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 快指针向前移动 k-1</span></span><br><span class=\"line\">    SinglyLinkedNode* fast = *head_ref;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; k &amp;&amp; fast != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        ++i;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果快指针为空，说明结点个数小于 k</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fast == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode* slow = *head_ref;</span><br><span class=\"line\">    SinglyLinkedNode* prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast-&gt;next != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        prev = slow;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果 prev 为空，头结点刚好是第 k 个结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!prev) {</span><br><span class=\"line\">        (*head_ref) = (*head_ref)-&gt;next;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        prev-&gt;next = slow-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(slow);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_deleteLastKth</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    SinglyLinkedNode* head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">1</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">3</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">4</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">5</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1. 删除头结点</span></span><br><span class=\"line\">    deleteLastKth(&amp;head, <span class=\"number\">5</span>);</span><br><span class=\"line\">    printLinkedList(head);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 删除中间结点</span></span><br><span class=\"line\">    deleteLastKth(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    printLinkedList(head);</span><br><span class=\"line\">    </span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 求中间结点  */</span></span><br><span class=\"line\"><span class=\"function\">SinglyLinkedNode* <span class=\"title\">findMiddleNode</span><span class=\"params\">(SinglyLinkedNode* head)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    SinglyLinkedNode* slow = head;</span><br><span class=\"line\">    SinglyLinkedNode* fast = head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1. 慢指针走一步，快指针两步</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast-&gt;next != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_findMiddleNode</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    SinglyLinkedNode* head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">1</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">3</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">4</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">5</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode* middleNode = findMiddleNode(head);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, middleNode-&gt;data);</span><br><span class=\"line\">    printLinkedList(head);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 工具方法 */</span></span><br><span class=\"line\"><span class=\"comment\">// 插入新结点到链表头部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insertNode</span><span class=\"params\">(SinglyLinkedNode** head_ref, <span class=\"keyword\">int</span> data)</span> </span>{</span><br><span class=\"line\">    SinglyLinkedNode* new_node = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(SinglyLinkedNode));</span><br><span class=\"line\">    new_node-&gt;data = data;</span><br><span class=\"line\">    new_node-&gt;next = *head_ref;</span><br><span class=\"line\">    *head_ref = new_node;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printLinkedList</span><span class=\"params\">(SinglyLinkedNode* node)</span> </span>{</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"--- start ---\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (node) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"data: %d\\n\"</span>, node-&gt;data);</span><br><span class=\"line\">        node = node-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"--- end ---\\n\"</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 跑测试</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    test_reverse();  </span><br><span class=\"line\"><span class=\"comment\">//    test_checkCircle();</span></span><br><span class=\"line\"><span class=\"comment\">//    test_mergeSortedLinkedList();</span></span><br><span class=\"line\"><span class=\"comment\">//    test_deleteLastKth();  </span></span><br><span class=\"line\"><span class=\"comment\">//    test_findMiddleNode();</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<details>\n<summary>linklist_jinshaohui</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: lisklist.c</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-10-07  </span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stlistNode</span></span></span><br><span class=\"line\"><span class=\"class\">{</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">}listNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*反转链表*/</span></span><br><span class=\"line\"><span class=\"function\">listNode <span class=\"title\">reverseList</span><span class=\"params\">(listNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    listNode *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    listNode *next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        next = head-&gt;next;</span><br><span class=\"line\">        head-&gt;next = prev;</span><br><span class=\"line\">        prev = head;</span><br><span class=\"line\">        head = next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*判断链表是否有环*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hasCycle</span><span class=\"params\">(listNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    listNode * fast = head;</span><br><span class=\"line\">    listNode * low = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        low = low-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (low == fast) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*合并有序链表*/</span></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">mergeTwoLists</span><span class=\"params\">(listNode *l1,listNode *l2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    listNode head = {<span class=\"number\">0</span>};</span><br><span class=\"line\">    listNode *pRes = &amp;head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1 == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            pRes-&gt;next = l2;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            pRes-&gt;next = l1;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1-&gt;val &lt; l2-&gt;val) {</span><br><span class=\"line\">            pRes-&gt;next = l1;</span><br><span class=\"line\">            l1 = l1-&gt;next;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            pRes-&gt;next = l2;</span><br><span class=\"line\">            l2 = l2-&gt;next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        pRes = pRes-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *删除链表倒数第n个节点，并返回链表头节点 */</span></span><br><span class=\"line\"><span class=\"function\">listNode * <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(listNode*headi,<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    listNode *fast = head;</span><br><span class=\"line\">    listNode *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    listNpde *next = head;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = n;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*快指针往后移动k-1*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((k &gt; <span class=\"number\">1</span>) &amp;&amp; (fast != <span class=\"literal\">NULL</span>)) {</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        k--;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*说明链表数目不足n个*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fast == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast-&gt;next != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        prev = next;</span><br><span class=\"line\">        next = next-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(prev == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*求链表的中间节点*/</span></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">middleNode</span><span class=\"params\">(listNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    listNode * fast = head;</span><br><span class=\"line\">    listNode * low = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        low = low-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<h4 id=\"2-1-3-双链表\"><a href=\"#2-1-3-双链表\" class=\"headerlink\" title=\"2.1.3 双链表\"></a>2.1.3 双链表</h4><p>  双向链表的元素通过两个指针链接，一个指向直接后继，一个指向直接前驱。双向链表可以正向遍历，也可反向遍历。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DListElmt_</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DListElmt_</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DListElmt_</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">} DListElmt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DList_</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destroy)(<span class=\"keyword\">void</span> *data);</span><br><span class=\"line\">    DListElmt *head;</span><br><span class=\"line\">    DListElmt *tail;</span><br><span class=\"line\">} DList;</span><br></pre></td></tr></tbody></table></figure>\n\n<details>\n<summary>Dlist</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Dlist.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DlistNode</span> {</span>    <span class=\"comment\">//双向链表中每一个节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DlistNode</span> *<span class=\"title\">prev</span>;</span>   <span class=\"comment\">//节点前项指针</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DlistNode</span> *<span class=\"title\">next</span>;</span>   <span class=\"comment\">//节点后项指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>    data;              <span class=\"comment\">//数据</span></span><br><span class=\"line\">}stDlistNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Dlisthead</span> {</span>    <span class=\"comment\">//定义链表总体</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;                 <span class=\"comment\">//链表长度</span></span><br><span class=\"line\">    stDlistNode *head;        <span class=\"comment\">//头指针</span></span><br><span class=\"line\">    stDlistNode *tail;        <span class=\"comment\">//尾部指针</span></span><br><span class=\"line\">}stDlistHead;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dlist.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"./Dlist.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dlist_init</span><span class=\"params\">(stDlistHead *dlist)</span>    <span class=\"comment\">//链表初始化</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    dlist-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dlist-&gt;head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    dlist-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dlist_destory</span><span class=\"params\">(stDlistHead *dlist)</span>    <span class=\"comment\">//删除链表</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    stDlistNode *pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(dlist-&gt;size &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">        pNode = dlist-&gt;head;</span><br><span class=\"line\">        dlist-&gt;head = dlist-&gt;head-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(pNode);</span><br><span class=\"line\">        dlist-&gt;size--;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dlist,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(stDlistHead));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dlist_insert_head</span><span class=\"params\">(stDlistHead *dlist,stDlistNode *pNode,<span class=\"keyword\">int</span> data)</span>    <span class=\"comment\">//插入头结点，操作的链表，操作的节点，数据</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pNode == <span class=\"literal\">NULL</span>) {   <span class=\"comment\">//当只传递一个数据时</span></span><br><span class=\"line\">        pNode = (stDlistNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(stDlistNode));    <span class=\"comment\">//新建节点，为节点分配空间（malloc（）可能需要#include&lt;malloc.h&gt;）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pNode == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    pNode-&gt;data = data;    </span><br><span class=\"line\">    pNode-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    pNode-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dlist-&gt;size == <span class=\"number\">0</span>) {  <span class=\"comment\">//如果链表长度为0，即链表当前无节点，</span></span><br><span class=\"line\">        dlist-&gt;head = pNode;</span><br><span class=\"line\">        dlist-&gt;tail = pNode;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {                 <span class=\"comment\">//如果链表已有节点，则令新插入节点为头节点</span></span><br><span class=\"line\">        pNode-&gt;next = dlist-&gt;head;</span><br><span class=\"line\">        dlist-&gt;head-&gt;prev = pNode;</span><br><span class=\"line\">        dlist-&gt;head = pNode;    </span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    dlist-&gt;size++;    <span class=\"comment\">//每成功调用一次，链表长度+1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">stDlistNode * <span class=\"title\">dlist_remove_tail</span><span class=\"params\">(stDlistHead *dlist)</span>    <span class=\"comment\">//删除尾部节点,并返回删除节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    stDlistNode *pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dlist-&gt;size == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    pNode = dlist-&gt;tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dlist-&gt;size &gt; <span class=\"number\">1</span>) {</span><br><span class=\"line\">        dlist-&gt;tail = dlist-&gt;tail-&gt;prev;</span><br><span class=\"line\">        dlist-&gt;tail-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        dlist-&gt;head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        dlist-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    dlist-&gt;size--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pNode;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dlist_remove_node</span><span class=\"params\">(stDlistHead * dlist,stDlistNode *pNode)</span>     <span class=\"comment\">//删除指定节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((dlist == <span class=\"literal\">NULL</span>)||(pNode == <span class=\"literal\">NULL</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dlist-&gt;head == pNode) {</span><br><span class=\"line\">        dlist-&gt;head = dlist-&gt;head-&gt;next;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dlist-&gt;tail == pNode) {</span><br><span class=\"line\">        dlist-&gt;tail = pNode-&gt;prev;</span><br><span class=\"line\">        dlist-&gt;tail-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        pNode-&gt;prev-&gt;next = pNode-&gt;next;</span><br><span class=\"line\">        pNode-&gt;next-&gt;prev = pNode-&gt;prev;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    dlist-&gt;size--;</span><br><span class=\"line\">    pNode-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    pNode-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dlist-&gt;size == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dlist,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(stDlistHead));     <span class=\"comment\">//将dlist占用内存块的所有值置为0，也就是清空head,tail指针内容</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\">stDlistNode * <span class=\"title\">dlist_search</span><span class=\"params\">(stDlistHead * dlist,<span class=\"keyword\">int</span> data)</span>     <span class=\"comment\">//根据值搜索节点，并返回</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    stDlistNode *pNode = dlist-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(pNode != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pNode-&gt;data == data) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pNode;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        pNode = pNode-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dlist_dump</span><span class=\"params\">(stDlistHead *dlist)</span>    <span class=\"comment\">//显示链表中的数据</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> no = <span class=\"number\">0</span>;</span><br><span class=\"line\">    stDlistNode *pNode = dlist-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(pNode != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n [%d] = %d\"</span>,no++,pNode-&gt;data);</span><br><span class=\"line\">        pNode = pNode-&gt;next;    <span class=\"comment\">//将pNode的下一个节点赋值给pNode，推进循环</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Lru_dlist</span><span class=\"params\">(stDlistHead *dlist,<span class=\"keyword\">int</span> data)</span>     <span class=\"comment\">//LRU（最近最少使用）缓存淘汰算法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    stDlistNode *pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    pNode = dlist_search(dlist,data);    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNode != <span class=\"literal\">NULL</span>) {    <span class=\"comment\">//如果在链表中找到这个值，则删除储存这个值的节点，之后吧这个节点放在头部</span></span><br><span class=\"line\">        dlist_remove_node(dlist,pNode);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dlist-&gt;size &gt;= <span class=\"number\">4</span>)    {    <span class=\"comment\">//没在链表中找到，且链表长度大于4，则从链表中删除尾部节点，将新数据放在头部</span></span><br><span class=\"line\">        pNode = dlist_remove_tail(dlist);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    dlist_insert_head(dlist ,pNode,data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    stDlistHead dlist = {<span class=\"number\">0</span>};</span><br><span class=\"line\">    stDlistNode * pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    dlist_init(&amp;dlist);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n inset 1,2,3\"</span>);</span><br><span class=\"line\">    dlist_insert_head(&amp;dlist,<span class=\"literal\">NULL</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    dlist_insert_head(&amp;dlist,<span class=\"literal\">NULL</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    dlist_insert_head(&amp;dlist,<span class=\"literal\">NULL</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\"></span><br><span class=\"line\">    pNode = dlist_remove_tail(&amp;dlist);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pNode != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n remove %d\"</span>,pNode-&gt;data);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    dlist_insert_head(&amp;dlist,pNode,<span class=\"number\">4</span>);</span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\"></span><br><span class=\"line\">    Lru_dlist(&amp;dlist,<span class=\"number\">5</span>);</span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\">    Lru_dlist(&amp;dlist,<span class=\"number\">6</span>);</span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\">    Lru_dlist(&amp;dlist,<span class=\"number\">7</span>);</span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\">    Lru_dlist(&amp;dlist,<span class=\"number\">5</span>);</span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(dlist.size &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">        pNode = dlist_remove_tail(&amp;dlist);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pNode != <span class=\"literal\">NULL</span>) { </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n remove %d\"</span>,pNode-&gt;data);</span><br><span class=\"line\">            <span class=\"built_in\">free</span> (pNode);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<details>\n<summary>linux/list</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux内核源码双向链表实现include/linux/list.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _LIST_HEAD_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _LIST_HEAD_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 双向链表节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> {</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> *<span class=\"title\">next</span>, *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化节点：设置name节点的前继节点和后继节点都是指向name本身。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义表头(节点)：新建双向链表表头name，并设置name的前继节点和后继节点都是指向name本身。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LIST_HEAD(name) \\</span></span><br><span class=\"line\"><span class=\"meta\">    struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化节点：将list节点的前继节点和后继节点都是指向list本身。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">INIT_LIST_HEAD</span><span class=\"params\">(struct list_head *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;next = <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;prev = <span class=\"built_in\">list</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加节点：将new插入到prev和next之间。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> __list_add(struct list_head *<span class=\"keyword\">new</span>,</span><br><span class=\"line\">                  struct list_head *prev,</span><br><span class=\"line\">                  struct list_head *next)</span><br><span class=\"line\">{</span><br><span class=\"line\">    next-&gt;prev = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;next = next;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;prev = prev;</span><br><span class=\"line\">    prev-&gt;next = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加new节点：将new添加到head之后，是new称为head的后继节点。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">list_add</span><span class=\"params\">(struct list_head *<span class=\"keyword\">new</span>, struct list_head *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    __list_add(<span class=\"keyword\">new</span>, head, head-&gt;next);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加new节点：将new添加到head之前，即将new添加到双链表的末尾。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">list_add_tail</span><span class=\"params\">(struct list_head *<span class=\"keyword\">new</span>, struct list_head *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    __list_add(<span class=\"keyword\">new</span>, head-&gt;prev, head);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从双链表中删除entry节点。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> __list_del(struct list_head * prev, struct list_head * next)</span><br><span class=\"line\">{</span><br><span class=\"line\">    next-&gt;prev = prev;</span><br><span class=\"line\">    prev-&gt;next = next;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从双链表中删除entry节点。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">list_del</span><span class=\"params\">(struct list_head *entry)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从双链表中删除entry节点。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> __list_del_entry(struct list_head *entry)</span><br><span class=\"line\">{</span><br><span class=\"line\">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从双链表中删除entry节点，并将entry节点的前继节点和后继节点都指向entry本身。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">list_del_init</span><span class=\"params\">(struct list_head *entry)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    __list_del_entry(entry);</span><br><span class=\"line\">    INIT_LIST_HEAD(entry);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用new节点取代old节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">list_replace</span><span class=\"params\">(struct list_head *old,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                struct list_head *<span class=\"keyword\">new</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;next = old-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;next-&gt;prev = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;prev = old-&gt;prev;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;prev-&gt;next = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 双链表是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">list_empty</span><span class=\"params\">(<span class=\"keyword\">const</span> struct list_head *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head-&gt;next == head;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取\"MEMBER成员\"在\"结构体TYPE\"中的位置偏移</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据\"结构体(type)变量\"中的\"域成员变量(member)的指针(ptr)\"来获取指向整个结构体变量的指针</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> container_of(ptr, type, member) ({          \\</span></span><br><span class=\"line\"><span class=\"meta\">    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \\</span></span><br><span class=\"line\"><span class=\"meta\">    (type *)( (char *)__mptr - offsetof(type,member) );})</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历双向链表</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> list_for_each(pos, head) \\</span></span><br><span class=\"line\"><span class=\"meta\">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> list_for_each_safe(pos, n, head) \\</span></span><br><span class=\"line\"><span class=\"meta\">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \\</span></span><br><span class=\"line\"><span class=\"meta\">        pos = n, n = pos-&gt;next)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> list_entry(ptr, type, member) \\</span></span><br><span class=\"line\"><span class=\"meta\">    container_of(ptr, type, member)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<h4 id=\"2-1-4-跳表\"><a href=\"#2-1-4-跳表\" class=\"headerlink\" title=\"2.1.4 跳表\"></a>2.1.4 跳表</h4><p> 跳表对标的是平衡树(AVL Tree), 插入/删除/搜索都是 O(logn)的数据结构。</p>\n<details>\n<summary>skiplist</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: skiplist.h</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-10-31</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Desc:    </span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __SKIP_LIST_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __SKIP_LIST_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">node</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> key;    <span class=\"comment\">/*key是唯一的*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;  <span class=\"comment\">/*存储的内容*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_level; <span class=\"comment\">/*当前节点最大层数*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">node</span> *<span class=\"title\">next</span>[0];</span><span class=\"comment\">/*level层链表结构*/</span></span><br><span class=\"line\">}node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">skiplist</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    node *head;</span><br><span class=\"line\">}skiplist;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*根据当前结构体元素的地址，获取到结构体首地址*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> offsetof(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> container(ptr,type,member) ({\\</span></span><br><span class=\"line\"><span class=\"meta\">  const typeof( ((type *)0)-&gt;member) *__mptr = (ptr);\\</span></span><br><span class=\"line\"><span class=\"meta\">  (type *) ( (char *)__mptr - offsetof(type,member));})</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"./skiplist.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建node节点*/</span></span><br><span class=\"line\"><span class=\"function\">node* <span class=\"title\">skip_list_create_node</span><span class=\"params\">(<span class=\"keyword\">int</span> level,<span class=\"keyword\">int</span> key,<span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    node * tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    tmp =(node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(node) + level*<span class=\"keyword\">sizeof</span>(node *));</span><br><span class=\"line\">    assert(tmp != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(tmp,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(node) + level*<span class=\"keyword\">sizeof</span>(node*));</span><br><span class=\"line\">    tmp-&gt;key = key;</span><br><span class=\"line\">    tmp-&gt;value = value;</span><br><span class=\"line\">    tmp-&gt;max_level = level;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建跳表的表头，max_level层数*/</span></span><br><span class=\"line\"><span class=\"function\">skiplist * <span class=\"title\">skip_list_create</span><span class=\"params\">(<span class=\"keyword\">int</span> max_level)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    skiplist * <span class=\"built_in\">list</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span> = (skiplist *)<span class=\"built_in\">malloc</span> (<span class=\"keyword\">sizeof</span>(skiplist));</span><br><span class=\"line\">    assert(<span class=\"built_in\">list</span> != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;level = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = skip_list_create_node(max_level,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">list</span>-&gt;head == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*skiplist 销毁*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">skip_list_destory</span><span class=\"params\">(skiplist * <span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    node * tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((<span class=\"built_in\">list</span> == <span class=\"literal\">NULL</span>) || (<span class=\"built_in\">list</span>-&gt;head == <span class=\"literal\">NULL</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">list</span>-&gt;head-&gt;next[<span class=\"number\">0</span>] != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        tmp = <span class=\"built_in\">list</span>-&gt;head-&gt;next[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head-&gt;next[<span class=\"number\">0</span>] = tmp-&gt;next[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>-&gt;head);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*插入元素获得层数，是随机产生的*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">skip_list_level</span><span class=\"params\">(skiplist * <span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">list</span>-&gt;head-&gt;max_level; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((rand()%<span class=\"number\">2</span>) == <span class=\"number\">1</span>) {</span><br><span class=\"line\">            level++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> level;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">skip_list_insert</span><span class=\"params\">(skiplist *<span class=\"built_in\">list</span>,<span class=\"keyword\">int</span> key,<span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">    node **update = <span class=\"literal\">NULL</span>;<span class=\"comment\">/*用来更新每层的指针*/</span></span><br><span class=\"line\">    node *tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span> == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*申请update空间用于保存每层的指针*/</span></span><br><span class=\"line\">    update = (node **)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(node *)*<span class=\"built_in\">list</span>-&gt;head-&gt;max_level);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (update == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*逐层查询节点的*/</span></span><br><span class=\"line\">    prev = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = (<span class=\"built_in\">list</span>-&gt;level <span class=\"number\">-1</span>); i &gt;= <span class=\"number\">0</span>; i--) {</span><br><span class=\"line\">        <span class=\"comment\">/*初始化每level层的头指针*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(((tmp = prev-&gt;next[i]) != <span class=\"literal\">NULL</span>) &amp;&amp; (tmp-&gt;key &lt; key)) {</span><br><span class=\"line\">            prev  = tmp;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        update[i] = prev;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*当前key已经存在，返回错误*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tmp!= <span class=\"literal\">NULL</span>) &amp;&amp; (tmp-&gt;key == key)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">/*获取插入元素的随机层数，并更新跳表的最大层数*/</span></span><br><span class=\"line\">    level = skip_list_level(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"comment\">/*创建当前数据节点*/</span></span><br><span class=\"line\">    tmp = skip_list_create_node(level,key,value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*更新最大层数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (level &gt; <span class=\"built_in\">list</span>-&gt;level) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"built_in\">list</span>-&gt;level;i &lt; level; i ++) {</span><br><span class=\"line\">            update[i] = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;level = level;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*逐层更新节点的指针*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; level; i++) {</span><br><span class=\"line\">        tmp-&gt;next[i] = update[i]-&gt;next[i];</span><br><span class=\"line\">        update[i]-&gt;next[i] = tmp; </span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">skip_list_delete</span><span class=\"params\">(skiplist * <span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> key ,<span class=\"keyword\">int</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    node **update = <span class=\"literal\">NULL</span>;<span class=\"comment\">/*用来更新每层的指针*/</span></span><br><span class=\"line\">    node *tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">list</span> == <span class=\"literal\">NULL</span>) &amp;&amp; (value == <span class=\"literal\">NULL</span>)&amp;&amp; (<span class=\"built_in\">list</span>-&gt;count == <span class=\"number\">0</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">/*申请update空间用于保存每层的指针*/</span></span><br><span class=\"line\">    update = (node **)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(node *)*<span class=\"built_in\">list</span>-&gt;level);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (update == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">/*逐层查询节点的*/</span></span><br><span class=\"line\">    prev = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = (<span class=\"built_in\">list</span>-&gt;level <span class=\"number\">-1</span>); i &gt;= <span class=\"number\">0</span>; i--) {</span><br><span class=\"line\">        <span class=\"comment\">/*初始化每level层的头指针*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(((tmp = prev-&gt;next[i]) != <span class=\"literal\">NULL</span>) &amp;&amp; (tmp-&gt;key &lt; key)) {</span><br><span class=\"line\">            prev = tmp;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        update[i] = prev;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tmp != <span class=\"literal\">NULL</span>) &amp;&amp; (tmp-&gt;key == key)) {</span><br><span class=\"line\">        *value = tmp-&gt;value;</span><br><span class=\"line\">        <span class=\"comment\">/*逐层删除*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">list</span>-&gt;level; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(update[i]-&gt;next[i] == tmp) {</span><br><span class=\"line\">                update[i]-&gt;next[i] = tmp-&gt;next[i];       </span><br><span class=\"line\">            }    </span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">        tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*更新level的层数*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"built_in\">list</span>-&gt;level - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;head-&gt;next[i] == <span class=\"literal\">NULL</span> ) {</span><br><span class=\"line\">                <span class=\"built_in\">list</span>-&gt;level--;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;count--;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;<span class=\"comment\">/*未找到节点*/</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span> ;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*查询当前key是否在跳表中，如果存在返回查询的value数值，不存在返回-1*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">skip_list_search</span><span class=\"params\">(skiplist *<span class=\"built_in\">list</span>,<span class=\"keyword\">int</span> key,<span class=\"keyword\">int</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    node *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node *tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((<span class=\"built_in\">list</span> == <span class=\"literal\">NULL</span>) || (<span class=\"built_in\">list</span>-&gt;count == <span class=\"number\">0</span>) || (value == <span class=\"literal\">NULL</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    prev = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"built_in\">list</span>-&gt;level - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) {</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(((tmp = prev-&gt;next[i]) != <span class=\"literal\">NULL</span>) &amp;&amp; (tmp-&gt;key &lt;= key)) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp-&gt;key == key) {</span><br><span class=\"line\">                    *value = tmp-&gt;value;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            prev = tmp;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">skip_list_dump</span><span class=\"params\">(skiplist *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    node *ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n----------------------------------------------\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n skip list level[%d],count[%d]\"</span>,<span class=\"built_in\">list</span>-&gt;level,<span class=\"built_in\">list</span>-&gt;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"built_in\">list</span>-&gt;level - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i --) {</span><br><span class=\"line\">        ptmp = <span class=\"built_in\">list</span>-&gt;head-&gt;next[i];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n level[%d]:\"</span>,i);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ptmp != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d-%d \"</span>,ptmp-&gt;key,ptmp-&gt;value);</span><br><span class=\"line\">            ptmp = ptmp-&gt;next[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n----------------------------------------------\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> key = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</span><br><span class=\"line\">    skiplist *<span class=\"built_in\">list</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span> = skip_list_create(<span class=\"number\">5</span>);</span><br><span class=\"line\">    assert(<span class=\"built_in\">list</span> != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n 请输入key 和 value，当key = 1000时，退出输入：\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;key,&amp;value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"number\">1000</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        res = skip_list_insert(<span class=\"built_in\">list</span>,key,value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n skip list insert %d,failed,res=%d.\"</span>,key,res);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    skip_list_dump(<span class=\"built_in\">list</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n 通过key 查询value的数值，当key = 1000时，退出查询\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key == <span class=\"number\">1000</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        res = skip_list_search(<span class=\"built_in\">list</span>,key,&amp;value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n skip list search %d,failed,res=%d.\"</span>,key,res);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n skip list search %d,sucessful,value=%d.\"</span>,key,value);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    skip_list_dump(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n 通过key 删除节点，当key = 1000时，退出删除\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key == <span class=\"number\">1000</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        res = skip_list_delete(<span class=\"built_in\">list</span>,key,&amp;value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n skip list search %d,failed,res=%d.\"</span>,key,res);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n skip list search %d,sucessful,value=%d.\"</span>,key,value);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    skip_list_dump(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    skip_list_destory(<span class=\"built_in\">list</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<h4 id=\"2-1-5-栈\"><a href=\"#2-1-5-栈\" class=\"headerlink\" title=\"2.1.5 栈\"></a>2.1.5 栈</h4><p> 栈按照后进先出(LIFO)的顺序存储和检索数据的数据结构，检索元素的顺序和存储元素顺序相反。<br> 可通过链表来实现栈stack,允许插入和删除的为栈顶(<code>top</code>),另一端为栈底(<code>bottom</code>),栈中每个元素为<code>frame</code>,栈只支持三个操作:<code>pop</code>,<code>top</code>,<code>push</code>.</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> List Stack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> stack_init list_init;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stack_push</span><span class=\"params\">(Stack *<span class=\"built_in\">stack</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *data)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stack_pop</span><span class=\"params\">(Stack *<span class=\"built_in\">stack</span>, <span class=\"keyword\">void</span> **data)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> stack_peek(stack) ((stack)-&gt;head == NULL ? NULL : (stack)-&gt;head-&gt;data);</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> stack_size list_size;</span></span><br></pre></td></tr></tbody></table></figure>\n<p> c语言顺序栈</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 元素elem进栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">char</span> *a, <span class=\"keyword\">int</span> top, <span class=\"keyword\">char</span> elem)</span> </span>{</span><br><span class=\"line\">    a[++top] = elem;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 数据元素出栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"keyword\">char</span> *a, <span class=\"keyword\">int</span> top)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top == <span class=\"number\">-1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    top--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<details>\n<summary>arrayStack</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: arrayStack</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-10-12</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Desc:   数组实现顺序栈 </span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ARRAY_STACJ_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ARRAY_STACJ_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">array_stack</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;<span class=\"comment\">/*栈的大小*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos;<span class=\"comment\">/*当前存储元素的个数，即栈顶元素下表*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *<span class=\"built_in\">array</span>;<span class=\"comment\">/*数据存储区*/</span></span><br><span class=\"line\">}stArrayStack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> arrayStack_size(arrayStack) (arrayStack-&gt;size)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> arrayStack_is_empty(arrayStack) (arrayStack-&gt;pos == -1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> arrayStack_is_full(arrayStack)  (arrayStack-&gt;pos == (arrayStack-&gt;size-1))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"./arrayStack.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建并初始化顺序栈*/</span></span><br><span class=\"line\"><span class=\"function\">stArrayStack * <span class=\"title\">arrayStack_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    stArrayStack *parrStack = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    parrStack = (stArrayStack *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(stArrayStack));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parrStack == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    parrStack-&gt;size = size;</span><br><span class=\"line\">    parrStack-&gt;pos = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    parrStack-&gt;<span class=\"built_in\">array</span> = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(parrStack-&gt;<span class=\"built_in\">array</span> == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(parrStack);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> parrStack;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*销毁顺序栈*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">arrayStack_destory</span><span class=\"params\">(stArrayStack * parrStack)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(parrStack == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parrStack-&gt;<span class=\"built_in\">array</span> != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(parrStack-&gt;<span class=\"built_in\">array</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(parrStack);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*出栈*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrayStack_pop</span><span class=\"params\">(stArrayStack *parrStack)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arrayStack_is_empty(parrStack)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    data = parrStack-&gt;<span class=\"built_in\">array</span>[parrStack-&gt;pos];</span><br><span class=\"line\">    parrStack-&gt;pos--;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*入栈*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrayStack_push</span><span class=\"params\">(stArrayStack *parrStack,<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arrayStack_is_full(parrStack)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    parrStack-&gt;pos++;</span><br><span class=\"line\">    parrStack-&gt;<span class=\"built_in\">array</span>[parrStack-&gt;pos] = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrayStack_push_new</span><span class=\"params\">(stArrayStack*parrStack,<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*如果栈不满，直接插入*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!arrayStack_is_full(parrStack)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arrayStack_push(parrStack,data);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*如果栈已经满，申请内存*/</span></span><br><span class=\"line\">    ptmp = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">2</span>*parrStack-&gt;size*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptmp == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(ptmp,parrStack-&gt;<span class=\"built_in\">array</span>,parrStack-&gt;size*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(parrStack-&gt;<span class=\"built_in\">array</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    parrStack-&gt;<span class=\"built_in\">array</span> = ptmp;</span><br><span class=\"line\">    parrStack-&gt;size = <span class=\"number\">2</span>*parrStack-&gt;size;</span><br><span class=\"line\">    parrStack-&gt;pos++;</span><br><span class=\"line\">    parrStack-&gt;<span class=\"built_in\">array</span>[parrStack-&gt;pos] = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">arrayStack_dump</span><span class=\"params\">(stArrayStack *parrStack)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arrayStack_is_empty(parrStack)) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n arrayStack is empty.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\narrayStack size = %d,pos= %d,\"</span>,</span><br><span class=\"line\">    parrStack-&gt;size,parrStack-&gt;pos);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;= parrStack-&gt;pos; i++) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\narry[%d] = %d\"</span>,i,parrStack-&gt;<span class=\"built_in\">array</span>[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    stArrayStack * parrStack = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n create size = 4 arrayStack.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    parrStack = arrayStack_create(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parrStack == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n create size = 4 arrayStack faided.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) {</span><br><span class=\"line\">        ret = arrayStack_push(parrStack,i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ret != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n push size = %d arrayStack faided.\"</span>,i);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    arrayStack_dump(parrStack);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ret = arrayStack_push_new(parrStack,<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ret != <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n push size = %d arrayStack faided.\"</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    arrayStack_dump(parrStack);</span><br><span class=\"line\">    arrayStack_destory(parrStack);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<p> 链栈</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lineStack</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lineStack</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">}lineStack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">lineStack* <span class=\"title\">push</span><span class=\"params\">(lineStack * <span class=\"built_in\">stack</span>, <span class=\"keyword\">char</span> a)</span></span>{</span><br><span class=\"line\">    lineStack * line=(lineStack*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(lineStack));</span><br><span class=\"line\">    line-&gt;data=a;</span><br><span class=\"line\">    line-&gt;next=<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>=line;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">lineStack * <span class=\"title\">pop</span><span class=\"params\">(lineStack * <span class=\"built_in\">stack</span>)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span>) {</span><br><span class=\"line\">        lineStack * p=<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>=<span class=\"built_in\">stack</span>-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"弹栈元素：%c \"</span>,p-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"栈顶元素：%c\\n\"</span>,<span class=\"built_in\">stack</span>-&gt;data);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"栈已空\\n\"</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"栈内没有元素\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<details>\n<summary>linklist_stack</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: linklist_stack</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-10-12</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Desc:    </span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> STACK_LINK_LIST_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_LINK_LIST_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">linkliststack</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">linkliststack</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">}linklist_stack;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> stack_is_empty(liststack) (liststack-&gt;next == NULL)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"./linklist_stack.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linklist_stack * <span class=\"title\">stack_create</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    linklist_stack * <span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span> = (linklist_stack *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(linklist_stack));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">stack_destory</span><span class=\"params\">(linklist_stack* <span class=\"built_in\">stack</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    linklist_stack * ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!stack_is_empty(<span class=\"built_in\">stack</span>)) {</span><br><span class=\"line\">        ptmp = <span class=\"built_in\">stack</span>-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>-&gt;next = <span class=\"built_in\">stack</span>-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(ptmp);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stack_push</span><span class=\"params\">(linklist_stack *<span class=\"built_in\">stack</span>,<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    linklist_stack * ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ptmp = (linklist_stack *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(linklist_stack));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptmp == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    ptmp-&gt;data = data;</span><br><span class=\"line\">    ptmp-&gt;next = <span class=\"built_in\">stack</span>-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;next = ptmp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stack_pop</span><span class=\"params\">(linklist_stack*<span class=\"built_in\">stack</span>,<span class=\"keyword\">int</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    linklist_stack *ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(stack_is_empty(<span class=\"built_in\">stack</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;    </span><br><span class=\"line\">    }</span><br><span class=\"line\">    *data = <span class=\"built_in\">stack</span>-&gt;next-&gt;data;</span><br><span class=\"line\">    ptmp = <span class=\"built_in\">stack</span>-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;next = ptmp-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptmp);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">stack_dump</span><span class=\"params\">(linklist_stack *<span class=\"built_in\">stack</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    linklist_stack * ptmp = <span class=\"built_in\">stack</span>-&gt;next;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ptmp != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n data = %d\"</span>,ptmp-&gt;data);</span><br><span class=\"line\">        ptmp = ptmp-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\">    linklist_stack * <span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span> = stack_create();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n stack create falied.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    </span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) {</span><br><span class=\"line\">        ret = stack_push(<span class=\"built_in\">stack</span>,i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ret != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n stack push %d falied.\"</span>,i);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    stack_dump(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) {</span><br><span class=\"line\">        ret = stack_pop(<span class=\"built_in\">stack</span>,&amp;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ret != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n stack pop%d falied.\"</span>, i);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n data = %d,\"</span>,data);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    stack_destory(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<h4 id=\"2-1-6-队列\"><a href=\"#2-1-6-队列\" class=\"headerlink\" title=\"2.1.6 队列\"></a>2.1.6 队列</h4><p> 队列，在前端(<code>front</code>)进行删除操作，后端(<code>rear</code>)进行插入操作; 按照先进先出(<code>FIFO</code>)的顺序存储和检索数据的高效数据结构，按照元素的存储顺序检索元素。<br> 队列也可通过数组和链表实现。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> List Queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> queue_init list_init;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> queue_destroy list_destroy;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">queue_enqueue</span><span class=\"params\">(Queue *<span class=\"built_in\">queue</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *data)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">queue_dequeue</span><span class=\"params\">(Queue *<span class=\"built_in\">queue</span>, <span class=\"keyword\">void</span> **data)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> queue_peek(queue) ((queue)-&gt;head == NULL ? NULL : (queue)-&gt;head-&gt;data);</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> queue_size list_size;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<details>\n<summary>array_queue</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: array_queue</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-10-12</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Desc:    </span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ARRAY_QUEUE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ARRAY_QUEUE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">array_queue</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;<span class=\"comment\">/*队列的大小*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num; <span class=\"comment\">/*当前存储数据的大小*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> head;<span class=\"comment\">/*队列的头*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tail;<span class=\"comment\">/*队列的尾*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *<span class=\"built_in\">array</span>;<span class=\"comment\">/*数据存储区*/</span></span><br><span class=\"line\">}array_queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> array_queue_is_empty(array_queue) (array_queue-&gt;num == 0)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> array_queue_is_full(array_queue)  ((array_queue-&gt;num) == (array_queue-&gt;size))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"./array_queue.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">array_queue * <span class=\"title\">array_queue_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    array_queue * <span class=\"built_in\">queue</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> = (array_queue*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(array_queue));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span> = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span> == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;size  = size;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num   = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head  = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;tail  = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">array_queue_destory</span><span class=\"params\">(array_queue *<span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span> != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*入队列 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">array_queue_enqueue</span><span class=\"params\">(array_queue *<span class=\"built_in\">queue</span>,<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">/*队列为空，或者队列满时，返回-1*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) || (array_queue_is_full(<span class=\"built_in\">queue</span>))) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num++;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span>[<span class=\"built_in\">queue</span>-&gt;tail] = data;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;tail = (<span class=\"built_in\">queue</span>-&gt;tail + <span class=\"number\">1</span>) % <span class=\"built_in\">queue</span>-&gt;size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*出队列*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">array_queue_dequeue</span><span class=\"params\">(array_queue * <span class=\"built_in\">queue</span>,<span class=\"keyword\">int</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">/*队列为空，数据存储为空，队列为空时返回-1*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) || (data == <span class=\"literal\">NULL</span>) || (array_queue_is_empty(<span class=\"built_in\">queue</span>))) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    *data = <span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span>[<span class=\"built_in\">queue</span>-&gt;head];</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num--;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = (<span class=\"built_in\">queue</span>-&gt;head + <span class=\"number\">1</span>) % <span class=\"built_in\">queue</span>-&gt;size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">array_queue_dump</span><span class=\"params\">(array_queue *<span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) || (array_queue_is_empty(<span class=\"built_in\">queue</span>))) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n queue is empty\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n size:%d,num:%d,head:%d,tali:%d\"</span>,</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;size,<span class=\"built_in\">queue</span>-&gt;num,<span class=\"built_in\">queue</span>-&gt;head,<span class=\"built_in\">queue</span>-&gt;tail);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">queue</span>-&gt;num; i ++) {</span><br><span class=\"line\">        pos = (<span class=\"built_in\">queue</span>-&gt;head + i) %<span class=\"built_in\">queue</span>-&gt;size;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n array[%d] = %d\"</span>,pos,<span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span>[pos]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\">    array_queue * <span class=\"built_in\">queue</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> = array_queue_create(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n queue is create failed.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">/*队列时空时，出队返回错误*/</span></span><br><span class=\"line\">    ret = array_queue_dequeue(<span class=\"built_in\">queue</span>, &amp;data);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n queue %d dequeue failed.\"</span>,ret);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*队列大小是4，入队5个，最后一个报错*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) {</span><br><span class=\"line\">        ret = array_queue_enqueue(<span class=\"built_in\">queue</span>,i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n queue %d enqueue failed.\"</span>,i);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    array_queue_dump(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ret = array_queue_dequeue(<span class=\"built_in\">queue</span>, &amp;data);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n queue %d dequeue failed.\"</span>,i);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n queue %d dequue.\"</span>,data);</span><br><span class=\"line\">    array_queue_dump(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    data = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n queue %d enqueue.\"</span>,data);</span><br><span class=\"line\">    ret = array_queue_enqueue(<span class=\"built_in\">queue</span>,data);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n queue %d enqueue failed.\"</span>,data);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    array_queue_dump(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    array_queue_destory(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<details>\n<summary>list_queue</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> LINK_LIST_QUEUE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LINK_LIST_QUEUE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">list_queue_node</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">list_queue_node</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">}queue_node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">list_queue</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    queue_node *head;</span><br><span class=\"line\">    queue_node *tail;</span><br><span class=\"line\">}list_queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> list_queue_is_empty(queue) ((queue-&gt;num) == 0)</span></span><br><span class=\"line\"><span class=\"function\">list_queue *<span class=\"title\">list_queue_create</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">list_queue_enqueue</span><span class=\"params\">(list_queue *<span class=\"built_in\">queue</span>,<span class=\"keyword\">void</span> *data)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">list_queue_dequeue</span><span class=\"params\">(list_queue *<span class=\"built_in\">queue</span>,<span class=\"keyword\">void</span> **data)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"./list_queue.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建队列头*/</span></span><br><span class=\"line\"><span class=\"function\">list_queue *<span class=\"title\">list_queue_create</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    list_queue * <span class=\"built_in\">queue</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> = (list_queue *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(list_queue));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num  = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*入队*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">list_queue_enqueue</span><span class=\"params\">(list_queue *<span class=\"built_in\">queue</span>,<span class=\"keyword\">void</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    queue_node *ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ptmp = (queue_node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(queue_node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptmp == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    ptmp-&gt;data = data;</span><br><span class=\"line\">    ptmp-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;head == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;head = ptmp;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;tail-&gt;next = ptmp;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;tail = ptmp;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*出队*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">list_queue_dequeue</span><span class=\"params\">(list_queue *<span class=\"built_in\">queue</span>,<span class=\"keyword\">void</span> **data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    queue_node * ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) || (data == <span class=\"literal\">NULL</span>) || list_queue_is_empty(<span class=\"built_in\">queue</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    *data = <span class=\"built_in\">queue</span>-&gt;head-&gt;data;</span><br><span class=\"line\">    ptmp = <span class=\"built_in\">queue</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = <span class=\"built_in\">queue</span>-&gt;head-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;head == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<details>\n<summary>ring_queue</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ring_queue</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cap;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> head, tail;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *_q;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">alloc_queue</span><span class=\"params\">(struct ring_queue* <span class=\"built_in\">queue</span>, <span class=\"keyword\">int</span> cap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span> || cap &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;_q)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;_q = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(cap * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>-&gt;_q)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = <span class=\"built_in\">queue</span>-&gt;tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;cap = cap;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_queue</span><span class=\"params\">(struct ring_queue *<span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;cap = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = <span class=\"built_in\">queue</span>-&gt;tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">queue</span>-&gt;_q);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> _valid_index(<span class=\"keyword\">int</span> curr, <span class=\"keyword\">int</span> step, <span class=\"keyword\">int</span> cap)</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (curr + step) % cap;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> _next(<span class=\"keyword\">int</span> curr, <span class=\"keyword\">int</span> cap)</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _valid_index(curr, <span class=\"number\">1</span>, cap);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_empty</span><span class=\"params\">(struct ring_queue *<span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">queue</span>-&gt;head == <span class=\"built_in\">queue</span>-&gt;tail);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_full</span><span class=\"params\">(struct ring_queue *<span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> next_tail = _next(<span class=\"built_in\">queue</span>-&gt;tail, <span class=\"built_in\">queue</span>-&gt;cap);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (next_tail == <span class=\"built_in\">queue</span>-&gt;head);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">enqueue</span><span class=\"params\">(struct ring_queue* <span class=\"built_in\">queue</span>, <span class=\"keyword\">int</span> elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_full(<span class=\"built_in\">queue</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;_q[<span class=\"built_in\">queue</span>-&gt;tail] = elem;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;tail = _next(<span class=\"built_in\">queue</span>-&gt;tail, <span class=\"built_in\">queue</span>-&gt;cap);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dequeue</span><span class=\"params\">(struct ring_queue* <span class=\"built_in\">queue</span>, <span class=\"keyword\">int</span> *elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_empty(<span class=\"built_in\">queue</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elem)</span><br><span class=\"line\">    *elem = <span class=\"built_in\">queue</span>-&gt;_q[<span class=\"built_in\">queue</span>-&gt;head];</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = _next(<span class=\"built_in\">queue</span>-&gt;head, <span class=\"built_in\">queue</span>-&gt;cap);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">(struct ring_queue* <span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"built_in\">queue</span>-&gt;tail - <span class=\"built_in\">queue</span>-&gt;head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    size += <span class=\"built_in\">queue</span>-&gt;cap;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(struct ring_queue* <span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, idx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Queue has %d elements with %d capacity\\n\"</span>,</span><br><span class=\"line\">    size(<span class=\"built_in\">queue</span>), <span class=\"built_in\">queue</span>-&gt;cap);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size(<span class=\"built_in\">queue</span>); i++) {</span><br><span class=\"line\">        idx = _valid_index(<span class=\"built_in\">queue</span>-&gt;head, i, <span class=\"built_in\">queue</span>-&gt;cap);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"[%02d]: %08d\\n\"</span>, idx, <span class=\"built_in\">queue</span>-&gt;_q[idx]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ring_queue</span> <span class=\"title\">queue</span> =</span> {<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>};</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (alloc_queue(&amp;<span class=\"built_in\">queue</span>, <span class=\"number\">8</span>)) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed to allocate a queue\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"A new queue is %s\\n\"</span>, is_empty(&amp;<span class=\"built_in\">queue</span>)?<span class=\"string\">\"empty\"</span>:<span class=\"string\">\"not empty\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    enqueue(&amp;<span class=\"built_in\">queue</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"After enqueue 1 element, queue is %s\\n\"</span>, is_empty(&amp;<span class=\"built_in\">queue</span>)?<span class=\"string\">\"empty\"</span>:<span class=\"string\">\"not empty\"</span>);</span><br><span class=\"line\">    dequeue(&amp;<span class=\"built_in\">queue</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"After dequeue 1 element, queue is %s\\n\"</span>, is_empty(&amp;<span class=\"built_in\">queue</span>)?<span class=\"string\">\"empty\"</span>:<span class=\"string\">\"not empty\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">    enqueue(&amp;<span class=\"built_in\">queue</span>, i);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"After enqueue 7 element, queue is %s\\n\"</span>, is_full(&amp;<span class=\"built_in\">queue</span>)?<span class=\"string\">\"full\"</span>:<span class=\"string\">\"not full\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) {</span><br><span class=\"line\">        dequeue(&amp;<span class=\"built_in\">queue</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        enqueue(&amp;<span class=\"built_in\">queue</span>, i);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"After enqueue/dequeue 4 element, queue is %s\\n\"</span>,</span><br><span class=\"line\">    is_full(&amp;<span class=\"built_in\">queue</span>)?<span class=\"string\">\"full\"</span>:<span class=\"string\">\"not full\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Head is %d, Tail is %d\\n\"</span>, <span class=\"built_in\">queue</span>.head, <span class=\"built_in\">queue</span>.tail);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(&amp;<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    free_queue(&amp;<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<p> 队列应用：进程通信<br> 消息队列提供了从一个进程向另一个进程发送一个数据块的方法.每个数据库都认为含有一个类型,接收进程可以独立地接收含有不同类型的数据结构.</p>\n<p> linux内核 &lt;sys/msg.h&gt; 头文件中定义了消息队列结构</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msqid_ds</span> {</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">msg_perm</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msg</span>* <span class=\"title\">msg_first</span>;</span> <span class=\"comment\">// 指向队列中第一个消息</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msg</span>* <span class=\"title\">msg_last</span>;</span> <span class=\"comment\">// 队列中最后一个消息</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p> Linux消息队列函数接口</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建和访问一个消息队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 把消息添加到消息队列中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgsnd</span><span class=\"params\">(<span class=\"keyword\">int</span> msgid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_sz, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 从一个消息对立获取消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgrcv</span><span class=\"params\">(<span class=\"keyword\">int</span> msgid, <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_st, <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> msgtype, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 控制消息队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgctl</span><span class=\"params\">(<span class=\"keyword\">int</span> msgid, <span class=\"keyword\">int</span> command, struct msgid_ds *buf)</span></span>;</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"2-1-7-leetcode题目\"><a href=\"#2-1-7-leetcode题目\" class=\"headerlink\" title=\"2.1.7 leetcode题目\"></a>2.1.7 leetcode题目</h4><ul>\n<li><p>重复N次的元素&lt;数组&gt;</p>\n</li>\n<li><p>两数相加&lt;链表&gt;</p>\n</li>\n<li><p>基本计算器&lt;栈&gt;</p>\n</li>\n<li><p>设计循环队列&lt;队列&gt;</p>\n</li>\n</ul>\n<h3 id=\"2-2-哈希表\"><a href=\"#2-2-哈希表\" class=\"headerlink\" title=\"2.2 哈希表\"></a>2.2 哈希表</h3><p> 哈希表是一种最有效的检索方法，散列，从本质上看，一个哈希表包含一个数组，通过特殊的索引（键）来访问数组中的元素。哈希表主要思想是通过一个哈希函数，在所有可能的键和值直接建立映射表。<br> 每个记录的关键字k通过一种函数H(k)计算出函数值.此函数为哈希函数或散列函数.</p>\n<h4 id=\"2-2-1-哈希函数设计\"><a href=\"#2-2-1-哈希函数设计\" class=\"headerlink\" title=\"2.2.1 哈希函数设计\"></a>2.2.1 哈希函数设计</h4><ul>\n<li><p>直接地址法<br>关键字是整数类型的数据,直接地址的哈希函数H直接利用关键字求得哈希地址.<br>H(k) = aK*i + b</p>\n</li>\n<li><p>数字分析法<br>取关键字数中分布均匀的若干作为哈希地址</p>\n</li>\n<li><p>平方取中法<br>取关键字平方中间几位作为散列地址</p>\n</li>\n<li><p>折叠法<br>把关键字分割成位数相同的几段，段的位数取决于哈希地址的位数，然后将它们叠加和作为哈希地址</p>\n</li>\n<li><p>除留取余法<br>关键字K除以一个合适的不大于哈希表长度的正整数P,所得余数作为哈希地址.<br>H(K) = K MOD P</p>\n</li>\n</ul>\n<details>\n<summary>uthash用法</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: listhash.h</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-11-06</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Desc: 根据linux内核模块hashtab编写用户层hashtab接口</span></span><br><span class=\"line\"><span class=\"comment\">         linux-4.19.1\\security\\selinux\\ss\\hashtab.c</span></span><br><span class=\"line\"><span class=\"comment\">     linux-4.19.1\\security\\selinux\\ss\\hashtab.h</span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __HASHTAB_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __HASHTAB_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">hashtab_node</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> * key;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> * data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">hashtab_node</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">}hashtab_node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">hashtab</span> {</span></span><br><span class=\"line\">    hashtab_node **htables; <span class=\"comment\">/*哈希桶*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;              <span class=\"comment\">/*哈希桶的最大数量*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nel;               <span class=\"comment\">/*哈希桶中元素的个数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*hash_value)(struct _hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key); <span class=\"comment\">/*哈希函数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*keycmp)(struct _hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);<span class=\"comment\">/*哈希key比较函数，当哈希数值一致时使用*/</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*hash_node_free)(hashtab_node *node);</span><br><span class=\"line\">}hashtab;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HASHTAB_MAX_NODES  (0xffffffff)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*hash_key_func)</span><span class=\"params\">(struct _hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key)</span></span>; <span class=\"comment\">/*哈希函数*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*keycmp_func)</span><span class=\"params\">(struct _hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2)</span></span>;<span class=\"comment\">/*哈希key比较函数，当哈希数值一致时使用*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*hash_node_free_func)</span><span class=\"params\">(hashtab_node *node)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">/*根据当前结构体元素的地址，获取到结构体首地址*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> offsetof(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> container(ptr,type,member) ({\\</span></span><br><span class=\"line\"><span class=\"meta\">  const typeof( ((type *)0)-&gt;member) *__mptr = (ptr);\\</span></span><br><span class=\"line\"><span class=\"meta\">  (type *) ( (char *)__mptr - offsetof(type,member));})</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">hashtab * <span class=\"title\">hashtab_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size,hash_key_func hash_value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        keycmp_func keycmp,hash_node_free_func hash_node_free)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hashtab_destory</span><span class=\"params\">(hashtab *h)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashtab_insert</span><span class=\"params\">(hashtab * h,<span class=\"keyword\">void</span> *key,<span class=\"keyword\">void</span> *data)</span></span>;</span><br><span class=\"line\"><span class=\"function\">hashtab_node *<span class=\"title\">hashtab_delete</span><span class=\"params\">(hashtab *h, <span class=\"keyword\">void</span> *key)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">hashtab_search</span><span class=\"params\">(hashtab*h,<span class=\"keyword\">void</span> *key)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"listhash.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> MEMORY_TEST</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;mcheck.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">hashtab * <span class=\"title\">hashtab_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size,hash_key_func hash_value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    keycmp_func keycmp,hash_node_free_func hash_node_free)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    hashtab * h = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size &lt; <span class=\"number\">0</span>) || (hash_value == <span class=\"literal\">NULL</span>) || (keycmp == <span class=\"literal\">NULL</span>)) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    h = (hashtab *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(hashtab));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    h-&gt;htables = (hashtab_node **)<span class=\"built_in\">malloc</span>(size * <span class=\"keyword\">sizeof</span>(hashtab_node*));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h-&gt;htables == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    h-&gt;size = size;</span><br><span class=\"line\">    h-&gt;nel = <span class=\"number\">0</span>;</span><br><span class=\"line\">    h-&gt;hash_value = hash_value;</span><br><span class=\"line\">    h-&gt;keycmp = keycmp;</span><br><span class=\"line\">    h-&gt;hash_node_free = hash_node_free;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; i++) {</span><br><span class=\"line\">        h-&gt;htables[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hashtab_destory</span><span class=\"params\">(hashtab *h)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hashtab_node * cur = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    hashtab_node * tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt;h-&gt;size; i++) {</span><br><span class=\"line\">        cur = h-&gt;htables[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            tmp = cur;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">            h-&gt;hash_node_free(tmp);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        h-&gt;htables[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">free</span>(h-&gt;htables);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(h);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashtab_insert</span><span class=\"params\">(hashtab * h,<span class=\"keyword\">void</span> *key,<span class=\"keyword\">void</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> hvalue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hashtab_node *cur = <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">    hashtab_node *prev = <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">    hashtab_node *newnode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((h == <span class=\"literal\">NULL</span>) || (key == <span class=\"literal\">NULL</span>) || (data == <span class=\"literal\">NULL</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*获取hash 数值*/</span></span><br><span class=\"line\">    hvalue = h-&gt;hash_value(h,key);</span><br><span class=\"line\">    cur = h-&gt;htables[hvalue];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((cur != <span class=\"literal\">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt; <span class=\"number\">0</span>)) {</span><br><span class=\"line\">        prev = cur;</span><br><span class=\"line\">        cur = cur-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*如果key和当前key比对一致，直接返回，数据已经存在*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((cur != <span class=\"literal\">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) == <span class=\"number\">0</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    newnode = (hashtab_node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(hashtab_node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newnode == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    newnode-&gt;key = key;</span><br><span class=\"line\">    newnode-&gt;data = data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        newnode-&gt;next = h-&gt;htables[hvalue];</span><br><span class=\"line\">        h-&gt;htables[hvalue] = newnode;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        newnode-&gt;next = prev-&gt;next;</span><br><span class=\"line\">        prev-&gt;next = newnode;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    h-&gt;nel++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">hashtab_node *<span class=\"title\">hashtab_delete</span><span class=\"params\">(hashtab *h, <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hvalue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hashtab_node *cur = <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">    hashtab_node *prev = <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((h == <span class=\"literal\">NULL</span>) || (key == <span class=\"literal\">NULL</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*获取hash 数值*/</span></span><br><span class=\"line\">    hvalue = h-&gt;hash_value(h,key);</span><br><span class=\"line\">    cur = h-&gt;htables[hvalue];</span><br><span class=\"line\">    <span class=\"comment\">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((cur != <span class=\"literal\">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt;= <span class=\"number\">0</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h-&gt;keycmp(h,key,cur-&gt;key) == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">                        h-&gt;htables[hvalue] = cur-&gt;next;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                        prev-&gt;next = cur-&gt;next;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        prev = cur;</span><br><span class=\"line\">        cur = cur-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">hashtab_search</span><span class=\"params\">(hashtab*h,<span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hvalue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hashtab_node *cur = <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((h == <span class=\"literal\">NULL</span>) || (key == <span class=\"literal\">NULL</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*获取hash 数值*/</span></span><br><span class=\"line\">    hvalue = h-&gt;hash_value(h,key);</span><br><span class=\"line\">    cur = h-&gt;htables[hvalue];</span><br><span class=\"line\">    <span class=\"comment\">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((cur != <span class=\"literal\">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt;= <span class=\"number\">0</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h-&gt;keycmp(h,key,cur-&gt;key) == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur-&gt;data;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        cur = cur-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hashtab_dump</span><span class=\"params\">(hashtab *h)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hashtab_node * cur = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n----开始--size[%d],nel[%d]------------\"</span>,h-&gt;size,h-&gt;nel);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; h-&gt;size; i ++) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n htables[%d]:\"</span>,i);</span><br><span class=\"line\">        cur = h-&gt;htables[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>((cur != <span class=\"literal\">NULL</span>)) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"key[%s],data[%s] \"</span>,cur-&gt;key,cur-&gt;data);    </span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n----结束--size[%d],nel[%d]------------\"</span>,h-&gt;size,h-&gt;nel);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">test_node</span></span></span><br><span class=\"line\"><span class=\"class\">{</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> key[<span class=\"number\">80</span>];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> data[<span class=\"number\">80</span>];</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">siample_hash</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> hash = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> seed = <span class=\"number\">131</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(*str) {</span><br><span class=\"line\">        hash = hash*seed + *str++;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash &amp; (<span class=\"number\">0x7FFFFFFF</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashtab_hvalue</span><span class=\"params\">(hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (siample_hash(key) % h-&gt;size);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashtab_keycmp</span><span class=\"params\">(hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(key1,key2);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hashtab_node_free</span><span class=\"params\">(hashtab_node*node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">test_node</span> * <span class=\"title\">ptmp</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    ptmp = container(node-&gt;key,struct test_node,key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptmp);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(node);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *pres = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    hashtab_node * node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">test_node</span> *<span class=\"title\">p</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    hashtab *h = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> MEMORY_TEST</span></span><br><span class=\"line\">    setenv(<span class=\"string\">\"MALLOC_TRACE\"</span>,<span class=\"string\">\"1.txt\"</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    mtrace();</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    h = hashtab_create(<span class=\"number\">5</span>,hashtab_hvalue,hashtab_keycmp,hashtab_node_free);</span><br><span class=\"line\">    assert(h!= <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) {</span><br><span class=\"line\">        p = (struct test_node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct test_node));</span><br><span class=\"line\">        assert(p != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n 请输入key 和value，当可以等于\\\"quit\\\"时退出\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,p-&gt;key);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,p-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(p-&gt;key,<span class=\"string\">\"quit\"</span>) == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        res = hashtab_insert(h,p-&gt;key,p-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res != <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n key[%s],data[%s] insert failed %d\"</span>,p-&gt;key,p-&gt;data,res);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n key[%s],data[%s] insert success %d\"</span>,p-&gt;key,p-&gt;data,res);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    hashtab_dump(h);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) {</span><br><span class=\"line\">        p = (struct test_node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct test_node));</span><br><span class=\"line\">        assert(p != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n 请输入key 查询value的数值，当可以等于\\\"quit\\\"时退出\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,p-&gt;key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(p-&gt;key,<span class=\"string\">\"quit\"</span>) == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        pres = hashtab_search(h,p-&gt;key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pres == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n key[%s] search data failed\"</span>,p-&gt;key);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n key[%s],search data[%s] success\"</span>,p-&gt;key,pres);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    hashtab_dump(h);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) {</span><br><span class=\"line\">        p = (struct test_node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct test_node));</span><br><span class=\"line\">        assert(p != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n 请输入key 删除节点的数值，当可以等于\\\"quit\\\"时退出\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,p-&gt;key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(p-&gt;key,<span class=\"string\">\"quit\"</span>) == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        node = hashtab_delete(h,p-&gt;key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n key[%s] delete node failed \"</span>,p-&gt;key);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n key[%s],delete data[%s] success\"</span>,node-&gt;key,node-&gt;data);</span><br><span class=\"line\">            h-&gt;hash_node_free(node);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">        hashtab_dump(h);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    hashtab_destory(h);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> MEMORY_TEST</span></span><br><span class=\"line\">        muntrace();</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<details>\n<summary>hash_table</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* One implementation of hash table with linear probing. */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HASH_SHIFT 4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HASH_SIZE (1 &lt;&lt; HASH_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HASH_MASK (HASH_SIZE - 1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hash_table</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>  used;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> entry[HASH_SIZE];</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_reset</span><span class=\"params\">(struct hash_table *table)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    table-&gt;used = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HASH_SIZE; i++)</span><br><span class=\"line\">    table-&gt;entry[i] = ~<span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">hash_function</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value &amp; HASH_MASK;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump_hash_table</span><span class=\"params\">(struct hash_table *table)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HASH_SIZE; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table-&gt;entry[i] == ~<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%2u:       nil \\n\"</span>, i);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%2u:%10lu -&gt; %2u\\n\"</span>,</span><br><span class=\"line\">        i, table-&gt;entry[i],</span><br><span class=\"line\">        hash_function(table-&gt;entry[i]));</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_function_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    srandom(time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> val = random();</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%10lu -&gt; %2u\\n\"</span>, val, hash_function(val));;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">next_probe</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prev_key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (prev_key + <span class=\"number\">1</span>) &amp; HASH_MASK;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">next_probe_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> key1, key2;</span><br><span class=\"line\"></span><br><span class=\"line\">    key1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HASH_SIZE; i++) {</span><br><span class=\"line\">        key2 = next_probe(key1);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%2u -&gt; %2u\\n\"</span>, key1, key2);</span><br><span class=\"line\">        key1 = key2;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_add</span><span class=\"params\">(struct hash_table *table, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> key = hash_function(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (table-&gt;used &gt;= HASH_SIZE)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (table-&gt;entry[key] != ~<span class=\"number\">0</span>)</span><br><span class=\"line\">        key = next_probe(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    table-&gt;entry[key] = value;</span><br><span class=\"line\">    table-&gt;used++;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">hash_table_slot</span><span class=\"params\">(struct hash_table *table, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> key = hash_function(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HASH_SIZE; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table-&gt;entry[key] == value || table-&gt;entry[key] == ~<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        key = next_probe(key);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hash_table_find</span><span class=\"params\">(struct hash_table *table, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> table-&gt;entry[hash_table_slot(table, value)] == value;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_del</span><span class=\"params\">(struct hash_table *table, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i, j, k;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hash_table_find(table, value))</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    i = j = hash_table_slot(table, value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">        table-&gt;entry[i] = ~<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> {</span><br><span class=\"line\">            j = next_probe(j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table-&gt;entry[j] == ~<span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            k = hash_function(table-&gt;entry[j]);</span><br><span class=\"line\">        } <span class=\"keyword\">while</span> ((i &lt;= j) ? (i &lt; k &amp;&amp; k &lt;= j) : (i &lt; k || k &lt;= j));</span><br><span class=\"line\"></span><br><span class=\"line\">        table-&gt;entry[i] = table-&gt;entry[j];</span><br><span class=\"line\">        i = j;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    table-&gt;used++;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_add_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hash_table</span> <span class=\"title\">table</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    hash_table_reset(&amp;table);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">87645</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Table has%s 87645\\n\"</span>,</span><br><span class=\"line\">    hash_table_find(&amp;table, <span class=\"number\">87645</span>) ? <span class=\"string\">\"\"</span>:<span class=\"string\">\"n't\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Table has%s 87647\\n\"</span>,</span><br><span class=\"line\">    hash_table_find(&amp;table, <span class=\"number\">87647</span>) ? <span class=\"string\">\"\"</span>:<span class=\"string\">\"n't\"</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_del_test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hash_table</span> <span class=\"title\">table</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    hash_table_reset(&amp;table);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x1ff0</span>);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x2ff0</span>);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x3ff0</span>);</span><br><span class=\"line\">    dump_hash_table(&amp;table);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"=== Remove 0x1ff0\\n\"</span>);</span><br><span class=\"line\">    hash_table_del(&amp;table, <span class=\"number\">0x1ff0</span>);</span><br><span class=\"line\">    dump_hash_table(&amp;table);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_del_test2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hash_table</span> <span class=\"title\">table</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    hash_table_reset(&amp;table);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x1ff0</span>);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x1ff1</span>);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x1ff2</span>);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x2ff0</span>);</span><br><span class=\"line\">    dump_hash_table(&amp;table);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"=== Remove 0x1ff0\\n\"</span>);</span><br><span class=\"line\">    hash_table_del(&amp;table, <span class=\"number\">0x1ff0</span>);</span><br><span class=\"line\">    dump_hash_table(&amp;table);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">//hash_function_test();</span></span><br><span class=\"line\">    <span class=\"comment\">//next_probe_test();</span></span><br><span class=\"line\">    <span class=\"comment\">//hash_table_add_test();</span></span><br><span class=\"line\">    hash_table_del_test2();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<h4 id=\"2-2-2-哈希冲突\"><a href=\"#2-2-2-哈希冲突\" class=\"headerlink\" title=\"2.2.2 哈希冲突\"></a>2.2.2 哈希冲突</h4><p> 理想情况下,哈希函数在关键字和地址之间建立一对一关系.但H(k1) = H(k2),即为冲突.</p>\n<p> 解决哈希冲突常用方法:</p>\n<ul>\n<li>链地址法<br>将哈希值相同的元素构成一个同义词的单链表,并将单链表头指针存放在哈希表的地i个单元中,查找,插入和删除主要在同义词链表中.</li>\n<li>线性探测</li>\n<li>二次探测</li>\n</ul>\n<h4 id=\"2-2-3-uthash\"><a href=\"#2-2-3-uthash\" class=\"headerlink\" title=\"2.2.3 uthash\"></a>2.2.3 uthash</h4><p> uthash的插入、查找、删除的操作时间都是常量</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"uthash.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;            <span class=\"comment\">/* we'll use this field as the key */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\">    UT_hash_handle hh; <span class=\"comment\">/* makes this structure hashable */</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">users</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_user</span><span class=\"params\">(struct my_struct *s)</span> </span>{</span><br><span class=\"line\">    HASH_ADD_INT(users, id, s);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<details>\n<summary>uthash用法</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span>   <span class=\"comment\">/* gets */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span>  <span class=\"comment\">/* atoi, malloc */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span>  <span class=\"comment\">/* strcpy */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"uthash.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;                    <span class=\"comment\">/* key */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\">    UT_hash_handle hh;         <span class=\"comment\">/* makes this structure hashable */</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">users</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_user</span><span class=\"params\">(<span class=\"keyword\">int</span> user_id, <span class=\"keyword\">char</span> *name)</span> </span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">s</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    HASH_FIND_INT(users, &amp;user_id, s);  <span class=\"comment\">/* id already in the hash? */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s==<span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        s = (struct my_struct *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span> *s);</span><br><span class=\"line\">        s-&gt;id = user_id;</span><br><span class=\"line\">        HASH_ADD_INT( users, id, s );  <span class=\"comment\">/* id: name of key field */</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(s-&gt;name, name);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct my_struct *<span class=\"title\">find_user</span><span class=\"params\">(<span class=\"keyword\">int</span> user_id)</span> </span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">s</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    HASH_FIND_INT(users, &amp;user_id, s);  <span class=\"comment\">/* s: output pointer */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete_user</span><span class=\"params\">(struct my_struct *user)</span> </span>{</span><br><span class=\"line\">    HASH_DEL(users, user);  <span class=\"comment\">/* user: pointer to deletee */</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(user);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete_all</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">current_user</span>, *<span class=\"title\">tmp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    HASH_ITER(hh, users, current_user, tmp) {</span><br><span class=\"line\">        HASH_DEL(users, current_user);  <span class=\"comment\">/* delete it (users advances to next) */</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(current_user);             <span class=\"comment\">/* free it */</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_users</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">s</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(s=users; s != <span class=\"literal\">NULL</span>; s=(struct my_struct*)(s-&gt;hh.next)) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"user id %d: name %s\\n\"</span>, s-&gt;id, s-&gt;name);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">name_sort</span><span class=\"params\">(struct my_struct *a, struct my_struct *b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(a-&gt;name,b-&gt;name);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">id_sort</span><span class=\"params\">(struct my_struct *a, struct my_struct *b)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a-&gt;id - b-&gt;id);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort_by_name</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    HASH_SORT(users, name_sort);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort_by_id</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    HASH_SORT(users, id_sort);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">char</span> in[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> id=<span class=\"number\">1</span>, running=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">s</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> num_users;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (running) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" 1. add user\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" 2. add/rename user by id\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" 3. find user\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" 4. delete user\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" 5. delete all users\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" 6. sort items by name\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" 7. sort items by id\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" 8. print users\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" 9. count users\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"10. quit\\n\"</span>);</span><br><span class=\"line\">        gets(in);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(atoi(in)) {</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"name?\\n\"</span>);</span><br><span class=\"line\">                add_user(id++, gets(in));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"id?\\n\"</span>);</span><br><span class=\"line\">                gets(in); id = atoi(in);</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"name?\\n\"</span>);</span><br><span class=\"line\">                add_user(id, gets(in));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"id?\\n\"</span>);</span><br><span class=\"line\">                s = find_user(atoi(gets(in)));</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"user: %s\\n\"</span>, s ? s-&gt;name : <span class=\"string\">\"unknown\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"id?\\n\"</span>);</span><br><span class=\"line\">                s = find_user(atoi(gets(in)));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s) delete_user(s);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"id unknown\\n\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">                delete_all();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">                sort_by_name();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">                sort_by_id();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">                print_users();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">9</span>:</span><br><span class=\"line\">                num_users=HASH_COUNT(users);</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"there are %u users\\n\"</span>, num_users);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">10</span>:</span><br><span class=\"line\">                running=<span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    delete_all();  <span class=\"comment\">/* free any structures */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n</details>\n\n<ul>\n<li>参考链接<br>官网:<a href=\"https://troydhanson.github.io/uthash/\">https://troydhanson.github.io/uthash/</a><br><a href=\"https://blog.csdn.net/fan_h_l/article/details/107241520\">https://blog.csdn.net/fan_h_l/article/details/107241520</a><br><a href=\"https://blog.csdn.net/whatday/article/details/95926766\">https://blog.csdn.net/whatday/article/details/95926766</a><br><a href=\"https://www.cnblogs.com/pam-sh/p/12827658.html\">https://www.cnblogs.com/pam-sh/p/12827658.html</a></li>\n</ul>\n<h4 id=\"2-2-4-leetcode题目\"><a href=\"#2-2-4-leetcode题目\" class=\"headerlink\" title=\"2.2.4 leetcode题目\"></a>2.2.4 leetcode题目</h4><ul>\n<li><p>设计哈希集合 </p>\n</li>\n<li><p>设计哈希映射</p>\n</li>\n<li><p>根据字符出现频率排序</p>\n</li>\n</ul>\n<h3 id=\"2-3-树与二叉树\"><a href=\"#2-3-树与二叉树\" class=\"headerlink\" title=\"2.3 树与二叉树\"></a>2.3 树与二叉树</h3><p> 树(tree)是一种用来模拟树状结构的抽象数据结构(ADT);</p>\n<p> 树的特点:</p>\n<ul>\n<li>没有父节点的节点称为根节点</li>\n<li>每个非根节点有且只有一个父节点</li>\n<li>除了根结点外,每个子节点可分为多个不相交的子树</li>\n<li>树中没有环路</li>\n</ul>\n<h4 id=\"2-3-1-概述\"><a href=\"#2-3-1-概述\" class=\"headerlink\" title=\"2.3.1 概述\"></a>2.3.1 概述</h4><ul>\n<li>节点的度: 一个节点含有子树的个数</li>\n<li>树的度: 树中最大的节点度</li>\n<li>叶节点: 度为零的节点</li>\n<li>父节点</li>\n<li>子节点</li>\n<li>兄弟节点</li>\n<li>节点的层次</li>\n<li>深度: 任意节点n,n的深度为从n到一片树叶的最长路径长,根的深度为0</li>\n<li>高度: 对任意节点n,n的高度为从n到一片树叶的最长路径长,所有树叶的高度为0.</li>\n<li>森林</li>\n</ul>\n<p> 树由称为结点的元素按照层次结构的方式组织而成。最顶端称为根。与根直接相连的结点称为根的子结点。子节点本身也可以有子结点。除根结点外，每个结点都有唯一的父结点。</p>\n<h4 id=\"2-3-2-树的种类\"><a href=\"#2-3-2-树的种类\" class=\"headerlink\" title=\"2.3.2 树的种类\"></a>2.3.2 树的种类</h4><ul>\n<li><p>无序树</p>\n</li>\n<li><p>有序树</p>\n<ul>\n<li><p>二叉树: 每个节点最多含有两个子树的树.</p>\n<ul>\n<li>完全二叉树: 对于一颗深度为d的二叉树,除第d层外,其他各层节点数目均达最大值,且第d层所有节点从左向右连续紧密排列.<ul>\n<li>满二叉树:所有叶节点都最底层的完全二叉树.</li>\n</ul>\n</li>\n<li>平衡二叉树(AVL):当且仅当任何节点的两颗子树的高度差不大于1的二叉树.</li>\n<li>排序二叉树:二叉查找树</li>\n</ul>\n</li>\n<li><p>霍夫曼树:带权路径最短的二叉树(又称最优二叉树).</p>\n</li>\n<li><p>B树:一种堆读写操作进行优化的自平衡二叉查找树,能够保持数据有序,拥有多余两个子树.</p>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>二叉树</td>\n<td>二叉查找树(BST) 笛卡尔树 MVP树 Top tree T树</td>\n</tr>\n<tr>\n<td>自平衡二叉查找树</td>\n<td>AVL树 红黑树 加权平衡树 AA树</td>\n</tr>\n<tr>\n<td>B树</td>\n<td>B树 B+树</td>\n</tr>\n<tr>\n<td>堆</td>\n<td>二项堆 斐波那契堆</td>\n</tr>\n<tr>\n<td>Trie</td>\n<td>后缀树 基数树 三叉查找树</td>\n</tr>\n</tbody></table>\n<p> 树有多种结构形式，包括二叉树、。</p>\n<h4 id=\"2-3-3-二叉树\"><a href=\"#2-3-3-二叉树\" class=\"headerlink\" title=\"2.3.3 二叉树\"></a>2.3.3 二叉树</h4><p> 二叉树两个条件:</p>\n<ul>\n<li>本身是有序树</li>\n<li>树中包含的各个节点的度不能超过2,即只能是0,1或者2</li>\n</ul>\n<p> 二叉树中结点包含三部分：一个数据成员两个左右指针。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTreeNode_</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTreeNode_</span> *<span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTreeNode_</span> *<span class=\"title\">right</span>;</span></span><br><span class=\"line\">}BiTreeNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTree_</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*compare)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destroy)(<span class=\"keyword\">void</span> *data);</span><br><span class=\"line\">    BiTreeNode *root;</span><br><span class=\"line\">}BiTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*树根*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tree</span>{</span></span><br><span class=\"line\">    Node * root;</span><br><span class=\"line\">}Tree;</span><br></pre></td></tr></tbody></table></figure>\n\n<details>\n<summary>二叉树</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">\"list_queue.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">treenode</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">treenode</span> *<span class=\"title\">lchild</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">treenode</span> *<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">}Tnode,Tree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_create</span><span class=\"params\">(Tree **Root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n输入节点数值((当输入为100时，当前节点创建完成))):\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a == <span class=\"number\">100</span>) {</span><br><span class=\"line\">        *Root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        *Root = (Tnode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Tnode));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*Root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        (*Root)-&gt;data = a;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n create %d 的左孩子:\"</span>,a);</span><br><span class=\"line\">        binarytree_create(&amp;((*Root)-&gt;lchild));</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n create %d 的右孩子:\"</span>,a);</span><br><span class=\"line\">        binarytree_create(&amp;((*Root)-&gt;rchild));</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_destory</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    binarytree_destory(root-&gt;lchild);</span><br><span class=\"line\">    binarytree_destory(root-&gt;rchild);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(root);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*先序遍历:根结点--》左子树---》右子树*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_preorder</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>,root-&gt;data);</span><br><span class=\"line\">    binarytree_preorder(root-&gt;lchild);</span><br><span class=\"line\">    binarytree_preorder(root-&gt;rchild);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*中序遍历:左子树--》跟节点---》右子树*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_inorder</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    binarytree_inorder(root-&gt;lchild);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>,root-&gt;data);</span><br><span class=\"line\">    binarytree_inorder(root-&gt;rchild);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*后序遍历:左子树---》右子树-》根节点*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_postorder</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    binarytree_postorder(root-&gt;lchild);</span><br><span class=\"line\">    binarytree_postorder(root-&gt;rchild);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>,root-&gt;data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_levelorder</span><span class=\"params\">(Tree * root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    list_queue *<span class=\"built_in\">queue</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Tnode * node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> = list_queue_create();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*根节点先入队*/</span></span><br><span class=\"line\">    list_queue_enqueue(<span class=\"built_in\">queue</span>,(<span class=\"keyword\">void</span> *)root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!list_queue_is_empty(<span class=\"built_in\">queue</span>)) {</span><br><span class=\"line\">        list_queue_dequeue(<span class=\"built_in\">queue</span>,(<span class=\"keyword\">void</span> *)&amp;node);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>,node-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node-&gt;lchild != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            list_queue_enqueue(<span class=\"built_in\">queue</span>,(<span class=\"keyword\">void</span> *)node-&gt;lchild);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node-&gt;rchild != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            list_queue_enqueue(<span class=\"built_in\">queue</span>,(<span class=\"keyword\">void</span> *)node-&gt;rchild);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*打印叶子节点*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_printfleaf</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((root-&gt;lchild == <span class=\"literal\">NULL</span>) &amp;&amp; (root-&gt;rchild == <span class=\"literal\">NULL</span>)) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>,root-&gt;data);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        binarytree_printfleaf(root-&gt;lchild);</span><br><span class=\"line\">        binarytree_printfleaf(root-&gt;rchild);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*打印叶子的个数*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarytree_getleafnum</span><span class=\"params\">(Tree*root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((root-&gt;lchild == <span class=\"literal\">NULL</span>) &amp;&amp; (root-&gt;rchild == <span class=\"literal\">NULL</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> binarytree_getleafnum(root-&gt;lchild) + binarytree_getleafnum(root-&gt;rchild);</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/*打印数的高度*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarytree_gethigh</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lhigh = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rhigh = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    lhigh = binarytree_gethigh(root-&gt;lchild);</span><br><span class=\"line\">    rhigh = binarytree_gethigh(root-&gt;rchild);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((lhigh &gt; rhigh)?(lhigh + <span class=\"number\">1</span>):(rhigh + <span class=\"number\">1</span>));</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Tree *root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    setenv(<span class=\"string\">\"MALLOC_TRACE\"</span>,<span class=\"string\">\"1.txt\"</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    mtrace();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n创建二叉树:\"</span>);</span><br><span class=\"line\">    binarytree_create(&amp;root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n先序遍历二叉树:\"</span>);</span><br><span class=\"line\">    binarytree_preorder(root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n中序遍历二叉树:\"</span>);</span><br><span class=\"line\">    binarytree_inorder(root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n后序遍历二叉树:\"</span>);</span><br><span class=\"line\">    binarytree_postorder(root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n层次遍历二叉树:\"</span>);</span><br><span class=\"line\">    binarytree_levelorder(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n打印二叉树叶子节点:\"</span>);</span><br><span class=\"line\">    binarytree_printfleaf(root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n打印二叉树叶子节点个数:%d\"</span>,binarytree_getleafnum(root));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\r\\n打印二叉树高度:%d\"</span>,binarytree_gethigh(root));</span><br><span class=\"line\"></span><br><span class=\"line\">    binarytree_destory(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    muntrace();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<details>\n<summary>binarytree</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Implement binary tree in array */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_TREE_NODES (1 &lt;&lt; 8)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binary_tree</span> {</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nodes;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">n</span>[<span class=\"title\">MAX_TREE_NODES</span>];</span></span><br><span class=\"line\">    };</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_binary_tree</span><span class=\"params\">(struct binary_tree *tree)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; MAX_TREE_NODES; i++) {</span><br><span class=\"line\">        tree-&gt;n[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct node* <span class=\"title\">create_node</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>* <span class=\"title\">n</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct node));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n)</span><br><span class=\"line\">        n-&gt;data = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fake_a_tree</span><span class=\"params\">(struct binary_tree* tree)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">/* data is in ordered */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, data[<span class=\"number\">10</span>] = {<span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    init_binary_tree(tree);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* root start at 1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        tree-&gt;n[i+<span class=\"number\">1</span>] = create_node(data[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    tree-&gt;nodes = <span class=\"number\">10</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _in_order(struct binary_tree* tree, <span class=\"keyword\">int</span> index)</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree-&gt;n[index])</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* left child at (index &lt;&lt; 1) */</span></span><br><span class=\"line\">    _in_order(tree, index &lt;&lt; <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"[%2d]: %4d\\n\"</span>, index, tree-&gt;n[index]-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* right child at (index &lt;&lt; 1) + 1 */</span></span><br><span class=\"line\">    _in_order(tree, (index &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">in_order</span><span class=\"params\">(struct binary_tree* tree)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    _in_order(tree, <span class=\"number\">1</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binary_tree</span> <span class=\"title\">tree</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fake_a_tree(&amp;tree);</span><br><span class=\"line\">    in_order(&amp;tree);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<p> 二叉树性质:</p>\n<ul>\n<li>二叉树中,第i层最多有 2^(i-1)个节点</li>\n<li>如果二叉树的深度为K,则二叉树最多有<code>2^K - 1</code>个节点</li>\n<li>二叉树中，终端结点树(叶子节点树)为n0，度为2的节点树为n1，则 n0=n1+1</li>\n</ul>\n<p><strong>满二叉树</strong><br> 如果二叉树中除了叶子节点，每个节点的度都为2，则此二叉树为满二叉树。</p>\n<p><strong>完全二叉树</strong><br> 如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p>\n<p> 树的周游算法包含先序遍历、中序遍历、后序遍历和层序遍历。</p>\n<ul>\n<li>先序遍历：先访问根结点，然后左子树，最后右子结点。深度优先思想。</li>\n<li>中序遍历：先访问左子结点，然后根结点，最后右子结点。</li>\n<li>后序遍历：先访问左子结点，然后右子结点，最后根结点。</li>\n<li>层序遍历：先访问树的根结点，然后依次向下层处理，按照从左向右的顺序访问每层结点。广度优先的策略。</li>\n</ul>\n<h4 id=\"2-3-4-二叉查找树-BST\"><a href=\"#2-3-4-二叉查找树-BST\" class=\"headerlink\" title=\"2.3.4 二叉查找树(BST)\"></a>2.3.4 二叉查找树(BST)</h4><p> 二叉查找树也称二叉搜索树,有序二叉树或排序二叉树,具有性质:</p>\n<ul>\n<li>若任意节点左子树不为空,则左子树上所有节点的值均小于它的根节点的值</li>\n<li>若任意节点的右子树不为空,则右子树所有节点的值均大于根节点的值</li>\n<li>任意节点的左,右子树也分别为二叉查找树</li>\n<li>没有键值相等的节点</li>\n</ul>\n<p> 一颗二叉搜索树要插入一个结点，要从根结点开始，一层一层往下，适当地移动左或右子结点上，当到达树的分支尽头时，执行插入操作。<br> 二叉搜索树是一种用于查找操作的高效数据结构，在最坏情况下，只需查找一个分支上的数据即可。<strong>查找,插入</strong>操作的复杂度是 <code>O(logn)</code>，<strong>搜索,插入,删除</strong>复杂度等于树高,期望<code>O(logn)</code>,最坏为<code>O(n)</code>,(树退化为线性表)n为树中结点数。<br> 保持一棵树的平衡是指对于给定数量的结点，要使得树的高度尽可能短。</p>\n<p> 二叉查找树是由二叉树组成的专用于查找和搜索目的的一种数据结构。二叉搜索树中查找一个结点，从根结点开始一层一层向下查找，当遇到一个比目标结点值大的结点时，顺着该结点左子树继续查找，如果遇到的结点值小于目标结点，则顺着该结点的右子树查找，直到找到目标结点为止。</p>\n<p> <strong>查找算法</strong><br>  1.若b是空树,则搜索失败,否则;<br>  2.若x等于b的根节点的数据域之值,则查找成功;<br>  3.若x小于b的根节点的数据域之值,则搜索左子树<br>  4.查找右子树</p>\n<p> <strong>插入算法</strong><br>  1.若b是空树,则将s所指节点作为根节点插入;否则<br>  2.若<code>s-&gt;data</code>等于b的根节点的数据域值,则返回,否则;<br>  3.若<code>s-&gt;data</code>小于b的根节点的数据域之值,则把s所值节点插入到左子树中,否则<br>  4.把s所指节点插入到右子树中,(新插入节点总是叶子节点)</p>\n<p> <strong>删除算法</strong><br>  1.若*p节点为叶子节点,即PL(左子树)和PR(右子树)均为空树.由于删去叶子节点不破坏整棵树的结构,则只需修改其双亲节点的指针即可.</p>\n<details>\n<summary>binarysearch</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OK 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRUE 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FALSE 0</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Status;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> ElemType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> {</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">} BTree, *BTreePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**************** 插入 **********************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Insert</span><span class=\"params\">(BTreePtr *T, ElemType e)</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    BTreePtr p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*T == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        *T = (BTreePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BTree));</span><br><span class=\"line\">        (*T)-&gt;data = e;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        p = *T;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( p != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e &gt; p-&gt;data) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p-&gt;rchild == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">                    p-&gt;rchild = (BTreePtr) <span class=\"built_in\">malloc</span> (<span class=\"keyword\">sizeof</span>(BTree));</span><br><span class=\"line\">                    p-&gt;rchild-&gt;data = e;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">                }</span><br><span class=\"line\">                p = p-&gt;rchild;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p-&gt;lchild == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">                    p-&gt;lchild = (BTreePtr) <span class=\"built_in\">malloc</span> (<span class=\"keyword\">sizeof</span>(BTree));</span><br><span class=\"line\">                    p-&gt;lchild-&gt;data = e;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">                }</span><br><span class=\"line\">                p = p-&gt;lchild;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/**************** 删除 **********************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Delete</span><span class=\"params\">(BTreePtr T, ElemType e)</span> </span>{</span><br><span class=\"line\">    BTreePtr p, pp, minP, minPP, child;</span><br><span class=\"line\">    child = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    p = T;</span><br><span class=\"line\">    pp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( (p != <span class=\"literal\">NULL</span>) &amp;&amp; (p-&gt;data != e) ) {</span><br><span class=\"line\">        pp = p;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e &gt; p-&gt;data) {</span><br><span class=\"line\">            p = p-&gt;rchild;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            p = p-&gt;lchild;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//双节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p-&gt;lchild != <span class=\"literal\">NULL</span>) &amp;&amp; (p-&gt;rchild != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        minPP = p;</span><br><span class=\"line\">        minP = p-&gt;rchild;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (minP-&gt;lchild != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            minPP = minP;</span><br><span class=\"line\">            minP = minP-&gt;lchild;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        p-&gt;data = minP-&gt;data;</span><br><span class=\"line\">        minPP-&gt;lchild = minP-&gt;rchild;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(minP);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p-&gt;lchild != <span class=\"literal\">NULL</span>) || (p-&gt;rchild != <span class=\"literal\">NULL</span>)) { <span class=\"comment\">//应该将原有的pp同child连接在一起</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;lchild) {</span><br><span class=\"line\">            child = p-&gt;lchild;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">           child = p-&gt;rchild;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pp-&gt;data&gt;p-&gt;data) {</span><br><span class=\"line\">            pp-&gt;lchild=child;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            pp-&gt;rchild=child;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//没有节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pp-&gt;lchild == p) {<span class=\"comment\">//这里面临pp除p以外的节点为null的情况</span></span><br><span class=\"line\">        pp-&gt;lchild = child;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        pp-&gt;rchild = child;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">/**************** 查找 **********************/</span></span><br><span class=\"line\">Status Find(BTreePtr T, ElemType e) {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((T != <span class=\"literal\">NULL</span>) &amp;&amp; (T-&gt;data != e)) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e &gt; T-&gt;data) {</span><br><span class=\"line\">            T = T-&gt;rchild;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            T = T-&gt;lchild;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**************** 最大值 **********************/</span></span><br><span class=\"line\">ElemType FindMax(BTreePtr T) {</span><br><span class=\"line\">    ElemType max;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        max = T-&gt;data;</span><br><span class=\"line\">        T = T-&gt;rchild;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**************** 最小值 **********************/</span></span><br><span class=\"line\">ElemType FindMin(BTreePtr T) {</span><br><span class=\"line\">    ElemType min;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        min = T-&gt;data;</span><br><span class=\"line\">        T = T-&gt;lchild;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> PreOrderTraverse(BTreePtr T)<span class=\"comment\">//前序遍历二叉树</span></span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,T-&gt;data);</span><br><span class=\"line\">        PreOrderTraverse(T-&gt;lchild);</span><br><span class=\"line\">        PreOrderTraverse(T-&gt;rchild);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> DestroyTree(BTreePtr T) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (T-&gt;lchild) {</span><br><span class=\"line\">            DestroyTree(T-&gt;lchild);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(T-&gt;rchild) {</span><br><span class=\"line\">            DestroyTree(T-&gt;rchild);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(T);</span><br><span class=\"line\">        T = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/***************** 执行测试 *************************/</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span><br><span class=\"line\">{</span><br><span class=\"line\">    BTreePtr T;</span><br><span class=\"line\">    T = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[] = {<span class=\"number\">33</span>, <span class=\"number\">16</span>, <span class=\"number\">50</span>, <span class=\"number\">13</span>, <span class=\"number\">18</span>, <span class=\"number\">34</span>, <span class=\"number\">58</span>, <span class=\"number\">15</span>, <span class=\"number\">17</span>, <span class=\"number\">25</span>, <span class=\"number\">51</span>, <span class=\"number\">66</span>, <span class=\"number\">19</span>, <span class=\"number\">27</span>, <span class=\"number\">55</span>};</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">15</span>; i++) {</span><br><span class=\"line\">        Insert(&amp;T, a[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Max is %d\\n\"</span>, FindMax(T));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Min is %d\\n\"</span>, FindMin(T));</span><br><span class=\"line\">    Delete(T, <span class=\"number\">18</span>);</span><br><span class=\"line\">    Delete(T, <span class=\"number\">13</span>);</span><br><span class=\"line\">    PreOrderTraverse(T);</span><br><span class=\"line\">    DestroyTree(T);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<details>\n<summary>bst</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">child_dir</span> {</span></span><br><span class=\"line\">    left_child,</span><br><span class=\"line\">    right_child,</span><br><span class=\"line\">    root,</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data; </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">right</span>;</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">root</span> {</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">r</span>;</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(struct node *node, <span class=\"keyword\">int</span> level, <span class=\"keyword\">enum</span> child_dir dir)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(node-&gt;right, level + <span class=\"number\">1</span>, right_child);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dir == left_child)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%*s\\n\"</span>, level*<span class=\"number\">3</span>, <span class=\"string\">\"|\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%*s - %05lu\\n\"</span>, level*<span class=\"number\">3</span>, <span class=\"string\">\" \"</span>, node-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dir == right_child)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%*s\\n\"</span>, level*<span class=\"number\">3</span>, <span class=\"string\">\"|\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(node-&gt;left, level + <span class=\"number\">1</span>, left_child);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct node* <span class=\"title\">find</span><span class=\"params\">(struct root *root, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>* <span class=\"title\">n</span> =</span> root-&gt;r;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n-&gt;data == data)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data &lt; n-&gt;data)</span><br><span class=\"line\">            n = n-&gt;left;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            n = n-&gt;right;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct node* <span class=\"title\">new_node</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">n</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct node));</span><br><span class=\"line\"></span><br><span class=\"line\">    n-&gt;data = data;</span><br><span class=\"line\">    n-&gt;left = n-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(struct root *root, struct node *<span class=\"keyword\">new</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">parent</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;r) {</span><br><span class=\"line\">        root-&gt;r = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    parent = root-&gt;r;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"comment\">/* Don't support duplicate data */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span>-&gt;data == parent-&gt;data)</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span>-&gt;data &lt; parent-&gt;data) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parent-&gt;left) {</span><br><span class=\"line\">            parent-&gt;left = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        parent = parent-&gt;left;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!parent-&gt;right) {</span><br><span class=\"line\">                parent-&gt;right = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            parent = parent-&gt;right;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct node* <span class=\"title\">delete</span><span class=\"params\">(struct root *root, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">n</span> =</span> root-&gt;r, **p = &amp;root-&gt;r;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">child</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &amp;&amp; n-&gt;data != data) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data &lt; n-&gt;data) {</span><br><span class=\"line\">            p = &amp;n-&gt;left;</span><br><span class=\"line\">            n = n-&gt;left;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            p = &amp;n-&gt;right;</span><br><span class=\"line\">            n = n-&gt;right;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!n)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n-&gt;left &amp;&amp; n-&gt;right) {</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">rn</span> =</span> n-&gt;right, **rp = &amp;n-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (rn-&gt;left) {</span><br><span class=\"line\">            rp = &amp;rn-&gt;left;</span><br><span class=\"line\">            rn = rn-&gt;left;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        n-&gt;data = rn-&gt;data;</span><br><span class=\"line\">        n = rn;</span><br><span class=\"line\">        p = rp;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    child = n-&gt;left ? n-&gt;left : n-&gt;right;</span><br><span class=\"line\">    *p = child;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">root</span> <span class=\"title\">tree</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>* <span class=\"title\">n</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tree.r = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">9</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">5</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">2</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">8</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">18</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">13</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">21</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(tree.r, <span class=\"number\">0</span>, root);</span><br><span class=\"line\"></span><br><span class=\"line\">    n = find(&amp;tree, <span class=\"number\">18</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &amp;&amp; n-&gt;data == <span class=\"number\">18</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Get 18\\n\"</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">root</span> <span class=\"title\">tree</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>* <span class=\"title\">n</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tree.r = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">9</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">5</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">2</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">8</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">18</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">13</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">21</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(tree.r, <span class=\"number\">0</span>, root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span>(&amp;tree, <span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Delete 20\\n\"</span>);</span><br><span class=\"line\">    dump(tree.r, <span class=\"number\">0</span>, root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span>(&amp;tree, <span class=\"number\">9</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Delete 9\\n\"</span>);</span><br><span class=\"line\">    dump(tree.r, <span class=\"number\">0</span>, root);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">//insert_test();</span></span><br><span class=\"line\">    delete_test();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<h4 id=\"2-3-5-平衡树\"><a href=\"#2-3-5-平衡树\" class=\"headerlink\" title=\"2.3.5 平衡树\"></a>2.3.5 平衡树</h4><p> 平衡树是一类改进的二叉查找树,一般二叉查找树的查询复杂度与目标节点到树根的距离(深度)有关,因此当深度较大时,查询均摊复杂度会上升.<br> <strong>平衡指所有叶子的深度趋于平衡</strong>,更广义指树上所有可能查找的均摊复杂度偏低.<strong>平衡树的操作时基于树旋转操作,通过旋转可使树趋于平衡</strong>.<br> 对一颗查找树进行查询,新增,删除等操作,所花的时间与树的高度h成比例,并不与树的容量n成比例.</p>\n<ul>\n<li><strong>AVL树</strong></li>\n</ul>\n<p> 在<strong>AVL树中,任一节点对于的两颗子树的最大高度差为1,因此也称为高度平衡树</strong>.查找,插入和删除的平均和最坏时间复杂度是O(logn),增加和删除元素的操作则可能需要借由一层或多次旋转,以实现树的重新平衡.<br> <strong>高度为h的AVL树,总节点数最多为2^h-1</strong>; 当前节点数为N时,高度h最多为:</p>\n<blockquote>\n<p>log(5*0.5 * (N + 1)) - 2</p>\n</blockquote>\n<br>\n\n<ul>\n<li><strong>红黑树</strong></li>\n</ul>\n<p> 红黑树是一种自平衡二叉查找树,典型的用途是实现关联数组.红黑树实现复制,查找,插入和删除时间复杂度为O(logn)<br> 红黑树相对于AVL树,牺牲了部分平衡性以换取插入\\删除操作时少量的旋转操作,整体性能优于AVL树.</p>\n<p> 红黑树与AVL树的相比:<br>  AVL树在插入,删除节点时要把树调整到完全平衡,红黑树只要调整到大致平衡,因此通常红黑树的插入,删除节点性能稍好.<br>  AVL的查找性能通常比红黑树好<br>  如果节点的增删操作远小于查找操作,则应选择AVL;反之,红黑树可能更好.</p>\n<p> 红黑树是每个节点都带有颜色属性的二叉树,颜色为红色或黑色.在二叉查找树强制一般要求以外,对于任何有效的红黑树我们怎讲了弱小额外要求:<br>  1.节点是红或黑色<br>  2.根是黑色<br>  3.所有叶子都是黑色(叶子是NIL节点)<br>  4.每个红色节点必须右两个黑色的子节点.(从每个叶子到根的所有路径上不能右两个连续的红色节点.)<br>  5.从任一节点到其每个叶子的所有简单路径都包含相同苏后面的黑色节点.<br> 红黑树关键特性:<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>.红黑树是大致平衡的.插入,删除和查找某个值最坏情况下与树的高度成比例.</p>\n<ul>\n<li><strong>B+树</strong></li>\n</ul>\n<p> B+树通常用于数据库和操作系统的文件系统中.<strong>B+树的特点是能够保持数据稳定有序,其插入与修改拥有较文档的对数时间复杂度</strong>.B+树元素自底向上插入,与二叉树相反.<br> B+树是内部节点可右在预定范围内的可变量目的子节点.因此,B+树不需要像其他自平衡二叉查找树那样重新平衡.</p>\n<ul>\n<li><strong>字典树</strong></li>\n</ul>\n<details>\n<summary>Trie</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OK 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRUE 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FALSE 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Status;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">children</span>[26];</span></span><br><span class=\"line\">    Status end;</span><br><span class=\"line\">} Trie, *TriePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Init</span><span class=\"params\">(TriePtr *T)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    (*T) = (TriePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Trie));</span><br><span class=\"line\">    (*T)-&gt;data = <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    (*T)-&gt;end = FALSE;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(TriePtr T, <span class=\"keyword\">char</span> *str)</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c = *str++) {</span><br><span class=\"line\">        index = c - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (T-&gt;children[index] == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            TriePtr Node;</span><br><span class=\"line\">            Node = (TriePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Trie));</span><br><span class=\"line\">            Node-&gt;data = c;</span><br><span class=\"line\">            Node-&gt;end = FALSE;</span><br><span class=\"line\">            T-&gt;children[index] = Node;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        T = T-&gt;children[index];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    T-&gt;end = TRUE;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Search</span><span class=\"params\">(TriePtr T, <span class=\"keyword\">char</span> *str)</span> </span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c = *str++) {</span><br><span class=\"line\">        index = c - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (T-&gt;children[index] == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        T = T-&gt;children[index];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T-&gt;end) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    TriePtr T;</span><br><span class=\"line\">    Init(&amp;T);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *str = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *str2 = <span class=\"string\">\"hi\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Insert(T, str);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"str is search %d\\n\"</span>, Search(T, str));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"str2 is search %d\\n\"</span>, Search(T, str2));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<h4 id=\"2-3-6-堆树和优先队列\"><a href=\"#2-3-6-堆树和优先队列\" class=\"headerlink\" title=\"2.3.6 堆树和优先队列\"></a>2.3.6 堆树和优先队列</h4><p> 堆(heap)也称为优先队列,堆遵守队列操作模式,在堆底插入元素,在堆顶取出元素,但堆中元素的排列不是按照到来的先后顺序,而是按照一定的有序顺序排列的.<br> 堆的本质是一个完全二叉树,可使用二叉树表示堆,也可使用数组来表示.<br> 堆的特性:<br>  必须是完全二叉树<br>  用数组实现<br>  任一节点的值是其子树所有节点的最大值或最小值<br>   最大值时,称为最大堆,也称大顶堆<br>   最小时,称为最小堆,也称小顶堆.<br> <strong>堆不能保证整棵树都是有序的,堆中的插入和删除操作时时间复杂度为O(log2n)</strong></p>\n<p> 堆是一颗二叉树，通常其子结点存储的值比父结点的值小，所以，根结点为树中最大的结点(大顶堆)。同样，根结点也可以是树中最小的结点(小顶堆)。能够快速确定包含最大(小)值的特点。<br> 堆时左平衡的树，随着结点增加，树会逐级从左至右增长。一个较好地表示左平衡二叉树的方式是，将结点通过层序遍历方式连续存储到一个数组中。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Heap_</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*compare)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destroy)(<span class=\"keyword\">void</span> *data);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> **tree;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<details>\n<summary>heap</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Implement heap */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_HEAP_SIZE (1 &lt;&lt; 8)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">heap</span> {</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> {</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> elements;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> *<span class=\"title\">elem</span>[<span class=\"title\">MAX_HEAP_SIZE</span>];</span></span><br><span class=\"line\">    };</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_heap</span><span class=\"params\">(struct heap *heap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; MAX_HEAP_SIZE; i++) {</span><br><span class=\"line\">        heap-&gt;elem[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump_heap</span><span class=\"params\">(struct heap *heap, <span class=\"keyword\">int</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> *<span class=\"title\">elem</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; heap-&gt;elements)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    elem = heap-&gt;elem[index];</span><br><span class=\"line\">    level = fls(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump_heap(heap, index * <span class=\"number\">2</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(index % <span class=\"number\">2</span>) &amp;&amp; index != <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%*s\\n\"</span>, level*<span class=\"number\">3</span>, <span class=\"string\">\"|\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%*s - %05d\\n\"</span>, level*<span class=\"number\">3</span>, <span class=\"string\">\" \"</span>, elem-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index % <span class=\"number\">2</span> &amp;&amp; index != <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%*s\\n\"</span>, level*<span class=\"number\">3</span>, <span class=\"string\">\"|\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump_heap(heap, index * <span class=\"number\">2</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(struct heap *heap, <span class=\"keyword\">int</span> elements)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= elements; i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"[%02d]: %4d\\n\"</span>, i, heap-&gt;elem[i]-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct element* <span class=\"title\">create_element</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> *<span class=\"title\">elem</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    elem = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct element));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elem)</span><br><span class=\"line\">        elem-&gt;data = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elem;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fake_a_heap</span><span class=\"params\">(struct heap *heap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">/* data is in ordered */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, data[<span class=\"number\">10</span>] = {<span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    init_heap(heap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* root start at 1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        heap-&gt;elem[i+<span class=\"number\">1</span>] = create_element(data[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    heap-&gt;elements = <span class=\"number\">10</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(struct heap *heap, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> *<span class=\"title\">tmp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = heap-&gt;elem[j];</span><br><span class=\"line\">    heap-&gt;elem[j] = heap-&gt;elem[i];</span><br><span class=\"line\">    heap-&gt;elem[i] = tmp;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">heapify</span><span class=\"params\">(struct heap *heap, <span class=\"keyword\">int</span> parent)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> **<span class=\"title\">elem</span> =</span> heap-&gt;elem;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> elements = heap-&gt;elements;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left, right, max;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">        left = parent * <span class=\"number\">2</span>;</span><br><span class=\"line\">        right = left + <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        max = parent;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt;= elements &amp;&amp; elem[max]-&gt;data &lt; elem[left]-&gt;data)</span><br><span class=\"line\">            max = left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt;= elements &amp;&amp; elem[max]-&gt;data &lt; elem[right]-&gt;data)</span><br><span class=\"line\">            max = right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (max == parent)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        swap(heap, max, parent);</span><br><span class=\"line\">        parent = max;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build_heap</span><span class=\"params\">(struct heap *heap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = heap-&gt;elements / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">1</span>; i--)</span><br><span class=\"line\">        heapify(heap, i);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">heap_sort</span><span class=\"params\">(struct heap *heap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> elements = heap-&gt;elements;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (heap-&gt;elements) {</span><br><span class=\"line\">        swap(heap, <span class=\"number\">1</span>, heap-&gt;elements);</span><br><span class=\"line\">        heap-&gt;elements--;</span><br><span class=\"line\">        heapify(heap, <span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> elements;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">heap</span> <span class=\"title\">heap</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> elements;</span><br><span class=\"line\"></span><br><span class=\"line\">    fake_a_heap(&amp;heap);</span><br><span class=\"line\">    dump_heap(&amp;heap, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"After Heapify:\\n\"</span>);</span><br><span class=\"line\">    build_heap(&amp;heap);</span><br><span class=\"line\">    dump_heap(&amp;heap, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"After Heap sort:\\n\"</span>);</span><br><span class=\"line\">    elements = heap_sort(&amp;heap);</span><br><span class=\"line\">    dump(&amp;heap, elements);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<p> 堆排序，要排序的数据首先存储在一个堆中。从堆中一次取出一个结点。放置到有序数据集的尾部。当取出每个结点时，它的下一个结点就会浮现到堆的顶部。</p>\n<p> 优先队列是从堆衍生的数据结构。在优先队列中，数据保存在一个堆中，可快速确定下一个最高优先级的结点。</p>\n<p> 优先队列将数据按照优先级顺序排列。一个优先队列由许多有序元素构成，所以优先级最高的元素可以有效而快速的确定。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Heap PQueue;</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h4 id=\"2-3-7-leetcode题目\"><a href=\"#2-3-7-leetcode题目\" class=\"headerlink\" title=\"2.3.7 leetcode题目\"></a>2.3.7 leetcode题目</h4><ul>\n<li>先序遍历构造二叉树</li>\n<li>从中序与后序遍历构造二叉树</li>\n<li>二叉树的层次遍历</li>\n<li>从二叉搜索树到更大和树</li>\n<li>二叉搜索树的最近公共祖先</li>\n<li>前K个高频单词&lt;堆&gt;</li>\n</ul>\n<h3 id=\"2-4-图\"><a href=\"#2-4-图\" class=\"headerlink\" title=\"2.4 图\"></a>2.4 图</h3><p> 图(Graph)是由顶点的有穷非空集合和顶点之间的边的集合组成,通常表示为:<code>G(V,E)</code>.其中,G表示一个图,V是入G中顶点的集合,E是图G中的集合.</p>\n<p> 图是一种灵活的数据结构，用来定义对象之间关联或联系的模型。对象由顶点表示，而对象直接的关系或关联则通过顶点之间的边来表示。<br> 图的访问方式：广度优先和深度优先。</p>\n<h4 id=\"2-4-1-基础知识\"><a href=\"#2-4-1-基础知识\" class=\"headerlink\" title=\"2.4.1 基础知识\"></a>2.4.1 基础知识</h4><p> 图由两种类型的元素组成：顶点和边，顶点代表对象，边则建立起对象之间的关系或关联。图的边可关联值或权重信息。</p>\n<ul>\n<li>一组顶点：用V(vertex)表示顶点集合</li>\n<li>一组边：用E(edge)表示边的集合<br> 图分为有向图和无向图。有向图，边是由两个顶点组成的有序对，具有特定的方向。边也可称为弧。无向图中，边是没有方向的。</li>\n<li>(v, w)表示无向边，即v和w是互通的</li>\n<li>&lt; v, w &gt;表示有向边，该边始于v，终于w<br> 图可分为连通图和非连通图</li>\n<li>连通图：所有的点都右路径相连</li>\n<li>非连通图：存在某两个点没有路径相连</li>\n<li>强连通图： </li>\n</ul>\n<p> 图中的顶点度</p>\n<ul>\n<li>度</li>\n<li>入度</li>\n<li>出度</li>\n</ul>\n<h4 id=\"2-4-2-图表示\"><a href=\"#2-4-2-图表示\" class=\"headerlink\" title=\"2.4.2 图表示\"></a>2.4.2 图表示</h4><p> 图的表示方法是G=(V, E)，V代表顶点的集合，而E和V之间是二元关系。<br> 图中由两个重要关系邻接(adjacency)和关联(incidence)。邻接是两个顶点之间的关系。关联是顶点和边之间的关系。<br>邻接矩阵表示</p>\n<p>邻接链表表示</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjList_</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *vertex;</span><br><span class=\"line\">    Set adjacent;</span><br><span class=\"line\">}AdjList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Graph_</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vcount;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ecount;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    List adjlists;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<details>\n<summary>graph</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> {</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span> *<span class=\"title\">v</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> *<span class=\"title\">adj</span>;</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_GRAPH_VERTEX (1 &lt;&lt; 8)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">graph</span> {</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span> *<span class=\"title\">vxs</span>[<span class=\"title\">MAX_GRAPH_VERTEX</span>];</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_graph</span><span class=\"params\">(struct graph *graph)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX_GRAPH_VERTEX; i++)</span><br><span class=\"line\">        graph-&gt;vxs[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct vertex *<span class=\"title\">create_vertex</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span> *<span class=\"title\">v</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    v = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct vertex));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v) {</span><br><span class=\"line\">        v-&gt;data = data;</span><br><span class=\"line\">        v-&gt;adj = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct vertex_adjs *<span class=\"title\">create_vertex_adj</span><span class=\"params\">(struct vertex *v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> *<span class=\"title\">v_adj</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    v_adj = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct vertex_adjs));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!v_adj)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    v_adj-&gt;v = v;</span><br><span class=\"line\">    v_adj-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v_adj;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_adj</span><span class=\"params\">(struct vertex *v, struct vertex *adj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> **<span class=\"title\">v_adj</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    v_adj = &amp;v-&gt;adj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*v_adj)</span><br><span class=\"line\">    v_adj = &amp;(*v_adj)-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    *v_adj = create_vertex_adj(adj);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump_raw</span><span class=\"params\">(struct graph *graph)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX_GRAPH_VERTEX; i++) {</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span> *<span class=\"title\">v</span> =</span> graph-&gt;vxs[i];</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> *<span class=\"title\">adj</span>;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Vertex[%02d]: %8d -&gt;\"</span>, i, v-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">        adj = v-&gt;adj;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (adj) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" %8d,\"</span>, adj-&gt;v-&gt;data);</span><br><span class=\"line\">            adj = adj-&gt;next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">  1 ----- 2 ----- 3</span></span><br><span class=\"line\"><span class=\"comment\">  |     / |     /</span></span><br><span class=\"line\"><span class=\"comment\">  |    /  |    / </span></span><br><span class=\"line\"><span class=\"comment\">  |   /   |   /  </span></span><br><span class=\"line\"><span class=\"comment\">  |  /    |  /   </span></span><br><span class=\"line\"><span class=\"comment\">  | /     | /    </span></span><br><span class=\"line\"><span class=\"comment\">  4 ----- 5</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fake_a_graph</span><span class=\"params\">(struct graph *graph)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    init_graph(graph);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">    graph-&gt;vxs[i] = create_vertex(i+<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* connect 1 -&gt; 2, 1 -&gt; 4 */</span></span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">0</span>], graph-&gt;vxs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">0</span>], graph-&gt;vxs[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    <span class=\"comment\">/* connect 2 -&gt; 1, 2 -&gt; 3, 2 -&gt; 5, 2 -&gt; 4 */</span></span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">1</span>], graph-&gt;vxs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">1</span>], graph-&gt;vxs[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">1</span>], graph-&gt;vxs[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">1</span>], graph-&gt;vxs[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    <span class=\"comment\">/* connect 3 -&gt; 2, 3 -&gt; 5 */</span></span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">2</span>], graph-&gt;vxs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">2</span>], graph-&gt;vxs[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"comment\">/* connect 4 -&gt; 1, 4 -&gt; 2, 4 -&gt; 5 */</span></span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">3</span>], graph-&gt;vxs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">3</span>], graph-&gt;vxs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">3</span>], graph-&gt;vxs[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"comment\">/* connect 5 -&gt; 4, 5 -&gt; 2, 5 -&gt; 3 */</span></span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">4</span>], graph-&gt;vxs[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">4</span>], graph-&gt;vxs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">4</span>], graph-&gt;vxs[<span class=\"number\">3</span>]);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">graph</span> <span class=\"title\">g</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fake_a_graph(&amp;g);</span><br><span class=\"line\">    dump_raw(&amp;g);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<h4 id=\"2-4-3-图遍历\"><a href=\"#2-4-3-图遍历\" class=\"headerlink\" title=\"2.4.3 图遍历\"></a>2.4.3 图遍历</h4><p> 图的搜索方法：深度优先搜索和广度优先搜索。<br> 深度优先遍历(DFS)<br> 思路: 从图中某点v出发:<br>   1.访问顶点v<br>   2.从v的未被访问的邻接点中选取一个顶点w,从w出发进行深度优先遍历.<br>   3.重复上述两步,直到图中所有和v有路径相通的顶点都被访问.<br> 伪代码: </p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(Vertex v)</span> </span>{</span><br><span class=\"line\">    vistied[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (v 的每个邻接点 w) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[w]) {</span><br><span class=\"line\">            DFS(w);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<details>\n<summary>dfs</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Graph.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_NODES 1000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> visited[MAX_NODES];  <span class=\"comment\">// array to store visiting order</span></span><br><span class=\"line\">                         <span class=\"comment\">// indexed by vertex 0..nV-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfsPathCheck</span><span class=\"params\">(Graph g, <span class=\"keyword\">int</span> nV, Vertex v, Vertex dest)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Vertex w;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (w = <span class=\"number\">0</span>; w &lt; nV; w++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (adjacent(g, v, w) &amp;&amp; visited[w] == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            visited[w] = v;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (w == dest)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dfsPathCheck(g, nV, w, dest))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">findPathDFS</span><span class=\"params\">(Graph g, <span class=\"keyword\">int</span> nV, Vertex src, Vertex dest)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Vertex v;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (v = <span class=\"number\">0</span>; v &lt; nV; v++) visited[v] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    visited[src] = src;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfsPathCheck(g, nV, src, dest);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> V = <span class=\"number\">6</span>;</span><br><span class=\"line\">    Graph g = newGraph(V);</span><br><span class=\"line\"></span><br><span class=\"line\">    Edge e;</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">1</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">4</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">5</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">5</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">4</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">4</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">2</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">4</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">3</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">5</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">3</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">1</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">2</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">3</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">2</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> src = <span class=\"number\">0</span>, dest = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPathDFS(g, V, src, dest)) {</span><br><span class=\"line\">        Vertex v = dest;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (v != src) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d - \"</span>, v);</span><br><span class=\"line\">            v = visited[v];</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, src);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<p> 广度优先遍历(BFS)<br> 思路:<br>   1.顶点v入队列<br>   2.当队列非空时则继续执行,否则算法结束.<br>   3.出队列取得队头顶点v’,访问顶点v 并标记顶点v已被访问.<br>   4.查找顶点v的第一个邻接顶点col<br>   5.若v的邻接顶点col未被访问过的,则col继续.<br>   6.查找顶点v的另一个新的邻接顶点col,转到步骤5入队列,直到顶点v的所有未被访问过的邻接点处理完,转到步骤2.</p>\n<details>\n<summary>bfs_queue</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Graph.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"queue.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_NODES 1000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> visited[MAX_NODES];  <span class=\"comment\">// array to store visiting order</span></span><br><span class=\"line\">                         <span class=\"comment\">// indexed by vertex 0..nV-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">findPathBFS</span><span class=\"params\">(Graph g, <span class=\"keyword\">int</span> nV, Vertex src, Vertex dest)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Vertex v;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (v = <span class=\"number\">0</span>; v &lt; nV; v++) visited[v] = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    visited[src] = src;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span> Q = newQueue();</span><br><span class=\"line\">    QueueEnqueue(Q, src);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!QueueIsEmpty(Q)) {</span><br><span class=\"line\">        v = QueueDequeue(Q);</span><br><span class=\"line\">        Vertex w;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (w = <span class=\"number\">0</span>; w &lt; nV; w++) (</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (adjacent(g, v, w) &amp;&amp; visited[w] == <span class=\"number\">-1</span>) {</span><br><span class=\"line\">                visited[w] = v;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (w == dest)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    QueueEnqueue(Q, w);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        )</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> V = <span class=\"number\">10</span>;</span><br><span class=\"line\">    Graph g = newGraph(V);</span><br><span class=\"line\"></span><br><span class=\"line\">    Edge e;</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">1</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">2</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">5</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">1</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">5</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">2</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">3</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">3</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">4</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">3</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">5</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">3</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">8</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">4</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">5</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">4</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">7</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">4</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">8</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">5</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">6</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">7</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">8</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">7</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">9</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">8</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">9</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> src = <span class=\"number\">0</span>, dest = <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPathBFS(g, V, src, dest)) {</span><br><span class=\"line\">        Vertex v = dest;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (v != src) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d - \"</span>, v);</span><br><span class=\"line\">            v = visited[v];</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, src);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<p> 深度优先搜索和广度优先搜索,时间复杂度都为O(n^2)</p>\n<p>深度优先:从初始点出发,不断向前走,如果碰到死路,就往回走一步,尝试另一条路,直到发现目标位置.<br>广度优先:从初始点出发,把所有可能的路径都走一遍,如果里面没有目标位置,则尝试把所有两步能够到的位置都走一遍,看有没有目标位置.</p>\n<h4 id=\"2-4-4-最短路径\"><a href=\"#2-4-4-最短路径\" class=\"headerlink\" title=\"2.4.4 最短路径\"></a>2.4.4 最短路径</h4><p><strong>迪杰斯特拉Dijkstra算法</strong><br> Dijkstra算法适用于权值为正的图.<br> Dijkstra算法属于单源算法,即只能求出某点到其它点最短距离,并不能得出任意两点之间的最短距离.<br> 在源点可达的情况下,Dijkstra算法的时间复杂度时 <code>O(ElogV)</code><br> 算法步骤:<br>  1.将所有边初始化为无穷大<br>  2.旋转一个开始的顶点,添加到优先队列中.<br>  3.对于该点的所有邻接顶点进行判断,如果到该点的距离小于原先的值,则该值进行更新.<br>  4.将该点所有邻接顶点添加到优先队列中.<br>  5.从优先队列中挑选除一个路径值最小的顶点,将其弹出,作为新的顶点,重复步骤3,4,5<br>  6.直到所有点都被处理过一次.</p>\n<detials>\n<summary>迪杰斯特拉</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 20</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 999</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> mat[MAX][MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> V;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dist[MAX];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> q[MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> qp = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>{ q[qp++] = v; }</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cf</span><span class=\"params\">(<span class=\"keyword\">void</span> *a, <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *x = (<span class=\"keyword\">int</span> *)a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *y = (<span class=\"keyword\">int</span> *)b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *y - *x;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dequeue</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    qsort(q, qp, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), cf);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q[--qp];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">queue_has_something</span><span class=\"params\">()</span> </span>{ <span class=\"keyword\">return</span> (qp &gt; <span class=\"number\">0</span>); }</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> visited[MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> vp = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    dist[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != s) {</span><br><span class=\"line\">            dist[i] = INF;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        enqueue(i);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue_has_something()) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> u = dequeue();</span><br><span class=\"line\">        visited[vp++] = u;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mat[u][i]) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dist[i] &gt; dist[u] + mat[u][i]) {</span><br><span class=\"line\">                    dist[i] = dist[u] + mat[u][i];</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter the number of vertices: \"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\" %d\"</span>, &amp;V);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter the adj matrix: \"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; V; ++j) {</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\" %d\"</span>, &amp;mat[i][j]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    dijkstra(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nNode\\tDist\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\t%d\\n\"</span>, i, dist[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</detials>\n\n<p><strong>弗洛伊德Floyd算法</strong><br> Floyd算法是一个经典的动态规划算法.首先目标是寻找从点<code>i</code>到<code>j</code>的最短路径.<br> <strong>Floyd算法可以求出任意两点的最短距离.时间复杂度:</strong><code>O(你^3)</code><br> 从任意节点i到任意节点j的最短路径不外乎2种可能:<br>  1.是之间从i到j<br>  2是从i到经过若干个节点k到j<br> 设Dist(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，则设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++) {</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[i][j] &gt; (A[i][k] + A[k][j])) {</span><br><span class=\"line\">                A[i][j] = A[i][k] + A[k][j];</span><br><span class=\"line\">                path[i][j] = k;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h4 id=\"2-4-5-拓扑排序\"><a href=\"#2-4-5-拓扑排序\" class=\"headerlink\" title=\"2.4.5 拓扑排序\"></a>2.4.5 拓扑排序</h4><p> 拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列.且该序列必须满足下面两个条件:</p>\n<ul>\n<li>每个顶点出现且只出现一次</li>\n<li>若存在一条顶点A到顶点B的路径,那么在序列中顶点A出现在顶点B的前面.<br> 有向无环图(DAG)才有拓扑排序，非DAG图没有拓扑排序。<br> 拓扑排序步骤：</li>\n<li>从DAG图中选择一个 没有前缀(即入度为0)的顶点并输出</li>\n<li>从图中删除该顶点和所有以它为起点的有向边</li>\n<li>重复1和2直到当前的DAG图为空或当前图中不存在无前缀的顶点为止。后一种情况说明有向图中必然存在环。</li>\n</ul>\n<h4 id=\"2-4-6-leetcode题目\"><a href=\"#2-4-6-leetcode题目\" class=\"headerlink\" title=\"2.4.6 leetcode题目\"></a>2.4.6 leetcode题目</h4><ul>\n<li>判断二分图</li>\n<li>克隆图</li>\n<li>找到小镇的法官</li>\n<li>钥匙和房间</li>\n<li>最短路径访问所有节点</li>\n</ul>\n<br>\n\n<h2 id=\"3-常见算法\"><a href=\"#3-常见算法\" class=\"headerlink\" title=\"3 常见算法\"></a>3 常见算法</h2><h3 id=\"3-1-递归思想\"><a href=\"#3-1-递归思想\" class=\"headerlink\" title=\"3.1 递归思想\"></a>3.1 递归思想</h3><h4 id=\"3-1-1-递归思想\"><a href=\"#3-1-1-递归思想\" class=\"headerlink\" title=\"3.1.1 递归思想\"></a>3.1.1 递归思想</h4><p> 递归思想是:将大问题分解为小问题来求解,然后再将小问题分解为更小的问题.逐层分解,直到问题规模被分解到可以直接计算结果.<br> 如果把一层一层分解过程画成图,它其实就是一棵树,称为递归树.</p>\n<!--more-->\n\n<p> 斐波那契数列</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N &lt; = <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> N;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(N<span class=\"number\">-1</span>) + fib(N<span class=\"number\">-2</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p> 递归的过程中,符合<strong>后进先出</strong>规则,所以用一个堆栈的数据结构.函数递归过程中会自动产生栈帧,当函数栈帧的深度越来越大,栈也也越来越大,如果递归没有终止条件,则会爆栈.递归算法第一步要思考的就是<strong>递归终止条件</strong>.<br> 递归思想的两个延申算法:分治算法和动态规划.<br> 递归的一般结构:</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (符合边界条件) {</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ..;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 某种形式的调用</span></span><br><span class=\"line\">    func();</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p> 阶乘函数:</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n * factorial(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>参考链接:<a href=\"https://www.jianshu.com/p/b2d2edb4ba5b\">https://www.jianshu.com/p/b2d2edb4ba5b</a></li>\n</ul>\n<h4 id=\"3-1-2-递归基本步骤\"><a href=\"#3-1-2-递归基本步骤\" class=\"headerlink\" title=\"3.1.2 递归基本步骤:\"></a>3.1.2 递归基本步骤:</h4><p>  1.定义一个函数,明确函数功能<br>  2.寻找问题与子问题之间的关系(递推公式)<br>  3.将递推公式在定义的函数中实现<br>  4.推导时间复杂度,判定是否可以接受,无法接受更换算法.</p>\n<h4 id=\"3-1-3-代表题目\"><a href=\"#3-1-3-代表题目\" class=\"headerlink\" title=\"3.1.3 代表题目\"></a>3.1.3 代表题目</h4><ul>\n<li>爬楼梯 70</li>\n</ul>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *mem = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * (n+<span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mem[n] = {};</span><br><span class=\"line\">    <span class=\"keyword\">return</span> climb(n, mem);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climb</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> *mem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mem[n] &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mem[n];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    mem[<span class=\"number\">0</span>] = climb(n<span class=\"number\">-1</span>, mem) + climb(n<span class=\"number\">-2</span>, mem);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mem[n];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>青蛙跳台阶 10-II</li>\n</ul>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numWays</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num[n+<span class=\"number\">1</span>] = {<span class=\"number\">-1</span>};</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jump(n, num);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jump</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> *num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num[n] != <span class=\"number\">-1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num[n];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span> || n == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    num[n] = (jump(n<span class=\"number\">-1</span>, num) + jump(n<span class=\"number\">-2</span>, num) % <span class=\"number\">1e9</span>+<span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num[n];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"3-1-4-触类旁通\"><a href=\"#3-1-4-触类旁通\" class=\"headerlink\" title=\"3.1.4 触类旁通\"></a>3.1.4 触类旁通</h4><ul>\n<li>反转二叉树 226<br> 1).对于根节点<code>1</code>来说,假设<code>2,3</code>节点下的节点都已经翻转,那么只要翻转<code>2,2</code>节点即满足需求.<br> 2).对于<code>2,3</code>节点来说,也是翻转其左右节点即可.<br> 依此类推,对每一个节点,依次翻转其左右节点,所以我们可知问题与子问题的关系是翻转(根节点) = 翻转(根节点的左节点) + 翻转(根节点的右节点),即<blockquote>\n<p>invert(root) = invert(root-&gt;left) + invert(root-&gt;right)<br> 加号是追加到root上的意思</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    TreeNode *left;</span><br><span class=\"line\">    TreeNode *right;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    TreeNode *left = (struct TreeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TreeNode));</span><br><span class=\"line\">    TreeNode *right = (struct TreeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TreeNode));</span><br><span class=\"line\">    left = invertTree(root.left);</span><br><span class=\"line\">    rgith = invertTree(root.right);</span><br><span class=\"line\">    root.left = right;</span><br><span class=\"line\">    root.right = left;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li><p>路径总和 112<br> 给定一个二叉树和一个目标和,判断该树中是否存在根节点到叶子节点的路径,这条路径上所有节点值相加等于目标和.</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">right</span>;</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> sum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">NULL</span> &amp;&amp; root.right == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.data == sum;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> remain = sum - root.data;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasPathSum(root.left, remain) || hashPashSum(root.right, remain);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n<li><p>细胞分裂</p>\n</li>\n</ul>\n<p><a href=\"https://www.jianshu.com/p/b2d2edb4ba5b\">https://www.jianshu.com/p/b2d2edb4ba5b</a></p>\n<h3 id=\"3-2-分治法\"><a href=\"#3-2-分治法\" class=\"headerlink\" title=\"3.2 分治法\"></a>3.2 分治法</h3><p> 把复杂问题分成两个或者更多相同或相似的子问题，再把子问题分成更小的子问题…，直到可以直接求解，原问题的解为子问题解的合并。<br> 分治法应用：排序算法(快速排序、归并排序);傅里叶变换()。</p>\n<h4 id=\"3-2-1-概述\"><a href=\"#3-2-1-概述\" class=\"headerlink\" title=\"3.2.1 概述\"></a>3.2.1 概述</h4><p> 分治法思想:将一个难以直接解决的大问题,分割成一些规模小的相同问题,分而治之.</p>\n<p> 分治法:把一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题…,直到最后子问题可以简单的直接求解,原问题的解即子问题的解的<strong>合并</strong>.分治法思想:排序(快速排序,归并排序),傅里叶变换(快速傅里叶变换<br> 1):数学归纳是使用分治思想.<br> 2):分治思想不一定使用递归结构.<br> 递归结构是循环结构的一种,也是分治思想应用最多的一种程序结构,但不一定使用它.分治法的核心是<strong>如何分</strong></p>\n<h4 id=\"3-2-2-策略\"><a href=\"#3-2-2-策略\" class=\"headerlink\" title=\"3.2.2 策略\"></a>3.2.2 策略</h4><p> 分治策略:对于一个规模为n的问题,若该问题可以容易解决则直接解决,否则将其分解为k个规模较小的子问题,子问题之间相互独立且与原问题形式相同,可递归求解.分治通常用递归实现.</p>\n<h4 id=\"3-2-3-应用场景\"><a href=\"#3-2-3-应用场景\" class=\"headerlink\" title=\"3.2.3 应用场景\"></a>3.2.3 应用场景</h4><p> 分治法特征:</p>\n<ul>\n<li>问题缩小到一定程度可容易解决.</li>\n<li>问题可分解为若干个规模较小的相同问题,即问题具有最优子结构性质.</li>\n<li>子问题的解可合并为该问题的解.</li>\n<li>问题分解的子问题相互独立,子问题之间不包含公告子问题.</li>\n</ul>\n<h4 id=\"3-2-4-步骤\"><a href=\"#3-2-4-步骤\" class=\"headerlink\" title=\"3.2.4 步骤\"></a>3.2.4 步骤</h4><p> 分治法一层递归步骤:</p>\n<ul>\n<li><ol>\n<li><strong>分解</strong>:将原问题分解为若干规模较小,相互独立,与原问题形式相同的子问题.</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><strong>解决</strong>:若子问题可直接求解,则直接求解,否则递归解各个子问题.</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><strong>合并</strong>:将各个子问题的解合并为原问题的解.</li>\n</ol>\n</li>\n</ul>\n<p> </p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n<br>\n\n<h4 id=\"3-2-5-应用\"><a href=\"#3-2-5-应用\" class=\"headerlink\" title=\"3.2.5 应用\"></a>3.2.5 应用</h4><blockquote>\n<p>分治思维方式：二分搜索;大整数乘法;合并排序;快速排序。</p>\n</blockquote>\n<p> 求x的n次幂<br> 对数复杂度O(logn)</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">power</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        result = power(x, n/<span class=\"number\">2</span>) * power(x, n / <span class=\"number\">2</span>);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        result = power(x, (n + <span class=\"number\">1</span>) / <span class=\"number\">2</span>) * power(x, (n - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"3-2-6-leetcode题目\"><a href=\"#3-2-6-leetcode题目\" class=\"headerlink\" title=\"3.2.6 leetcode题目\"></a>3.2.6 leetcode题目</h4><ul>\n<li>搜索二维矩阵II</li>\n<li>求众数</li>\n<li>合并k个排序链表</li>\n</ul>\n<h3 id=\"3-3-排序算法\"><a href=\"#3-3-排序算法\" class=\"headerlink\" title=\"3.3 排序算法\"></a>3.3 排序算法</h3><p> 各种排序算法，主要包括：插入排序、快速排序、归并排序、计数排序和技术排序。二分查找，</p>\n<h4 id=\"3-3-1-冒泡排序\"><a href=\"#3-3-1-冒泡排序\" class=\"headerlink\" title=\"3.3.1 冒泡排序\"></a>3.3.1 冒泡排序</h4><p> 重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。<br> <strong>冒泡排序算法复杂度是O(n^2)</strong></p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = arr.length;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> out = size - <span class=\"number\">1</span>; out &gt; <span class=\"number\">0</span>; out--) {</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> in = <span class=\"number\">0</span>; in &lt; out; in++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[in] &gt; arr[in + <span class=\"number\">1</span>]) {</span><br><span class=\"line\">                swap(arr, in, in + <span class=\"number\">1</span>);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SWAP(a,b) \\</span></span><br><span class=\"line\"><span class=\"meta\">do{\\</span></span><br><span class=\"line\"><span class=\"meta\">    (a) ^= (b);\\</span></span><br><span class=\"line\"><span class=\"meta\">    (b) ^= (a);\\</span></span><br><span class=\"line\"><span class=\"meta\">    (a) ^= (b);\\</span></span><br><span class=\"line\"><span class=\"meta\">}while(0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*冒泡排序*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> swap_flg = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = size - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) {<span class=\"comment\">/*排序的趟数*/</span> </span><br><span class=\"line\">        swap_flg = <span class=\"number\">0</span>;<span class=\"comment\">/*每次设置交换标识为0*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; i; j++) {          <span class=\"comment\">/*本趟排序的遍历元素个数*/</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] &gt; a[j + <span class=\"number\">1</span>]) {</span><br><span class=\"line\">                SWAP(a[j],a[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">                swap_flg = <span class=\"number\">1</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">/*本趟数，无数据交换的话，说明已经有序，直接退出*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (swap_flg == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<br>\n\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"comment\">//整数或浮点数皆可使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(T arr[], <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j; T temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; len - <span class=\"number\">1</span> - i; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) {</span><br><span class=\"line\">                temp = arr[j];</span><br><span class=\"line\">                arr[j] = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[j + <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"3-3-2-选择排序\"><a href=\"#3-3-2-选择排序\" class=\"headerlink\" title=\"3.3.2 选择排序\"></a>3.3.2 选择排序</h4><p> 选择排序算法时间复杂度为O(n^2)</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selectSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = arr.lenght;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> out = <span class=\"number\">0</span>; out &lt; size; out++) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mixIndex = out;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> in = out - <span class=\"number\">1</span>; in &lt; size; in++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[mixIndex] &gt; arr[in]) {</span><br><span class=\"line\">                mixIndex = in;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mixIndex != out) {</span><br><span class=\"line\">            swap(arr, mixIndex, out);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*选择排序*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">select_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size - <span class=\"number\">1</span>; i++)  {</span><br><span class=\"line\">        min = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i + <span class=\"number\">1</span>; j &lt; size; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] &lt; a[min]) {</span><br><span class=\"line\">                min = j;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (min != i) {</span><br><span class=\"line\">            SWAP(a[i],a[min]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"3-3-3-插入排序\"><a href=\"#3-3-3-插入排序\" class=\"headerlink\" title=\"3.3.3 插入排序\"></a>3.3.3 插入排序</h4><p> 插入排序每次从无序数据集合中取出一个元素，插入到已经排好序的数据集中适当位置，使数据集仍然有序。插入排序不需要额外空间。时间复杂度O(n2)</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = arr.lenght;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> out = <span class=\"number\">1</span>; out &lt; size; out++) {</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[out];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> in = out;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (in - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> &amp;&amp; arr[in - <span class=\"number\">1</span>] &gt; temp) {</span><br><span class=\"line\">            arr[in] = arr[in - <span class=\"number\">1</span>];</span><br><span class=\"line\">            in--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (in != out) {</span><br><span class=\"line\">            arr[in] = temp;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*插入排序*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i ++)<span class=\"comment\">/*需要插入的元素个数*/</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> key = a[i];<span class=\"comment\">/*保存插入的元素数据*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">/* i 之前的元素都是有序的，找到比key小的插入到他后面，</span></span><br><span class=\"line\"><span class=\"comment\">        * 比key大的，需要往后挪一个位置*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>((j &gt;= <span class=\"number\">0</span>) &amp;&amp; (a[j] &gt; key)) {</span><br><span class=\"line\">            a[j + <span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        a[j + <span class=\"number\">1</span>] = key;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">issort</span><span class=\"params\">(<span class=\"keyword\">void</span> *data, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> esize, <span class=\"keyword\">int</span> (*compare)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2))</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *a = data;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((key = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(esize)) == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">1</span>; j &lt; size; j++) {</span><br><span class=\"line\">        i = j - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span> &amp;&amp; compare(&amp;a[i * esize], key) &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">            mamcpy(&amp;a[(i + <span class=\"number\">1</span>) * esize], &amp;a[i * esize], esize);</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(&amp;a[(i + <span class=\"number\">1</span>) * esize], key, esize);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"3-3-4-希尔排序\"><a href=\"#3-3-4-希尔排序\" class=\"headerlink\" title=\"3.3.4 希尔排序\"></a>3.3.4 希尔排序</h4><p> 希尔排序时间复杂度O(n*(logn)^2)</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = arr.lenght;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (h &lt;= size / <span class=\"number\">3</span>) {</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        h = h * <span class=\"number\">3</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (h &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> out = h; out &lt; size; out++) {</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[out];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> in = out;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (in - h &gt;= <span class=\"number\">0</span> &amp;&amp; arr[in - h] &gt; temp) {</span><br><span class=\"line\">                arr[in] = arr[in - h];</span><br><span class=\"line\">                in = in - h;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (in != out) {</span><br><span class=\"line\">                arr[in] = temp;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        h = (h - <span class=\"number\">1</span>) / <span class=\"number\">3</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"3-3-5-归并排序\"><a href=\"#3-3-5-归并排序\" class=\"headerlink\" title=\"3.3.5 归并排序\"></a>3.3.5 归并排序</h4><p> 归并排序是一种分支排序算法。归并排序需要额外存储空间来完成排序。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  x &lt; y ? x : y;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *a = arr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *b = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(len * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> seg, start;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (seg = <span class=\"number\">1</span>; seg &lt; len; seg += seg) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (start )</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (idx = <span class=\"number\">0</span>; idx &lt; size; idx++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%08d\\n\"</span>, arr[idx]);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> __merge(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q, <span class=\"keyword\">int</span> r)</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *tmp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j, k;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">malloc</span>((r - p + <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tmp)</span><br><span class=\"line\">        <span class=\"built_in\">abort</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = p, j = q + <span class=\"number\">1</span>, k = <span class=\"number\">0</span>; i &lt;= q &amp;&amp; j &lt;= r;) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt;= arr[j])</span><br><span class=\"line\">            tmp[k++] = arr[i++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            tmp[k++] = arr[j++];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == q + <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &lt;= r;)</span><br><span class=\"line\">            tmp[k++] = arr[j++];</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt;= q;)</span><br><span class=\"line\">            tmp[k++] = arr[i++];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(arr + p, tmp, (r - p + <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> __merge_sort(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> r)</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> q;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p &gt;= r)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    q = (p + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    __merge_sort(arr, p, q);</span><br><span class=\"line\">    __merge_sort(arr, q + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    __merge(arr, p, q, r);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    __merge_sort(arr, <span class=\"number\">0</span>, size - <span class=\"number\">1</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_verify</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> test[<span class=\"number\">10</span>] = {<span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">23</span>, <span class=\"number\">67</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">31</span>, <span class=\"number\">56</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    __merge(test, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(test, <span class=\"number\">10</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> test[<span class=\"number\">10</span>] = {<span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">23</span>, <span class=\"number\">67</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">31</span>, <span class=\"number\">56</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    merge_sort(test, <span class=\"number\">10</span>);</span><br><span class=\"line\">    dump(test, <span class=\"number\">10</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">//merge_verify();</span></span><br><span class=\"line\">    merge_sort_test();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"3-3-6-快速排序\"><a href=\"#3-3-6-快速排序\" class=\"headerlink\" title=\"3.3.6 快速排序\"></a>3.3.6 快速排序</h4><p> 快速排序是一种分治排序算法。不需要额外存储空间，时间复杂度O(nlgn)</p>\n<p> 快速排序三个步骤：</p>\n<ul>\n<li>分：设定一个分割值并将数据分为两部分。</li>\n<li>治：分别在两部分使用递归方式继续使用快速排序方法。</li>\n<li>和：对分割部分排序直至完成。</li>\n</ul>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">Range</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">} Range;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Range <span class=\"title\">now_Range</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Range r;</span><br><span class=\"line\">    r.start = s;</span><br><span class=\"line\">    r.end = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *x, <span class=\"keyword\">int</span> *y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = *x;</span><br><span class=\"line\">    *x = *y;</span><br><span class=\"line\">    *y = t;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    Range r[len];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">    r[p++] = new_Range(<span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p) {</span><br><span class=\"line\">        Range range = r[--p];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.start &gt;= range.end) {</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = arr[(range.start + range.end) / <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = range.start;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = range.end;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> {</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (arr[left] &lt; mid) {</span><br><span class=\"line\">                ++left;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (arr[right] &gt; mid) {</span><br><span class=\"line\">                --right;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left &lt;= right) {</span><br><span class=\"line\">                swap(&amp;arr[left], &amp;arr[right]);</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        } <span class=\"keyword\">while</span> (left &lt;= right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.start &lt; right) {</span><br><span class=\"line\">            r[p++] = new_Range(range.start, right);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.end &gt; left) {</span><br><span class=\"line\">            r[p++] = new_Range(left, range.end);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QuickSort</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &lt; high) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = high;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = arr[low];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; j) {</span><br><span class=\"line\">            <span class=\"comment\">// 从右向左找第一个小于k的数</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= k) {</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            }</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; j) {</span><br><span class=\"line\">                arr[i++] = arr[j];</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"comment\">// 从左向右找第一个大于等于k的数</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; j &amp;&amp; arr[i] &lt; k) {</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            }</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; j) {</span><br><span class=\"line\">                arr[j--] = arr[i];</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        arr[i] = k;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">        QuickSort(arr, low, i - <span class=\"number\">1</span>); <span class=\"comment\">// 排序k左边</span></span><br><span class=\"line\">        QuickSort(arr, i + <span class=\"number\">1</span>, high); <span class=\"comment\">// 排序k右边</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">( <span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j, p, tmp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>)  <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = a[n / <span class=\"number\">2</span>];   <span class=\"comment\">// Get the middle element as pivot ..</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>, j = n <span class=\"number\">-1</span>;; i++, j--) {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[i] &lt; p)</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p &lt; a[j])</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i &gt;= j)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        tmp = a[i]; a[i] = a[j]; a[j] = tmp;    <span class=\"comment\">//swap both ..</span></span><br><span class=\"line\">    }   </span><br><span class=\"line\"></span><br><span class=\"line\">    quick_sort( a, i); </span><br><span class=\"line\">    quick_sort( a + i, n - i); </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (idx = <span class=\"number\">0</span>; idx &lt; size; idx++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%08d\\n\"</span>, arr[idx]);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = *a;</span><br><span class=\"line\">    *a = *b;</span><br><span class=\"line\">    *b = tmp;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">//int pivot = arr[r];</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    i = j = p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; j &lt; r; j++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[j] &lt; arr[r]) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i != j) {</span><br><span class=\"line\">                swap(arr + i, arr + j);</span><br><span class=\"line\"></span><br><span class=\"line\">            }</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    swap(arr + i, arr + r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> __quick_sort(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> r)</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> q;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p &gt;= r)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    q = partition(arr, p, r);</span><br><span class=\"line\">    __quick_sort(arr, p, q<span class=\"number\">-1</span>);</span><br><span class=\"line\">    __quick_sort(arr, q+<span class=\"number\">1</span>, r);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    __quick_sort(arr, <span class=\"number\">0</span>, size - <span class=\"number\">1</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> test[<span class=\"number\">10</span>] = {<span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">23</span>, <span class=\"number\">67</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">31</span>, <span class=\"number\">56</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    quick_sort(test, <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(test, <span class=\"number\">10</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    quick_sort_test();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Qsort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (high &lt;= low) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = high + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> key = arr[low];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">        <span class=\"comment\">/*从左向右找比key大的值*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (arr[++i] &lt; key) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == high) {</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*从右向左找比key小的值*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (arr[--j] &gt; key)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == low) {</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= j) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*交换i,j对应的值*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = temp;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">/*中枢值与j对应值交换*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = arr[low];</span><br><span class=\"line\">    arr[low] = arr[j];</span><br><span class=\"line\">    arr[j] = temp;</span><br><span class=\"line\">    <span class=\"built_in\">Qsort</span>(arr, low, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">Qsort</span>(arr, j + <span class=\"number\">1</span>, high);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>qsort/sort函数</strong><br> 在c语言库函数中已经实现了qsort函数,<br> qsort函数用法:</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qsort</span><span class=\"params\">(<span class=\"keyword\">void</span> *base, <span class=\"keyword\">int</span> nelem, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> (*fcmp)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 参数:1 带排序数组首地址, nelem 数组中待排元素数量  width 各元素所在空间大小  *fcmp 指向函数的指针</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// int 数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (*(<span class=\"keyword\">int</span> *)a - *(<span class=\"keyword\">int</span> *)b);</span><br><span class=\"line\">}</span><br><span class=\"line\">qsort(arr, n, <span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>]), cmp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// char 数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">com</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">char</span> *)a - *(<span class=\"keyword\">char</span> *)b;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">char</span> word[<span class=\"number\">100</span>];</span><br><span class=\"line\">qsort(word, <span class=\"number\">100</span>, <span class=\"keyword\">sizeof</span>(word[<span class=\"number\">0</span>]), cmp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// double 类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">double</span> *)a &gt; *(<span class=\"keyword\">double</span>*)b ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">double</span> in[<span class=\"number\">100</span>];</span><br><span class=\"line\">qsort(in, <span class=\"number\">100</span>, <span class=\"keyword\">sizeof</span>(in[<span class=\"number\">00</span>]), cmp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// struct 结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Sample</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">}st[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (*(Sample *)a).data &gt; (*(Sampel *)b).data ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\">qsort(s, <span class=\"number\">100</span>, <span class=\"keyword\">sizeof</span>(s[<span class=\"number\">0</span>]), cmp);</span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Sample</span> *<span class=\"title\">c</span> =</span> (Sample *)a;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Sample</span> *<span class=\"title\">d</span> =</span> (Sample *)b;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c-&gt;x != d-&gt;x) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c-&gt;x - d-&gt;x;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> d-&gt;y - c-&gt;y;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">qsort(s,<span class=\"number\">100</span>,<span class=\"keyword\">sizeof</span>(s[<span class=\"number\">0</span>]),cmp);</span><br><span class=\"line\"></span><br><span class=\"line\">truct Sample</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">100</span>];</span><br><span class=\"line\">}s[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按照结构体中字符串str的字典顺序排序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>((*(Sample *)a)-&gt;str , (*(Sample *)b)-&gt;str);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">qsort(s,<span class=\"number\">100</span>,<span class=\"keyword\">sizeof</span>(s[<span class=\"number\">0</span>]),cmp);</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"3-3-7-堆排序\"><a href=\"#3-3-7-堆排序\" class=\"headerlink\" title=\"3.3.7 堆排序\"></a>3.3.7 堆排序</h4><p> 桶排序算法基本原理：把数组中的所有元素分为若干个数据块，也就是若干个桶，然后对每个桶里的数据进行排序，最后将所有桶里的数据依次排列。<br> 存在两个问题：<br> (1)怎样划分数据块，也就是分几个桶，每个桶放哪几个数据。<br> (2)对每个数据块里的数据怎样排序。<br> 堆排序使利用堆这种数据结构设计的一种选择排序算法。堆是一种近似完全二叉树的结构(通常堆用一维数组实现),并满足性质；最大堆(大顶堆)为例，其父节点的值总是大于它的孩子节点。<br> 堆排序的过程：<br> 1.由输入的无序数组构造一个最大堆，作为初始的无序区<br> 2.把堆顶元素(最大值)和堆尾元素互换<br> 3.把堆(无序区)的尺寸缩小1，并调用heapify(A,0)从新的堆顶元素开始进行堆调整。<br> 4.重复步骤2，直到堆的尺寸为1<br> 因为每次插入数据效率是O(logN)，而我们需要进行n次循环，将数组中每个值插入到堆中，所以它的执行时间是O(N*logN)级。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sdtio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">} KeyNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bucket_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> keys[], <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> bucket_size)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    KeyNode **bucket_table = (KeyNode **)mallov(bucket_size * <span class=\"keyword\">sizeof</span>(KeyNode*));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; bucket_size;i++) {</span><br><span class=\"line\">        bucket_table[i] = (KeyNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(KeyNode));</span><br><span class=\"line\">        bucket_table[i]-&gt;key = <span class=\"number\">0</span>;</span><br><span class=\"line\">        bucket_table[i]-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>;j &lt; size;j++) {</span><br><span class=\"line\">        KeyNode *node = (KeyNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(KeyNode));</span><br><span class=\"line\">        node-&gt;key = keys[j];</span><br><span class=\"line\">        node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = keys[j]/<span class=\"number\">10</span>;</span><br><span class=\"line\">        KeyNode *p = bucket_table[index];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;key == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            bucket_table[index]-&gt;next = node;</span><br><span class=\"line\">            (bucket_table[index]-&gt;key)++;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p-&gt;next != <span class=\"literal\">NULL</span> &amp;&amp; p-&gt;next-&gt;key &lt;= node-&gt;key)</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">            node-&gt;next = p-&gt;next;</span><br><span class=\"line\">            p-&gt;next = node;</span><br><span class=\"line\">            (bucket_table[index]-&gt;key)++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">//print result</span></span><br><span class=\"line\">    KeyNode * k = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; bucket_size;i++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k = bucket_table[i]-&gt;next;k!=<span class=\"literal\">NULL</span>;k=k-&gt;next)</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,k-&gt;key);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> raw[] = {<span class=\"number\">49</span>,<span class=\"number\">38</span>,<span class=\"number\">65</span>,<span class=\"number\">97</span>,<span class=\"number\">76</span>,<span class=\"number\">13</span>,<span class=\"number\">27</span>,<span class=\"number\">49</span>};</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"keyword\">sizeof</span>(raw)/<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">    bucket_sort(raw,size,<span class=\"number\">10</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Heapify</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lef_child = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right_child = <span class=\"number\">2</span> * i + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lef_child &lt; size &amp;&amp; A[lef_child] &gt; A[max]) {</span><br><span class=\"line\">        max = lef_child;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right_child &lt; size &amp;&amp; A[right_child] &gt; A[max]) {</span><br><span class=\"line\">        max = right_child;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (max != i) {</span><br><span class=\"line\">        Swap(A, i max);</span><br><span class=\"line\">        Heapify(A, max, size);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BuildHeap</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heap_size = n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = heap_size / w - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) {</span><br><span class=\"line\">        Heapify(A, i, heap_size);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> heap_size;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HeapSort</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heap_size = BuildHeap(A, n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (heap_size &gt; <span class=\"number\">1</span>) {</span><br><span class=\"line\">        Swap(A, <span class=\"number\">0</span>, heap_size);</span><br><span class=\"line\">        Heap(A, <span class=\"number\">0</span>, heap_size);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"3-3-8-leetcode排序\"><a href=\"#3-3-8-leetcode排序\" class=\"headerlink\" title=\"3.3.8 leetcode排序\"></a>3.3.8 leetcode排序</h4><ul>\n<li>按奇偶排序数组</li>\n<li>对链表进行插入排序</li>\n<li>合并区间</li>\n<li>最大数</li>\n<li>最接近原点的K个点</li>\n</ul>\n<h3 id=\"3-4-贪心算法\"><a href=\"#3-4-贪心算法\" class=\"headerlink\" title=\"3.4 贪心算法\"></a>3.4 贪心算法</h3><h4 id=\"3-4-1-基本概念\"><a href=\"#3-4-1-基本概念\" class=\"headerlink\" title=\"3.4.1 基本概念\"></a>3.4.1 基本概念</h4><p> 贪心算法:在对问题求解时,总是做出在当前是最好的选择,即不考虑整体最优,仅考虑局部最优解.<br> 贪心算法没有固定算法框架,算法关键是贪心策略的选择.他想算法不是所有问题都得到最优解,选择贪心策略必须具备无后效性,即某个状态以后的过程不会影响一起的状态,只与当前状态有关.</p>\n<h4 id=\"3-4-2-描述\"><a href=\"#3-4-2-描述\" class=\"headerlink\" title=\"3.4.2 描述\"></a>3.4.2 描述</h4><p> 贪心算法实现步骤:<br> 1.建立数学模型描述问题<br> 2.把求解的问题分成若干个子问题<br> 3.对每个子问题求解,得到子问题的局部最优解<br> 4.把子问题的解局部最优解合成原来问题的一个解.<br> 实现算法过程:</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (能朝给定总目标前进一步)</span><br><span class=\"line\">{</span><br><span class=\"line\">    利用可行的决策,求出可行解的一个解元素;</span><br><span class=\"line\">}</span><br><span class=\"line\">由所有解元素组合成问题的一个可行解</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"3-4-3-应用\"><a href=\"#3-4-3-应用\" class=\"headerlink\" title=\"3.4.3 应用\"></a>3.4.3 应用</h4><p><strong>最小生成树算法</strong><br> 贪心算法经典实践:最小生成树算法<br> 设<code>G=(V, E)</code>是无向连通带权图,即一个网络,E中的每一条边<code>(v,w)</code> 的全为 <code>c[v][w]</code>.如果G的字体 G’ 是一颗包含 G 的所有顶点的数,则称 G’ 为 G 的生成树.生成树上各边权的总和称为生成树的耗费.在 G 的所有生成树中,耗费最小的生成树称为 G 的最小生成树.<br> 最小生成树的性质:<br>  设<code>G=(V, E)</code>是连通带权图, U是V的真子集.如果(u,v)属于E,且u属于E,v属于V-U,且在所有这样的边中,(u,v)的权c[u][v]最小,那么一定存在G的一颗最小生成树,它亦是(u,v)为其中一条边,这个性质有时也称为MST性质.</p>\n<p><strong>Prim算法</strong><br>  设<code>G=(V, E)</code>是连通带权图, V={1,2,…,n}.构造G的最小生成树Prim算法的基本思想是:**首先置S={1},然后,只有S是V的真子集,就进行如下的贪心选择:选取满足添加i属于S,j属于V-S,且c[i][j]最小的边,将顶点j添加到S中.这个过程一直进行到S=V时为止.在这个过程中选取到的所有边恰好构成G的一颗最小生成树.</p>\n<details>\n<summary>Prim</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @file</span></span><br><span class=\"line\"><span class=\"comment\"> * @author [Timothy Maloney](https://github.com/sl1mb0)</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief [Prim's algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)</span></span><br><span class=\"line\"><span class=\"comment\"> * implementation in C to find the MST of a weighted, connected graph.</span></span><br><span class=\"line\"><span class=\"comment\"> * @details Prim's algorithm uses a greedy approach to generate the MST of a</span></span><br><span class=\"line\"><span class=\"comment\"> *weighted connected graph. The algorithm begins at an arbitrary vertex v, and</span></span><br><span class=\"line\"><span class=\"comment\"> *selects a next vertex u, where v and u are connected by a weighted edge whose</span></span><br><span class=\"line\"><span class=\"comment\"> *weight is the minimum of all edges connected to v.</span></span><br><span class=\"line\"><span class=\"comment\"> * @references Page 319 \"Introduction to the Design and Analysis of Algorithms\"</span></span><br><span class=\"line\"><span class=\"comment\"> *- Anany Levitin</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * To test - run './prim -test'</span></span><br><span class=\"line\"><span class=\"comment\"> * prim() will find the MST of the following adj. matrix:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *\t  0  1  2  3</span></span><br><span class=\"line\"><span class=\"comment\"> *        1  0  4  6</span></span><br><span class=\"line\"><span class=\"comment\"> *        2  4  0  5</span></span><br><span class=\"line\"><span class=\"comment\"> *        3  6  5  0</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The minimum spanning tree for the above weighted connected graph is given by</span></span><br><span class=\"line\"><span class=\"comment\"> *the following adj matrix:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *\t  0  1  2  3</span></span><br><span class=\"line\"><span class=\"comment\"> *\t  1  0  0  0</span></span><br><span class=\"line\"><span class=\"comment\"> *\t  2  0  0  0</span></span><br><span class=\"line\"><span class=\"comment\"> *\t  3  0  0  0</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The following [link](https://visualgo.net/en/mst) provides a visual</span></span><br><span class=\"line\"><span class=\"comment\"> *representation of graphs that can be used to test/verify the algorithm for</span></span><br><span class=\"line\"><span class=\"comment\"> *different adj matrices and their weighted, connected graphs.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span>    <span class=\"comment\">/// for assert()</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;inttypes.h&gt;</span>  <span class=\"comment\">/// for uint16_t</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span>     <span class=\"comment\">/// for IO operations</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span>    <span class=\"comment\">/// for string comparison</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 20</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 999</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Finds index of minimum element in edge list for an arbitrary vertex</span></span><br><span class=\"line\"><span class=\"comment\"> * @param arr graph row</span></span><br><span class=\"line\"><span class=\"comment\"> * @param N number of elements in arr</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns index of minimum element in arr</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint16_t</span> <span class=\"title\">minimum</span><span class=\"params\">(<span class=\"keyword\">uint16_t</span> arr[], <span class=\"keyword\">uint16_t</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> min = INF;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> i = <span class=\"number\">0</span>; i &lt; N; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; min) {</span><br><span class=\"line\">            min = arr[i];</span><br><span class=\"line\">            index = i;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Used to find MST of user-generated adj matrix G</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">prim</span><span class=\"params\">(<span class=\"keyword\">uint16_t</span> G[][MAX], <span class=\"keyword\">uint16_t</span> MST[][MAX], <span class=\"keyword\">uint16_t</span> V)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> u, v;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> E_t[MAX], path[MAX];</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> V_t[MAX], no_of_edges;</span><br><span class=\"line\"></span><br><span class=\"line\">    E_t[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;  <span class=\"comment\">// edges for current vertex</span></span><br><span class=\"line\">    V_t[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;  <span class=\"comment\">// list of visited vertices</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> i = <span class=\"number\">1</span>; i &lt; V; i++) {</span><br><span class=\"line\">        E_t[i] = G[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        path[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        V_t[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    no_of_edges = V - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (no_of_edges &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">        u = minimum(E_t, V);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (V_t[u] == <span class=\"number\">1</span>) {</span><br><span class=\"line\">            E_t[u] = INF;</span><br><span class=\"line\">            u = minimum(E_t, V);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        v = path[u];</span><br><span class=\"line\">        MST[v][u] = E_t[u];</span><br><span class=\"line\">        MST[u][v] = E_t[u];</span><br><span class=\"line\">        no_of_edges--;</span><br><span class=\"line\">        V_t[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> i = <span class=\"number\">1</span>; i &lt; V; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (V_t[i] == <span class=\"number\">0</span> &amp;&amp; G[u][i] &lt; E_t[i]) {</span><br><span class=\"line\">                E_t[i] = G[u][i];</span><br><span class=\"line\">                path[i] = v;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Self-test implementations</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">uint16_t</span> G[][MAX], <span class=\"keyword\">uint16_t</span> MST[][MAX], <span class=\"keyword\">uint16_t</span> V)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> test[<span class=\"number\">4</span>][<span class=\"number\">4</span>] = {</span><br><span class=\"line\">        {<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>}, {<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>}, {<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>}, {<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">0</span>}};</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> solution[<span class=\"number\">4</span>][<span class=\"number\">4</span>] = {</span><br><span class=\"line\">        {<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>}, {<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>}, {<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>}, {<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>}};</span><br><span class=\"line\"></span><br><span class=\"line\">    V = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> i = <span class=\"number\">0</span>; i &lt; V; ++i) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> j = <span class=\"number\">0</span>; j &lt; V; ++j) {</span><br><span class=\"line\">            G[i][j] = test[i][j];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    prim(&amp;(*G), &amp;(*MST), V);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> i = <span class=\"number\">0</span>; i &lt; V; ++i) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> j = <span class=\"number\">0</span>; j &lt; V; ++j) {</span><br><span class=\"line\">            assert(MST[i][j] == solution[i][j]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Function user_graph();</span></span><br><span class=\"line\"><span class=\"comment\"> * gets user input adj. matrix and finds MST of that graph</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">user_graph</span><span class=\"params\">(<span class=\"keyword\">uint16_t</span> G[][MAX], <span class=\"keyword\">uint16_t</span> MST[][MAX], <span class=\"keyword\">uint16_t</span> V)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter the number of vertices: \"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\" %hd\"</span>, &amp;V);</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(V &lt;= MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter the adj matrix\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; V; ++j) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"G[%d][%d]: \"</span>, i, j);</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\" %hd\"</span>, &amp;G[i][j]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (G[i][j] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                G[i][j] = INF;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    prim(&amp;(*G), &amp;(*MST), V);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"minimum spanning tree:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; V; ++j) {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\t\"</span>, MST[i][j]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Main function</span></span><br><span class=\"line\"><span class=\"comment\"> * @param argc commandline argument count (ignored)</span></span><br><span class=\"line\"><span class=\"comment\"> * @param argv commandline array of arguments (ignored)</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns 0 on exit</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> G[MAX][MAX];    <span class=\"comment\">///&lt; weighted, connected graph G</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> MST[MAX][MAX];  <span class=\"comment\">///&lt; adj matrix to hold minimum spanning tree of G</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> V;              <span class=\"comment\">///&lt; number of vertices in V in G</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc == <span class=\"number\">2</span> &amp;&amp; <span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">\"-test\"</span>) == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        test(&amp;(*G), &amp;(*MST), V);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        user_graph(&amp;(*G), &amp;(*MST), V);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<h4 id=\"3-4-4-leetcode题目\"><a href=\"#3-4-4-leetcode题目\" class=\"headerlink\" title=\"3.4.4 leetcode题目\"></a>3.4.4 leetcode题目</h4><ul>\n<li>柠檬水找零</li>\n<li>分发饼干</li>\n</ul>\n<h3 id=\"3-5-动态规划\"><a href=\"#3-5-动态规划\" class=\"headerlink\" title=\"3.5 动态规划\"></a>3.5 动态规划</h3><p> 动态规划(<code>DP</code>):是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.常用于重叠子问题和最优子结构性质的问题,动态规划时间通常远小于朴素解法.</p>\n<h4 id=\"3-5-1-基本概念\"><a href=\"#3-5-1-基本概念\" class=\"headerlink\" title=\"3.5.1 基本概念\"></a>3.5.1 基本概念</h4><p> 动态规划:要解一个给定问题,需要解其不同部分(即子问题),再根据子问题的解以得出原问题的解.通常子问题非常相似,子问题解算出后,将其记录.<br> 动态规划过程是:每次决策依赖于当前状态,又随即引起状态转移.一个决策序列就是在变化的状态中产生除留的,这种多阶段最优化决策解决过程称为动态规划.<br> 动态规划与分治法的区别是子问题通常不是独立的.</p>\n<h4 id=\"3-5-2-描述算法\"><a href=\"#3-5-2-描述算法\" class=\"headerlink\" title=\"3.5.2 描述算法\"></a>3.5.2 描述算法</h4><p> 可采用动态规划的问题3个性质:<br> 1) <strong>最优化原理</strong>:如果问题的最优解所包含的子问题的解也是最优的,则称该问题具有最优子结构,即满足最优化原理.<br> 2) <strong>无后效性</strong>:即某阶段状态确定后,就不受之后的决策影响,即某状态以后过程不影响以前的状态,只与当前状态有关.<br> 3) <strong>有重叠子问题</strong>:</p>\n<br>\n 动态规划所处理的问题是一个多阶段决策问题,由初始状态开始,通过中间阶段决策的选择,达到结束状态.形成一个决策序列.\n\n<p> 动态规划求解三要素:</p>\n<blockquote>\n<p>(1) 问题的节点<br>(2) 每个阶段的状态<br>(3) 从前一个阶段转化到后一个阶段之间的递推关系</p>\n</blockquote>\n<p> <strong>最优决策表</strong></p>\n<blockquote>\n<p>f(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}</p>\n</blockquote>\n<h4 id=\"3-5-3-背包问题\"><a href=\"#3-5-3-背包问题\" class=\"headerlink\" title=\"3.5.3 背包问题\"></a>3.5.3 背包问题</h4><p> 问题描述:<br> 有N件物品和一个体积为V的背包.(每种物品只有一件)第i件物品的体积是volume[i],价值是value[i],求解哪些物品装入背包可使这些物品的体积综合不超过背包体积,且价值总和最大.<br> 解题思路:<br> p[i][j]代表前i件物品组合在容量为j的背包的最优解.将前i件物品放入容量为v的背包中这个子问题,若只考虑第i件物品的策略(放或不放),那么可以转化为一个只牵扯前i-1物品的问题.如果不放第i件物品,那么问题就转化为”前i-1件物品放入容量为v的背包中,价值为p[i-1][v];如果放第i件物品,那么问题就转化为”前i-1物品放入剩下的容量为v-volume[i]的背包中”,此时能获得的最大价值就是p[i-1][j-volume]再加上通过放入第i件物品获得的价值value[i].</p>\n<p> <strong>状态转移方程:</strong></p>\n<blockquote>\n<p>p[i][j] = max{p[i-1][j-vol] + value[i], p[i-1][j]}<br> 伪代码描述:</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1.</span>..N</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j = V..<span class=\"number\">.0</span></span><br><span class=\"line\">        p[j] = max{p[j-volume[i]] + value[i], p[j]};</span><br></pre></td></tr></tbody></table></figure>\n\n\n<details>\n<summary>dp</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> v[]={<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>};</span><br><span class=\"line\"><span class=\"keyword\">int</span> w[]={<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>};</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">100</span>][<span class=\"number\">100</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>{</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a&gt;=b){</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t}<span class=\"keyword\">else</span>{</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">}</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getAns</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> wi)</span> </span>{</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x=<span class=\"number\">0</span>;x&lt;=i;x++) {</span><br><span class=\"line\">\t\tdp[x][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt;= wi; x++) {</span><br><span class=\"line\">\t\tdp[<span class=\"number\">0</span>][x]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">1</span>; x &lt;= i; x++) {</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y=<span class=\"number\">1</span>;y&lt;=wi;y++) {</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(y&gt;=w[x<span class=\"number\">-1</span>]) {</span><br><span class=\"line\">\t\t\t\tdp[x][y]=Max(dp[x<span class=\"number\">-1</span>][y],v[x<span class=\"number\">-1</span>]+dp[x<span class=\"number\">-1</span>][y-w[x<span class=\"number\">-1</span>]]);</span><br><span class=\"line\">\t\t\t} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">\t\t\t\tdp[x][y]=dp[x<span class=\"number\">-1</span>][y];</span><br><span class=\"line\">\t\t\t}</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%4d\"</span>,dp[x][y]);</span><br><span class=\"line\">\t\t}</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\t}</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[i][wi];</span><br><span class=\"line\">}</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> max=getAns(<span class=\"number\">5</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,max);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">} </span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<h4 id=\"3-5-4-最长公共子序列\"><a href=\"#3-5-4-最长公共子序列\" class=\"headerlink\" title=\"3.5.4 最长公共子序列\"></a>3.5.4 最长公共子序列</h4><p> 问题描述:<br> 一个散列S,如果分别是两个或多个已知数列的子序列,且是所有匹配此条件序列中最长的,则S称为已知序列的最长公共子序列(LCS)<br> 给定两个序列X,Y,求两个序列的最长公共子序列.<br> 解题思路:<br> 最长公共子序列问题存在最优子结构；这个问题可分解成更小，更简单的“子问题”，这个子问题可以分成更多的子问题，因此整个问题就变得简单了。<br> 最长公共子序列问题的子问题的解是可以重复使用的，即，更高级别的子问题通常会重用低级子问题的解。拥有这个两个属性的问题可以使用动态规划算法来解决，这样子问题的解就可以存储起来，而不用重复计算。这个过程需要在一个表中存储同一级别的子问题的解，因此这个解可被更高级的子问题使用。设有二维数组f[i][j]表示X的i位和Y的j位之前的最长公共子序列的长度，则有：</p>\n<blockquote>\n<p>f[1][1] = same(1,1)<br>f[i][j] = max{f[i-1][j-1] + same(i, j), f[i-1][j], f[i][j-1]}<br> 其中，<code>same(a,b)</code>当X的第a位与Y的第b位完全相同是”1”，否则位”1”。<br> 此时，f[i][j]中最大的数便是X和Y的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。<br> 该算法的空间、时间复杂度位O(n^2)，经过优化后，空间复杂度位O(n)。</p>\n</blockquote>\n<p> 伪代码:</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">LCSLength</span><span class=\"params\">(X[<span class=\"number\">1.</span>.m], Y[<span class=\"number\">1.</span>.n])</span></span></span><br><span class=\"line\"><span class=\"function\">    C </span>= <span class=\"built_in\">array</span>(<span class=\"number\">0.</span>.m, <span class=\"number\">0.</span>.n)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0.</span>.m</span><br><span class=\"line\">        C[i, <span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"number\">0.</span>.n</span><br><span class=\"line\">        C[<span class=\"number\">0</span>, j] = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1.</span>.m</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">1.</span>.n</span><br><span class=\"line\">            <span class=\"keyword\">if</span> X[i] = Y[j]</span><br><span class=\"line\">                C[i, j] := C[i<span class=\"number\">-1</span>, j<span class=\"number\">-1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                C[i, j] := max(C[i, j<span class=\"number\">-1</span>], C[i<span class=\"number\">-1</span>,j])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> C[m, n]</span><br></pre></td></tr></tbody></table></figure>\n\n<details>\n<summary>最长公共序列数</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">100</span>][<span class=\"number\">100</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c)</span></span>{</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> max=a;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(b&gt;max){</span><br><span class=\"line\">\t\tmax=b;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(c&gt;max){</span><br><span class=\"line\">\t\tmax=c;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> max;</span><br><span class=\"line\">}</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMax</span><span class=\"params\">(<span class=\"keyword\">char</span> s1[],<span class=\"keyword\">char</span> s2[],<span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> n)</span></span>{</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;m;i++){       <span class=\"comment\">//当 s2取 1个的时候 ,s1为可变长度 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s1[i]==s2[<span class=\"number\">0</span>]){</span><br><span class=\"line\">\t\t\tdp[i][<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(j=i+<span class=\"number\">1</span>;j&lt;m;j++){</span><br><span class=\"line\">\t\t\t\tdp[j][<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t}</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t} </span><br><span class=\"line\">\t}</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++){      <span class=\"comment\">//当 s1取 1个的时候 ,s2为可变长度 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s2[i]==s1[<span class=\"number\">0</span>]){</span><br><span class=\"line\">\t\t\tdp[<span class=\"number\">0</span>][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(j=i+<span class=\"number\">1</span>;j&lt;n;j++){</span><br><span class=\"line\">\t\t\t\tdp[<span class=\"number\">0</span>][j]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t}</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t} </span><br><span class=\"line\">\t} </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;m;i++){</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;n;j++){</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(s1[i]==s2[j]){</span><br><span class=\"line\">\t\t\t\tdp[i][j]=Max(dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>,dp[i<span class=\"number\">-1</span>][j],dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t\t}<span class=\"keyword\">else</span>{</span><br><span class=\"line\">\t\t\t\tdp[i][j]=dp[i<span class=\"number\">-1</span>][j]&gt;=dp[i][j<span class=\"number\">-1</span>]?dp[i<span class=\"number\">-1</span>][j]:dp[i][j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\t}</span><br><span class=\"line\">\t\t}</span><br><span class=\"line\">\t} </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>];</span><br><span class=\"line\">}</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m,n;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> s1[<span class=\"number\">100</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> s2[<span class=\"number\">100</span>];</span><br><span class=\"line\">\tgets(s1);</span><br><span class=\"line\">\tgets(s2);</span><br><span class=\"line\">\tm=<span class=\"built_in\">strlen</span>(s1);</span><br><span class=\"line\">\tn=<span class=\"built_in\">strlen</span>(s2);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,getMax(s1,s2,m,n));</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n<details>\n<summary>Fibonacci_dp</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fibonacci Series using Dynamic Programming</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Author: Moinak Banerjee(moinak878)</span></span><br><span class=\"line\"><span class=\"comment\">   Date : 1 October ,2019</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">// Out of Range checking</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nNo Such term !\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// declaring array to store fibonacci numbers -- memoization</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *f = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>((n + <span class=\"number\">2</span>) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));  <span class=\"comment\">//  one extra to handle edge case, n = 0</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* let 0th and 1st number of the series be 0 and 1*/</span></span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    f[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= n; i++) {</span><br><span class=\"line\">        <span class=\"comment\">// Adding the previous 2 terms to make the 3rd term</span></span><br><span class=\"line\">        f[i] = f[i - <span class=\"number\">1</span>] + f[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> out = f[n];</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(f);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> number;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Asks for the number/position of term in Fibonnacci sequence</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc == <span class=\"number\">2</span>) {</span><br><span class=\"line\">        number = atoi(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter the value of n(n starts from 0 ): \"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;number);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The nth term is : %d \\n\"</span>, fib(number));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<h4 id=\"3-5-5-leetcode题目\"><a href=\"#3-5-5-leetcode题目\" class=\"headerlink\" title=\"3.5.5 leetcode题目\"></a>3.5.5 leetcode题目</h4><ul>\n<li>最大子序和</li>\n<li>编辑距离</li>\n<li>大礼包</li>\n<li>最长上升子序列</li>\n</ul>\n<h3 id=\"3-6-回溯法\"><a href=\"#3-6-回溯法\" class=\"headerlink\" title=\"3.6 回溯法\"></a>3.6 回溯法</h3><h4 id=\"3-6-1-基本概念\"><a href=\"#3-6-1-基本概念\" class=\"headerlink\" title=\"3.6.1 基本概念\"></a>3.6.1 基本概念</h4><p> 回溯算法实际上一个类似枚举的搜索尝试过程,主要是在<strong>搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就”回溯”返回,尝试别的路径</strong>.<br> 回溯法是一种迭代搜索法,按选优条件详情搜索,以达到目标.但当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择,这种走不通就退回再走的技术为回溯法,而满足回溯条件的某个状态的点称为”回溯法”.<br> 许多复杂度,规模较大的问题都看看而已使用回溯法,有”通用解题方法”的美称.</p>\n<p> 在包含问题的所有解的解空间树中,按照深度优先的策略,从根节点出发深度探索解空间树.当探索到某一节点时,要先判断该节点是否包含问题的解,如果包含,就从该节点出发继续探索下去,如果该节点不包含问题的解,则逐层向其足协节点回溯.(其实回溯法就是堆隐式图的深度优先搜索算法).<br> 若用回溯法求问题的所有解时,要回溯的根,且根节点的所有可行的子树都要已被搜索遍才结束,而若使用回溯法求任一个解时,只要搜索到问题的一个解就可以结束.<br> 回溯法一般解题步骤:<br> 1.<strong>针对所给问题,确定问题的解空间</strong>;首先应明确定义问题的解空间,解空间应至少包含问题的一个(最优)解.<br> 2.<strong>确定节点的扩展搜索规则</strong><br> 3.<strong>以深度优先方式搜索解空间,并在搜索过程中用剪枝函数避免无效搜索</strong></p>\n<p> 伪代码:</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">iterativeBacktrack</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f(n, t) &lt;= g(n, t)) {</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = f(n,t); i &lt;= g(n,t); i++) {</span><br><span class=\"line\">                x[t] = h(i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (constraint(t) &amp;&amp; bound(t)) {</span><br><span class=\"line\">                    <span class=\"comment\">//</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (solution(t)) {</span><br><span class=\"line\">                        output(x);</span><br><span class=\"line\">                    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                        t++;</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                    t--;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"3-6-2-八皇后问题\"><a href=\"#3-6-2-八皇后问题\" class=\"headerlink\" title=\"3.6.2 八皇后问题\"></a>3.6.2 八皇后问题</h4><p> 问题描述<br> 八皇后问题使一个以国际象棋为背景的问题:如何能够在 8x8 的国际象棋棋盘上放着八个皇后,使得任何一个皇后都无法直接吃掉其他的皇后?为了达到此目的,任两个皇后都不能处于同一条横行,纵行或斜线上.<br> 转化规则:其实八皇后问题可以推广为更一般的n皇后摆放问题;这时棋盘大小变为nxn,而皇后个数也变成n.当且仅当n = 1 或 n &gt;= 4 时间问题有解。令一个一维数组a[n]保存所得解，其中a[i]表示把第i个皇后放在第i行的列数(注意i的值都是从0开始计算的),下面就八皇后问题的约束条件。<br>（1）因为所有的皇后都不能放在同一列，因为任意两个a[0]…a[7]的值不能存在相同的两个值<br>（2）所有的皇后都不能在堆角线上，那么该如何检测两个皇后是否在同一个对角线上？我们将棋盘的方格成一个二维数组，如下：<br> 假设有两个皇后被放置在(i,j)和(k,l)的位置上，明显，当且仅当|i-k|=|j-l|时，两个皇后才在同一条对角线上。</p>\n<p> 伪代码描述</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">queens</span><span class=\"params\">(<span class=\"keyword\">int</span> Queens)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, k, flag, not_finish = <span class=\"number\">1</span>, count = <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 正在处理的元素下标，表示前i-1个元素已符合要求，在处理第i个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[Queeens+<span class=\"number\">1</span>]; <span class=\"comment\">// 八皇后问题的皇后所在的行列位置，从1开始算起，所以加1</span></span><br><span class=\"line\">    i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a[<span class=\"number\">1</span>] = <span class=\"number\">1</span>; <span class=\"comment\">// 为数组的第一个元素赋初值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (not_finish) { <span class=\"comment\">// not_finish=1 处理尚未结束</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(not_finish &amp;&amp; i &lt;= Queens) { <span class=\"comment\">// 处理尚未结束且还没处理到第Queeens个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (flag=<span class=\"number\">1</span>, k=<span class=\"number\">1</span>; flag &amp;&amp; k &lt; i; k++) {</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否有多个皇后在同一行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[k] == a[i]) {</span><br><span class=\"line\">                flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否有多个皇后在同一个对角线</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (k=<span class=\"number\">1</span>; flag &amp;&amp; k &lt; i; k++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((a[i] == a[k] - (k-i)) || (a]i] == a[k] + [k-i])) {</span><br><span class=\"line\">                flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"3-6-3-leetcode题目\"><a href=\"#3-6-3-leetcode题目\" class=\"headerlink\" title=\"3.6.3 leetcode题目\"></a>3.6.3 leetcode题目</h4><ul>\n<li>N皇后</li>\n<li>括号生成</li>\n<li>单词搜索</li>\n<li>解数独</li>\n</ul>\n<h2 id=\"4-参考链接\"><a href=\"#4-参考链接\" class=\"headerlink\" title=\"4 参考链接\"></a>4 参考链接</h2><ul>\n<li>复杂度速查表<br><a href=\"https://liam.page/2016/06/20/big-O-cheat-sheet/\">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></li>\n<li>线性表<br><a href=\"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8\">https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8</a><ul>\n<li>单链表<br><a href=\"https://www.jianshu.com/p/73f0d8f807aa\">https://www.jianshu.com/p/73f0d8f807aa</a></li>\n</ul>\n</li>\n</ul>\n<p><a href=\"http://cocofe.cn/\">http://cocofe.cn/</a></p>\n<ul>\n<li>数据结构<br><a href=\"https://github.com/wangzheng0822/algo/\">https://github.com/wangzheng0822/algo/</a></li>\n</ul>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"XMWJ68","length":124923,"excerpt":"<h2 id=\"1-程序性能\"><a href=\"#1-程序性能\" class=\"headerlink\" title=\"1 程序性能\"></a>1 程序性能</h2>","more":"<p>&ensp;程序性能是指运行程序所需要的<strong>内存大小(空间复杂度)和时间(时间复杂度)</strong>,运行时间和占用空间是算法性能最关键的指标。<br>&ensp;软件程序性能衡量指标:<br>&emsp;响应时间、启动时间、执行时间、执行速度、计算资源分配、内存分配、磁盘吞吐量、网络吞吐量、负载承受能力</p>\n<h3 id=\"1-1-空间复杂度\"><a href=\"#1-1-空间复杂度\" class=\"headerlink\" title=\"1.1 空间复杂度\"></a>1.1 空间复杂度</h3><p>&ensp;空间复杂度(Space complexity)，算法完全运行所需存储空间。表示算法的存储空间与数据规模之间的增长关系：常量空间、线性空间、二维空间。<br>&ensp;算法在计算机存储器上所占用的存储空间，包括<strong>存储程序本身占用的存储空间，算法输入输出数据所占的存储空间和算法在运行过程中临时占用的存储空间</strong>。</p>\n<h3 id=\"1-2-时间复杂度\"><a href=\"#1-2-时间复杂度\" class=\"headerlink\" title=\"1.2 时间复杂度\"></a>1.2 时间复杂度</h3><p>&ensp;时间复杂度(Time complexity)，算法完全运行所需运算时间。时间复杂度通常用大O符合表示。</p>\n<p><img src=\"https://i.loli.net/2021/10/27/UxWCvnRQLYz5eiG.png\" alt=\"20211027233029\"></p>\n<h4 id=\"1-2-1-常见算法大O\"><a href=\"#1-2-1-常见算法大O\" class=\"headerlink\" title=\"1.2.1 常见算法大O\"></a>1.2.1 常见算法大O</h4><p>&emsp; 常量阶O(1); 对数阶O(logn); 线性阶O(n); 线性对数阶O(nlogn); k次方阶O(n^k)<br><img src=\"https://i.loli.net/2021/10/28/GWOFcUi3qdVIlmf.png\" alt=\"20211028010721\"></p>\n<h4 id=\"1-2-2-常见数据结构\"><a href=\"#1-2-2-常见数据结构\" class=\"headerlink\" title=\"1.2.2 常见数据结构\"></a>1.2.2 常见数据结构</h4><blockquote class=\"pullquote mindmap mindmap-md\"><ul>\n<li>数据结构与算法<ul>\n<li>线性表<ul>\n<li>数组</li>\n<li>链表<ul>\n<li>单链表</li>\n<li>双链表</li>\n<li>循环链表</li>\n<li>双向循环链表</li>\n<li>静态链表</li>\n</ul>\n</li>\n<li>栈<ul>\n<li>顺序栈</li>\n<li>链式栈</li>\n</ul>\n</li>\n<li>队列<ul>\n<li>普通队列</li>\n<li>双端队列</li>\n<li>阻塞队列</li>\n<li>并发队列</li>\n<li>阻塞并发队列</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>散列表<ul>\n<li>散列函数</li>\n<li>冲突解决<ul>\n<li>链表法</li>\n<li>开放地址</li>\n<li>其他</li>\n</ul>\n</li>\n<li>动态扩容</li>\n<li>位置</li>\n</ul>\n</li>\n<li>树<ul>\n<li>二叉树<ul>\n<li>二叉查找树</li>\n<li>平衡二叉树</li>\n<li>平衡二叉查找树<ul>\n<li>AVL树</li>\n<li>红黑树</li>\n</ul>\n</li>\n<li>完全二叉树</li>\n<li>满二叉树</li>\n</ul>\n</li>\n<li>多路查找树<ul>\n<li>B树</li>\n<li>B+树</li>\n<li>2-3树</li>\n<li>2-3-4树</li>\n</ul>\n</li>\n<li>堆<ul>\n<li>小顶堆</li>\n<li>大顶堆</li>\n<li>优先级队列</li>\n<li>斐波那契堆</li>\n<li>二项堆</li>\n</ul>\n</li>\n<li>其他<ul>\n<li>树状数组</li>\n<li>线段树</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>图<ul>\n<li>图的存储<ul>\n<li>邻接矩阵</li>\n<li>邻接表</li>\n</ul>\n</li>\n<li>拓扑排序</li>\n<li>最短路径</li>\n<li>关键路径</li>\n<li>最小生成树</li>\n<li>二分图</li>\n<li>最大流</li>\n</ul>\n</li>\n<li>复杂度分析<ul>\n<li>空间复杂度</li>\n<li>时间复杂度</li>\n</ul>\n</li>\n<li>基本算法思想<ul>\n<li>分治法</li>\n<li>递归算法</li>\n<li>贪心算法</li>\n<li>动态规划</li>\n<li>回溯法</li>\n<li>枚举法</li>\n</ul>\n</li>\n<li>排序<ul>\n<li>O(n^2)<ul>\n<li>冒泡排序</li>\n<li>插入排序</li>\n<li>选择排序</li>\n<li>希尔排序</li>\n</ul>\n</li>\n<li>O(nlogn)<ul>\n<li>归并排序</li>\n<li>快速排序</li>\n<li>堆排序</li>\n</ul>\n</li>\n<li>O(n)<ul>\n<li>计数排序</li>\n<li>基数排序</li>\n<li>桶排序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>搜索<ul>\n<li>深度优先搜索</li>\n<li>广度优先搜索</li>\n<li>A*启发式搜索</li>\n</ul>\n</li>\n<li>查找<ul>\n<li>线性表查找</li>\n<li>树结构查找</li>\n<li>散列表查找</li>\n</ul>\n</li>\n<li>字符串匹配<ul>\n<li>朴素</li>\n<li>KMP</li>\n<li>Robin-Karp</li>\n<li>Boyer-Moore</li>\n<li>AC自动机</li>\n<li>Trie</li>\n<li>后缀数组</li>\n</ul>\n</li>\n<li>其他<ul>\n<li>数论</li>\n<li>计算几何</li>\n<li>概率分析</li>\n<li>并查集</li>\n<li>拓扑网络</li>\n<li>矩阵运算</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n\n<h3 id=\"本章参考：\"><a href=\"#本章参考：\" class=\"headerlink\" title=\"本章参考：\"></a>本章参考：</h3><ul>\n<li>复杂度速查表<br><a href=\"https://liam.page/2016/06/20/big-O-cheat-sheet/\">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></li>\n</ul>\n<h2 id=\"2-基本数据结构\"><a href=\"#2-基本数据结构\" class=\"headerlink\" title=\"2 基本数据结构\"></a>2 基本数据结构</h2><h3 id=\"2-1-线性表\"><a href=\"#2-1-线性表\" class=\"headerlink\" title=\"2.1 线性表\"></a>2.1 线性表</h3><p>&ensp;线性表是n个具有相同特性的数据元素的有序序列。线性表除第一个和最后一个数据元素之外，其他数据元素都是首尾相接的。<br>&ensp;数据在实际的物理存储中有两种形式：分散存储和集中存储,常见数据结构有栈、队列、字符串、链表等。<br>&ensp;两种情况下数据的存储问题：<br>&emsp; 数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；<br>&emsp; 数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”</p>\n<h4 id=\"2-1-1-数组\"><a href=\"#2-1-1-数组\" class=\"headerlink\" title=\"2.1.1 数组\"></a>2.1.1 数组</h4><p>&emsp;数组是一批相同数据的集合。数组的三部分：<code>地址 大小 和 空间</code>。数组的保存形式为线性表。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>]; <span class=\"comment\">// /[]内必须是常量/常量表达式(3+8)，不能是一个变量(x...)</span></span><br><span class=\"line\"><span class=\"comment\">// 数组初始化</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> arr1[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">char</span> arr6[] = <span class=\"string\">&quot;abcdef&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *ptr = <span class=\"literal\">NULL</span>;<span class=\"comment\">//定义一个整型的指针变量，初始化为NULL</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *ptr = <span class=\"literal\">NULL</span>;<span class=\"comment\">//定义一个字符的指针变量，初始化为NULL</span></span><br><span class=\"line\"><span class=\"comment\">// 二维数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">3</span>][<span class=\"number\">5</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// C 传递数组给函数</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> *param)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> param[<span class=\"number\">10</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> param[])</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// C 从函数返回数组</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">myFunction</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>array</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">array</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> used;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *arr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(struct <span class=\"built_in\">array</span> *<span class=\"built_in\">array</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>; idx &lt; <span class=\"built_in\">array</span>-&gt;used; idx++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%02d]: %08d\\n&quot;</span>, idx, <span class=\"built_in\">array</span>-&gt;arr[idx]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alloc</span><span class=\"params\">(struct <span class=\"built_in\">array</span> *<span class=\"built_in\">array</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">array</span>-&gt;arr = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">array</span>-&gt;size * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insert</span><span class=\"params\">(struct <span class=\"built_in\">array</span> *<span class=\"built_in\">array</span>, <span class=\"keyword\">int</span> elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>-&gt;used &gt;= <span class=\"built_in\">array</span>-&gt;size)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (idx = <span class=\"number\">0</span>; idx &lt; <span class=\"built_in\">array</span>-&gt;used; idx++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>-&gt;arr[idx] &gt; elem)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"built_in\">array</span>-&gt;used)</span><br><span class=\"line\">        memmove(&amp;<span class=\"built_in\">array</span>-&gt;arr[idx+<span class=\"number\">1</span>], &amp;<span class=\"built_in\">array</span>-&gt;arr[idx],</span><br><span class=\"line\">            (<span class=\"built_in\">array</span>-&gt;used - idx) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">array</span>-&gt;arr[idx] = elem;</span><br><span class=\"line\">    <span class=\"built_in\">array</span>-&gt;used++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> idx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">delete</span><span class=\"params\">(struct <span class=\"built_in\">array</span> *<span class=\"built_in\">array</span>, <span class=\"keyword\">int</span> idx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span> || idx &gt;= <span class=\"built_in\">array</span>-&gt;used)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    memmove(&amp;<span class=\"built_in\">array</span>-&gt;arr[idx], &amp;<span class=\"built_in\">array</span>-&gt;arr[idx+<span class=\"number\">1</span>],</span><br><span class=\"line\">        (<span class=\"built_in\">array</span>-&gt;used - idx - <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"built_in\">array</span>-&gt;used--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(struct <span class=\"built_in\">array</span> *<span class=\"built_in\">array</span>, <span class=\"keyword\">int</span> elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>; idx &lt; <span class=\"built_in\">array</span>-&gt;used; idx++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>-&gt;arr[idx] == elem)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> idx;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>-&gt;arr[idx] &gt; elem)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">array</span> <span class=\"title\">ten_int</span> =</span> &#123;<span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    alloc(&amp;ten_int);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ten_int.arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    insert(&amp;ten_int, <span class=\"number\">1</span>);</span><br><span class=\"line\">    insert(&amp;ten_int, <span class=\"number\">3</span>);</span><br><span class=\"line\">    insert(&amp;ten_int, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=== insert 1, 3, 2\\n&quot;</span>);</span><br><span class=\"line\">    dump(&amp;ten_int);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = search(&amp;ten_int, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;2 is at position %d\\n&quot;</span>, idx);</span><br><span class=\"line\">    idx = search(&amp;ten_int, <span class=\"number\">9</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;9 is at position %d\\n&quot;</span>, idx);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=== delete [6] element \\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>(&amp;ten_int, <span class=\"number\">6</span>);</span><br><span class=\"line\">    dump(&amp;ten_int);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=== delete [0] element \\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>(&amp;ten_int, <span class=\"number\">0</span>);</span><br><span class=\"line\">    dump(&amp;ten_int);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<br>\n\n<p><strong>二分搜索</strong><br>&emsp;基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）<br>&emsp;二分搜索的时间复杂度为 <em><strong>对数时间O(logn)</strong></em></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binary_search</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid, count = <span class=\"number\">0</span>, count1 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(low &lt; high) &#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        mid = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; a[mid]) &#123;</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; a[mid]) &#123;</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key == a[mid]) &#123;</span><br><span class=\"line\">            count1++;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count1 == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-2-单链表\"><a href=\"#2-1-2-单链表\" class=\"headerlink\" title=\"2.1.2 单链表\"></a>2.1.2 单链表</h4><p>&emsp; 单链表元素之间有一个单独的指针链接。这种结构的链表可以使得从第一个元素遍历到最后一个元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListElmt_</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data;  <span class=\"comment\">// 数据成员</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListElmt_</span> * <span class=\"title\">next</span>;</span> <span class=\"comment\">// next指针</span></span><br><span class=\"line\">&#125; ListElmt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">List_</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destroy)(<span class=\"keyword\">void</span> *data);</span><br><span class=\"line\">    ListElmt *head;</span><br><span class=\"line\">    ListElmt *tail;</span><br><span class=\"line\">&#125; List;</span><br></pre></td></tr></table></figure>\n<p>&emsp;单链表操作：插入、删除、<br>&emsp;如何判断单链表存在回环？<br>&emsp;&emsp;设有两个指针p1，p2。在美学循环的时候，p1先走一步，p2走两步，直到p2碰到空指针或者两者相等时循环结束，如果两个指针相等则说明存在回环。</p>\n<details>\n<summary>singleList</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __SINGLELIST_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __SINGLELIST_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\">&#125;listNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">linkedList</span> &#123;</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> typesize;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span>(*dup)(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>(*match)(<span class=\"keyword\">void</span>*, <span class=\"keyword\">void</span>*);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>(*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span>*);</span><br><span class=\"line\">&#125;linkedList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList *<span class=\"title\">listCreate</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRelease</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listEmpty</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">linkedList *<span class=\"title\">listAddNodeHead</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span>;</span><br><span class=\"line\"><span class=\"function\">linkedList *<span class=\"title\">listAddNodeTail</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span>;</span><br><span class=\"line\"><span class=\"function\">linkedList *<span class=\"title\">listInsertNode</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, listNode *old_node, <span class=\"keyword\">void</span> *value, <span class=\"keyword\">bool</span> after)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listDelNode</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, listNode *node)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listSearchKey</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *key)</span></span>;</span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listIndex</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">long</span> index)</span></span>;</span><br><span class=\"line\"><span class=\"function\">linkedList* <span class=\"title\">listRewind</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">listLength</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// !__SINGLELIST_H__</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;singleList.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList * <span class=\"title\">listCreate</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    linkedList *<span class=\"built_in\">list</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span> = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(*<span class=\"built_in\">list</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;dup = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;match = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRelease</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listEmpty(<span class=\"built_in\">list</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"built_in\">list</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listEmpty</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">NULL</span> != <span class=\"built_in\">list</span>-&gt;head) &#123;</span><br><span class=\"line\">        listNode *pNode = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = pNode-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>(pNode-&gt;value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(pNode-&gt;value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        pNode-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(pNode);</span><br><span class=\"line\">        pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList * <span class=\"title\">listAddNodeHead</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> * value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span> || <span class=\"literal\">NULL</span> == value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(*node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\">    node-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = node;</span><br><span class=\"line\"></span><br><span class=\"line\">    ++<span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList * <span class=\"title\">listAddNodeTail</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span> || <span class=\"literal\">NULL</span> == value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(*node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>-&gt;head &amp;&amp; <span class=\"built_in\">list</span>-&gt;len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        listNode *tail = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        listNode *pre = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">NULL</span> != tail) &#123;</span><br><span class=\"line\">            pre = tail;</span><br><span class=\"line\">            tail = tail-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        pre-&gt;next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ++<span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList * <span class=\"title\">listInsertNode</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, listNode *old_node, <span class=\"keyword\">void</span> *value, <span class=\"keyword\">bool</span> after)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span> || <span class=\"literal\">NULL</span> == old_node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    pNode = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(*pNode));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == pNode) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pNode-&gt;value = value;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (after) &#123;</span><br><span class=\"line\">        pNode-&gt;next = old_node-&gt;next;</span><br><span class=\"line\">        old_node-&gt;next = pNode;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        listNode *pre = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pre-&gt;next != old_node) &#123;</span><br><span class=\"line\">            pre = pre-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != pre) &#123;</span><br><span class=\"line\">            pre-&gt;next = pNode;</span><br><span class=\"line\">            pNode-&gt;next = old_node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ++<span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listDelNode</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, listNode *node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span> || <span class=\"literal\">NULL</span> == node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *pre = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    listNode *cur = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">NULL</span> != cur &amp;&amp; cur != node) &#123;</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        cur = cur-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == pre) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pre-&gt;next = node-&gt;next;</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    --<span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>(node-&gt;value);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(node);</span><br><span class=\"line\">        node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">listNode * <span class=\"title\">listSearchKey</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *node = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">NULL</span> != node) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != <span class=\"built_in\">list</span>-&gt;match) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;match(key, node-&gt;value) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key == node-&gt;value) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        node = node-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">listNode * <span class=\"title\">listIndex</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>, <span class=\"keyword\">long</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt;= <span class=\"number\">0</span> || index &gt; <span class=\"built_in\">list</span>-&gt;len) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *pNode = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> i = <span class=\"number\">0</span>; i &lt; index; ++i) &#123;</span><br><span class=\"line\">        pNode = pNode-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> pNode;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linkedList* <span class=\"title\">listRewind</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *head = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    listNode *pre = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    listNode *next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">NULL</span> != head) &#123;</span><br><span class=\"line\">        next = head-&gt;next;</span><br><span class=\"line\">        head-&gt;next = pre;</span><br><span class=\"line\">        pre = head;</span><br><span class=\"line\">        head = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = pre;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">listLength</span><span class=\"params\">(linkedList *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<details>\n<summary>single_list</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list_head</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">head</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_empty</span><span class=\"params\">(struct single_list_head *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head-&gt;head == <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(struct single_list_head *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">tmp</span> =</span> head-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%02d]: %08d\\n&quot;</span>, idx++, tmp-&gt;val);</span><br><span class=\"line\">        tmp = tmp-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(struct single_list **prev, struct single_list *elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!prev)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    elem-&gt;next = *prev;</span><br><span class=\"line\">    *prev = elem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_head</span><span class=\"params\">(struct single_list_head *head, struct single_list *elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    insert(&amp;head-&gt;head, elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct single_list* <span class=\"title\">del</span><span class=\"params\">(struct single_list **prev)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">tmp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!prev)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*prev == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    tmp = *prev;</span><br><span class=\"line\">    *prev = (*prev)-&gt;next;</span><br><span class=\"line\">    tmp-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct single_list* <span class=\"title\">delete_head</span><span class=\"params\">(struct single_list_head* head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> del(&amp;head-&gt;head);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct single_list** <span class=\"title\">search</span><span class=\"params\">(struct single_list_head* head, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> **<span class=\"title\">prev</span>, *<span class=\"title\">tmp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (prev = &amp;head-&gt;head, tmp = *prev; tmp &amp;&amp; (tmp-&gt;val &lt; target);</span><br><span class=\"line\">    prev = &amp;tmp-&gt;next, tmp = *prev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(struct single_list_head* head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list_head</span> <span class=\"title\">tmp</span> =</span> &#123;<span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">elem</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!is_empty(head)) &#123;</span><br><span class=\"line\">        elem = delete_head(head);</span><br><span class=\"line\">        insert_head(&amp;tmp, elem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    head-&gt;head = tmp.head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_cyclic</span><span class=\"params\">(struct single_list_head* head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">s1</span>, *<span class=\"title\">s2</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    s1 = s2 = head-&gt;head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(s1 &amp;&amp; s2) &#123;</span><br><span class=\"line\">        s1 = s1-&gt;next;</span><br><span class=\"line\">        s2 = s2-&gt;next ? s2-&gt;next-&gt;next:s2-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1 == s2)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct single_list* <span class=\"title\">middle</span><span class=\"params\">(struct single_list_head* head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> *<span class=\"title\">s1</span>, *<span class=\"title\">s2</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> <span class=\"title\">pseudo_head</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    pseudo_head.next = head-&gt;head;</span><br><span class=\"line\">    s1 = s2 = &amp;pseudo_head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!s2 || !s2-&gt;next)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s1;</span><br><span class=\"line\">        s1 = s1-&gt;next;</span><br><span class=\"line\">        s2 = s2-&gt;next-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list_head</span> <span class=\"title\">head</span> =</span> &#123;<span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> <span class=\"title\">lists</span>[10];</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">single_list</span> **<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (idx = <span class=\"number\">0</span>; idx &lt; <span class=\"number\">10</span>; idx++) &#123;</span><br><span class=\"line\">        lists[idx].val = idx;</span><br><span class=\"line\">        lists[idx].next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    insert_head(&amp;head, &amp;lists[<span class=\"number\">6</span>]);</span><br><span class=\"line\">    insert_head(&amp;head, &amp;lists[<span class=\"number\">5</span>]);</span><br><span class=\"line\">    insert_head(&amp;head, &amp;lists[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    insert_head(&amp;head, &amp;lists[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    insert_head(&amp;head, &amp;lists[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=== insert 0, 1, 4, 5, 6\\n&quot;</span>);</span><br><span class=\"line\">    dump(&amp;head);</span><br><span class=\"line\"></span><br><span class=\"line\">    prev = search(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    insert(prev, &amp;lists[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=== insert 2\\n&quot;</span>);</span><br><span class=\"line\">    dump(&amp;head);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;middle elem is %d\\n&quot;</span>, middle(&amp;head)-&gt;val);</span><br><span class=\"line\"></span><br><span class=\"line\">    prev = search(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((*prev) &amp;&amp; ((*prev)-&gt;val == <span class=\"number\">2</span>))</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The list contains 2\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The list not contains 2\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    del(prev);</span><br><span class=\"line\">    prev = search(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;After remove 2\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((*prev) &amp;&amp; ((*prev)-&gt;val == <span class=\"number\">2</span>))</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The list contains 2\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The list not contains 2\\n&quot;</span>);</span><br><span class=\"line\">    dump(&amp;head);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;After reverse \\n&quot;</span>);</span><br><span class=\"line\">    reverse(&amp;head);</span><br><span class=\"line\">    dump(&amp;head);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;middle elem is %d\\n&quot;</span>, middle(&amp;head)-&gt;val);</span><br><span class=\"line\"></span><br><span class=\"line\">    lists[<span class=\"number\">0</span>].next = &amp;lists[<span class=\"number\">6</span>];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;list is%s cyclic\\n&quot;</span>, is_cyclic(&amp;head)?<span class=\"string\">&quot;&quot;</span>:<span class=\"string\">&quot; not&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<details>\n<summary>LinkedListAlgo</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 1) 单链表反转</span></span><br><span class=\"line\"><span class=\"comment\"> * 2) 链表中环的检测</span></span><br><span class=\"line\"><span class=\"comment\"> * 3) 两个有序的链表合并</span></span><br><span class=\"line\"><span class=\"comment\"> * 4) 删除链表倒数第 n 个结点</span></span><br><span class=\"line\"><span class=\"comment\"> * 5) 求链表的中间结点</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author: Smallfly</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SinglyLinkedNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SinglyLinkedNode</span>* <span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; SinglyLinkedNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insertNode</span><span class=\"params\">(SinglyLinkedNode** head_ref, <span class=\"keyword\">int</span> data)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printLinkedList</span><span class=\"params\">(SinglyLinkedNode* head)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 反转单链表 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(SinglyLinkedNode** head_ref)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*head_ref == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    SinglyLinkedNode *current = *head_ref;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (current) &#123;</span><br><span class=\"line\">        SinglyLinkedNode *next = current-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!next) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 到达尾结点时，将地址存入 head_ref</span></span><br><span class=\"line\">            *head_ref = current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current-&gt;next = prev;</span><br><span class=\"line\">        prev = current;</span><br><span class=\"line\">        current = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_reverse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    SinglyLinkedNode* head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">3</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    reverse(&amp;head);</span><br><span class=\"line\">    printLinkedList(head);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 检测单链表是否有环 */</span></span><br><span class=\"line\"><span class=\"comment\">// 这里使用一级指针也可以</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">checkCircle</span><span class=\"params\">(SinglyLinkedNode** head_ref)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*head_ref == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    SinglyLinkedNode *slow = *head_ref, *fast = *head_ref;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slow == fast) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_checkCircle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    SinglyLinkedNode* head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">3</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result1 = checkCircle(&amp;head);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;has circle: %d\\n&quot;</span>, result1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// make circle linklist</span></span><br><span class=\"line\">    SinglyLinkedNode* current = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(SinglyLinkedNode));</span><br><span class=\"line\">    current-&gt;data = <span class=\"number\">0</span>;</span><br><span class=\"line\">    SinglyLinkedNode* h = current;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">        SinglyLinkedNode* node = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(SinglyLinkedNode));</span><br><span class=\"line\">        node-&gt;data = i;</span><br><span class=\"line\">        current-&gt;next = node;</span><br><span class=\"line\">        <span class=\"comment\">//reset current node</span></span><br><span class=\"line\">        current = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    current-&gt;next = h;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> result2 = checkCircle(&amp;h);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;has circle: %d\\n&quot;</span>, result2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 有序链表合并 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveNode</span><span class=\"params\">(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">SinglyLinkedNode* <span class=\"title\">mergeSortedLinkedList</span><span class=\"params\">(SinglyLinkedNode* la, SinglyLinkedNode* lb)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 辅助结点，next 指针持有合并后的有序链表</span></span><br><span class=\"line\">    SinglyLinkedNode dummy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 有序链表的尾结点</span></span><br><span class=\"line\">    SinglyLinkedNode* tail = &amp;dummy;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果有一个链表为空，直接与另一个链表接起来</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!la) &#123;</span><br><span class=\"line\">            tail-&gt;next = lb;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!lb) &#123;</span><br><span class=\"line\">            tail-&gt;next = la;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将头结点较小的优先添加到 tail</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (la-&gt;data &lt;= lb-&gt;data) &#123;</span><br><span class=\"line\">            moveNode(&amp;(tail-&gt;next), &amp;la);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            moveNode(&amp;(tail-&gt;next), &amp;lb);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tail = tail-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 src_ref 的头结点，添加到 dest_ref 的头部。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveNode</span><span class=\"params\">(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*src_ref == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    SinglyLinkedNode* new_node = *src_ref;</span><br><span class=\"line\">    </span><br><span class=\"line\">    *src_ref = new_node-&gt;next;</span><br><span class=\"line\">    </span><br><span class=\"line\">    new_node-&gt;next = *dest_ref;</span><br><span class=\"line\">    *dest_ref = new_node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_mergeSortedLinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    SinglyLinkedNode* a = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;a, <span class=\"number\">10</span>);</span><br><span class=\"line\">    insertNode(&amp;a, <span class=\"number\">5</span>);</span><br><span class=\"line\">    insertNode(&amp;a, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode* b = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;b, <span class=\"number\">8</span>);</span><br><span class=\"line\">    insertNode(&amp;b, <span class=\"number\">6</span>);</span><br><span class=\"line\">    insertNode(&amp;b, <span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode* result = mergeSortedLinkedList(a, b);</span><br><span class=\"line\">    printLinkedList(result);</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode* result2 = mergeSortedLinkedList(a, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    printLinkedList(result2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 删除倒数第 K 个结点 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteLastKth</span><span class=\"params\">(SinglyLinkedNode** head_ref, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*head_ref == <span class=\"literal\">NULL</span> || k == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 快指针向前移动 k-1</span></span><br><span class=\"line\">    SinglyLinkedNode* fast = *head_ref;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; k &amp;&amp; fast != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        ++i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果快指针为空，说明结点个数小于 k</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fast == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode* slow = *head_ref;</span><br><span class=\"line\">    SinglyLinkedNode* prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        prev = slow;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果 prev 为空，头结点刚好是第 k 个结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!prev) &#123;</span><br><span class=\"line\">        (*head_ref) = (*head_ref)-&gt;next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        prev-&gt;next = slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(slow);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_deleteLastKth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    SinglyLinkedNode* head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">1</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">3</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">4</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">5</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1. 删除头结点</span></span><br><span class=\"line\">    deleteLastKth(&amp;head, <span class=\"number\">5</span>);</span><br><span class=\"line\">    printLinkedList(head);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 删除中间结点</span></span><br><span class=\"line\">    deleteLastKth(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    printLinkedList(head);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 求中间结点  */</span></span><br><span class=\"line\"><span class=\"function\">SinglyLinkedNode* <span class=\"title\">findMiddleNode</span><span class=\"params\">(SinglyLinkedNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    SinglyLinkedNode* slow = head;</span><br><span class=\"line\">    SinglyLinkedNode* fast = head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1. 慢指针走一步，快指针两步</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast-&gt;next != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_findMiddleNode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    SinglyLinkedNode* head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">1</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">2</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">3</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">4</span>);</span><br><span class=\"line\">    insertNode(&amp;head, <span class=\"number\">5</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    SinglyLinkedNode* middleNode = findMiddleNode(head);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, middleNode-&gt;data);</span><br><span class=\"line\">    printLinkedList(head);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 工具方法 */</span></span><br><span class=\"line\"><span class=\"comment\">// 插入新结点到链表头部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insertNode</span><span class=\"params\">(SinglyLinkedNode** head_ref, <span class=\"keyword\">int</span> data)</span> </span>&#123;</span><br><span class=\"line\">    SinglyLinkedNode* new_node = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(SinglyLinkedNode));</span><br><span class=\"line\">    new_node-&gt;data = data;</span><br><span class=\"line\">    new_node-&gt;next = *head_ref;</span><br><span class=\"line\">    *head_ref = new_node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printLinkedList</span><span class=\"params\">(SinglyLinkedNode* node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;--- start ---\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (node) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;data: %d\\n&quot;</span>, node-&gt;data);</span><br><span class=\"line\">        node = node-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;--- end ---\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 跑测试</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    test_reverse();  </span><br><span class=\"line\"><span class=\"comment\">//    test_checkCircle();</span></span><br><span class=\"line\"><span class=\"comment\">//    test_mergeSortedLinkedList();</span></span><br><span class=\"line\"><span class=\"comment\">//    test_deleteLastKth();  </span></span><br><span class=\"line\"><span class=\"comment\">//    test_findMiddleNode();</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<details>\n<summary>linklist_jinshaohui</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: lisklist.c</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-10-07  </span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stlistNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;listNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*反转链表*/</span></span><br><span class=\"line\"><span class=\"function\">listNode <span class=\"title\">reverseList</span><span class=\"params\">(listNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    listNode *next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        next = head-&gt;next;</span><br><span class=\"line\">        head-&gt;next = prev;</span><br><span class=\"line\">        prev = head;</span><br><span class=\"line\">        head = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*判断链表是否有环*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hasCycle</span><span class=\"params\">(listNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode * fast = head;</span><br><span class=\"line\">    listNode * low = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        low = low-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (low == fast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*合并有序链表*/</span></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">mergeTwoLists</span><span class=\"params\">(listNode *l1,listNode *l2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode head = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    listNode *pRes = &amp;head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1 == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            pRes-&gt;next = l2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            pRes-&gt;next = l1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class=\"line\">            pRes-&gt;next = l1;</span><br><span class=\"line\">            l1 = l1-&gt;next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pRes-&gt;next = l2;</span><br><span class=\"line\">            l2 = l2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pRes = pRes-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *删除链表倒数第n个节点，并返回链表头节点 */</span></span><br><span class=\"line\"><span class=\"function\">listNode * <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(listNode*headi,<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *fast = head;</span><br><span class=\"line\">    listNode *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    listNpde *next = head;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = n;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*快指针往后移动k-1*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((k &gt; <span class=\"number\">1</span>) &amp;&amp; (fast != <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        k--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*说明链表数目不足n个*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fast == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        prev = next;</span><br><span class=\"line\">        next = next-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(prev == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*求链表的中间节点*/</span></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">middleNode</span><span class=\"params\">(listNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode * fast = head;</span><br><span class=\"line\">    listNode * low = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fast != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        low = low-&gt;next;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> low;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<h4 id=\"2-1-3-双链表\"><a href=\"#2-1-3-双链表\" class=\"headerlink\" title=\"2.1.3 双链表\"></a>2.1.3 双链表</h4><p>&emsp; 双向链表的元素通过两个指针链接，一个指向直接后继，一个指向直接前驱。双向链表可以正向遍历，也可反向遍历。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DListElmt_</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DListElmt_</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DListElmt_</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; DListElmt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DList_</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destroy)(<span class=\"keyword\">void</span> *data);</span><br><span class=\"line\">    DListElmt *head;</span><br><span class=\"line\">    DListElmt *tail;</span><br><span class=\"line\">&#125; DList;</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>Dlist</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Dlist.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DlistNode</span> &#123;</span>    <span class=\"comment\">//双向链表中每一个节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DlistNode</span> *<span class=\"title\">prev</span>;</span>   <span class=\"comment\">//节点前项指针</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DlistNode</span> *<span class=\"title\">next</span>;</span>   <span class=\"comment\">//节点后项指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>    data;              <span class=\"comment\">//数据</span></span><br><span class=\"line\">&#125;stDlistNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Dlisthead</span> &#123;</span>    <span class=\"comment\">//定义链表总体</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;                 <span class=\"comment\">//链表长度</span></span><br><span class=\"line\">    stDlistNode *head;        <span class=\"comment\">//头指针</span></span><br><span class=\"line\">    stDlistNode *tail;        <span class=\"comment\">//尾部指针</span></span><br><span class=\"line\">&#125;stDlistHead;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dlist.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;./Dlist.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dlist_init</span><span class=\"params\">(stDlistHead *dlist)</span>    <span class=\"comment\">//链表初始化</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    dlist-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dlist-&gt;head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    dlist-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dlist_destory</span><span class=\"params\">(stDlistHead *dlist)</span>    <span class=\"comment\">//删除链表</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    stDlistNode *pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(dlist-&gt;size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        pNode = dlist-&gt;head;</span><br><span class=\"line\">        dlist-&gt;head = dlist-&gt;head-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(pNode);</span><br><span class=\"line\">        dlist-&gt;size--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dlist,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(stDlistHead));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dlist_insert_head</span><span class=\"params\">(stDlistHead *dlist,stDlistNode *pNode,<span class=\"keyword\">int</span> data)</span>    <span class=\"comment\">//插入头结点，操作的链表，操作的节点，数据</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pNode == <span class=\"literal\">NULL</span>) &#123;   <span class=\"comment\">//当只传递一个数据时</span></span><br><span class=\"line\">        pNode = (stDlistNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(stDlistNode));    <span class=\"comment\">//新建节点，为节点分配空间（malloc（）可能需要#include&lt;malloc.h&gt;）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pNode == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pNode-&gt;data = data;    </span><br><span class=\"line\">    pNode-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    pNode-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dlist-&gt;size == <span class=\"number\">0</span>) &#123;  <span class=\"comment\">//如果链表长度为0，即链表当前无节点，</span></span><br><span class=\"line\">        dlist-&gt;head = pNode;</span><br><span class=\"line\">        dlist-&gt;tail = pNode;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                 <span class=\"comment\">//如果链表已有节点，则令新插入节点为头节点</span></span><br><span class=\"line\">        pNode-&gt;next = dlist-&gt;head;</span><br><span class=\"line\">        dlist-&gt;head-&gt;prev = pNode;</span><br><span class=\"line\">        dlist-&gt;head = pNode;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dlist-&gt;size++;    <span class=\"comment\">//每成功调用一次，链表长度+1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">stDlistNode * <span class=\"title\">dlist_remove_tail</span><span class=\"params\">(stDlistHead *dlist)</span>    <span class=\"comment\">//删除尾部节点,并返回删除节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    stDlistNode *pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dlist-&gt;size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pNode = dlist-&gt;tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dlist-&gt;size &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        dlist-&gt;tail = dlist-&gt;tail-&gt;prev;</span><br><span class=\"line\">        dlist-&gt;tail-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dlist-&gt;head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        dlist-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dlist-&gt;size--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pNode;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dlist_remove_node</span><span class=\"params\">(stDlistHead * dlist,stDlistNode *pNode)</span>     <span class=\"comment\">//删除指定节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((dlist == <span class=\"literal\">NULL</span>)||(pNode == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dlist-&gt;head == pNode) &#123;</span><br><span class=\"line\">        dlist-&gt;head = dlist-&gt;head-&gt;next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dlist-&gt;tail == pNode) &#123;</span><br><span class=\"line\">        dlist-&gt;tail = pNode-&gt;prev;</span><br><span class=\"line\">        dlist-&gt;tail-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        pNode-&gt;prev-&gt;next = pNode-&gt;next;</span><br><span class=\"line\">        pNode-&gt;next-&gt;prev = pNode-&gt;prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dlist-&gt;size--;</span><br><span class=\"line\">    pNode-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    pNode-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dlist-&gt;size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dlist,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(stDlistHead));     <span class=\"comment\">//将dlist占用内存块的所有值置为0，也就是清空head,tail指针内容</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">stDlistNode * <span class=\"title\">dlist_search</span><span class=\"params\">(stDlistHead * dlist,<span class=\"keyword\">int</span> data)</span>     <span class=\"comment\">//根据值搜索节点，并返回</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    stDlistNode *pNode = dlist-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(pNode != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pNode-&gt;data == data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pNode = pNode-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dlist_dump</span><span class=\"params\">(stDlistHead *dlist)</span>    <span class=\"comment\">//显示链表中的数据</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> no = <span class=\"number\">0</span>;</span><br><span class=\"line\">    stDlistNode *pNode = dlist-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(pNode != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n [%d] = %d&quot;</span>,no++,pNode-&gt;data);</span><br><span class=\"line\">        pNode = pNode-&gt;next;    <span class=\"comment\">//将pNode的下一个节点赋值给pNode，推进循环</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Lru_dlist</span><span class=\"params\">(stDlistHead *dlist,<span class=\"keyword\">int</span> data)</span>     <span class=\"comment\">//LRU（最近最少使用）缓存淘汰算法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    stDlistNode *pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    pNode = dlist_search(dlist,data);    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNode != <span class=\"literal\">NULL</span>) &#123;    <span class=\"comment\">//如果在链表中找到这个值，则删除储存这个值的节点，之后吧这个节点放在头部</span></span><br><span class=\"line\">        dlist_remove_node(dlist,pNode);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dlist-&gt;size &gt;= <span class=\"number\">4</span>)    &#123;    <span class=\"comment\">//没在链表中找到，且链表长度大于4，则从链表中删除尾部节点，将新数据放在头部</span></span><br><span class=\"line\">        pNode = dlist_remove_tail(dlist);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dlist_insert_head(dlist ,pNode,data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    stDlistHead dlist = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    stDlistNode * pNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    dlist_init(&amp;dlist);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n inset 1,2,3&quot;</span>);</span><br><span class=\"line\">    dlist_insert_head(&amp;dlist,<span class=\"literal\">NULL</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    dlist_insert_head(&amp;dlist,<span class=\"literal\">NULL</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    dlist_insert_head(&amp;dlist,<span class=\"literal\">NULL</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\"></span><br><span class=\"line\">    pNode = dlist_remove_tail(&amp;dlist);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pNode != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n remove %d&quot;</span>,pNode-&gt;data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dlist_insert_head(&amp;dlist,pNode,<span class=\"number\">4</span>);</span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\"></span><br><span class=\"line\">    Lru_dlist(&amp;dlist,<span class=\"number\">5</span>);</span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\">    Lru_dlist(&amp;dlist,<span class=\"number\">6</span>);</span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\">    Lru_dlist(&amp;dlist,<span class=\"number\">7</span>);</span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\">    Lru_dlist(&amp;dlist,<span class=\"number\">5</span>);</span><br><span class=\"line\">    dlist_dump(&amp;dlist);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(dlist.size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        pNode = dlist_remove_tail(&amp;dlist);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pNode != <span class=\"literal\">NULL</span>) &#123; </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n remove %d&quot;</span>,pNode-&gt;data);</span><br><span class=\"line\">            <span class=\"built_in\">free</span> (pNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<details>\n<summary>linux/list</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// linux内核源码双向链表实现include/linux/list.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _LIST_HEAD_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _LIST_HEAD_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 双向链表节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> *<span class=\"title\">next</span>, *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化节点：设置name节点的前继节点和后继节点都是指向name本身。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义表头(节点)：新建双向链表表头name，并设置name的前继节点和后继节点都是指向name本身。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LIST_HEAD(name) \\</span></span><br><span class=\"line\"><span class=\"meta\">    struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化节点：将list节点的前继节点和后继节点都是指向list本身。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">INIT_LIST_HEAD</span><span class=\"params\">(struct list_head *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;next = <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;prev = <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加节点：将new插入到prev和next之间。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> __list_add(struct list_head *<span class=\"keyword\">new</span>,</span><br><span class=\"line\">                  struct list_head *prev,</span><br><span class=\"line\">                  struct list_head *next)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    next-&gt;prev = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;next = next;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;prev = prev;</span><br><span class=\"line\">    prev-&gt;next = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加new节点：将new添加到head之后，是new称为head的后继节点。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">list_add</span><span class=\"params\">(struct list_head *<span class=\"keyword\">new</span>, struct list_head *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    __list_add(<span class=\"keyword\">new</span>, head, head-&gt;next);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加new节点：将new添加到head之前，即将new添加到双链表的末尾。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">list_add_tail</span><span class=\"params\">(struct list_head *<span class=\"keyword\">new</span>, struct list_head *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    __list_add(<span class=\"keyword\">new</span>, head-&gt;prev, head);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从双链表中删除entry节点。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> __list_del(struct list_head * prev, struct list_head * next)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    next-&gt;prev = prev;</span><br><span class=\"line\">    prev-&gt;next = next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从双链表中删除entry节点。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">list_del</span><span class=\"params\">(struct list_head *entry)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从双链表中删除entry节点。</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> __list_del_entry(struct list_head *entry)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从双链表中删除entry节点，并将entry节点的前继节点和后继节点都指向entry本身。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">list_del_init</span><span class=\"params\">(struct list_head *entry)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    __list_del_entry(entry);</span><br><span class=\"line\">    INIT_LIST_HEAD(entry);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用new节点取代old节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">list_replace</span><span class=\"params\">(struct list_head *old,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                struct list_head *<span class=\"keyword\">new</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;next = old-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;next-&gt;prev = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;prev = old-&gt;prev;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>-&gt;prev-&gt;next = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 双链表是否为空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">list_empty</span><span class=\"params\">(<span class=\"keyword\">const</span> struct list_head *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head-&gt;next == head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取&quot;MEMBER成员&quot;在&quot;结构体TYPE&quot;中的位置偏移</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据&quot;结构体(type)变量&quot;中的&quot;域成员变量(member)的指针(ptr)&quot;来获取指向整个结构体变量的指针</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> container_of(ptr, type, member) (&#123;          \\</span></span><br><span class=\"line\"><span class=\"meta\">    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \\</span></span><br><span class=\"line\"><span class=\"meta\">    (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历双向链表</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> list_for_each(pos, head) \\</span></span><br><span class=\"line\"><span class=\"meta\">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> list_for_each_safe(pos, n, head) \\</span></span><br><span class=\"line\"><span class=\"meta\">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \\</span></span><br><span class=\"line\"><span class=\"meta\">        pos = n, n = pos-&gt;next)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> list_entry(ptr, type, member) \\</span></span><br><span class=\"line\"><span class=\"meta\">    container_of(ptr, type, member)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n</details>\n\n<h4 id=\"2-1-4-跳表\"><a href=\"#2-1-4-跳表\" class=\"headerlink\" title=\"2.1.4 跳表\"></a>2.1.4 跳表</h4><p>&emsp;跳表对标的是平衡树(AVL Tree), 插入/删除/搜索都是 O(logn)的数据结构。</p>\n<details>\n<summary>skiplist</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: skiplist.h</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-10-31</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Desc:    </span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __SKIP_LIST_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __SKIP_LIST_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> key;    <span class=\"comment\">/*key是唯一的*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;  <span class=\"comment\">/*存储的内容*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_level; <span class=\"comment\">/*当前节点最大层数*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">node</span> *<span class=\"title\">next</span>[0];</span><span class=\"comment\">/*level层链表结构*/</span></span><br><span class=\"line\">&#125;node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">skiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    node *head;</span><br><span class=\"line\">&#125;skiplist;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*根据当前结构体元素的地址，获取到结构体首地址*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> offsetof(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> container(ptr,type,member) (&#123;\\</span></span><br><span class=\"line\"><span class=\"meta\">  const typeof( ((type *)0)-&gt;member) *__mptr = (ptr);\\</span></span><br><span class=\"line\"><span class=\"meta\">  (type *) ( (char *)__mptr - offsetof(type,member));&#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;./skiplist.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建node节点*/</span></span><br><span class=\"line\"><span class=\"function\">node* <span class=\"title\">skip_list_create_node</span><span class=\"params\">(<span class=\"keyword\">int</span> level,<span class=\"keyword\">int</span> key,<span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    node * tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    tmp =(node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(node) + level*<span class=\"keyword\">sizeof</span>(node *));</span><br><span class=\"line\">    assert(tmp != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(tmp,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(node) + level*<span class=\"keyword\">sizeof</span>(node*));</span><br><span class=\"line\">    tmp-&gt;key = key;</span><br><span class=\"line\">    tmp-&gt;value = value;</span><br><span class=\"line\">    tmp-&gt;max_level = level;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建跳表的表头，max_level层数*/</span></span><br><span class=\"line\"><span class=\"function\">skiplist * <span class=\"title\">skip_list_create</span><span class=\"params\">(<span class=\"keyword\">int</span> max_level)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    skiplist * <span class=\"built_in\">list</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span> = (skiplist *)<span class=\"built_in\">malloc</span> (<span class=\"keyword\">sizeof</span>(skiplist));</span><br><span class=\"line\">    assert(<span class=\"built_in\">list</span> != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;level = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = skip_list_create_node(max_level,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">list</span>-&gt;head == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*skiplist 销毁*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">skip_list_destory</span><span class=\"params\">(skiplist * <span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    node * tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((<span class=\"built_in\">list</span> == <span class=\"literal\">NULL</span>) || (<span class=\"built_in\">list</span>-&gt;head == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">list</span>-&gt;head-&gt;next[<span class=\"number\">0</span>] != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        tmp = <span class=\"built_in\">list</span>-&gt;head-&gt;next[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head-&gt;next[<span class=\"number\">0</span>] = tmp-&gt;next[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>-&gt;head);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*插入元素获得层数，是随机产生的*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">skip_list_level</span><span class=\"params\">(skiplist * <span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">list</span>-&gt;head-&gt;max_level; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((rand()%<span class=\"number\">2</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            level++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> level;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">skip_list_insert</span><span class=\"params\">(skiplist *<span class=\"built_in\">list</span>,<span class=\"keyword\">int</span> key,<span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">    node **update = <span class=\"literal\">NULL</span>;<span class=\"comment\">/*用来更新每层的指针*/</span></span><br><span class=\"line\">    node *tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*申请update空间用于保存每层的指针*/</span></span><br><span class=\"line\">    update = (node **)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(node *)*<span class=\"built_in\">list</span>-&gt;head-&gt;max_level);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (update == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*逐层查询节点的*/</span></span><br><span class=\"line\">    prev = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = (<span class=\"built_in\">list</span>-&gt;level <span class=\"number\">-1</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*初始化每level层的头指针*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(((tmp = prev-&gt;next[i]) != <span class=\"literal\">NULL</span>) &amp;&amp; (tmp-&gt;key &lt; key)) &#123;</span><br><span class=\"line\">            prev  = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        update[i] = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*当前key已经存在，返回错误*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tmp!= <span class=\"literal\">NULL</span>) &amp;&amp; (tmp-&gt;key == key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*获取插入元素的随机层数，并更新跳表的最大层数*/</span></span><br><span class=\"line\">    level = skip_list_level(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"comment\">/*创建当前数据节点*/</span></span><br><span class=\"line\">    tmp = skip_list_create_node(level,key,value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*更新最大层数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (level &gt; <span class=\"built_in\">list</span>-&gt;level) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"built_in\">list</span>-&gt;level;i &lt; level; i ++) &#123;</span><br><span class=\"line\">            update[i] = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;level = level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*逐层更新节点的指针*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; level; i++) &#123;</span><br><span class=\"line\">        tmp-&gt;next[i] = update[i]-&gt;next[i];</span><br><span class=\"line\">        update[i]-&gt;next[i] = tmp; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">skip_list_delete</span><span class=\"params\">(skiplist * <span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> key ,<span class=\"keyword\">int</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    node **update = <span class=\"literal\">NULL</span>;<span class=\"comment\">/*用来更新每层的指针*/</span></span><br><span class=\"line\">    node *tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">list</span> == <span class=\"literal\">NULL</span>) &amp;&amp; (value == <span class=\"literal\">NULL</span>)&amp;&amp; (<span class=\"built_in\">list</span>-&gt;count == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*申请update空间用于保存每层的指针*/</span></span><br><span class=\"line\">    update = (node **)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(node *)*<span class=\"built_in\">list</span>-&gt;level);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (update == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*逐层查询节点的*/</span></span><br><span class=\"line\">    prev = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = (<span class=\"built_in\">list</span>-&gt;level <span class=\"number\">-1</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*初始化每level层的头指针*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(((tmp = prev-&gt;next[i]) != <span class=\"literal\">NULL</span>) &amp;&amp; (tmp-&gt;key &lt; key)) &#123;</span><br><span class=\"line\">            prev = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        update[i] = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tmp != <span class=\"literal\">NULL</span>) &amp;&amp; (tmp-&gt;key == key)) &#123;</span><br><span class=\"line\">        *value = tmp-&gt;value;</span><br><span class=\"line\">        <span class=\"comment\">/*逐层删除*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">list</span>-&gt;level; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(update[i]-&gt;next[i] == tmp) &#123;</span><br><span class=\"line\">                update[i]-&gt;next[i] = tmp-&gt;next[i];       </span><br><span class=\"line\">            &#125;    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">        tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*更新level的层数*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"built_in\">list</span>-&gt;level - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;head-&gt;next[i] == <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">list</span>-&gt;level--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;count--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;<span class=\"comment\">/*未找到节点*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*查询当前key是否在跳表中，如果存在返回查询的value数值，不存在返回-1*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">skip_list_search</span><span class=\"params\">(skiplist *<span class=\"built_in\">list</span>,<span class=\"keyword\">int</span> key,<span class=\"keyword\">int</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    node *prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node *tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((<span class=\"built_in\">list</span> == <span class=\"literal\">NULL</span>) || (<span class=\"built_in\">list</span>-&gt;count == <span class=\"number\">0</span>) || (value == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    prev = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"built_in\">list</span>-&gt;level - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(((tmp = prev-&gt;next[i]) != <span class=\"literal\">NULL</span>) &amp;&amp; (tmp-&gt;key &lt;= key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp-&gt;key == key) &#123;</span><br><span class=\"line\">                    *value = tmp-&gt;value;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            prev = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">skip_list_dump</span><span class=\"params\">(skiplist *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    node *ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n----------------------------------------------&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n skip list level[%d],count[%d]&quot;</span>,<span class=\"built_in\">list</span>-&gt;level,<span class=\"built_in\">list</span>-&gt;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"built_in\">list</span>-&gt;level - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i --) &#123;</span><br><span class=\"line\">        ptmp = <span class=\"built_in\">list</span>-&gt;head-&gt;next[i];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n level[%d]:&quot;</span>,i);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ptmp != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d-%d &quot;</span>,ptmp-&gt;key,ptmp-&gt;value);</span><br><span class=\"line\">            ptmp = ptmp-&gt;next[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n----------------------------------------------&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> key = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>;</span><br><span class=\"line\">    skiplist *<span class=\"built_in\">list</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">list</span> = skip_list_create(<span class=\"number\">5</span>);</span><br><span class=\"line\">    assert(<span class=\"built_in\">list</span> != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n 请输入key 和 value，当key = 1000时，退出输入：&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>,&amp;key,&amp;value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"number\">1000</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = skip_list_insert(<span class=\"built_in\">list</span>,key,value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n skip list insert %d,failed,res=%d.&quot;</span>,key,res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    skip_list_dump(<span class=\"built_in\">list</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n 通过key 查询value的数值，当key = 1000时，退出查询&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key == <span class=\"number\">1000</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = skip_list_search(<span class=\"built_in\">list</span>,key,&amp;value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n skip list search %d,failed,res=%d.&quot;</span>,key,res);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n skip list search %d,sucessful,value=%d.&quot;</span>,key,value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    skip_list_dump(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n 通过key 删除节点，当key = 1000时，退出删除&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key == <span class=\"number\">1000</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = skip_list_delete(<span class=\"built_in\">list</span>,key,&amp;value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n skip list search %d,failed,res=%d.&quot;</span>,key,res);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n skip list search %d,sucessful,value=%d.&quot;</span>,key,value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    skip_list_dump(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    skip_list_destory(<span class=\"built_in\">list</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<h4 id=\"2-1-5-栈\"><a href=\"#2-1-5-栈\" class=\"headerlink\" title=\"2.1.5 栈\"></a>2.1.5 栈</h4><p>&emsp;栈按照后进先出(LIFO)的顺序存储和检索数据的数据结构，检索元素的顺序和存储元素顺序相反。<br>&emsp;可通过链表来实现栈stack,允许插入和删除的为栈顶(<code>top</code>),另一端为栈底(<code>bottom</code>),栈中每个元素为<code>frame</code>,栈只支持三个操作:<code>pop</code>,<code>top</code>,<code>push</code>.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> List Stack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> stack_init list_init;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stack_push</span><span class=\"params\">(Stack *<span class=\"built_in\">stack</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *data)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stack_pop</span><span class=\"params\">(Stack *<span class=\"built_in\">stack</span>, <span class=\"keyword\">void</span> **data)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> stack_peek(stack) ((stack)-&gt;head == NULL ? NULL : (stack)-&gt;head-&gt;data);</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> stack_size list_size;</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;c语言顺序栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 元素elem进栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">char</span> *a, <span class=\"keyword\">int</span> top, <span class=\"keyword\">char</span> elem)</span> </span>&#123;</span><br><span class=\"line\">    a[++top] = elem;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 数据元素出栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"keyword\">char</span> *a, <span class=\"keyword\">int</span> top)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (top == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    top--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<details>\n<summary>arrayStack</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: arrayStack</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-10-12</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Desc:   数组实现顺序栈 </span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ARRAY_STACJ_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ARRAY_STACJ_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">array_stack</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;<span class=\"comment\">/*栈的大小*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos;<span class=\"comment\">/*当前存储元素的个数，即栈顶元素下表*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *<span class=\"built_in\">array</span>;<span class=\"comment\">/*数据存储区*/</span></span><br><span class=\"line\">&#125;stArrayStack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> arrayStack_size(arrayStack) (arrayStack-&gt;size)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> arrayStack_is_empty(arrayStack) (arrayStack-&gt;pos == -1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> arrayStack_is_full(arrayStack)  (arrayStack-&gt;pos == (arrayStack-&gt;size-1))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;./arrayStack.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建并初始化顺序栈*/</span></span><br><span class=\"line\"><span class=\"function\">stArrayStack * <span class=\"title\">arrayStack_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    stArrayStack *parrStack = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    parrStack = (stArrayStack *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(stArrayStack));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parrStack == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    parrStack-&gt;size = size;</span><br><span class=\"line\">    parrStack-&gt;pos = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    parrStack-&gt;<span class=\"built_in\">array</span> = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(parrStack-&gt;<span class=\"built_in\">array</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(parrStack);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> parrStack;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*销毁顺序栈*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">arrayStack_destory</span><span class=\"params\">(stArrayStack * parrStack)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(parrStack == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parrStack-&gt;<span class=\"built_in\">array</span> != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(parrStack-&gt;<span class=\"built_in\">array</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(parrStack);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*出栈*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrayStack_pop</span><span class=\"params\">(stArrayStack *parrStack)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arrayStack_is_empty(parrStack)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    data = parrStack-&gt;<span class=\"built_in\">array</span>[parrStack-&gt;pos];</span><br><span class=\"line\">    parrStack-&gt;pos--;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*入栈*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrayStack_push</span><span class=\"params\">(stArrayStack *parrStack,<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arrayStack_is_full(parrStack)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parrStack-&gt;pos++;</span><br><span class=\"line\">    parrStack-&gt;<span class=\"built_in\">array</span>[parrStack-&gt;pos] = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrayStack_push_new</span><span class=\"params\">(stArrayStack*parrStack,<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*如果栈不满，直接插入*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!arrayStack_is_full(parrStack)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arrayStack_push(parrStack,data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*如果栈已经满，申请内存*/</span></span><br><span class=\"line\">    ptmp = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">2</span>*parrStack-&gt;size*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptmp == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(ptmp,parrStack-&gt;<span class=\"built_in\">array</span>,parrStack-&gt;size*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(parrStack-&gt;<span class=\"built_in\">array</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    parrStack-&gt;<span class=\"built_in\">array</span> = ptmp;</span><br><span class=\"line\">    parrStack-&gt;size = <span class=\"number\">2</span>*parrStack-&gt;size;</span><br><span class=\"line\">    parrStack-&gt;pos++;</span><br><span class=\"line\">    parrStack-&gt;<span class=\"built_in\">array</span>[parrStack-&gt;pos] = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">arrayStack_dump</span><span class=\"params\">(stArrayStack *parrStack)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arrayStack_is_empty(parrStack)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n arrayStack is empty.&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\narrayStack size = %d,pos= %d,&quot;</span>,</span><br><span class=\"line\">    parrStack-&gt;size,parrStack-&gt;pos);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt;= parrStack-&gt;pos; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\narry[%d] = %d&quot;</span>,i,parrStack-&gt;<span class=\"built_in\">array</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    stArrayStack * parrStack = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n create size = 4 arrayStack.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    parrStack = arrayStack_create(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parrStack == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n create size = 4 arrayStack faided.&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        ret = arrayStack_push(parrStack,i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n push size = %d arrayStack faided.&quot;</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arrayStack_dump(parrStack);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ret = arrayStack_push_new(parrStack,<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n push size = %d arrayStack faided.&quot;</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arrayStack_dump(parrStack);</span><br><span class=\"line\">    arrayStack_destory(parrStack);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<p>&emsp;链栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lineStack</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lineStack</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;lineStack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">lineStack* <span class=\"title\">push</span><span class=\"params\">(lineStack * <span class=\"built_in\">stack</span>, <span class=\"keyword\">char</span> a)</span></span>&#123;</span><br><span class=\"line\">    lineStack * line=(lineStack*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(lineStack));</span><br><span class=\"line\">    line-&gt;data=a;</span><br><span class=\"line\">    line-&gt;next=<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>=line;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">lineStack * <span class=\"title\">pop</span><span class=\"params\">(lineStack * <span class=\"built_in\">stack</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span>) &#123;</span><br><span class=\"line\">        lineStack * p=<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>=<span class=\"built_in\">stack</span>-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;弹栈元素：%c &quot;</span>,p-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈顶元素：%c\\n&quot;</span>,<span class=\"built_in\">stack</span>-&gt;data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈已空\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈内没有元素&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>linklist_stack</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: linklist_stack</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-10-12</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Desc:    </span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> STACK_LINK_LIST_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_LINK_LIST_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">linkliststack</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">linkliststack</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;linklist_stack;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> stack_is_empty(liststack) (liststack-&gt;next == NULL)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;./linklist_stack.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">linklist_stack * <span class=\"title\">stack_create</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    linklist_stack * <span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span> = (linklist_stack *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(linklist_stack));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">stack_destory</span><span class=\"params\">(linklist_stack* <span class=\"built_in\">stack</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    linklist_stack * ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!stack_is_empty(<span class=\"built_in\">stack</span>)) &#123;</span><br><span class=\"line\">        ptmp = <span class=\"built_in\">stack</span>-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>-&gt;next = <span class=\"built_in\">stack</span>-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(ptmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stack_push</span><span class=\"params\">(linklist_stack *<span class=\"built_in\">stack</span>,<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    linklist_stack * ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ptmp = (linklist_stack *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(linklist_stack));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptmp == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ptmp-&gt;data = data;</span><br><span class=\"line\">    ptmp-&gt;next = <span class=\"built_in\">stack</span>-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;next = ptmp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stack_pop</span><span class=\"params\">(linklist_stack*<span class=\"built_in\">stack</span>,<span class=\"keyword\">int</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    linklist_stack *ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(stack_is_empty(<span class=\"built_in\">stack</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *data = <span class=\"built_in\">stack</span>-&gt;next-&gt;data;</span><br><span class=\"line\">    ptmp = <span class=\"built_in\">stack</span>-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;next = ptmp-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptmp);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">stack_dump</span><span class=\"params\">(linklist_stack *<span class=\"built_in\">stack</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    linklist_stack * ptmp = <span class=\"built_in\">stack</span>-&gt;next;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ptmp != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n data = %d&quot;</span>,ptmp-&gt;data);</span><br><span class=\"line\">        ptmp = ptmp-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\">    linklist_stack * <span class=\"built_in\">stack</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span> = stack_create();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n stack create falied.&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">        ret = stack_push(<span class=\"built_in\">stack</span>,i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n stack push %d falied.&quot;</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack_dump(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        ret = stack_pop(<span class=\"built_in\">stack</span>,&amp;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n stack pop%d falied.&quot;</span>, i);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n data = %d,&quot;</span>,data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack_destory(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<h4 id=\"2-1-6-队列\"><a href=\"#2-1-6-队列\" class=\"headerlink\" title=\"2.1.6 队列\"></a>2.1.6 队列</h4><p>&emsp;队列，在前端(<code>front</code>)进行删除操作，后端(<code>rear</code>)进行插入操作; 按照先进先出(<code>FIFO</code>)的顺序存储和检索数据的高效数据结构，按照元素的存储顺序检索元素。<br>&emsp;队列也可通过数组和链表实现。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> List Queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> queue_init list_init;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> queue_destroy list_destroy;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">queue_enqueue</span><span class=\"params\">(Queue *<span class=\"built_in\">queue</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *data)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">queue_dequeue</span><span class=\"params\">(Queue *<span class=\"built_in\">queue</span>, <span class=\"keyword\">void</span> **data)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> queue_peek(queue) ((queue)-&gt;head == NULL ? NULL : (queue)-&gt;head-&gt;data);</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> queue_size list_size;</span></span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>array_queue</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: array_queue</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-10-12</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Desc:    </span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ARRAY_QUEUE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ARRAY_QUEUE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">array_queue</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;<span class=\"comment\">/*队列的大小*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num; <span class=\"comment\">/*当前存储数据的大小*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> head;<span class=\"comment\">/*队列的头*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tail;<span class=\"comment\">/*队列的尾*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *<span class=\"built_in\">array</span>;<span class=\"comment\">/*数据存储区*/</span></span><br><span class=\"line\">&#125;array_queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> array_queue_is_empty(array_queue) (array_queue-&gt;num == 0)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> array_queue_is_full(array_queue)  ((array_queue-&gt;num) == (array_queue-&gt;size))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;./array_queue.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">array_queue * <span class=\"title\">array_queue_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    array_queue * <span class=\"built_in\">queue</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> = (array_queue*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(array_queue));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span> = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;size  = size;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num   = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head  = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;tail  = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">array_queue_destory</span><span class=\"params\">(array_queue *<span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span> != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*入队列 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">array_queue_enqueue</span><span class=\"params\">(array_queue *<span class=\"built_in\">queue</span>,<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*队列为空，或者队列满时，返回-1*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) || (array_queue_is_full(<span class=\"built_in\">queue</span>))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num++;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span>[<span class=\"built_in\">queue</span>-&gt;tail] = data;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;tail = (<span class=\"built_in\">queue</span>-&gt;tail + <span class=\"number\">1</span>) % <span class=\"built_in\">queue</span>-&gt;size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*出队列*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">array_queue_dequeue</span><span class=\"params\">(array_queue * <span class=\"built_in\">queue</span>,<span class=\"keyword\">int</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*队列为空，数据存储为空，队列为空时返回-1*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) || (data == <span class=\"literal\">NULL</span>) || (array_queue_is_empty(<span class=\"built_in\">queue</span>))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *data = <span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span>[<span class=\"built_in\">queue</span>-&gt;head];</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num--;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = (<span class=\"built_in\">queue</span>-&gt;head + <span class=\"number\">1</span>) % <span class=\"built_in\">queue</span>-&gt;size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">array_queue_dump</span><span class=\"params\">(array_queue *<span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) || (array_queue_is_empty(<span class=\"built_in\">queue</span>))) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n queue is empty&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n size:%d,num:%d,head:%d,tali:%d&quot;</span>,</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;size,<span class=\"built_in\">queue</span>-&gt;num,<span class=\"built_in\">queue</span>-&gt;head,<span class=\"built_in\">queue</span>-&gt;tail);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">queue</span>-&gt;num; i ++) &#123;</span><br><span class=\"line\">        pos = (<span class=\"built_in\">queue</span>-&gt;head + i) %<span class=\"built_in\">queue</span>-&gt;size;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n array[%d] = %d&quot;</span>,pos,<span class=\"built_in\">queue</span>-&gt;<span class=\"built_in\">array</span>[pos]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\">    array_queue * <span class=\"built_in\">queue</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> = array_queue_create(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n queue is create failed.&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*队列时空时，出队返回错误*/</span></span><br><span class=\"line\">    ret = array_queue_dequeue(<span class=\"built_in\">queue</span>, &amp;data);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n queue %d dequeue failed.&quot;</span>,ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*队列大小是4，入队5个，最后一个报错*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        ret = array_queue_enqueue(<span class=\"built_in\">queue</span>,i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n queue %d enqueue failed.&quot;</span>,i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    array_queue_dump(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ret = array_queue_dequeue(<span class=\"built_in\">queue</span>, &amp;data);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n queue %d dequeue failed.&quot;</span>,i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n queue %d dequue.&quot;</span>,data);</span><br><span class=\"line\">    array_queue_dump(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    data = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n queue %d enqueue.&quot;</span>,data);</span><br><span class=\"line\">    ret = array_queue_enqueue(<span class=\"built_in\">queue</span>,data);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n queue %d enqueue failed.&quot;</span>,data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    array_queue_dump(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    array_queue_destory(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<details>\n<summary>list_queue</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> LINK_LIST_QUEUE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LINK_LIST_QUEUE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">list_queue_node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">list_queue_node</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;queue_node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">list_queue</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    queue_node *head;</span><br><span class=\"line\">    queue_node *tail;</span><br><span class=\"line\">&#125;list_queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> list_queue_is_empty(queue) ((queue-&gt;num) == 0)</span></span><br><span class=\"line\"><span class=\"function\">list_queue *<span class=\"title\">list_queue_create</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">list_queue_enqueue</span><span class=\"params\">(list_queue *<span class=\"built_in\">queue</span>,<span class=\"keyword\">void</span> *data)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">list_queue_dequeue</span><span class=\"params\">(list_queue *<span class=\"built_in\">queue</span>,<span class=\"keyword\">void</span> **data)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;./list_queue.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建队列头*/</span></span><br><span class=\"line\"><span class=\"function\">list_queue *<span class=\"title\">list_queue_create</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    list_queue * <span class=\"built_in\">queue</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> = (list_queue *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(list_queue));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num  = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*入队*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">list_queue_enqueue</span><span class=\"params\">(list_queue *<span class=\"built_in\">queue</span>,<span class=\"keyword\">void</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    queue_node *ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ptmp = (queue_node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(queue_node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptmp == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ptmp-&gt;data = data;</span><br><span class=\"line\">    ptmp-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;head == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;head = ptmp;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;tail-&gt;next = ptmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;tail = ptmp;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*出队*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">list_queue_dequeue</span><span class=\"params\">(list_queue *<span class=\"built_in\">queue</span>,<span class=\"keyword\">void</span> **data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    queue_node * ptmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">queue</span> == <span class=\"literal\">NULL</span>) || (data == <span class=\"literal\">NULL</span>) || list_queue_is_empty(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *data = <span class=\"built_in\">queue</span>-&gt;head-&gt;data;</span><br><span class=\"line\">    ptmp = <span class=\"built_in\">queue</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = <span class=\"built_in\">queue</span>-&gt;head-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;num--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;head == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<details>\n<summary>ring_queue</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ring_queue</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cap;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> head, tail;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *_q;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">alloc_queue</span><span class=\"params\">(struct ring_queue* <span class=\"built_in\">queue</span>, <span class=\"keyword\">int</span> cap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span> || cap &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>-&gt;_q)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;_q = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(cap * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">queue</span>-&gt;_q)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = <span class=\"built_in\">queue</span>-&gt;tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;cap = cap;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">free_queue</span><span class=\"params\">(struct ring_queue *<span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;cap = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = <span class=\"built_in\">queue</span>-&gt;tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">queue</span>-&gt;_q);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> _valid_index(<span class=\"keyword\">int</span> curr, <span class=\"keyword\">int</span> step, <span class=\"keyword\">int</span> cap)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (curr + step) % cap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> _next(<span class=\"keyword\">int</span> curr, <span class=\"keyword\">int</span> cap)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _valid_index(curr, <span class=\"number\">1</span>, cap);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_empty</span><span class=\"params\">(struct ring_queue *<span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">queue</span>-&gt;head == <span class=\"built_in\">queue</span>-&gt;tail);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_full</span><span class=\"params\">(struct ring_queue *<span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> next_tail = _next(<span class=\"built_in\">queue</span>-&gt;tail, <span class=\"built_in\">queue</span>-&gt;cap);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (next_tail == <span class=\"built_in\">queue</span>-&gt;head);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">enqueue</span><span class=\"params\">(struct ring_queue* <span class=\"built_in\">queue</span>, <span class=\"keyword\">int</span> elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_full(<span class=\"built_in\">queue</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;_q[<span class=\"built_in\">queue</span>-&gt;tail] = elem;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;tail = _next(<span class=\"built_in\">queue</span>-&gt;tail, <span class=\"built_in\">queue</span>-&gt;cap);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dequeue</span><span class=\"params\">(struct ring_queue* <span class=\"built_in\">queue</span>, <span class=\"keyword\">int</span> *elem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_empty(<span class=\"built_in\">queue</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elem)</span><br><span class=\"line\">    *elem = <span class=\"built_in\">queue</span>-&gt;_q[<span class=\"built_in\">queue</span>-&gt;head];</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>-&gt;head = _next(<span class=\"built_in\">queue</span>-&gt;head, <span class=\"built_in\">queue</span>-&gt;cap);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">(struct ring_queue* <span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"built_in\">queue</span>-&gt;tail - <span class=\"built_in\">queue</span>-&gt;head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    size += <span class=\"built_in\">queue</span>-&gt;cap;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(struct ring_queue* <span class=\"built_in\">queue</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, idx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Queue has %d elements with %d capacity\\n&quot;</span>,</span><br><span class=\"line\">    size(<span class=\"built_in\">queue</span>), <span class=\"built_in\">queue</span>-&gt;cap);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size(<span class=\"built_in\">queue</span>); i++) &#123;</span><br><span class=\"line\">        idx = _valid_index(<span class=\"built_in\">queue</span>-&gt;head, i, <span class=\"built_in\">queue</span>-&gt;cap);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%02d]: %08d\\n&quot;</span>, idx, <span class=\"built_in\">queue</span>-&gt;_q[idx]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ring_queue</span> <span class=\"title\">queue</span> =</span> &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (alloc_queue(&amp;<span class=\"built_in\">queue</span>, <span class=\"number\">8</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Failed to allocate a queue\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;A new queue is %s\\n&quot;</span>, is_empty(&amp;<span class=\"built_in\">queue</span>)?<span class=\"string\">&quot;empty&quot;</span>:<span class=\"string\">&quot;not empty&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    enqueue(&amp;<span class=\"built_in\">queue</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;After enqueue 1 element, queue is %s\\n&quot;</span>, is_empty(&amp;<span class=\"built_in\">queue</span>)?<span class=\"string\">&quot;empty&quot;</span>:<span class=\"string\">&quot;not empty&quot;</span>);</span><br><span class=\"line\">    dequeue(&amp;<span class=\"built_in\">queue</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;After dequeue 1 element, queue is %s\\n&quot;</span>, is_empty(&amp;<span class=\"built_in\">queue</span>)?<span class=\"string\">&quot;empty&quot;</span>:<span class=\"string\">&quot;not empty&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">    enqueue(&amp;<span class=\"built_in\">queue</span>, i);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;After enqueue 7 element, queue is %s\\n&quot;</span>, is_full(&amp;<span class=\"built_in\">queue</span>)?<span class=\"string\">&quot;full&quot;</span>:<span class=\"string\">&quot;not full&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">        dequeue(&amp;<span class=\"built_in\">queue</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        enqueue(&amp;<span class=\"built_in\">queue</span>, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;After enqueue/dequeue 4 element, queue is %s\\n&quot;</span>,</span><br><span class=\"line\">    is_full(&amp;<span class=\"built_in\">queue</span>)?<span class=\"string\">&quot;full&quot;</span>:<span class=\"string\">&quot;not full&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Head is %d, Tail is %d\\n&quot;</span>, <span class=\"built_in\">queue</span>.head, <span class=\"built_in\">queue</span>.tail);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(&amp;<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    free_queue(&amp;<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<p>&ensp;队列应用：进程通信<br>&emsp;消息队列提供了从一个进程向另一个进程发送一个数据块的方法.每个数据库都认为含有一个类型,接收进程可以独立地接收含有不同类型的数据结构.</p>\n<p>&emsp;linux内核 &lt;sys/msg.h&gt; 头文件中定义了消息队列结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msqid_ds</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">msg_perm</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msg</span>* <span class=\"title\">msg_first</span>;</span> <span class=\"comment\">// 指向队列中第一个消息</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msg</span>* <span class=\"title\">msg_last</span>;</span> <span class=\"comment\">// 队列中最后一个消息</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;Linux消息队列函数接口</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建和访问一个消息队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 把消息添加到消息队列中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgsnd</span><span class=\"params\">(<span class=\"keyword\">int</span> msgid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_sz, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 从一个消息对立获取消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgrcv</span><span class=\"params\">(<span class=\"keyword\">int</span> msgid, <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_st, <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> msgtype, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 控制消息队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgctl</span><span class=\"params\">(<span class=\"keyword\">int</span> msgid, <span class=\"keyword\">int</span> command, struct msgid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-7-leetcode题目\"><a href=\"#2-1-7-leetcode题目\" class=\"headerlink\" title=\"2.1.7 leetcode题目\"></a>2.1.7 leetcode题目</h4><ul>\n<li><p>重复N次的元素&lt;数组&gt;</p>\n</li>\n<li><p>两数相加&lt;链表&gt;</p>\n</li>\n<li><p>基本计算器&lt;栈&gt;</p>\n</li>\n<li><p>设计循环队列&lt;队列&gt;</p>\n</li>\n</ul>\n<h3 id=\"2-2-哈希表\"><a href=\"#2-2-哈希表\" class=\"headerlink\" title=\"2.2 哈希表\"></a>2.2 哈希表</h3><p>&ensp;哈希表是一种最有效的检索方法，散列，从本质上看，一个哈希表包含一个数组，通过特殊的索引（键）来访问数组中的元素。哈希表主要思想是通过一个哈希函数，在所有可能的键和值直接建立映射表。<br>&ensp;每个记录的关键字k通过一种函数H(k)计算出函数值.此函数为哈希函数或散列函数.</p>\n<h4 id=\"2-2-1-哈希函数设计\"><a href=\"#2-2-1-哈希函数设计\" class=\"headerlink\" title=\"2.2.1 哈希函数设计\"></a>2.2.1 哈希函数设计</h4><ul>\n<li><p>直接地址法<br>关键字是整数类型的数据,直接地址的哈希函数H直接利用关键字求得哈希地址.<br>H(k) = aK*i + b</p>\n</li>\n<li><p>数字分析法<br>取关键字数中分布均匀的若干作为哈希地址</p>\n</li>\n<li><p>平方取中法<br>取关键字平方中间几位作为散列地址</p>\n</li>\n<li><p>折叠法<br>把关键字分割成位数相同的几段，段的位数取决于哈希地址的位数，然后将它们叠加和作为哈希地址</p>\n</li>\n<li><p>除留取余法<br>关键字K除以一个合适的不大于哈希表长度的正整数P,所得余数作为哈希地址.<br>H(K) = K MOD P</p>\n</li>\n</ul>\n<details>\n<summary>uthash用法</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; File Name: listhash.h</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Author:  jinshaohui</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Time:    18-11-06</span></span><br><span class=\"line\"><span class=\"comment\"> &gt; Desc: 根据linux内核模块hashtab编写用户层hashtab接口</span></span><br><span class=\"line\"><span class=\"comment\">         linux-4.19.1\\security\\selinux\\ss\\hashtab.c</span></span><br><span class=\"line\"><span class=\"comment\">     linux-4.19.1\\security\\selinux\\ss\\hashtab.h</span></span><br><span class=\"line\"><span class=\"comment\"> ************************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __HASHTAB_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __HASHTAB_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">hashtab_node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> * key;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> * data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">hashtab_node</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;hashtab_node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">hashtab</span> &#123;</span></span><br><span class=\"line\">    hashtab_node **htables; <span class=\"comment\">/*哈希桶*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;              <span class=\"comment\">/*哈希桶的最大数量*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nel;               <span class=\"comment\">/*哈希桶中元素的个数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*hash_value)(struct _hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key); <span class=\"comment\">/*哈希函数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*keycmp)(struct _hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);<span class=\"comment\">/*哈希key比较函数，当哈希数值一致时使用*/</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*hash_node_free)(hashtab_node *node);</span><br><span class=\"line\">&#125;hashtab;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HASHTAB_MAX_NODES  (0xffffffff)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*hash_key_func)</span><span class=\"params\">(struct _hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key)</span></span>; <span class=\"comment\">/*哈希函数*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*keycmp_func)</span><span class=\"params\">(struct _hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2)</span></span>;<span class=\"comment\">/*哈希key比较函数，当哈希数值一致时使用*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*hash_node_free_func)</span><span class=\"params\">(hashtab_node *node)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">/*根据当前结构体元素的地址，获取到结构体首地址*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> offsetof(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> container(ptr,type,member) (&#123;\\</span></span><br><span class=\"line\"><span class=\"meta\">  const typeof( ((type *)0)-&gt;member) *__mptr = (ptr);\\</span></span><br><span class=\"line\"><span class=\"meta\">  (type *) ( (char *)__mptr - offsetof(type,member));&#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">hashtab * <span class=\"title\">hashtab_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size,hash_key_func hash_value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        keycmp_func keycmp,hash_node_free_func hash_node_free)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hashtab_destory</span><span class=\"params\">(hashtab *h)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashtab_insert</span><span class=\"params\">(hashtab * h,<span class=\"keyword\">void</span> *key,<span class=\"keyword\">void</span> *data)</span></span>;</span><br><span class=\"line\"><span class=\"function\">hashtab_node *<span class=\"title\">hashtab_delete</span><span class=\"params\">(hashtab *h, <span class=\"keyword\">void</span> *key)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">hashtab_search</span><span class=\"params\">(hashtab*h,<span class=\"keyword\">void</span> *key)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;listhash.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> MEMORY_TEST</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;mcheck.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">hashtab * <span class=\"title\">hashtab_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size,hash_key_func hash_value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    keycmp_func keycmp,hash_node_free_func hash_node_free)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    hashtab * h = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size &lt; <span class=\"number\">0</span>) || (hash_value == <span class=\"literal\">NULL</span>) || (keycmp == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    h = (hashtab *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(hashtab));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    h-&gt;htables = (hashtab_node **)<span class=\"built_in\">malloc</span>(size * <span class=\"keyword\">sizeof</span>(hashtab_node*));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h-&gt;htables == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    h-&gt;size = size;</span><br><span class=\"line\">    h-&gt;nel = <span class=\"number\">0</span>;</span><br><span class=\"line\">    h-&gt;hash_value = hash_value;</span><br><span class=\"line\">    h-&gt;keycmp = keycmp;</span><br><span class=\"line\">    h-&gt;hash_node_free = hash_node_free;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        h-&gt;htables[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hashtab_destory</span><span class=\"params\">(hashtab *h)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hashtab_node * cur = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    hashtab_node * tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt;h-&gt;size; i++) &#123;</span><br><span class=\"line\">        cur = h-&gt;htables[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            tmp = cur;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">            h-&gt;hash_node_free(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h-&gt;htables[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">free</span>(h-&gt;htables);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(h);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashtab_insert</span><span class=\"params\">(hashtab * h,<span class=\"keyword\">void</span> *key,<span class=\"keyword\">void</span> *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> hvalue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hashtab_node *cur = <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">    hashtab_node *prev = <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">    hashtab_node *newnode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((h == <span class=\"literal\">NULL</span>) || (key == <span class=\"literal\">NULL</span>) || (data == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*获取hash 数值*/</span></span><br><span class=\"line\">    hvalue = h-&gt;hash_value(h,key);</span><br><span class=\"line\">    cur = h-&gt;htables[hvalue];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((cur != <span class=\"literal\">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        prev = cur;</span><br><span class=\"line\">        cur = cur-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*如果key和当前key比对一致，直接返回，数据已经存在*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((cur != <span class=\"literal\">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    newnode = (hashtab_node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(hashtab_node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newnode == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    newnode-&gt;key = key;</span><br><span class=\"line\">    newnode-&gt;data = data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        newnode-&gt;next = h-&gt;htables[hvalue];</span><br><span class=\"line\">        h-&gt;htables[hvalue] = newnode;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newnode-&gt;next = prev-&gt;next;</span><br><span class=\"line\">        prev-&gt;next = newnode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    h-&gt;nel++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">hashtab_node *<span class=\"title\">hashtab_delete</span><span class=\"params\">(hashtab *h, <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hvalue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hashtab_node *cur = <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">    hashtab_node *prev = <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((h == <span class=\"literal\">NULL</span>) || (key == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*获取hash 数值*/</span></span><br><span class=\"line\">    hvalue = h-&gt;hash_value(h,key);</span><br><span class=\"line\">    cur = h-&gt;htables[hvalue];</span><br><span class=\"line\">    <span class=\"comment\">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((cur != <span class=\"literal\">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h-&gt;keycmp(h,key,cur-&gt;key) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                        h-&gt;htables[hvalue] = cur-&gt;next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        prev-&gt;next = cur-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        prev = cur;</span><br><span class=\"line\">        cur = cur-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">hashtab_search</span><span class=\"params\">(hashtab*h,<span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hvalue = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hashtab_node *cur = <span class=\"literal\">NULL</span>; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((h == <span class=\"literal\">NULL</span>) || (key == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*获取hash 数值*/</span></span><br><span class=\"line\">    hvalue = h-&gt;hash_value(h,key);</span><br><span class=\"line\">    cur = h-&gt;htables[hvalue];</span><br><span class=\"line\">    <span class=\"comment\">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((cur != <span class=\"literal\">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h-&gt;keycmp(h,key,cur-&gt;key) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur-&gt;data;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur = cur-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hashtab_dump</span><span class=\"params\">(hashtab *h)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hashtab_node * cur = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n----开始--size[%d],nel[%d]------------&quot;</span>,h-&gt;size,h-&gt;nel);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; h-&gt;size; i ++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n htables[%d]:&quot;</span>,i);</span><br><span class=\"line\">        cur = h-&gt;htables[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>((cur != <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;key[%s],data[%s] &quot;</span>,cur-&gt;key,cur-&gt;data);    </span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n----结束--size[%d],nel[%d]------------&quot;</span>,h-&gt;size,h-&gt;nel);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">test_node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> key[<span class=\"number\">80</span>];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> data[<span class=\"number\">80</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">siample_hash</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> hash = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> seed = <span class=\"number\">131</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(*str) &#123;</span><br><span class=\"line\">        hash = hash*seed + *str++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash &amp; (<span class=\"number\">0x7FFFFFFF</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashtab_hvalue</span><span class=\"params\">(hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (siample_hash(key) % h-&gt;size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashtab_keycmp</span><span class=\"params\">(hashtab *h,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(key1,key2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hashtab_node_free</span><span class=\"params\">(hashtab_node*node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">test_node</span> * <span class=\"title\">ptmp</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    ptmp = container(node-&gt;key,struct test_node,key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(ptmp);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *pres = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    hashtab_node * node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">test_node</span> *<span class=\"title\">p</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    hashtab *h = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> MEMORY_TEST</span></span><br><span class=\"line\">    setenv(<span class=\"string\">&quot;MALLOC_TRACE&quot;</span>,<span class=\"string\">&quot;1.txt&quot;</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    mtrace();</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    h = hashtab_create(<span class=\"number\">5</span>,hashtab_hvalue,hashtab_keycmp,hashtab_node_free);</span><br><span class=\"line\">    assert(h!= <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        p = (struct test_node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct test_node));</span><br><span class=\"line\">        assert(p != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n 请输入key 和value，当可以等于\\&quot;quit\\&quot;时退出&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,p-&gt;key);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,p-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(p-&gt;key,<span class=\"string\">&quot;quit&quot;</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        res = hashtab_insert(h,p-&gt;key,p-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n key[%s],data[%s] insert failed %d&quot;</span>,p-&gt;key,p-&gt;data,res);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n key[%s],data[%s] insert success %d&quot;</span>,p-&gt;key,p-&gt;data,res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    hashtab_dump(h);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        p = (struct test_node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct test_node));</span><br><span class=\"line\">        assert(p != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n 请输入key 查询value的数值，当可以等于\\&quot;quit\\&quot;时退出&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,p-&gt;key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(p-&gt;key,<span class=\"string\">&quot;quit&quot;</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pres = hashtab_search(h,p-&gt;key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pres == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n key[%s] search data failed&quot;</span>,p-&gt;key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n key[%s],search data[%s] success&quot;</span>,p-&gt;key,pres);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hashtab_dump(h);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        p = (struct test_node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct test_node));</span><br><span class=\"line\">        assert(p != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n 请输入key 删除节点的数值，当可以等于\\&quot;quit\\&quot;时退出&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,p-&gt;key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(p-&gt;key,<span class=\"string\">&quot;quit&quot;</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        node = hashtab_delete(h,p-&gt;key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n key[%s] delete node failed &quot;</span>,p-&gt;key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n key[%s],delete data[%s] success&quot;</span>,node-&gt;key,node-&gt;data);</span><br><span class=\"line\">            h-&gt;hash_node_free(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">        hashtab_dump(h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    hashtab_destory(h);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> MEMORY_TEST</span></span><br><span class=\"line\">        muntrace();</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<details>\n<summary>hash_table</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* One implementation of hash table with linear probing. */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HASH_SHIFT 4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HASH_SIZE (1 &lt;&lt; HASH_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HASH_MASK (HASH_SIZE - 1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hash_table</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>  used;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> entry[HASH_SIZE];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_reset</span><span class=\"params\">(struct hash_table *table)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    table-&gt;used = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HASH_SIZE; i++)</span><br><span class=\"line\">    table-&gt;entry[i] = ~<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">hash_function</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value &amp; HASH_MASK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump_hash_table</span><span class=\"params\">(struct hash_table *table)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HASH_SIZE; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table-&gt;entry[i] == ~<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%2u:       nil \\n&quot;</span>, i);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%2u:%10lu -&gt; %2u\\n&quot;</span>,</span><br><span class=\"line\">        i, table-&gt;entry[i],</span><br><span class=\"line\">        hash_function(table-&gt;entry[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_function_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    srandom(time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> val = random();</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%10lu -&gt; %2u\\n&quot;</span>, val, hash_function(val));;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">next_probe</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prev_key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (prev_key + <span class=\"number\">1</span>) &amp; HASH_MASK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">next_probe_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> key1, key2;</span><br><span class=\"line\"></span><br><span class=\"line\">    key1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HASH_SIZE; i++) &#123;</span><br><span class=\"line\">        key2 = next_probe(key1);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%2u -&gt; %2u\\n&quot;</span>, key1, key2);</span><br><span class=\"line\">        key1 = key2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_add</span><span class=\"params\">(struct hash_table *table, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> key = hash_function(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (table-&gt;used &gt;= HASH_SIZE)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (table-&gt;entry[key] != ~<span class=\"number\">0</span>)</span><br><span class=\"line\">        key = next_probe(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    table-&gt;entry[key] = value;</span><br><span class=\"line\">    table-&gt;used++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">hash_table_slot</span><span class=\"params\">(struct hash_table *table, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> key = hash_function(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HASH_SIZE; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table-&gt;entry[key] == value || table-&gt;entry[key] == ~<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        key = next_probe(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hash_table_find</span><span class=\"params\">(struct hash_table *table, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> table-&gt;entry[hash_table_slot(table, value)] == value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_del</span><span class=\"params\">(struct hash_table *table, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i, j, k;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hash_table_find(table, value))</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    i = j = hash_table_slot(table, value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        table-&gt;entry[i] = ~<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            j = next_probe(j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table-&gt;entry[j] == ~<span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            k = hash_function(table-&gt;entry[j]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ((i &lt;= j) ? (i &lt; k &amp;&amp; k &lt;= j) : (i &lt; k || k &lt;= j));</span><br><span class=\"line\"></span><br><span class=\"line\">        table-&gt;entry[i] = table-&gt;entry[j];</span><br><span class=\"line\">        i = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    table-&gt;used++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_add_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hash_table</span> <span class=\"title\">table</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    hash_table_reset(&amp;table);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">87645</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Table has%s 87645\\n&quot;</span>,</span><br><span class=\"line\">    hash_table_find(&amp;table, <span class=\"number\">87645</span>) ? <span class=\"string\">&quot;&quot;</span>:<span class=\"string\">&quot;n&#x27;t&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Table has%s 87647\\n&quot;</span>,</span><br><span class=\"line\">    hash_table_find(&amp;table, <span class=\"number\">87647</span>) ? <span class=\"string\">&quot;&quot;</span>:<span class=\"string\">&quot;n&#x27;t&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_del_test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hash_table</span> <span class=\"title\">table</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    hash_table_reset(&amp;table);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x1ff0</span>);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x2ff0</span>);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x3ff0</span>);</span><br><span class=\"line\">    dump_hash_table(&amp;table);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=== Remove 0x1ff0\\n&quot;</span>);</span><br><span class=\"line\">    hash_table_del(&amp;table, <span class=\"number\">0x1ff0</span>);</span><br><span class=\"line\">    dump_hash_table(&amp;table);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hash_table_del_test2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hash_table</span> <span class=\"title\">table</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    hash_table_reset(&amp;table);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x1ff0</span>);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x1ff1</span>);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x1ff2</span>);</span><br><span class=\"line\">    hash_table_add(&amp;table, <span class=\"number\">0x2ff0</span>);</span><br><span class=\"line\">    dump_hash_table(&amp;table);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=== Remove 0x1ff0\\n&quot;</span>);</span><br><span class=\"line\">    hash_table_del(&amp;table, <span class=\"number\">0x1ff0</span>);</span><br><span class=\"line\">    dump_hash_table(&amp;table);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//hash_function_test();</span></span><br><span class=\"line\">    <span class=\"comment\">//next_probe_test();</span></span><br><span class=\"line\">    <span class=\"comment\">//hash_table_add_test();</span></span><br><span class=\"line\">    hash_table_del_test2();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<h4 id=\"2-2-2-哈希冲突\"><a href=\"#2-2-2-哈希冲突\" class=\"headerlink\" title=\"2.2.2 哈希冲突\"></a>2.2.2 哈希冲突</h4><p>&ensp;理想情况下,哈希函数在关键字和地址之间建立一对一关系.但H(k1) = H(k2),即为冲突.</p>\n<p>&emsp;解决哈希冲突常用方法:</p>\n<ul>\n<li>链地址法<br>将哈希值相同的元素构成一个同义词的单链表,并将单链表头指针存放在哈希表的地i个单元中,查找,插入和删除主要在同义词链表中.</li>\n<li>线性探测</li>\n<li>二次探测</li>\n</ul>\n<h4 id=\"2-2-3-uthash\"><a href=\"#2-2-3-uthash\" class=\"headerlink\" title=\"2.2.3 uthash\"></a>2.2.3 uthash</h4><p>&ensp;uthash的插入、查找、删除的操作时间都是常量</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;uthash.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;            <span class=\"comment\">/* we&#x27;ll use this field as the key */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\">    UT_hash_handle hh; <span class=\"comment\">/* makes this structure hashable */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">users</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_user</span><span class=\"params\">(struct my_struct *s)</span> </span>&#123;</span><br><span class=\"line\">    HASH_ADD_INT(users, id, s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>uthash用法</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span>   <span class=\"comment\">/* gets */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span>  <span class=\"comment\">/* atoi, malloc */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span>  <span class=\"comment\">/* strcpy */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;uthash.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;                    <span class=\"comment\">/* key */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\">    UT_hash_handle hh;         <span class=\"comment\">/* makes this structure hashable */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">users</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_user</span><span class=\"params\">(<span class=\"keyword\">int</span> user_id, <span class=\"keyword\">char</span> *name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">s</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    HASH_FIND_INT(users, &amp;user_id, s);  <span class=\"comment\">/* id already in the hash? */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s==<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        s = (struct my_struct *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span> *s);</span><br><span class=\"line\">        s-&gt;id = user_id;</span><br><span class=\"line\">        HASH_ADD_INT( users, id, s );  <span class=\"comment\">/* id: name of key field */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(s-&gt;name, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct my_struct *<span class=\"title\">find_user</span><span class=\"params\">(<span class=\"keyword\">int</span> user_id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">s</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    HASH_FIND_INT(users, &amp;user_id, s);  <span class=\"comment\">/* s: output pointer */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete_user</span><span class=\"params\">(struct my_struct *user)</span> </span>&#123;</span><br><span class=\"line\">    HASH_DEL(users, user);  <span class=\"comment\">/* user: pointer to deletee */</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(user);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete_all</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">current_user</span>, *<span class=\"title\">tmp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    HASH_ITER(hh, users, current_user, tmp) &#123;</span><br><span class=\"line\">        HASH_DEL(users, current_user);  <span class=\"comment\">/* delete it (users advances to next) */</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(current_user);             <span class=\"comment\">/* free it */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_users</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">s</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(s=users; s != <span class=\"literal\">NULL</span>; s=(struct my_struct*)(s-&gt;hh.next)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;user id %d: name %s\\n&quot;</span>, s-&gt;id, s-&gt;name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">name_sort</span><span class=\"params\">(struct my_struct *a, struct my_struct *b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(a-&gt;name,b-&gt;name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">id_sort</span><span class=\"params\">(struct my_struct *a, struct my_struct *b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a-&gt;id - b-&gt;id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort_by_name</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    HASH_SORT(users, name_sort);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort_by_id</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    HASH_SORT(users, id_sort);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> in[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> id=<span class=\"number\">1</span>, running=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">my_struct</span> *<span class=\"title\">s</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> num_users;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; 1. add user\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; 2. add/rename user by id\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; 3. find user\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; 4. delete user\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; 5. delete all users\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; 6. sort items by name\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; 7. sort items by id\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; 8. print users\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; 9. count users\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;10. quit\\n&quot;</span>);</span><br><span class=\"line\">        gets(in);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(atoi(in)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name?\\n&quot;</span>);</span><br><span class=\"line\">                add_user(id++, gets(in));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;id?\\n&quot;</span>);</span><br><span class=\"line\">                gets(in); id = atoi(in);</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name?\\n&quot;</span>);</span><br><span class=\"line\">                add_user(id, gets(in));</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;id?\\n&quot;</span>);</span><br><span class=\"line\">                s = find_user(atoi(gets(in)));</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;user: %s\\n&quot;</span>, s ? s-&gt;name : <span class=\"string\">&quot;unknown&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;id?\\n&quot;</span>);</span><br><span class=\"line\">                s = find_user(atoi(gets(in)));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s) delete_user(s);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;id unknown\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">                delete_all();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">                sort_by_name();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">                sort_by_id();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">                print_users();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">9</span>:</span><br><span class=\"line\">                num_users=HASH_COUNT(users);</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;there are %u users\\n&quot;</span>, num_users);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">10</span>:</span><br><span class=\"line\">                running=<span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    delete_all();  <span class=\"comment\">/* free any structures */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<ul>\n<li>参考链接<br>官网:<a href=\"https://troydhanson.github.io/uthash/\">https://troydhanson.github.io/uthash/</a><br><a href=\"https://blog.csdn.net/fan_h_l/article/details/107241520\">https://blog.csdn.net/fan_h_l/article/details/107241520</a><br><a href=\"https://blog.csdn.net/whatday/article/details/95926766\">https://blog.csdn.net/whatday/article/details/95926766</a><br><a href=\"https://www.cnblogs.com/pam-sh/p/12827658.html\">https://www.cnblogs.com/pam-sh/p/12827658.html</a></li>\n</ul>\n<h4 id=\"2-2-4-leetcode题目\"><a href=\"#2-2-4-leetcode题目\" class=\"headerlink\" title=\"2.2.4 leetcode题目\"></a>2.2.4 leetcode题目</h4><ul>\n<li><p>设计哈希集合 </p>\n</li>\n<li><p>设计哈希映射</p>\n</li>\n<li><p>根据字符出现频率排序</p>\n</li>\n</ul>\n<h3 id=\"2-3-树与二叉树\"><a href=\"#2-3-树与二叉树\" class=\"headerlink\" title=\"2.3 树与二叉树\"></a>2.3 树与二叉树</h3><p>&emsp;树(tree)是一种用来模拟树状结构的抽象数据结构(ADT);</p>\n<p>&emsp;树的特点:</p>\n<ul>\n<li>没有父节点的节点称为根节点</li>\n<li>每个非根节点有且只有一个父节点</li>\n<li>除了根结点外,每个子节点可分为多个不相交的子树</li>\n<li>树中没有环路</li>\n</ul>\n<h4 id=\"2-3-1-概述\"><a href=\"#2-3-1-概述\" class=\"headerlink\" title=\"2.3.1 概述\"></a>2.3.1 概述</h4><ul>\n<li>节点的度: 一个节点含有子树的个数</li>\n<li>树的度: 树中最大的节点度</li>\n<li>叶节点: 度为零的节点</li>\n<li>父节点</li>\n<li>子节点</li>\n<li>兄弟节点</li>\n<li>节点的层次</li>\n<li>深度: 任意节点n,n的深度为从n到一片树叶的最长路径长,根的深度为0</li>\n<li>高度: 对任意节点n,n的高度为从n到一片树叶的最长路径长,所有树叶的高度为0.</li>\n<li>森林</li>\n</ul>\n<p>&emsp;树由称为结点的元素按照层次结构的方式组织而成。最顶端称为根。与根直接相连的结点称为根的子结点。子节点本身也可以有子结点。除根结点外，每个结点都有唯一的父结点。</p>\n<h4 id=\"2-3-2-树的种类\"><a href=\"#2-3-2-树的种类\" class=\"headerlink\" title=\"2.3.2 树的种类\"></a>2.3.2 树的种类</h4><ul>\n<li><p>无序树</p>\n</li>\n<li><p>有序树</p>\n<ul>\n<li><p>二叉树: 每个节点最多含有两个子树的树.</p>\n<ul>\n<li>完全二叉树: 对于一颗深度为d的二叉树,除第d层外,其他各层节点数目均达最大值,且第d层所有节点从左向右连续紧密排列.<ul>\n<li>满二叉树:所有叶节点都最底层的完全二叉树.</li>\n</ul>\n</li>\n<li>平衡二叉树(AVL):当且仅当任何节点的两颗子树的高度差不大于1的二叉树.</li>\n<li>排序二叉树:二叉查找树</li>\n</ul>\n</li>\n<li><p>霍夫曼树:带权路径最短的二叉树(又称最优二叉树).</p>\n</li>\n<li><p>B树:一种堆读写操作进行优化的自平衡二叉查找树,能够保持数据有序,拥有多余两个子树.</p>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>二叉树</td>\n<td>二叉查找树(BST) 笛卡尔树 MVP树 Top tree T树</td>\n</tr>\n<tr>\n<td>自平衡二叉查找树</td>\n<td>AVL树 红黑树 加权平衡树 AA树</td>\n</tr>\n<tr>\n<td>B树</td>\n<td>B树 B+树</td>\n</tr>\n<tr>\n<td>堆</td>\n<td>二项堆 斐波那契堆</td>\n</tr>\n<tr>\n<td>Trie</td>\n<td>后缀树 基数树 三叉查找树</td>\n</tr>\n</tbody></table>\n<p>&emsp;树有多种结构形式，包括二叉树、。</p>\n<h4 id=\"2-3-3-二叉树\"><a href=\"#2-3-3-二叉树\" class=\"headerlink\" title=\"2.3.3 二叉树\"></a>2.3.3 二叉树</h4><p>&ensp;二叉树两个条件:</p>\n<ul>\n<li>本身是有序树</li>\n<li>树中包含的各个节点的度不能超过2,即只能是0,1或者2</li>\n</ul>\n<p>&emsp;二叉树中结点包含三部分：一个数据成员两个左右指针。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTreeNode_</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTreeNode_</span> *<span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTreeNode_</span> *<span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125;BiTreeNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTree_</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*compare)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destroy)(<span class=\"keyword\">void</span> *data);</span><br><span class=\"line\">    BiTreeNode *root;</span><br><span class=\"line\">&#125;BiTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*树根*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tree</span>&#123;</span></span><br><span class=\"line\">    Node * root;</span><br><span class=\"line\">&#125;Tree;</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>二叉树</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;list_queue.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">treenode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">treenode</span> *<span class=\"title\">lchild</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">treenode</span> *<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;Tnode,Tree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_create</span><span class=\"params\">(Tree **Root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n输入节点数值((当输入为100时，当前节点创建完成))):&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">        *Root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        *Root = (Tnode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Tnode));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*Root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        (*Root)-&gt;data = a;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n create %d 的左孩子:&quot;</span>,a);</span><br><span class=\"line\">        binarytree_create(&amp;((*Root)-&gt;lchild));</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n create %d 的右孩子:&quot;</span>,a);</span><br><span class=\"line\">        binarytree_create(&amp;((*Root)-&gt;rchild));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_destory</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    binarytree_destory(root-&gt;lchild);</span><br><span class=\"line\">    binarytree_destory(root-&gt;rchild);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*先序遍历:根结点--》左子树---》右子树*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_preorder</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>,root-&gt;data);</span><br><span class=\"line\">    binarytree_preorder(root-&gt;lchild);</span><br><span class=\"line\">    binarytree_preorder(root-&gt;rchild);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*中序遍历:左子树--》跟节点---》右子树*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_inorder</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    binarytree_inorder(root-&gt;lchild);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>,root-&gt;data);</span><br><span class=\"line\">    binarytree_inorder(root-&gt;rchild);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*后序遍历:左子树---》右子树-》根节点*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_postorder</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    binarytree_postorder(root-&gt;lchild);</span><br><span class=\"line\">    binarytree_postorder(root-&gt;rchild);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>,root-&gt;data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_levelorder</span><span class=\"params\">(Tree * root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    list_queue *<span class=\"built_in\">queue</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Tnode * node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> = list_queue_create();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*根节点先入队*/</span></span><br><span class=\"line\">    list_queue_enqueue(<span class=\"built_in\">queue</span>,(<span class=\"keyword\">void</span> *)root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!list_queue_is_empty(<span class=\"built_in\">queue</span>)) &#123;</span><br><span class=\"line\">        list_queue_dequeue(<span class=\"built_in\">queue</span>,(<span class=\"keyword\">void</span> *)&amp;node);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>,node-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node-&gt;lchild != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            list_queue_enqueue(<span class=\"built_in\">queue</span>,(<span class=\"keyword\">void</span> *)node-&gt;lchild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node-&gt;rchild != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            list_queue_enqueue(<span class=\"built_in\">queue</span>,(<span class=\"keyword\">void</span> *)node-&gt;rchild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*打印叶子节点*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">binarytree_printfleaf</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((root-&gt;lchild == <span class=\"literal\">NULL</span>) &amp;&amp; (root-&gt;rchild == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>,root-&gt;data);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        binarytree_printfleaf(root-&gt;lchild);</span><br><span class=\"line\">        binarytree_printfleaf(root-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*打印叶子的个数*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarytree_getleafnum</span><span class=\"params\">(Tree*root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((root-&gt;lchild == <span class=\"literal\">NULL</span>) &amp;&amp; (root-&gt;rchild == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> binarytree_getleafnum(root-&gt;lchild) + binarytree_getleafnum(root-&gt;rchild);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*打印数的高度*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarytree_gethigh</span><span class=\"params\">(Tree *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lhigh = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rhigh = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lhigh = binarytree_gethigh(root-&gt;lchild);</span><br><span class=\"line\">    rhigh = binarytree_gethigh(root-&gt;rchild);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((lhigh &gt; rhigh)?(lhigh + <span class=\"number\">1</span>):(rhigh + <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Tree *root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    setenv(<span class=\"string\">&quot;MALLOC_TRACE&quot;</span>,<span class=\"string\">&quot;1.txt&quot;</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    mtrace();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n创建二叉树:&quot;</span>);</span><br><span class=\"line\">    binarytree_create(&amp;root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n先序遍历二叉树:&quot;</span>);</span><br><span class=\"line\">    binarytree_preorder(root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n中序遍历二叉树:&quot;</span>);</span><br><span class=\"line\">    binarytree_inorder(root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n后序遍历二叉树:&quot;</span>);</span><br><span class=\"line\">    binarytree_postorder(root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n层次遍历二叉树:&quot;</span>);</span><br><span class=\"line\">    binarytree_levelorder(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n打印二叉树叶子节点:&quot;</span>);</span><br><span class=\"line\">    binarytree_printfleaf(root);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n打印二叉树叶子节点个数:%d&quot;</span>,binarytree_getleafnum(root));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\r\\n打印二叉树高度:%d&quot;</span>,binarytree_gethigh(root));</span><br><span class=\"line\"></span><br><span class=\"line\">    binarytree_destory(root);</span><br><span class=\"line\"></span><br><span class=\"line\">    muntrace();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<details>\n<summary>binarytree</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Implement binary tree in array */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_TREE_NODES (1 &lt;&lt; 8)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binary_tree</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> nodes;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">n</span>[<span class=\"title\">MAX_TREE_NODES</span>];</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_binary_tree</span><span class=\"params\">(struct binary_tree *tree)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; MAX_TREE_NODES; i++) &#123;</span><br><span class=\"line\">        tree-&gt;n[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct node* <span class=\"title\">create_node</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>* <span class=\"title\">n</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct node));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n)</span><br><span class=\"line\">        n-&gt;data = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fake_a_tree</span><span class=\"params\">(struct binary_tree* tree)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* data is in ordered */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, data[<span class=\"number\">10</span>] = &#123;<span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    init_binary_tree(tree);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* root start at 1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        tree-&gt;n[i+<span class=\"number\">1</span>] = create_node(data[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    tree-&gt;nodes = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _in_order(struct binary_tree* tree, <span class=\"keyword\">int</span> index)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tree-&gt;n[index])</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* left child at (index &lt;&lt; 1) */</span></span><br><span class=\"line\">    _in_order(tree, index &lt;&lt; <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%2d]: %4d\\n&quot;</span>, index, tree-&gt;n[index]-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* right child at (index &lt;&lt; 1) + 1 */</span></span><br><span class=\"line\">    _in_order(tree, (index &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">in_order</span><span class=\"params\">(struct binary_tree* tree)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    _in_order(tree, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binary_tree</span> <span class=\"title\">tree</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fake_a_tree(&amp;tree);</span><br><span class=\"line\">    in_order(&amp;tree);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<p>&ensp;二叉树性质:</p>\n<ul>\n<li>二叉树中,第i层最多有 2^(i-1)个节点</li>\n<li>如果二叉树的深度为K,则二叉树最多有<code>2^K - 1</code>个节点</li>\n<li>二叉树中，终端结点树(叶子节点树)为n0，度为2的节点树为n1，则 n0=n1+1</li>\n</ul>\n<p><strong>满二叉树</strong><br>&emsp;如果二叉树中除了叶子节点，每个节点的度都为2，则此二叉树为满二叉树。</p>\n<p><strong>完全二叉树</strong><br>&emsp;如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p>\n<p>&emsp;树的周游算法包含先序遍历、中序遍历、后序遍历和层序遍历。</p>\n<ul>\n<li>先序遍历：先访问根结点，然后左子树，最后右子结点。深度优先思想。</li>\n<li>中序遍历：先访问左子结点，然后根结点，最后右子结点。</li>\n<li>后序遍历：先访问左子结点，然后右子结点，最后根结点。</li>\n<li>层序遍历：先访问树的根结点，然后依次向下层处理，按照从左向右的顺序访问每层结点。广度优先的策略。</li>\n</ul>\n<h4 id=\"2-3-4-二叉查找树-BST\"><a href=\"#2-3-4-二叉查找树-BST\" class=\"headerlink\" title=\"2.3.4 二叉查找树(BST)\"></a>2.3.4 二叉查找树(BST)</h4><p>&ensp;二叉查找树也称二叉搜索树,有序二叉树或排序二叉树,具有性质:</p>\n<ul>\n<li>若任意节点左子树不为空,则左子树上所有节点的值均小于它的根节点的值</li>\n<li>若任意节点的右子树不为空,则右子树所有节点的值均大于根节点的值</li>\n<li>任意节点的左,右子树也分别为二叉查找树</li>\n<li>没有键值相等的节点</li>\n</ul>\n<p>&emsp;一颗二叉搜索树要插入一个结点，要从根结点开始，一层一层往下，适当地移动左或右子结点上，当到达树的分支尽头时，执行插入操作。<br>&emsp;二叉搜索树是一种用于查找操作的高效数据结构，在最坏情况下，只需查找一个分支上的数据即可。<strong>查找,插入</strong>操作的复杂度是 <code>O(logn)</code>，<strong>搜索,插入,删除</strong>复杂度等于树高,期望<code>O(logn)</code>,最坏为<code>O(n)</code>,(树退化为线性表)n为树中结点数。<br>&emsp;保持一棵树的平衡是指对于给定数量的结点，要使得树的高度尽可能短。</p>\n<p>&emsp;二叉查找树是由二叉树组成的专用于查找和搜索目的的一种数据结构。二叉搜索树中查找一个结点，从根结点开始一层一层向下查找，当遇到一个比目标结点值大的结点时，顺着该结点左子树继续查找，如果遇到的结点值小于目标结点，则顺着该结点的右子树查找，直到找到目标结点为止。</p>\n<p>&ensp;<strong>查找算法</strong><br>&emsp;&emsp;1.若b是空树,则搜索失败,否则;<br>&emsp;&emsp;2.若x等于b的根节点的数据域之值,则查找成功;<br>&emsp;&emsp;3.若x小于b的根节点的数据域之值,则搜索左子树<br>&emsp;&emsp;4.查找右子树</p>\n<p>&ensp;<strong>插入算法</strong><br>&emsp;&emsp;1.若b是空树,则将s所指节点作为根节点插入;否则<br>&emsp;&emsp;2.若<code>s-&gt;data</code>等于b的根节点的数据域值,则返回,否则;<br>&emsp;&emsp;3.若<code>s-&gt;data</code>小于b的根节点的数据域之值,则把s所值节点插入到左子树中,否则<br>&emsp;&emsp;4.把s所指节点插入到右子树中,(新插入节点总是叶子节点)</p>\n<p>&ensp;<strong>删除算法</strong><br>&emsp;&emsp;1.若*p节点为叶子节点,即PL(左子树)和PR(右子树)均为空树.由于删去叶子节点不破坏整棵树的结构,则只需修改其双亲节点的指针即可.</p>\n<details>\n<summary>binarysearch</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OK 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRUE 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FALSE 0</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Status;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> ElemType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125; BTree, *BTreePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**************** 插入 **********************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Insert</span><span class=\"params\">(BTreePtr *T, ElemType e)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    BTreePtr p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*T == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        *T = (BTreePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BTree));</span><br><span class=\"line\">        (*T)-&gt;data = e;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        p = *T;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( p != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e &gt; p-&gt;data) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p-&gt;rchild == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                    p-&gt;rchild = (BTreePtr) <span class=\"built_in\">malloc</span> (<span class=\"keyword\">sizeof</span>(BTree));</span><br><span class=\"line\">                    p-&gt;rchild-&gt;data = e;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                p = p-&gt;rchild;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p-&gt;lchild == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                    p-&gt;lchild = (BTreePtr) <span class=\"built_in\">malloc</span> (<span class=\"keyword\">sizeof</span>(BTree));</span><br><span class=\"line\">                    p-&gt;lchild-&gt;data = e;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                p = p-&gt;lchild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**************** 删除 **********************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Delete</span><span class=\"params\">(BTreePtr T, ElemType e)</span> </span>&#123;</span><br><span class=\"line\">    BTreePtr p, pp, minP, minPP, child;</span><br><span class=\"line\">    child = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    p = T;</span><br><span class=\"line\">    pp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( (p != <span class=\"literal\">NULL</span>) &amp;&amp; (p-&gt;data != e) ) &#123;</span><br><span class=\"line\">        pp = p;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e &gt; p-&gt;data) &#123;</span><br><span class=\"line\">            p = p-&gt;rchild;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            p = p-&gt;lchild;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//双节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p-&gt;lchild != <span class=\"literal\">NULL</span>) &amp;&amp; (p-&gt;rchild != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        minPP = p;</span><br><span class=\"line\">        minP = p-&gt;rchild;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (minP-&gt;lchild != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            minPP = minP;</span><br><span class=\"line\">            minP = minP-&gt;lchild;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p-&gt;data = minP-&gt;data;</span><br><span class=\"line\">        minPP-&gt;lchild = minP-&gt;rchild;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(minP);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p-&gt;lchild != <span class=\"literal\">NULL</span>) || (p-&gt;rchild != <span class=\"literal\">NULL</span>)) &#123; <span class=\"comment\">//应该将原有的pp同child连接在一起</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;lchild) &#123;</span><br><span class=\"line\">            child = p-&gt;lchild;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           child = p-&gt;rchild;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pp-&gt;data&gt;p-&gt;data) &#123;</span><br><span class=\"line\">            pp-&gt;lchild=child;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pp-&gt;rchild=child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//没有节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pp-&gt;lchild == p) &#123;<span class=\"comment\">//这里面临pp除p以外的节点为null的情况</span></span><br><span class=\"line\">        pp-&gt;lchild = child;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        pp-&gt;rchild = child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**************** 查找 **********************/</span></span><br><span class=\"line\">Status Find(BTreePtr T, ElemType e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((T != <span class=\"literal\">NULL</span>) &amp;&amp; (T-&gt;data != e)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e &gt; T-&gt;data) &#123;</span><br><span class=\"line\">            T = T-&gt;rchild;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            T = T-&gt;lchild;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**************** 最大值 **********************/</span></span><br><span class=\"line\">ElemType FindMax(BTreePtr T) &#123;</span><br><span class=\"line\">    ElemType max;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        max = T-&gt;data;</span><br><span class=\"line\">        T = T-&gt;rchild;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**************** 最小值 **********************/</span></span><br><span class=\"line\">ElemType FindMin(BTreePtr T) &#123;</span><br><span class=\"line\">    ElemType min;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(T != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        min = T-&gt;data;</span><br><span class=\"line\">        T = T-&gt;lchild;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> PreOrderTraverse(BTreePtr T)<span class=\"comment\">//前序遍历二叉树</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,T-&gt;data);</span><br><span class=\"line\">        PreOrderTraverse(T-&gt;lchild);</span><br><span class=\"line\">        PreOrderTraverse(T-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> DestroyTree(BTreePtr T) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (T-&gt;lchild) &#123;</span><br><span class=\"line\">            DestroyTree(T-&gt;lchild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(T-&gt;rchild) &#123;</span><br><span class=\"line\">            DestroyTree(T-&gt;rchild);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(T);</span><br><span class=\"line\">        T = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/***************** 执行测试 *************************/</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BTreePtr T;</span><br><span class=\"line\">    T = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">33</span>, <span class=\"number\">16</span>, <span class=\"number\">50</span>, <span class=\"number\">13</span>, <span class=\"number\">18</span>, <span class=\"number\">34</span>, <span class=\"number\">58</span>, <span class=\"number\">15</span>, <span class=\"number\">17</span>, <span class=\"number\">25</span>, <span class=\"number\">51</span>, <span class=\"number\">66</span>, <span class=\"number\">19</span>, <span class=\"number\">27</span>, <span class=\"number\">55</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">15</span>; i++) &#123;</span><br><span class=\"line\">        Insert(&amp;T, a[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Max is %d\\n&quot;</span>, FindMax(T));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Min is %d\\n&quot;</span>, FindMin(T));</span><br><span class=\"line\">    Delete(T, <span class=\"number\">18</span>);</span><br><span class=\"line\">    Delete(T, <span class=\"number\">13</span>);</span><br><span class=\"line\">    PreOrderTraverse(T);</span><br><span class=\"line\">    DestroyTree(T);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<details>\n<summary>bst</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">child_dir</span> &#123;</span></span><br><span class=\"line\">    left_child,</span><br><span class=\"line\">    right_child,</span><br><span class=\"line\">    root,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data; </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">root</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">r</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(struct node *node, <span class=\"keyword\">int</span> level, <span class=\"keyword\">enum</span> child_dir dir)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(node-&gt;right, level + <span class=\"number\">1</span>, right_child);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dir == left_child)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%*s\\n&quot;</span>, level*<span class=\"number\">3</span>, <span class=\"string\">&quot;|&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%*s - %05lu\\n&quot;</span>, level*<span class=\"number\">3</span>, <span class=\"string\">&quot; &quot;</span>, node-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dir == right_child)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%*s\\n&quot;</span>, level*<span class=\"number\">3</span>, <span class=\"string\">&quot;|&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(node-&gt;left, level + <span class=\"number\">1</span>, left_child);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct node* <span class=\"title\">find</span><span class=\"params\">(struct root *root, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>* <span class=\"title\">n</span> =</span> root-&gt;r;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n-&gt;data == data)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data &lt; n-&gt;data)</span><br><span class=\"line\">            n = n-&gt;left;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            n = n-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct node* <span class=\"title\">new_node</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">n</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct node));</span><br><span class=\"line\"></span><br><span class=\"line\">    n-&gt;data = data;</span><br><span class=\"line\">    n-&gt;left = n-&gt;right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(struct root *root, struct node *<span class=\"keyword\">new</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">parent</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root-&gt;r) &#123;</span><br><span class=\"line\">        root-&gt;r = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parent = root-&gt;r;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Don&#x27;t support duplicate data */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span>-&gt;data == parent-&gt;data)</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span>-&gt;data &lt; parent-&gt;data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parent-&gt;left) &#123;</span><br><span class=\"line\">            parent-&gt;left = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parent = parent-&gt;left;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!parent-&gt;right) &#123;</span><br><span class=\"line\">                parent-&gt;right = <span class=\"keyword\">new</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            parent = parent-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct node* <span class=\"title\">delete</span><span class=\"params\">(struct root *root, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">n</span> =</span> root-&gt;r, **p = &amp;root-&gt;r;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">child</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &amp;&amp; n-&gt;data != data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data &lt; n-&gt;data) &#123;</span><br><span class=\"line\">            p = &amp;n-&gt;left;</span><br><span class=\"line\">            n = n-&gt;left;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            p = &amp;n-&gt;right;</span><br><span class=\"line\">            n = n-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!n)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n-&gt;left &amp;&amp; n-&gt;right) &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">rn</span> =</span> n-&gt;right, **rp = &amp;n-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (rn-&gt;left) &#123;</span><br><span class=\"line\">            rp = &amp;rn-&gt;left;</span><br><span class=\"line\">            rn = rn-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        n-&gt;data = rn-&gt;data;</span><br><span class=\"line\">        n = rn;</span><br><span class=\"line\">        p = rp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    child = n-&gt;left ? n-&gt;left : n-&gt;right;</span><br><span class=\"line\">    *p = child;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">root</span> <span class=\"title\">tree</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>* <span class=\"title\">n</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tree.r = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">9</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">5</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">2</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">8</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">18</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">13</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">21</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(tree.r, <span class=\"number\">0</span>, root);</span><br><span class=\"line\"></span><br><span class=\"line\">    n = find(&amp;tree, <span class=\"number\">18</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &amp;&amp; n-&gt;data == <span class=\"number\">18</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Get 18\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">root</span> <span class=\"title\">tree</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>* <span class=\"title\">n</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tree.r = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">9</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">5</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">2</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">8</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">18</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">13</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">21</span>));</span><br><span class=\"line\">    insert(&amp;tree, new_node(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(tree.r, <span class=\"number\">0</span>, root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span>(&amp;tree, <span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Delete 20\\n&quot;</span>);</span><br><span class=\"line\">    dump(tree.r, <span class=\"number\">0</span>, root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span>(&amp;tree, <span class=\"number\">9</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Delete 9\\n&quot;</span>);</span><br><span class=\"line\">    dump(tree.r, <span class=\"number\">0</span>, root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//insert_test();</span></span><br><span class=\"line\">    delete_test();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<h4 id=\"2-3-5-平衡树\"><a href=\"#2-3-5-平衡树\" class=\"headerlink\" title=\"2.3.5 平衡树\"></a>2.3.5 平衡树</h4><p>&ensp;平衡树是一类改进的二叉查找树,一般二叉查找树的查询复杂度与目标节点到树根的距离(深度)有关,因此当深度较大时,查询均摊复杂度会上升.<br>&ensp;<strong>平衡指所有叶子的深度趋于平衡</strong>,更广义指树上所有可能查找的均摊复杂度偏低.<strong>平衡树的操作时基于树旋转操作,通过旋转可使树趋于平衡</strong>.<br>&ensp;对一颗查找树进行查询,新增,删除等操作,所花的时间与树的高度h成比例,并不与树的容量n成比例.</p>\n<ul>\n<li><strong>AVL树</strong></li>\n</ul>\n<p>&emsp;在<strong>AVL树中,任一节点对于的两颗子树的最大高度差为1,因此也称为高度平衡树</strong>.查找,插入和删除的平均和最坏时间复杂度是O(logn),增加和删除元素的操作则可能需要借由一层或多次旋转,以实现树的重新平衡.<br>&emsp;<strong>高度为h的AVL树,总节点数最多为2^h-1</strong>; 当前节点数为N时,高度h最多为:</p>\n<blockquote>\n<p>log(5*0.5 * (N + 1)) - 2</p>\n</blockquote>\n<br>\n\n<ul>\n<li><strong>红黑树</strong></li>\n</ul>\n<p>&ensp;红黑树是一种自平衡二叉查找树,典型的用途是实现关联数组.红黑树实现复制,查找,插入和删除时间复杂度为O(logn)<br>&ensp;红黑树相对于AVL树,牺牲了部分平衡性以换取插入\\删除操作时少量的旋转操作,整体性能优于AVL树.</p>\n<p>&emsp;红黑树与AVL树的相比:<br>&emsp;&emsp;AVL树在插入,删除节点时要把树调整到完全平衡,红黑树只要调整到大致平衡,因此通常红黑树的插入,删除节点性能稍好.<br>&emsp;&emsp;AVL的查找性能通常比红黑树好<br>&emsp;&emsp;如果节点的增删操作远小于查找操作,则应选择AVL;反之,红黑树可能更好.</p>\n<p>&ensp;红黑树是每个节点都带有颜色属性的二叉树,颜色为红色或黑色.在二叉查找树强制一般要求以外,对于任何有效的红黑树我们怎讲了弱小额外要求:<br>&emsp;&emsp;1.节点是红或黑色<br>&emsp;&emsp;2.根是黑色<br>&emsp;&emsp;3.所有叶子都是黑色(叶子是NIL节点)<br>&emsp;&emsp;4.每个红色节点必须右两个黑色的子节点.(从每个叶子到根的所有路径上不能右两个连续的红色节点.)<br>&emsp;&emsp;5.从任一节点到其每个叶子的所有简单路径都包含相同苏后面的黑色节点.<br>&ensp;红黑树关键特性:<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>.红黑树是大致平衡的.插入,删除和查找某个值最坏情况下与树的高度成比例.</p>\n<ul>\n<li><strong>B+树</strong></li>\n</ul>\n<p>&ensp;B+树通常用于数据库和操作系统的文件系统中.<strong>B+树的特点是能够保持数据稳定有序,其插入与修改拥有较文档的对数时间复杂度</strong>.B+树元素自底向上插入,与二叉树相反.<br>&ensp;B+树是内部节点可右在预定范围内的可变量目的子节点.因此,B+树不需要像其他自平衡二叉查找树那样重新平衡.</p>\n<ul>\n<li><strong>字典树</strong></li>\n</ul>\n<details>\n<summary>Trie</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OK 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ERROR 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRUE 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FALSE 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Status;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">children</span>[26];</span></span><br><span class=\"line\">    Status end;</span><br><span class=\"line\">&#125; Trie, *TriePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Init</span><span class=\"params\">(TriePtr *T)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    (*T) = (TriePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Trie));</span><br><span class=\"line\">    (*T)-&gt;data = <span class=\"string\">&#x27;/&#x27;</span>;</span><br><span class=\"line\">    (*T)-&gt;end = FALSE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(TriePtr T, <span class=\"keyword\">char</span> *str)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c = *str++) &#123;</span><br><span class=\"line\">        index = c - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (T-&gt;children[index] == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            TriePtr Node;</span><br><span class=\"line\">            Node = (TriePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Trie));</span><br><span class=\"line\">            Node-&gt;data = c;</span><br><span class=\"line\">            Node-&gt;end = FALSE;</span><br><span class=\"line\">            T-&gt;children[index] = Node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        T = T-&gt;children[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    T-&gt;end = TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Search</span><span class=\"params\">(TriePtr T, <span class=\"keyword\">char</span> *str)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c = *str++) &#123;</span><br><span class=\"line\">        index = c - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (T-&gt;children[index] == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        T = T-&gt;children[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (T-&gt;end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TriePtr T;</span><br><span class=\"line\">    Init(&amp;T);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *str = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *str2 = <span class=\"string\">&quot;hi&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Insert(T, str);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;str is search %d\\n&quot;</span>, Search(T, str));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;str2 is search %d\\n&quot;</span>, Search(T, str2));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<h4 id=\"2-3-6-堆树和优先队列\"><a href=\"#2-3-6-堆树和优先队列\" class=\"headerlink\" title=\"2.3.6 堆树和优先队列\"></a>2.3.6 堆树和优先队列</h4><p>&ensp;堆(heap)也称为优先队列,堆遵守队列操作模式,在堆底插入元素,在堆顶取出元素,但堆中元素的排列不是按照到来的先后顺序,而是按照一定的有序顺序排列的.<br>&ensp;堆的本质是一个完全二叉树,可使用二叉树表示堆,也可使用数组来表示.<br>&ensp;堆的特性:<br>&emsp;&emsp;必须是完全二叉树<br>&emsp;&emsp;用数组实现<br>&emsp;&emsp;任一节点的值是其子树所有节点的最大值或最小值<br>&emsp;&emsp;&emsp;最大值时,称为最大堆,也称大顶堆<br>&emsp;&emsp;&emsp;最小时,称为最小堆,也称小顶堆.<br>&emsp;<strong>堆不能保证整棵树都是有序的,堆中的插入和删除操作时时间复杂度为O(log2n)</strong></p>\n<p>&emsp;堆是一颗二叉树，通常其子结点存储的值比父结点的值小，所以，根结点为树中最大的结点(大顶堆)。同样，根结点也可以是树中最小的结点(小顶堆)。能够快速确定包含最大(小)值的特点。<br>&emsp;堆时左平衡的树，随着结点增加，树会逐级从左至右增长。一个较好地表示左平衡二叉树的方式是，将结点通过层序遍历方式连续存储到一个数组中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Heap_</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*compare)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destroy)(<span class=\"keyword\">void</span> *data);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> **tree;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>heap</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Implement heap */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_HEAP_SIZE (1 &lt;&lt; 8)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">heap</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> elements;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> *<span class=\"title\">elem</span>[<span class=\"title\">MAX_HEAP_SIZE</span>];</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_heap</span><span class=\"params\">(struct heap *heap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; MAX_HEAP_SIZE; i++) &#123;</span><br><span class=\"line\">        heap-&gt;elem[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump_heap</span><span class=\"params\">(struct heap *heap, <span class=\"keyword\">int</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> *<span class=\"title\">elem</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; heap-&gt;elements)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    elem = heap-&gt;elem[index];</span><br><span class=\"line\">    level = fls(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump_heap(heap, index * <span class=\"number\">2</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(index % <span class=\"number\">2</span>) &amp;&amp; index != <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%*s\\n&quot;</span>, level*<span class=\"number\">3</span>, <span class=\"string\">&quot;|&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%*s - %05d\\n&quot;</span>, level*<span class=\"number\">3</span>, <span class=\"string\">&quot; &quot;</span>, elem-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index % <span class=\"number\">2</span> &amp;&amp; index != <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%*s\\n&quot;</span>, level*<span class=\"number\">3</span>, <span class=\"string\">&quot;|&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump_heap(heap, index * <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(struct heap *heap, <span class=\"keyword\">int</span> elements)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= elements; i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%02d]: %4d\\n&quot;</span>, i, heap-&gt;elem[i]-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct element* <span class=\"title\">create_element</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> *<span class=\"title\">elem</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    elem = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct element));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elem)</span><br><span class=\"line\">        elem-&gt;data = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fake_a_heap</span><span class=\"params\">(struct heap *heap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* data is in ordered */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, data[<span class=\"number\">10</span>] = &#123;<span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    init_heap(heap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* root start at 1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        heap-&gt;elem[i+<span class=\"number\">1</span>] = create_element(data[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    heap-&gt;elements = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(struct heap *heap, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> *<span class=\"title\">tmp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = heap-&gt;elem[j];</span><br><span class=\"line\">    heap-&gt;elem[j] = heap-&gt;elem[i];</span><br><span class=\"line\">    heap-&gt;elem[i] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">heapify</span><span class=\"params\">(struct heap *heap, <span class=\"keyword\">int</span> parent)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">element</span> **<span class=\"title\">elem</span> =</span> heap-&gt;elem;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> elements = heap-&gt;elements;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left, right, max;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        left = parent * <span class=\"number\">2</span>;</span><br><span class=\"line\">        right = left + <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        max = parent;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt;= elements &amp;&amp; elem[max]-&gt;data &lt; elem[left]-&gt;data)</span><br><span class=\"line\">            max = left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt;= elements &amp;&amp; elem[max]-&gt;data &lt; elem[right]-&gt;data)</span><br><span class=\"line\">            max = right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (max == parent)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        swap(heap, max, parent);</span><br><span class=\"line\">        parent = max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build_heap</span><span class=\"params\">(struct heap *heap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = heap-&gt;elements / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">1</span>; i--)</span><br><span class=\"line\">        heapify(heap, i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">heap_sort</span><span class=\"params\">(struct heap *heap)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> elements = heap-&gt;elements;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (heap-&gt;elements) &#123;</span><br><span class=\"line\">        swap(heap, <span class=\"number\">1</span>, heap-&gt;elements);</span><br><span class=\"line\">        heap-&gt;elements--;</span><br><span class=\"line\">        heapify(heap, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> elements;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">heap</span> <span class=\"title\">heap</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> elements;</span><br><span class=\"line\"></span><br><span class=\"line\">    fake_a_heap(&amp;heap);</span><br><span class=\"line\">    dump_heap(&amp;heap, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;After Heapify:\\n&quot;</span>);</span><br><span class=\"line\">    build_heap(&amp;heap);</span><br><span class=\"line\">    dump_heap(&amp;heap, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;After Heap sort:\\n&quot;</span>);</span><br><span class=\"line\">    elements = heap_sort(&amp;heap);</span><br><span class=\"line\">    dump(&amp;heap, elements);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<p>&emsp;堆排序，要排序的数据首先存储在一个堆中。从堆中一次取出一个结点。放置到有序数据集的尾部。当取出每个结点时，它的下一个结点就会浮现到堆的顶部。</p>\n<p>&emsp;优先队列是从堆衍生的数据结构。在优先队列中，数据保存在一个堆中，可快速确定下一个最高优先级的结点。</p>\n<p>&emsp;优先队列将数据按照优先级顺序排列。一个优先队列由许多有序元素构成，所以优先级最高的元素可以有效而快速的确定。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Heap PQueue;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-3-7-leetcode题目\"><a href=\"#2-3-7-leetcode题目\" class=\"headerlink\" title=\"2.3.7 leetcode题目\"></a>2.3.7 leetcode题目</h4><ul>\n<li>先序遍历构造二叉树</li>\n<li>从中序与后序遍历构造二叉树</li>\n<li>二叉树的层次遍历</li>\n<li>从二叉搜索树到更大和树</li>\n<li>二叉搜索树的最近公共祖先</li>\n<li>前K个高频单词&lt;堆&gt;</li>\n</ul>\n<h3 id=\"2-4-图\"><a href=\"#2-4-图\" class=\"headerlink\" title=\"2.4 图\"></a>2.4 图</h3><p>&ensp;图(Graph)是由顶点的有穷非空集合和顶点之间的边的集合组成,通常表示为:<code>G(V,E)</code>.其中,G表示一个图,V是入G中顶点的集合,E是图G中的集合.</p>\n<p>&emsp;图是一种灵活的数据结构，用来定义对象之间关联或联系的模型。对象由顶点表示，而对象直接的关系或关联则通过顶点之间的边来表示。<br>&emsp;图的访问方式：广度优先和深度优先。</p>\n<h4 id=\"2-4-1-基础知识\"><a href=\"#2-4-1-基础知识\" class=\"headerlink\" title=\"2.4.1 基础知识\"></a>2.4.1 基础知识</h4><p>&emsp;图由两种类型的元素组成：顶点和边，顶点代表对象，边则建立起对象之间的关系或关联。图的边可关联值或权重信息。</p>\n<ul>\n<li>一组顶点：用V(vertex)表示顶点集合</li>\n<li>一组边：用E(edge)表示边的集合<br>&emsp;图分为有向图和无向图。有向图，边是由两个顶点组成的有序对，具有特定的方向。边也可称为弧。无向图中，边是没有方向的。</li>\n<li>(v, w)表示无向边，即v和w是互通的</li>\n<li>&lt; v, w &gt;表示有向边，该边始于v，终于w<br>&ensp;图可分为连通图和非连通图</li>\n<li>连通图：所有的点都右路径相连</li>\n<li>非连通图：存在某两个点没有路径相连</li>\n<li>强连通图： </li>\n</ul>\n<p>&emsp;图中的顶点度</p>\n<ul>\n<li>度</li>\n<li>入度</li>\n<li>出度</li>\n</ul>\n<h4 id=\"2-4-2-图表示\"><a href=\"#2-4-2-图表示\" class=\"headerlink\" title=\"2.4.2 图表示\"></a>2.4.2 图表示</h4><p>&emsp;图的表示方法是G=(V, E)，V代表顶点的集合，而E和V之间是二元关系。<br>&emsp;图中由两个重要关系邻接(adjacency)和关联(incidence)。邻接是两个顶点之间的关系。关联是顶点和边之间的关系。<br>邻接矩阵表示</p>\n<p>邻接链表表示</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjList_</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *vertex;</span><br><span class=\"line\">    Set adjacent;</span><br><span class=\"line\">&#125;AdjList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Graph_</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vcount;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ecount;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    List adjlists;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>graph</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span> *<span class=\"title\">v</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> *<span class=\"title\">adj</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_GRAPH_VERTEX (1 &lt;&lt; 8)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">graph</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span> *<span class=\"title\">vxs</span>[<span class=\"title\">MAX_GRAPH_VERTEX</span>];</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_graph</span><span class=\"params\">(struct graph *graph)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX_GRAPH_VERTEX; i++)</span><br><span class=\"line\">        graph-&gt;vxs[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct vertex *<span class=\"title\">create_vertex</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span> *<span class=\"title\">v</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    v = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct vertex));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v) &#123;</span><br><span class=\"line\">        v-&gt;data = data;</span><br><span class=\"line\">        v-&gt;adj = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">struct vertex_adjs *<span class=\"title\">create_vertex_adj</span><span class=\"params\">(struct vertex *v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> *<span class=\"title\">v_adj</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    v_adj = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct vertex_adjs));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!v_adj)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    v_adj-&gt;v = v;</span><br><span class=\"line\">    v_adj-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v_adj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_adj</span><span class=\"params\">(struct vertex *v, struct vertex *adj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> **<span class=\"title\">v_adj</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    v_adj = &amp;v-&gt;adj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*v_adj)</span><br><span class=\"line\">    v_adj = &amp;(*v_adj)-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    *v_adj = create_vertex_adj(adj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump_raw</span><span class=\"params\">(struct graph *graph)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX_GRAPH_VERTEX; i++) &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex</span> *<span class=\"title\">v</span> =</span> graph-&gt;vxs[i];</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vertex_adjs</span> *<span class=\"title\">adj</span>;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Vertex[%02d]: %8d -&gt;&quot;</span>, i, v-&gt;data);</span><br><span class=\"line\"></span><br><span class=\"line\">        adj = v-&gt;adj;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (adj) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %8d,&quot;</span>, adj-&gt;v-&gt;data);</span><br><span class=\"line\">            adj = adj-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">  1 ----- 2 ----- 3</span></span><br><span class=\"line\"><span class=\"comment\">  |     / |     /</span></span><br><span class=\"line\"><span class=\"comment\">  |    /  |    / </span></span><br><span class=\"line\"><span class=\"comment\">  |   /   |   /  </span></span><br><span class=\"line\"><span class=\"comment\">  |  /    |  /   </span></span><br><span class=\"line\"><span class=\"comment\">  | /     | /    </span></span><br><span class=\"line\"><span class=\"comment\">  4 ----- 5</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fake_a_graph</span><span class=\"params\">(struct graph *graph)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    init_graph(graph);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">    graph-&gt;vxs[i] = create_vertex(i+<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* connect 1 -&gt; 2, 1 -&gt; 4 */</span></span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">0</span>], graph-&gt;vxs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">0</span>], graph-&gt;vxs[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    <span class=\"comment\">/* connect 2 -&gt; 1, 2 -&gt; 3, 2 -&gt; 5, 2 -&gt; 4 */</span></span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">1</span>], graph-&gt;vxs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">1</span>], graph-&gt;vxs[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">1</span>], graph-&gt;vxs[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">1</span>], graph-&gt;vxs[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    <span class=\"comment\">/* connect 3 -&gt; 2, 3 -&gt; 5 */</span></span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">2</span>], graph-&gt;vxs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">2</span>], graph-&gt;vxs[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"comment\">/* connect 4 -&gt; 1, 4 -&gt; 2, 4 -&gt; 5 */</span></span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">3</span>], graph-&gt;vxs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">3</span>], graph-&gt;vxs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">3</span>], graph-&gt;vxs[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"comment\">/* connect 5 -&gt; 4, 5 -&gt; 2, 5 -&gt; 3 */</span></span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">4</span>], graph-&gt;vxs[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">4</span>], graph-&gt;vxs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    insert_adj(graph-&gt;vxs[<span class=\"number\">4</span>], graph-&gt;vxs[<span class=\"number\">3</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">graph</span> <span class=\"title\">g</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fake_a_graph(&amp;g);</span><br><span class=\"line\">    dump_raw(&amp;g);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<h4 id=\"2-4-3-图遍历\"><a href=\"#2-4-3-图遍历\" class=\"headerlink\" title=\"2.4.3 图遍历\"></a>2.4.3 图遍历</h4><p>&ensp;图的搜索方法：深度优先搜索和广度优先搜索。<br>&emsp;深度优先遍历(DFS)<br>&emsp;思路: 从图中某点v出发:<br>&emsp;&emsp;&emsp;1.访问顶点v<br>&emsp;&emsp;&emsp;2.从v的未被访问的邻接点中选取一个顶点w,从w出发进行深度优先遍历.<br>&emsp;&emsp;&emsp;3.重复上述两步,直到图中所有和v有路径相通的顶点都被访问.<br>&emsp;伪代码: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(Vertex v)</span> </span>&#123;</span><br><span class=\"line\">    vistied[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (v 的每个邻接点 w) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[w]) &#123;</span><br><span class=\"line\">            DFS(w);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<details>\n<summary>dfs</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Graph.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_NODES 1000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> visited[MAX_NODES];  <span class=\"comment\">// array to store visiting order</span></span><br><span class=\"line\">                         <span class=\"comment\">// indexed by vertex 0..nV-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfsPathCheck</span><span class=\"params\">(Graph g, <span class=\"keyword\">int</span> nV, Vertex v, Vertex dest)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Vertex w;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (w = <span class=\"number\">0</span>; w &lt; nV; w++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (adjacent(g, v, w) &amp;&amp; visited[w] == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            visited[w] = v;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (w == dest)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dfsPathCheck(g, nV, w, dest))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">findPathDFS</span><span class=\"params\">(Graph g, <span class=\"keyword\">int</span> nV, Vertex src, Vertex dest)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Vertex v;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (v = <span class=\"number\">0</span>; v &lt; nV; v++) visited[v] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    visited[src] = src;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfsPathCheck(g, nV, src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> V = <span class=\"number\">6</span>;</span><br><span class=\"line\">    Graph g = newGraph(V);</span><br><span class=\"line\"></span><br><span class=\"line\">    Edge e;</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">1</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">4</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">5</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">5</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">4</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">4</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">2</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">4</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">3</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">5</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">3</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">1</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">2</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">3</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">2</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> src = <span class=\"number\">0</span>, dest = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPathDFS(g, V, src, dest)) &#123;</span><br><span class=\"line\">        Vertex v = dest;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (v != src) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d - &quot;</span>, v);</span><br><span class=\"line\">            v = visited[v];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, src);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<p>&ensp;广度优先遍历(BFS)<br>&emsp;思路:<br>&emsp;&emsp;&emsp;1.顶点v入队列<br>&emsp;&emsp;&emsp;2.当队列非空时则继续执行,否则算法结束.<br>&emsp;&emsp;&emsp;3.出队列取得队头顶点v’,访问顶点v 并标记顶点v已被访问.<br>&emsp;&emsp;&emsp;4.查找顶点v的第一个邻接顶点col<br>&emsp;&emsp;&emsp;5.若v的邻接顶点col未被访问过的,则col继续.<br>&emsp;&emsp;&emsp;6.查找顶点v的另一个新的邻接顶点col,转到步骤5入队列,直到顶点v的所有未被访问过的邻接点处理完,转到步骤2.</p>\n<details>\n<summary>bfs_queue</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Graph.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;queue.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_NODES 1000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> visited[MAX_NODES];  <span class=\"comment\">// array to store visiting order</span></span><br><span class=\"line\">                         <span class=\"comment\">// indexed by vertex 0..nV-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">findPathBFS</span><span class=\"params\">(Graph g, <span class=\"keyword\">int</span> nV, Vertex src, Vertex dest)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Vertex v;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (v = <span class=\"number\">0</span>; v &lt; nV; v++) visited[v] = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    visited[src] = src;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span> Q = newQueue();</span><br><span class=\"line\">    QueueEnqueue(Q, src);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!QueueIsEmpty(Q)) &#123;</span><br><span class=\"line\">        v = QueueDequeue(Q);</span><br><span class=\"line\">        Vertex w;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (w = <span class=\"number\">0</span>; w &lt; nV; w++) (</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (adjacent(g, v, w) &amp;&amp; visited[w] == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                visited[w] = v;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (w == dest)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    QueueEnqueue(Q, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> V = <span class=\"number\">10</span>;</span><br><span class=\"line\">    Graph g = newGraph(V);</span><br><span class=\"line\"></span><br><span class=\"line\">    Edge e;</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">1</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">2</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">5</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">1</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">5</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">2</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">3</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">3</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">4</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">3</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">5</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">3</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">8</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">4</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">5</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">4</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">7</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">4</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">8</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">5</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">6</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">7</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">8</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">7</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">9</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\">    e.v = <span class=\"number\">8</span>;</span><br><span class=\"line\">    e.w = <span class=\"number\">9</span>;</span><br><span class=\"line\">    insertEdge(g, e);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> src = <span class=\"number\">0</span>, dest = <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (findPathBFS(g, V, src, dest)) &#123;</span><br><span class=\"line\">        Vertex v = dest;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (v != src) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d - &quot;</span>, v);</span><br><span class=\"line\">            v = visited[v];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, src);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<p>&ensp;深度优先搜索和广度优先搜索,时间复杂度都为O(n^2)</p>\n<p>深度优先:从初始点出发,不断向前走,如果碰到死路,就往回走一步,尝试另一条路,直到发现目标位置.<br>广度优先:从初始点出发,把所有可能的路径都走一遍,如果里面没有目标位置,则尝试把所有两步能够到的位置都走一遍,看有没有目标位置.</p>\n<h4 id=\"2-4-4-最短路径\"><a href=\"#2-4-4-最短路径\" class=\"headerlink\" title=\"2.4.4 最短路径\"></a>2.4.4 最短路径</h4><p><strong>迪杰斯特拉Dijkstra算法</strong><br>&ensp;Dijkstra算法适用于权值为正的图.<br>&ensp;Dijkstra算法属于单源算法,即只能求出某点到其它点最短距离,并不能得出任意两点之间的最短距离.<br>&ensp;在源点可达的情况下,Dijkstra算法的时间复杂度时 <code>O(ElogV)</code><br>&ensp;算法步骤:<br>&emsp;&emsp;1.将所有边初始化为无穷大<br>&emsp;&emsp;2.旋转一个开始的顶点,添加到优先队列中.<br>&emsp;&emsp;3.对于该点的所有邻接顶点进行判断,如果到该点的距离小于原先的值,则该值进行更新.<br>&emsp;&emsp;4.将该点所有邻接顶点添加到优先队列中.<br>&emsp;&emsp;5.从优先队列中挑选除一个路径值最小的顶点,将其弹出,作为新的顶点,重复步骤3,4,5<br>&emsp;&emsp;6.直到所有点都被处理过一次.</p>\n<detials>\n<summary>迪杰斯特拉</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 20</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 999</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> mat[MAX][MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> V;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dist[MAX];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> q[MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> qp = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span> </span>&#123; q[qp++] = v; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cf</span><span class=\"params\">(<span class=\"keyword\">void</span> *a, <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *x = (<span class=\"keyword\">int</span> *)a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *y = (<span class=\"keyword\">int</span> *)b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *y - *x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dequeue</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    qsort(q, qp, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), cf);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q[--qp];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">queue_has_something</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> (qp &gt; <span class=\"number\">0</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> visited[MAX];</span><br><span class=\"line\"><span class=\"keyword\">int</span> vp = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    dist[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != s) &#123;</span><br><span class=\"line\">            dist[i] = INF;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        enqueue(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue_has_something()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> u = dequeue();</span><br><span class=\"line\">        visited[vp++] = u;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mat[u][i]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dist[i] &gt; dist[u] + mat[u][i]) &#123;</span><br><span class=\"line\">                    dist[i] = dist[u] + mat[u][i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter the number of vertices: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot; %d&quot;</span>, &amp;V);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter the adj matrix: &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; V; ++j) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot; %d&quot;</span>, &amp;mat[i][j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dijkstra(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\nNode\\tDist\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\t%d\\n&quot;</span>, i, dist[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</detials>\n\n<p><strong>弗洛伊德Floyd算法</strong><br>&ensp;Floyd算法是一个经典的动态规划算法.首先目标是寻找从点<code>i</code>到<code>j</code>的最短路径.<br>&ensp;<strong>Floyd算法可以求出任意两点的最短距离.时间复杂度:</strong><code>O(你^3)</code><br>&ensp;从任意节点i到任意节点j的最短路径不外乎2种可能:<br>&emsp;&emsp;1.是之间从i到j<br>&emsp;&emsp;2是从i到经过若干个节点k到j<br>&emsp;设Dist(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，则设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[i][j] &gt; (A[i][k] + A[k][j])) &#123;</span><br><span class=\"line\">                A[i][j] = A[i][k] + A[k][j];</span><br><span class=\"line\">                path[i][j] = k;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"2-4-5-拓扑排序\"><a href=\"#2-4-5-拓扑排序\" class=\"headerlink\" title=\"2.4.5 拓扑排序\"></a>2.4.5 拓扑排序</h4><p>&ensp;拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列.且该序列必须满足下面两个条件:</p>\n<ul>\n<li>每个顶点出现且只出现一次</li>\n<li>若存在一条顶点A到顶点B的路径,那么在序列中顶点A出现在顶点B的前面.<br>&emsp;有向无环图(DAG)才有拓扑排序，非DAG图没有拓扑排序。<br>&ensp;拓扑排序步骤：</li>\n<li>从DAG图中选择一个 没有前缀(即入度为0)的顶点并输出</li>\n<li>从图中删除该顶点和所有以它为起点的有向边</li>\n<li>重复1和2直到当前的DAG图为空或当前图中不存在无前缀的顶点为止。后一种情况说明有向图中必然存在环。</li>\n</ul>\n<h4 id=\"2-4-6-leetcode题目\"><a href=\"#2-4-6-leetcode题目\" class=\"headerlink\" title=\"2.4.6 leetcode题目\"></a>2.4.6 leetcode题目</h4><ul>\n<li>判断二分图</li>\n<li>克隆图</li>\n<li>找到小镇的法官</li>\n<li>钥匙和房间</li>\n<li>最短路径访问所有节点</li>\n</ul>\n<br>\n\n<h2 id=\"3-常见算法\"><a href=\"#3-常见算法\" class=\"headerlink\" title=\"3 常见算法\"></a>3 常见算法</h2><h3 id=\"3-1-递归思想\"><a href=\"#3-1-递归思想\" class=\"headerlink\" title=\"3.1 递归思想\"></a>3.1 递归思想</h3><h4 id=\"3-1-1-递归思想\"><a href=\"#3-1-1-递归思想\" class=\"headerlink\" title=\"3.1.1 递归思想\"></a>3.1.1 递归思想</h4><p>&ensp;递归思想是:将大问题分解为小问题来求解,然后再将小问题分解为更小的问题.逐层分解,直到问题规模被分解到可以直接计算结果.<br>&ensp;如果把一层一层分解过程画成图,它其实就是一棵树,称为递归树.</p>\n<!--more-->\n\n<p>&ensp;斐波那契数列</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (N &lt; = <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> N;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(N<span class=\"number\">-1</span>) + fib(N<span class=\"number\">-2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&ensp;递归的过程中,符合<strong>后进先出</strong>规则,所以用一个堆栈的数据结构.函数递归过程中会自动产生栈帧,当函数栈帧的深度越来越大,栈也也越来越大,如果递归没有终止条件,则会爆栈.递归算法第一步要思考的就是<strong>递归终止条件</strong>.<br>&ensp;递归思想的两个延申算法:分治算法和动态规划.<br>&ensp;递归的一般结构:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (符合边界条件) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ..;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 某种形式的调用</span></span><br><span class=\"line\">    func();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&ensp;阶乘函数:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n * factorial(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参考链接:<a href=\"https://www.jianshu.com/p/b2d2edb4ba5b\">https://www.jianshu.com/p/b2d2edb4ba5b</a></li>\n</ul>\n<h4 id=\"3-1-2-递归基本步骤\"><a href=\"#3-1-2-递归基本步骤\" class=\"headerlink\" title=\"3.1.2 递归基本步骤:\"></a>3.1.2 递归基本步骤:</h4><p>&ensp;&emsp;1.定义一个函数,明确函数功能<br>&ensp;&emsp;2.寻找问题与子问题之间的关系(递推公式)<br>&ensp;&emsp;3.将递推公式在定义的函数中实现<br>&ensp;&emsp;4.推导时间复杂度,判定是否可以接受,无法接受更换算法.</p>\n<h4 id=\"3-1-3-代表题目\"><a href=\"#3-1-3-代表题目\" class=\"headerlink\" title=\"3.1.3 代表题目\"></a>3.1.3 代表题目</h4><ul>\n<li>爬楼梯 70</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *mem = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * (n+<span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mem[n] = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> climb(n, mem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climb</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> *mem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mem[n] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mem[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mem[<span class=\"number\">0</span>] = climb(n<span class=\"number\">-1</span>, mem) + climb(n<span class=\"number\">-2</span>, mem);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mem[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>青蛙跳台阶 10-II</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numWays</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num[n+<span class=\"number\">1</span>] = &#123;<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jump(n, num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jump</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> *num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num[n] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span> || n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    num[n] = (jump(n<span class=\"number\">-1</span>, num) + jump(n<span class=\"number\">-2</span>, num) % <span class=\"number\">1e9</span>+<span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-1-4-触类旁通\"><a href=\"#3-1-4-触类旁通\" class=\"headerlink\" title=\"3.1.4 触类旁通\"></a>3.1.4 触类旁通</h4><ul>\n<li>反转二叉树 226<br>&emsp;1).对于根节点<code>1</code>来说,假设<code>2,3</code>节点下的节点都已经翻转,那么只要翻转<code>2,2</code>节点即满足需求.<br>&emsp;2).对于<code>2,3</code>节点来说,也是翻转其左右节点即可.<br>&emsp;依此类推,对每一个节点,依次翻转其左右节点,所以我们可知问题与子问题的关系是翻转(根节点) = 翻转(根节点的左节点) + 翻转(根节点的右节点),即<blockquote>\n<p>invert(root) = invert(root-&gt;left) + invert(root-&gt;right)<br>&emsp;加号是追加到root上的意思</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    TreeNode *left;</span><br><span class=\"line\">    TreeNode *right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    TreeNode *left = (struct TreeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TreeNode));</span><br><span class=\"line\">    TreeNode *right = (struct TreeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TreeNode));</span><br><span class=\"line\">    left = invertTree(root.left);</span><br><span class=\"line\">    rgith = invertTree(root.right);</span><br><span class=\"line\">    root.left = right;</span><br><span class=\"line\">    root.right = left;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>路径总和 112<br>&emsp;给定一个二叉树和一个目标和,判断该树中是否存在根节点到叶子节点的路径,这条路径上所有节点值相加等于目标和.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> sum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">NULL</span> &amp;&amp; root.right == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.data == sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> remain = sum - root.data;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasPathSum(root.left, remain) || hashPashSum(root.right, remain);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>细胞分裂</p>\n</li>\n</ul>\n<p><a href=\"https://www.jianshu.com/p/b2d2edb4ba5b\">https://www.jianshu.com/p/b2d2edb4ba5b</a></p>\n<h3 id=\"3-2-分治法\"><a href=\"#3-2-分治法\" class=\"headerlink\" title=\"3.2 分治法\"></a>3.2 分治法</h3><p>&emsp;把复杂问题分成两个或者更多相同或相似的子问题，再把子问题分成更小的子问题…，直到可以直接求解，原问题的解为子问题解的合并。<br>&emsp;分治法应用：排序算法(快速排序、归并排序);傅里叶变换()。</p>\n<h4 id=\"3-2-1-概述\"><a href=\"#3-2-1-概述\" class=\"headerlink\" title=\"3.2.1 概述\"></a>3.2.1 概述</h4><p>&ensp;分治法思想:将一个难以直接解决的大问题,分割成一些规模小的相同问题,分而治之.</p>\n<p>&emsp;分治法:把一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题…,直到最后子问题可以简单的直接求解,原问题的解即子问题的解的<strong>合并</strong>.分治法思想:排序(快速排序,归并排序),傅里叶变换(快速傅里叶变换<br>&emsp;1):数学归纳是使用分治思想.<br>&emsp;2):分治思想不一定使用递归结构.<br>&ensp;递归结构是循环结构的一种,也是分治思想应用最多的一种程序结构,但不一定使用它.分治法的核心是<strong>如何分</strong></p>\n<h4 id=\"3-2-2-策略\"><a href=\"#3-2-2-策略\" class=\"headerlink\" title=\"3.2.2 策略\"></a>3.2.2 策略</h4><p>&ensp;分治策略:对于一个规模为n的问题,若该问题可以容易解决则直接解决,否则将其分解为k个规模较小的子问题,子问题之间相互独立且与原问题形式相同,可递归求解.分治通常用递归实现.</p>\n<h4 id=\"3-2-3-应用场景\"><a href=\"#3-2-3-应用场景\" class=\"headerlink\" title=\"3.2.3 应用场景\"></a>3.2.3 应用场景</h4><p>&ensp;分治法特征:</p>\n<ul>\n<li>问题缩小到一定程度可容易解决.</li>\n<li>问题可分解为若干个规模较小的相同问题,即问题具有最优子结构性质.</li>\n<li>子问题的解可合并为该问题的解.</li>\n<li>问题分解的子问题相互独立,子问题之间不包含公告子问题.</li>\n</ul>\n<h4 id=\"3-2-4-步骤\"><a href=\"#3-2-4-步骤\" class=\"headerlink\" title=\"3.2.4 步骤\"></a>3.2.4 步骤</h4><p>&ensp;分治法一层递归步骤:</p>\n<ul>\n<li><ol>\n<li><strong>分解</strong>:将原问题分解为若干规模较小,相互独立,与原问题形式相同的子问题.</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><strong>解决</strong>:若子问题可直接求解,则直接求解,否则递归解各个子问题.</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><strong>合并</strong>:将各个子问题的解合并为原问题的解.</li>\n</ol>\n</li>\n</ul>\n<p>&ensp;</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<br>\n\n<h4 id=\"3-2-5-应用\"><a href=\"#3-2-5-应用\" class=\"headerlink\" title=\"3.2.5 应用\"></a>3.2.5 应用</h4><blockquote>\n<p>分治思维方式：二分搜索;大整数乘法;合并排序;快速排序。</p>\n</blockquote>\n<p>&ensp;求x的n次幂<br>&emsp;对数复杂度O(logn)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">power</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        result = power(x, n/<span class=\"number\">2</span>) * power(x, n / <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        result = power(x, (n + <span class=\"number\">1</span>) / <span class=\"number\">2</span>) * power(x, (n - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-6-leetcode题目\"><a href=\"#3-2-6-leetcode题目\" class=\"headerlink\" title=\"3.2.6 leetcode题目\"></a>3.2.6 leetcode题目</h4><ul>\n<li>搜索二维矩阵II</li>\n<li>求众数</li>\n<li>合并k个排序链表</li>\n</ul>\n<h3 id=\"3-3-排序算法\"><a href=\"#3-3-排序算法\" class=\"headerlink\" title=\"3.3 排序算法\"></a>3.3 排序算法</h3><p>&emsp;各种排序算法，主要包括：插入排序、快速排序、归并排序、计数排序和技术排序。二分查找，</p>\n<h4 id=\"3-3-1-冒泡排序\"><a href=\"#3-3-1-冒泡排序\" class=\"headerlink\" title=\"3.3.1 冒泡排序\"></a>3.3.1 冒泡排序</h4><p>&ensp;重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。<br>&ensp;<strong>冒泡排序算法复杂度是O(n^2)</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = arr.length;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> out = size - <span class=\"number\">1</span>; out &gt; <span class=\"number\">0</span>; out--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> in = <span class=\"number\">0</span>; in &lt; out; in++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[in] &gt; arr[in + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                swap(arr, in, in + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SWAP(a,b) \\</span></span><br><span class=\"line\"><span class=\"meta\">do&#123;\\</span></span><br><span class=\"line\"><span class=\"meta\">    (a) ^= (b);\\</span></span><br><span class=\"line\"><span class=\"meta\">    (b) ^= (a);\\</span></span><br><span class=\"line\"><span class=\"meta\">    (a) ^= (b);\\</span></span><br><span class=\"line\"><span class=\"meta\">&#125;while(0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*冒泡排序*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> swap_flg = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = size - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;<span class=\"comment\">/*排序的趟数*/</span> </span><br><span class=\"line\">        swap_flg = <span class=\"number\">0</span>;<span class=\"comment\">/*每次设置交换标识为0*/</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;          <span class=\"comment\">/*本趟排序的遍历元素个数*/</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] &gt; a[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                SWAP(a[j],a[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">                swap_flg = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*本趟数，无数据交换的话，说明已经有序，直接退出*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (swap_flg == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"comment\">//整数或浮点数皆可使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(T arr[], <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j; T temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; len - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                temp = arr[j];</span><br><span class=\"line\">                arr[j] = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[j + <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-2-选择排序\"><a href=\"#3-3-2-选择排序\" class=\"headerlink\" title=\"3.3.2 选择排序\"></a>3.3.2 选择排序</h4><p>&emsp;选择排序算法时间复杂度为O(n^2)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selectSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = arr.lenght;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> out = <span class=\"number\">0</span>; out &lt; size; out++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mixIndex = out;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> in = out - <span class=\"number\">1</span>; in &lt; size; in++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[mixIndex] &gt; arr[in]) &#123;</span><br><span class=\"line\">                mixIndex = in;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mixIndex != out) &#123;</span><br><span class=\"line\">            swap(arr, mixIndex, out);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*选择排序*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">select_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size - <span class=\"number\">1</span>; i++)  &#123;</span><br><span class=\"line\">        min = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i + <span class=\"number\">1</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class=\"line\">                min = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (min != i) &#123;</span><br><span class=\"line\">            SWAP(a[i],a[min]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-3-插入排序\"><a href=\"#3-3-3-插入排序\" class=\"headerlink\" title=\"3.3.3 插入排序\"></a>3.3.3 插入排序</h4><p>&emsp;插入排序每次从无序数据集合中取出一个元素，插入到已经排好序的数据集中适当位置，使数据集仍然有序。插入排序不需要额外空间。时间复杂度O(n2)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = arr.lenght;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> out = <span class=\"number\">1</span>; out &lt; size; out++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[out];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> in = out;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (in - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> &amp;&amp; arr[in - <span class=\"number\">1</span>] &gt; temp) &#123;</span><br><span class=\"line\">            arr[in] = arr[in - <span class=\"number\">1</span>];</span><br><span class=\"line\">            in--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (in != out) &#123;</span><br><span class=\"line\">            arr[in] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*插入排序*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i ++)<span class=\"comment\">/*需要插入的元素个数*/</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> key = a[i];<span class=\"comment\">/*保存插入的元素数据*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">/* i 之前的元素都是有序的，找到比key小的插入到他后面，</span></span><br><span class=\"line\"><span class=\"comment\">        * 比key大的，需要往后挪一个位置*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>((j &gt;= <span class=\"number\">0</span>) &amp;&amp; (a[j] &gt; key)) &#123;</span><br><span class=\"line\">            a[j + <span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[j + <span class=\"number\">1</span>] = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">issort</span><span class=\"params\">(<span class=\"keyword\">void</span> *data, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> esize, <span class=\"keyword\">int</span> (*compare)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2))</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *a = data;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((key = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(esize)) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">1</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">        i = j - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span> &amp;&amp; compare(&amp;a[i * esize], key) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mamcpy(&amp;a[(i + <span class=\"number\">1</span>) * esize], &amp;a[i * esize], esize);</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(&amp;a[(i + <span class=\"number\">1</span>) * esize], key, esize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-4-希尔排序\"><a href=\"#3-3-4-希尔排序\" class=\"headerlink\" title=\"3.3.4 希尔排序\"></a>3.3.4 希尔排序</h4><p>&ensp;希尔排序时间复杂度O(n*(logn)^2)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = arr.lenght;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (h &lt;= size / <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        h = h * <span class=\"number\">3</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (h &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> out = h; out &lt; size; out++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = arr[out];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> in = out;</span><br><span class=\"line\">            <span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (in - h &gt;= <span class=\"number\">0</span> &amp;&amp; arr[in - h] &gt; temp) &#123;</span><br><span class=\"line\">                arr[in] = arr[in - h];</span><br><span class=\"line\">                in = in - h;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (in != out) &#123;</span><br><span class=\"line\">                arr[in] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h = (h - <span class=\"number\">1</span>) / <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-5-归并排序\"><a href=\"#3-3-5-归并排序\" class=\"headerlink\" title=\"3.3.5 归并排序\"></a>3.3.5 归并排序</h4><p>&emsp;归并排序是一种分支排序算法。归并排序需要额外存储空间来完成排序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  x &lt; y ? x : y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *a = arr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *b = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(len * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> seg, start;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (seg = <span class=\"number\">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (start )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (idx = <span class=\"number\">0</span>; idx &lt; size; idx++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%08d\\n&quot;</span>, arr[idx]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> __merge(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q, <span class=\"keyword\">int</span> r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *tmp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j, k;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">malloc</span>((r - p + <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tmp)</span><br><span class=\"line\">        <span class=\"built_in\">abort</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = p, j = q + <span class=\"number\">1</span>, k = <span class=\"number\">0</span>; i &lt;= q &amp;&amp; j &lt;= r;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt;= arr[j])</span><br><span class=\"line\">            tmp[k++] = arr[i++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            tmp[k++] = arr[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == q + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &lt;= r;)</span><br><span class=\"line\">            tmp[k++] = arr[j++];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt;= q;)</span><br><span class=\"line\">            tmp[k++] = arr[i++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(arr + p, tmp, (r - p + <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> __merge_sort(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> q;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p &gt;= r)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    q = (p + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    __merge_sort(arr, p, q);</span><br><span class=\"line\">    __merge_sort(arr, q + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    __merge(arr, p, q, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    __merge_sort(arr, <span class=\"number\">0</span>, size - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_verify</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> test[<span class=\"number\">10</span>] = &#123;<span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">23</span>, <span class=\"number\">67</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">31</span>, <span class=\"number\">56</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    __merge(test, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(test, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> test[<span class=\"number\">10</span>] = &#123;<span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">23</span>, <span class=\"number\">67</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">31</span>, <span class=\"number\">56</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    merge_sort(test, <span class=\"number\">10</span>);</span><br><span class=\"line\">    dump(test, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//merge_verify();</span></span><br><span class=\"line\">    merge_sort_test();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-6-快速排序\"><a href=\"#3-3-6-快速排序\" class=\"headerlink\" title=\"3.3.6 快速排序\"></a>3.3.6 快速排序</h4><p>&emsp;快速排序是一种分治排序算法。不需要额外存储空间，时间复杂度O(nlgn)</p>\n<p>&emsp;快速排序三个步骤：</p>\n<ul>\n<li>分：设定一个分割值并将数据分为两部分。</li>\n<li>治：分别在两部分使用递归方式继续使用快速排序方法。</li>\n<li>和：对分割部分排序直至完成。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">Range</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">&#125; Range;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Range <span class=\"title\">now_Range</span><span class=\"params\">(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Range r;</span><br><span class=\"line\">    r.start = s;</span><br><span class=\"line\">    r.end = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *x, <span class=\"keyword\">int</span> *y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = *x;</span><br><span class=\"line\">    *x = *y;</span><br><span class=\"line\">    *y = t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Range r[len];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">    r[p++] = new_Range(<span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p) &#123;</span><br><span class=\"line\">        Range range = r[--p];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.start &gt;= range.end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = arr[(range.start + range.end) / <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = range.start;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = range.end;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (arr[left] &lt; mid) &#123;</span><br><span class=\"line\">                ++left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (arr[right] &gt; mid) &#123;</span><br><span class=\"line\">                --right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left &lt;= right) &#123;</span><br><span class=\"line\">                swap(&amp;arr[left], &amp;arr[right]);</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (left &lt;= right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.start &lt; right) &#123;</span><br><span class=\"line\">            r[p++] = new_Range(range.start, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range.end &gt; left) &#123;</span><br><span class=\"line\">            r[p++] = new_Range(left, range.end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QuickSort</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &lt; high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = high;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = arr[low];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从右向左找第一个小于k的数</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= k) &#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">                arr[i++] = arr[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 从左向右找第一个大于等于k的数</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; j &amp;&amp; arr[i] &lt; k) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; j) &#123;</span><br><span class=\"line\">                arr[j--] = arr[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[i] = k;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 递归调用</span></span><br><span class=\"line\">        QuickSort(arr, low, i - <span class=\"number\">1</span>); <span class=\"comment\">// 排序k左边</span></span><br><span class=\"line\">        QuickSort(arr, i + <span class=\"number\">1</span>, high); <span class=\"comment\">// 排序k右边</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">( <span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j, p, tmp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>)  <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = a[n / <span class=\"number\">2</span>];   <span class=\"comment\">// Get the middle element as pivot ..</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>, j = n <span class=\"number\">-1</span>;; i++, j--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[i] &lt; p)</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p &lt; a[j])</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i &gt;= j)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        tmp = a[i]; a[i] = a[j]; a[j] = tmp;    <span class=\"comment\">//swap both ..</span></span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    quick_sort( a, i); </span><br><span class=\"line\">    quick_sort( a + i, n - i); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dump</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (idx = <span class=\"number\">0</span>; idx &lt; size; idx++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%08d\\n&quot;</span>, arr[idx]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = *a;</span><br><span class=\"line\">    *a = *b;</span><br><span class=\"line\">    *b = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//int pivot = arr[r];</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    i = j = p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; j &lt; r; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[j] &lt; arr[r]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i != j) &#123;</span><br><span class=\"line\">                swap(arr + i, arr + j);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    swap(arr + i, arr + r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> __quick_sort(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> q;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p &gt;= r)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    q = partition(arr, p, r);</span><br><span class=\"line\">    __quick_sort(arr, p, q<span class=\"number\">-1</span>);</span><br><span class=\"line\">    __quick_sort(arr, q+<span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    __quick_sort(arr, <span class=\"number\">0</span>, size - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> test[<span class=\"number\">10</span>] = &#123;<span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">23</span>, <span class=\"number\">67</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">31</span>, <span class=\"number\">56</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    quick_sort(test, <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dump(test, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    quick_sort_test();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Qsort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (high &lt;= low) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = high + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> key = arr[low];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*从左向右找比key大的值*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (arr[++i] &lt; key) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == high) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*从右向左找比key小的值*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (arr[--j] &gt; key)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == low) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= j) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*交换i,j对应的值*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*中枢值与j对应值交换*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = arr[low];</span><br><span class=\"line\">    arr[low] = arr[j];</span><br><span class=\"line\">    arr[j] = temp;</span><br><span class=\"line\">    <span class=\"built_in\">Qsort</span>(arr, low, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">Qsort</span>(arr, j + <span class=\"number\">1</span>, high);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>qsort/sort函数</strong><br>&ensp;在c语言库函数中已经实现了qsort函数,<br>&emsp;qsort函数用法:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qsort</span><span class=\"params\">(<span class=\"keyword\">void</span> *base, <span class=\"keyword\">int</span> nelem, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> (*fcmp)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 参数:1 带排序数组首地址, nelem 数组中待排元素数量  width 各元素所在空间大小  *fcmp 指向函数的指针</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// int 数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (*(<span class=\"keyword\">int</span> *)a - *(<span class=\"keyword\">int</span> *)b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">qsort(arr, n, <span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>]), cmp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// char 数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">com</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">char</span> *)a - *(<span class=\"keyword\">char</span> *)b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">char</span> word[<span class=\"number\">100</span>];</span><br><span class=\"line\">qsort(word, <span class=\"number\">100</span>, <span class=\"keyword\">sizeof</span>(word[<span class=\"number\">0</span>]), cmp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// double 类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"keyword\">double</span> *)a &gt; *(<span class=\"keyword\">double</span>*)b ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">double</span> in[<span class=\"number\">100</span>];</span><br><span class=\"line\">qsort(in, <span class=\"number\">100</span>, <span class=\"keyword\">sizeof</span>(in[<span class=\"number\">00</span>]), cmp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// struct 结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Sample</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">&#125;st[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (*(Sample *)a).data &gt; (*(Sampel *)b).data ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">qsort(s, <span class=\"number\">100</span>, <span class=\"keyword\">sizeof</span>(s[<span class=\"number\">0</span>]), cmp);</span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Sample</span> *<span class=\"title\">c</span> =</span> (Sample *)a;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Sample</span> *<span class=\"title\">d</span> =</span> (Sample *)b;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c-&gt;x != d-&gt;x) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c-&gt;x - d-&gt;x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> d-&gt;y - c-&gt;y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">qsort(s,<span class=\"number\">100</span>,<span class=\"keyword\">sizeof</span>(s[<span class=\"number\">0</span>]),cmp);</span><br><span class=\"line\"></span><br><span class=\"line\">truct Sample</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">100</span>];</span><br><span class=\"line\">&#125;s[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按照结构体中字符串str的字典顺序排序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *a, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>((*(Sample *)a)-&gt;str , (*(Sample *)b)-&gt;str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">qsort(s,<span class=\"number\">100</span>,<span class=\"keyword\">sizeof</span>(s[<span class=\"number\">0</span>]),cmp);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-7-堆排序\"><a href=\"#3-3-7-堆排序\" class=\"headerlink\" title=\"3.3.7 堆排序\"></a>3.3.7 堆排序</h4><p>&emsp;桶排序算法基本原理：把数组中的所有元素分为若干个数据块，也就是若干个桶，然后对每个桶里的数据进行排序，最后将所有桶里的数据依次排列。<br>&emsp;存在两个问题：<br>&emsp;(1)怎样划分数据块，也就是分几个桶，每个桶放哪几个数据。<br>&emsp;(2)对每个数据块里的数据怎样排序。<br>&ensp;堆排序使利用堆这种数据结构设计的一种选择排序算法。堆是一种近似完全二叉树的结构(通常堆用一维数组实现),并满足性质；最大堆(大顶堆)为例，其父节点的值总是大于它的孩子节点。<br>&ensp;堆排序的过程：<br>&emsp;1.由输入的无序数组构造一个最大堆，作为初始的无序区<br>&emsp;2.把堆顶元素(最大值)和堆尾元素互换<br>&emsp;3.把堆(无序区)的尺寸缩小1，并调用heapify(A,0)从新的堆顶元素开始进行堆调整。<br>&emsp;4.重复步骤2，直到堆的尺寸为1<br>&ensp;因为每次插入数据效率是O(logN)，而我们需要进行n次循环，将数组中每个值插入到堆中，所以它的执行时间是O(N*logN)级。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sdtio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; KeyNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bucket_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> keys[], <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> bucket_size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    KeyNode **bucket_table = (KeyNode **)mallov(bucket_size * <span class=\"keyword\">sizeof</span>(KeyNode*));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; bucket_size;i++) &#123;</span><br><span class=\"line\">        bucket_table[i] = (KeyNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(KeyNode));</span><br><span class=\"line\">        bucket_table[i]-&gt;key = <span class=\"number\">0</span>;</span><br><span class=\"line\">        bucket_table[i]-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>;j &lt; size;j++) &#123;</span><br><span class=\"line\">        KeyNode *node = (KeyNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(KeyNode));</span><br><span class=\"line\">        node-&gt;key = keys[j];</span><br><span class=\"line\">        node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = keys[j]/<span class=\"number\">10</span>;</span><br><span class=\"line\">        KeyNode *p = bucket_table[index];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;key == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            bucket_table[index]-&gt;next = node;</span><br><span class=\"line\">            (bucket_table[index]-&gt;key)++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p-&gt;next != <span class=\"literal\">NULL</span> &amp;&amp; p-&gt;next-&gt;key &lt;= node-&gt;key)</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">            node-&gt;next = p-&gt;next;</span><br><span class=\"line\">            p-&gt;next = node;</span><br><span class=\"line\">            (bucket_table[index]-&gt;key)++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//print result</span></span><br><span class=\"line\">    KeyNode * k = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; bucket_size;i++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k = bucket_table[i]-&gt;next;k!=<span class=\"literal\">NULL</span>;k=k-&gt;next)</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,k-&gt;key);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> raw[] = &#123;<span class=\"number\">49</span>,<span class=\"number\">38</span>,<span class=\"number\">65</span>,<span class=\"number\">97</span>,<span class=\"number\">76</span>,<span class=\"number\">13</span>,<span class=\"number\">27</span>,<span class=\"number\">49</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"keyword\">sizeof</span>(raw)/<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">    bucket_sort(raw,size,<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Heapify</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lef_child = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> right_child = <span class=\"number\">2</span> * i + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lef_child &lt; size &amp;&amp; A[lef_child] &gt; A[max]) &#123;</span><br><span class=\"line\">        max = lef_child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right_child &lt; size &amp;&amp; A[right_child] &gt; A[max]) &#123;</span><br><span class=\"line\">        max = right_child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (max != i) &#123;</span><br><span class=\"line\">        Swap(A, i max);</span><br><span class=\"line\">        Heapify(A, max, size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BuildHeap</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heap_size = n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = heap_size / w - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        Heapify(A, i, heap_size);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> heap_size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HeapSort</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heap_size = BuildHeap(A, n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (heap_size &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        Swap(A, <span class=\"number\">0</span>, heap_size);</span><br><span class=\"line\">        Heap(A, <span class=\"number\">0</span>, heap_size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-8-leetcode排序\"><a href=\"#3-3-8-leetcode排序\" class=\"headerlink\" title=\"3.3.8 leetcode排序\"></a>3.3.8 leetcode排序</h4><ul>\n<li>按奇偶排序数组</li>\n<li>对链表进行插入排序</li>\n<li>合并区间</li>\n<li>最大数</li>\n<li>最接近原点的K个点</li>\n</ul>\n<h3 id=\"3-4-贪心算法\"><a href=\"#3-4-贪心算法\" class=\"headerlink\" title=\"3.4 贪心算法\"></a>3.4 贪心算法</h3><h4 id=\"3-4-1-基本概念\"><a href=\"#3-4-1-基本概念\" class=\"headerlink\" title=\"3.4.1 基本概念\"></a>3.4.1 基本概念</h4><p>&ensp;贪心算法:在对问题求解时,总是做出在当前是最好的选择,即不考虑整体最优,仅考虑局部最优解.<br>&ensp;贪心算法没有固定算法框架,算法关键是贪心策略的选择.他想算法不是所有问题都得到最优解,选择贪心策略必须具备无后效性,即某个状态以后的过程不会影响一起的状态,只与当前状态有关.</p>\n<h4 id=\"3-4-2-描述\"><a href=\"#3-4-2-描述\" class=\"headerlink\" title=\"3.4.2 描述\"></a>3.4.2 描述</h4><p>&ensp;贪心算法实现步骤:<br>&emsp;1.建立数学模型描述问题<br>&emsp;2.把求解的问题分成若干个子问题<br>&emsp;3.对每个子问题求解,得到子问题的局部最优解<br>&emsp;4.把子问题的解局部最优解合成原来问题的一个解.<br>&ensp;实现算法过程:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (能朝给定总目标前进一步)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    利用可行的决策,求出可行解的一个解元素;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">由所有解元素组合成问题的一个可行解</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-4-3-应用\"><a href=\"#3-4-3-应用\" class=\"headerlink\" title=\"3.4.3 应用\"></a>3.4.3 应用</h4><p><strong>最小生成树算法</strong><br>&ensp;贪心算法经典实践:最小生成树算法<br>&emsp;设<code>G=(V, E)</code>是无向连通带权图,即一个网络,E中的每一条边<code>(v,w)</code> 的全为 <code>c[v][w]</code>.如果G的字体 G’ 是一颗包含 G 的所有顶点的数,则称 G’ 为 G 的生成树.生成树上各边权的总和称为生成树的耗费.在 G 的所有生成树中,耗费最小的生成树称为 G 的最小生成树.<br>&ensp;最小生成树的性质:<br>&emsp;&emsp;设<code>G=(V, E)</code>是连通带权图, U是V的真子集.如果(u,v)属于E,且u属于E,v属于V-U,且在所有这样的边中,(u,v)的权c[u][v]最小,那么一定存在G的一颗最小生成树,它亦是(u,v)为其中一条边,这个性质有时也称为MST性质.</p>\n<p><strong>Prim算法</strong><br>&emsp;&emsp;设<code>G=(V, E)</code>是连通带权图, V={1,2,…,n}.构造G的最小生成树Prim算法的基本思想是:**首先置S={1},然后,只有S是V的真子集,就进行如下的贪心选择:选取满足添加i属于S,j属于V-S,且c[i][j]最小的边,将顶点j添加到S中.这个过程一直进行到S=V时为止.在这个过程中选取到的所有边恰好构成G的一颗最小生成树.</p>\n<details>\n<summary>Prim</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @file</span></span><br><span class=\"line\"><span class=\"comment\"> * @author [Timothy Maloney](https://github.com/sl1mb0)</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief [Prim&#x27;s algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)</span></span><br><span class=\"line\"><span class=\"comment\"> * implementation in C to find the MST of a weighted, connected graph.</span></span><br><span class=\"line\"><span class=\"comment\"> * @details Prim&#x27;s algorithm uses a greedy approach to generate the MST of a</span></span><br><span class=\"line\"><span class=\"comment\"> *weighted connected graph. The algorithm begins at an arbitrary vertex v, and</span></span><br><span class=\"line\"><span class=\"comment\"> *selects a next vertex u, where v and u are connected by a weighted edge whose</span></span><br><span class=\"line\"><span class=\"comment\"> *weight is the minimum of all edges connected to v.</span></span><br><span class=\"line\"><span class=\"comment\"> * @references Page 319 &quot;Introduction to the Design and Analysis of Algorithms&quot;</span></span><br><span class=\"line\"><span class=\"comment\"> *- Anany Levitin</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * To test - run &#x27;./prim -test&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * prim() will find the MST of the following adj. matrix:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *\t  0  1  2  3</span></span><br><span class=\"line\"><span class=\"comment\"> *        1  0  4  6</span></span><br><span class=\"line\"><span class=\"comment\"> *        2  4  0  5</span></span><br><span class=\"line\"><span class=\"comment\"> *        3  6  5  0</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The minimum spanning tree for the above weighted connected graph is given by</span></span><br><span class=\"line\"><span class=\"comment\"> *the following adj matrix:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *\t  0  1  2  3</span></span><br><span class=\"line\"><span class=\"comment\"> *\t  1  0  0  0</span></span><br><span class=\"line\"><span class=\"comment\"> *\t  2  0  0  0</span></span><br><span class=\"line\"><span class=\"comment\"> *\t  3  0  0  0</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The following [link](https://visualgo.net/en/mst) provides a visual</span></span><br><span class=\"line\"><span class=\"comment\"> *representation of graphs that can be used to test/verify the algorithm for</span></span><br><span class=\"line\"><span class=\"comment\"> *different adj matrices and their weighted, connected graphs.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span>    <span class=\"comment\">/// for assert()</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;inttypes.h&gt;</span>  <span class=\"comment\">/// for uint16_t</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span>     <span class=\"comment\">/// for IO operations</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span>    <span class=\"comment\">/// for string comparison</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 20</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 999</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Finds index of minimum element in edge list for an arbitrary vertex</span></span><br><span class=\"line\"><span class=\"comment\"> * @param arr graph row</span></span><br><span class=\"line\"><span class=\"comment\"> * @param N number of elements in arr</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns index of minimum element in arr</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint16_t</span> <span class=\"title\">minimum</span><span class=\"params\">(<span class=\"keyword\">uint16_t</span> arr[], <span class=\"keyword\">uint16_t</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> min = INF;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; min) &#123;</span><br><span class=\"line\">            min = arr[i];</span><br><span class=\"line\">            index = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Used to find MST of user-generated adj matrix G</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">prim</span><span class=\"params\">(<span class=\"keyword\">uint16_t</span> G[][MAX], <span class=\"keyword\">uint16_t</span> MST[][MAX], <span class=\"keyword\">uint16_t</span> V)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> u, v;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> E_t[MAX], path[MAX];</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> V_t[MAX], no_of_edges;</span><br><span class=\"line\"></span><br><span class=\"line\">    E_t[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;  <span class=\"comment\">// edges for current vertex</span></span><br><span class=\"line\">    V_t[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;  <span class=\"comment\">// list of visited vertices</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> i = <span class=\"number\">1</span>; i &lt; V; i++) &#123;</span><br><span class=\"line\">        E_t[i] = G[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        path[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        V_t[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    no_of_edges = V - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (no_of_edges &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        u = minimum(E_t, V);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (V_t[u] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            E_t[u] = INF;</span><br><span class=\"line\">            u = minimum(E_t, V);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        v = path[u];</span><br><span class=\"line\">        MST[v][u] = E_t[u];</span><br><span class=\"line\">        MST[u][v] = E_t[u];</span><br><span class=\"line\">        no_of_edges--;</span><br><span class=\"line\">        V_t[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> i = <span class=\"number\">1</span>; i &lt; V; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (V_t[i] == <span class=\"number\">0</span> &amp;&amp; G[u][i] &lt; E_t[i]) &#123;</span><br><span class=\"line\">                E_t[i] = G[u][i];</span><br><span class=\"line\">                path[i] = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Self-test implementations</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">uint16_t</span> G[][MAX], <span class=\"keyword\">uint16_t</span> MST[][MAX], <span class=\"keyword\">uint16_t</span> V)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> test[<span class=\"number\">4</span>][<span class=\"number\">4</span>] = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>&#125;, &#123;<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>&#125;, &#123;<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> solution[<span class=\"number\">4</span>][<span class=\"number\">4</span>] = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    V = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> i = <span class=\"number\">0</span>; i &lt; V; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> j = <span class=\"number\">0</span>; j &lt; V; ++j) &#123;</span><br><span class=\"line\">            G[i][j] = test[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prim(&amp;(*G), &amp;(*MST), V);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> i = <span class=\"number\">0</span>; i &lt; V; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">uint16_t</span> j = <span class=\"number\">0</span>; j &lt; V; ++j) &#123;</span><br><span class=\"line\">            assert(MST[i][j] == solution[i][j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Function user_graph();</span></span><br><span class=\"line\"><span class=\"comment\"> * gets user input adj. matrix and finds MST of that graph</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns void</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">user_graph</span><span class=\"params\">(<span class=\"keyword\">uint16_t</span> G[][MAX], <span class=\"keyword\">uint16_t</span> MST[][MAX], <span class=\"keyword\">uint16_t</span> V)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter the number of vertices: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot; %hd&quot;</span>, &amp;V);</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(V &lt;= MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter the adj matrix\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; V; ++j) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;G[%d][%d]: &quot;</span>, i, j);</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot; %hd&quot;</span>, &amp;G[i][j]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (G[i][j] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                G[i][j] = INF;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prim(&amp;(*G), &amp;(*MST), V);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;minimum spanning tree:\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; V; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; V; ++j) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\t&quot;</span>, MST[i][j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Main function</span></span><br><span class=\"line\"><span class=\"comment\"> * @param argc commandline argument count (ignored)</span></span><br><span class=\"line\"><span class=\"comment\"> * @param argv commandline array of arguments (ignored)</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns 0 on exit</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> G[MAX][MAX];    <span class=\"comment\">///&lt; weighted, connected graph G</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> MST[MAX][MAX];  <span class=\"comment\">///&lt; adj matrix to hold minimum spanning tree of G</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> V;              <span class=\"comment\">///&lt; number of vertices in V in G</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc == <span class=\"number\">2</span> &amp;&amp; <span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;-test&quot;</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        test(&amp;(*G), &amp;(*MST), V);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        user_graph(&amp;(*G), &amp;(*MST), V);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<h4 id=\"3-4-4-leetcode题目\"><a href=\"#3-4-4-leetcode题目\" class=\"headerlink\" title=\"3.4.4 leetcode题目\"></a>3.4.4 leetcode题目</h4><ul>\n<li>柠檬水找零</li>\n<li>分发饼干</li>\n</ul>\n<h3 id=\"3-5-动态规划\"><a href=\"#3-5-动态规划\" class=\"headerlink\" title=\"3.5 动态规划\"></a>3.5 动态规划</h3><p>&ensp;动态规划(<code>DP</code>):是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.常用于重叠子问题和最优子结构性质的问题,动态规划时间通常远小于朴素解法.</p>\n<h4 id=\"3-5-1-基本概念\"><a href=\"#3-5-1-基本概念\" class=\"headerlink\" title=\"3.5.1 基本概念\"></a>3.5.1 基本概念</h4><p>&ensp;动态规划:要解一个给定问题,需要解其不同部分(即子问题),再根据子问题的解以得出原问题的解.通常子问题非常相似,子问题解算出后,将其记录.<br>&ensp;动态规划过程是:每次决策依赖于当前状态,又随即引起状态转移.一个决策序列就是在变化的状态中产生除留的,这种多阶段最优化决策解决过程称为动态规划.<br>&ensp;动态规划与分治法的区别是子问题通常不是独立的.</p>\n<h4 id=\"3-5-2-描述算法\"><a href=\"#3-5-2-描述算法\" class=\"headerlink\" title=\"3.5.2 描述算法\"></a>3.5.2 描述算法</h4><p>&ensp;可采用动态规划的问题3个性质:<br>&emsp;1) <strong>最优化原理</strong>:如果问题的最优解所包含的子问题的解也是最优的,则称该问题具有最优子结构,即满足最优化原理.<br>&emsp;2) <strong>无后效性</strong>:即某阶段状态确定后,就不受之后的决策影响,即某状态以后过程不影响以前的状态,只与当前状态有关.<br>&emsp;3) <strong>有重叠子问题</strong>:</p>\n<br>\n&ensp;动态规划所处理的问题是一个多阶段决策问题,由初始状态开始,通过中间阶段决策的选择,达到结束状态.形成一个决策序列.\n\n<p>&ensp;动态规划求解三要素:</p>\n<blockquote>\n<p>(1) 问题的节点<br>(2) 每个阶段的状态<br>(3) 从前一个阶段转化到后一个阶段之间的递推关系</p>\n</blockquote>\n<p>&ensp;<strong>最优决策表</strong></p>\n<blockquote>\n<p>f(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}</p>\n</blockquote>\n<h4 id=\"3-5-3-背包问题\"><a href=\"#3-5-3-背包问题\" class=\"headerlink\" title=\"3.5.3 背包问题\"></a>3.5.3 背包问题</h4><p>&ensp;问题描述:<br>&emsp;有N件物品和一个体积为V的背包.(每种物品只有一件)第i件物品的体积是volume[i],价值是value[i],求解哪些物品装入背包可使这些物品的体积综合不超过背包体积,且价值总和最大.<br>&ensp;解题思路:<br>&emsp;p[i][j]代表前i件物品组合在容量为j的背包的最优解.将前i件物品放入容量为v的背包中这个子问题,若只考虑第i件物品的策略(放或不放),那么可以转化为一个只牵扯前i-1物品的问题.如果不放第i件物品,那么问题就转化为”前i-1件物品放入容量为v的背包中,价值为p[i-1][v];如果放第i件物品,那么问题就转化为”前i-1物品放入剩下的容量为v-volume[i]的背包中”,此时能获得的最大价值就是p[i-1][j-volume]再加上通过放入第i件物品获得的价值value[i].</p>\n<p>&ensp;<strong>状态转移方程:</strong></p>\n<blockquote>\n<p>p[i][j] = max{p[i-1][j-vol] + value[i], p[i-1][j]}<br>&ensp;伪代码描述:</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1.</span>..N</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j = V..<span class=\"number\">.0</span></span><br><span class=\"line\">        p[j] = max&#123;p[j-volume[i]] + value[i], p[j]&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<details>\n<summary>dp</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> v[]=&#123;<span class=\"number\">6</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> w[]=&#123;<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">100</span>][<span class=\"number\">100</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a&gt;=b)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getAns</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> wi)</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x=<span class=\"number\">0</span>;x&lt;=i;x++) &#123;</span><br><span class=\"line\">\t\tdp[x][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt;= wi; x++) &#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">0</span>][x]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = <span class=\"number\">1</span>; x &lt;= i; x++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y=<span class=\"number\">1</span>;y&lt;=wi;y++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(y&gt;=w[x<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">\t\t\t\tdp[x][y]=Max(dp[x<span class=\"number\">-1</span>][y],v[x<span class=\"number\">-1</span>]+dp[x<span class=\"number\">-1</span>][y-w[x<span class=\"number\">-1</span>]]);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tdp[x][y]=dp[x<span class=\"number\">-1</span>][y];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%4d&quot;</span>,dp[x][y]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[i][wi];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> max=getAns(<span class=\"number\">5</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,max);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n</details>\n\n<h4 id=\"3-5-4-最长公共子序列\"><a href=\"#3-5-4-最长公共子序列\" class=\"headerlink\" title=\"3.5.4 最长公共子序列\"></a>3.5.4 最长公共子序列</h4><p>&ensp;问题描述:<br>&emsp;一个散列S,如果分别是两个或多个已知数列的子序列,且是所有匹配此条件序列中最长的,则S称为已知序列的最长公共子序列(LCS)<br>&ensp;给定两个序列X,Y,求两个序列的最长公共子序列.<br>&ensp;解题思路:<br>&emsp;最长公共子序列问题存在最优子结构；这个问题可分解成更小，更简单的“子问题”，这个子问题可以分成更多的子问题，因此整个问题就变得简单了。<br>&emsp;最长公共子序列问题的子问题的解是可以重复使用的，即，更高级别的子问题通常会重用低级子问题的解。拥有这个两个属性的问题可以使用动态规划算法来解决，这样子问题的解就可以存储起来，而不用重复计算。这个过程需要在一个表中存储同一级别的子问题的解，因此这个解可被更高级的子问题使用。设有二维数组f[i][j]表示X的i位和Y的j位之前的最长公共子序列的长度，则有：</p>\n<blockquote>\n<p>f[1][1] = same(1,1)<br>f[i][j] = max{f[i-1][j-1] + same(i, j), f[i-1][j], f[i][j-1]}<br>&emsp;其中，<code>same(a,b)</code>当X的第a位与Y的第b位完全相同是”1”，否则位”1”。<br>&emsp;此时，f[i][j]中最大的数便是X和Y的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。<br>&emsp;该算法的空间、时间复杂度位O(n^2)，经过优化后，空间复杂度位O(n)。</p>\n</blockquote>\n<p>&ensp;伪代码:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">LCSLength</span><span class=\"params\">(X[<span class=\"number\">1.</span>.m], Y[<span class=\"number\">1.</span>.n])</span></span></span><br><span class=\"line\"><span class=\"function\">    C </span>= <span class=\"built_in\">array</span>(<span class=\"number\">0.</span>.m, <span class=\"number\">0.</span>.n)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0.</span>.m</span><br><span class=\"line\">        C[i, <span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"number\">0.</span>.n</span><br><span class=\"line\">        C[<span class=\"number\">0</span>, j] = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1.</span>.m</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">1.</span>.n</span><br><span class=\"line\">            <span class=\"keyword\">if</span> X[i] = Y[j]</span><br><span class=\"line\">                C[i, j] := C[i<span class=\"number\">-1</span>, j<span class=\"number\">-1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                C[i, j] := max(C[i, j<span class=\"number\">-1</span>], C[i<span class=\"number\">-1</span>,j])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> C[m, n]</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>最长公共序列数</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">100</span>][<span class=\"number\">100</span>];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> max=a;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(b&gt;max)&#123;</span><br><span class=\"line\">\t\tmax=b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(c&gt;max)&#123;</span><br><span class=\"line\">\t\tmax=c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMax</span><span class=\"params\">(<span class=\"keyword\">char</span> s1[],<span class=\"keyword\">char</span> s2[],<span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;m;i++)&#123;       <span class=\"comment\">//当 s2取 1个的时候 ,s1为可变长度 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s1[i]==s2[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">\t\t\tdp[i][<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(j=i+<span class=\"number\">1</span>;j&lt;m;j++)&#123;</span><br><span class=\"line\">\t\t\t\tdp[j][<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;      <span class=\"comment\">//当 s1取 1个的时候 ,s2为可变长度 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s2[i]==s1[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">\t\t\tdp[<span class=\"number\">0</span>][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(j=i+<span class=\"number\">1</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">\t\t\t\tdp[<span class=\"number\">0</span>][j]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(s1[i]==s2[j])&#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j]=Max(dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>,dp[i<span class=\"number\">-1</span>][j],dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j]=dp[i<span class=\"number\">-1</span>][j]&gt;=dp[i][j<span class=\"number\">-1</span>]?dp[i<span class=\"number\">-1</span>][j]:dp[i][j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m,n;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> s1[<span class=\"number\">100</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> s2[<span class=\"number\">100</span>];</span><br><span class=\"line\">\tgets(s1);</span><br><span class=\"line\">\tgets(s2);</span><br><span class=\"line\">\tm=<span class=\"built_in\">strlen</span>(s1);</span><br><span class=\"line\">\tn=<span class=\"built_in\">strlen</span>(s2);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,getMax(s1,s2,m,n));</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n\n<details>\n<summary>Fibonacci_dp</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fibonacci Series using Dynamic Programming</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Author: Moinak Banerjee(moinak878)</span></span><br><span class=\"line\"><span class=\"comment\">   Date : 1 October ,2019</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Out of Range checking</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\nNo Such term !\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// declaring array to store fibonacci numbers -- memoization</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *f = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>((n + <span class=\"number\">2</span>) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));  <span class=\"comment\">//  one extra to handle edge case, n = 0</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* let 0th and 1st number of the series be 0 and 1*/</span></span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    f[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Adding the previous 2 terms to make the 3rd term</span></span><br><span class=\"line\">        f[i] = f[i - <span class=\"number\">1</span>] + f[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> out = f[n];</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(f);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> number;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Asks for the number/position of term in Fibonnacci sequence</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        number = atoi(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter the value of n(n starts from 0 ): &quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;number);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The nth term is : %d \\n&quot;</span>, fib(number));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<h4 id=\"3-5-5-leetcode题目\"><a href=\"#3-5-5-leetcode题目\" class=\"headerlink\" title=\"3.5.5 leetcode题目\"></a>3.5.5 leetcode题目</h4><ul>\n<li>最大子序和</li>\n<li>编辑距离</li>\n<li>大礼包</li>\n<li>最长上升子序列</li>\n</ul>\n<h3 id=\"3-6-回溯法\"><a href=\"#3-6-回溯法\" class=\"headerlink\" title=\"3.6 回溯法\"></a>3.6 回溯法</h3><h4 id=\"3-6-1-基本概念\"><a href=\"#3-6-1-基本概念\" class=\"headerlink\" title=\"3.6.1 基本概念\"></a>3.6.1 基本概念</h4><p>&ensp;回溯算法实际上一个类似枚举的搜索尝试过程,主要是在<strong>搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就”回溯”返回,尝试别的路径</strong>.<br>&ensp;回溯法是一种迭代搜索法,按选优条件详情搜索,以达到目标.但当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择,这种走不通就退回再走的技术为回溯法,而满足回溯条件的某个状态的点称为”回溯法”.<br>&ensp;许多复杂度,规模较大的问题都看看而已使用回溯法,有”通用解题方法”的美称.</p>\n<p>&ensp;在包含问题的所有解的解空间树中,按照深度优先的策略,从根节点出发深度探索解空间树.当探索到某一节点时,要先判断该节点是否包含问题的解,如果包含,就从该节点出发继续探索下去,如果该节点不包含问题的解,则逐层向其足协节点回溯.(其实回溯法就是堆隐式图的深度优先搜索算法).<br>&ensp;若用回溯法求问题的所有解时,要回溯的根,且根节点的所有可行的子树都要已被搜索遍才结束,而若使用回溯法求任一个解时,只要搜索到问题的一个解就可以结束.<br>&ensp;回溯法一般解题步骤:<br>&emsp;1.<strong>针对所给问题,确定问题的解空间</strong>;首先应明确定义问题的解空间,解空间应至少包含问题的一个(最优)解.<br>&emsp;2.<strong>确定节点的扩展搜索规则</strong><br>&emsp;3.<strong>以深度优先方式搜索解空间,并在搜索过程中用剪枝函数避免无效搜索</strong></p>\n<p>&ensp;伪代码:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">iterativeBacktrack</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f(n, t) &lt;= g(n, t)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = f(n,t); i &lt;= g(n,t); i++) &#123;</span><br><span class=\"line\">                x[t] = h(i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (constraint(t) &amp;&amp; bound(t)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (solution(t)) &#123;</span><br><span class=\"line\">                        output(x);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        t++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    t--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-6-2-八皇后问题\"><a href=\"#3-6-2-八皇后问题\" class=\"headerlink\" title=\"3.6.2 八皇后问题\"></a>3.6.2 八皇后问题</h4><p>&ensp;问题描述<br>&emsp;八皇后问题使一个以国际象棋为背景的问题:如何能够在 8x8 的国际象棋棋盘上放着八个皇后,使得任何一个皇后都无法直接吃掉其他的皇后?为了达到此目的,任两个皇后都不能处于同一条横行,纵行或斜线上.<br>&ensp;转化规则:其实八皇后问题可以推广为更一般的n皇后摆放问题;这时棋盘大小变为nxn,而皇后个数也变成n.当且仅当n = 1 或 n &gt;= 4 时间问题有解。令一个一维数组a[n]保存所得解，其中a[i]表示把第i个皇后放在第i行的列数(注意i的值都是从0开始计算的),下面就八皇后问题的约束条件。<br>（1）因为所有的皇后都不能放在同一列，因为任意两个a[0]…a[7]的值不能存在相同的两个值<br>（2）所有的皇后都不能在堆角线上，那么该如何检测两个皇后是否在同一个对角线上？我们将棋盘的方格成一个二维数组，如下：<br>&ensp;假设有两个皇后被放置在(i,j)和(k,l)的位置上，明显，当且仅当|i-k|=|j-l|时，两个皇后才在同一条对角线上。</p>\n<p>&ensp;伪代码描述</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">queens</span><span class=\"params\">(<span class=\"keyword\">int</span> Queens)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, k, flag, not_finish = <span class=\"number\">1</span>, count = <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 正在处理的元素下标，表示前i-1个元素已符合要求，在处理第i个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[Queeens+<span class=\"number\">1</span>]; <span class=\"comment\">// 八皇后问题的皇后所在的行列位置，从1开始算起，所以加1</span></span><br><span class=\"line\">    i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a[<span class=\"number\">1</span>] = <span class=\"number\">1</span>; <span class=\"comment\">// 为数组的第一个元素赋初值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (not_finish) &#123; <span class=\"comment\">// not_finish=1 处理尚未结束</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(not_finish &amp;&amp; i &lt;= Queens) &#123; <span class=\"comment\">// 处理尚未结束且还没处理到第Queeens个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (flag=<span class=\"number\">1</span>, k=<span class=\"number\">1</span>; flag &amp;&amp; k &lt; i; k++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是否有多个皇后在同一行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[k] == a[i]) &#123;</span><br><span class=\"line\">                flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否有多个皇后在同一个对角线</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (k=<span class=\"number\">1</span>; flag &amp;&amp; k &lt; i; k++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((a[i] == a[k] - (k-i)) || (a]i] == a[k] + [k-i])) &#123;</span><br><span class=\"line\">                flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-6-3-leetcode题目\"><a href=\"#3-6-3-leetcode题目\" class=\"headerlink\" title=\"3.6.3 leetcode题目\"></a>3.6.3 leetcode题目</h4><ul>\n<li>N皇后</li>\n<li>括号生成</li>\n<li>单词搜索</li>\n<li>解数独</li>\n</ul>\n<h2 id=\"4-参考链接\"><a href=\"#4-参考链接\" class=\"headerlink\" title=\"4 参考链接\"></a>4 参考链接</h2><ul>\n<li>复杂度速查表<br><a href=\"https://liam.page/2016/06/20/big-O-cheat-sheet/\">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></li>\n<li>线性表<br><a href=\"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8\">https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8</a><ul>\n<li>单链表<br><a href=\"https://www.jianshu.com/p/73f0d8f807aa\">https://www.jianshu.com/p/73f0d8f807aa</a></li>\n</ul>\n</li>\n</ul>\n<p><a href=\"http://cocofe.cn/\">http://cocofe.cn/</a></p>\n<ul>\n<li>数据结构<br><a href=\"https://github.com/wangzheng0822/algo/\">https://github.com/wangzheng0822/algo/</a></li>\n</ul>"},{"title":"leetcode题解算法分析","date":"2021-10-26T16:47:53.000Z","updated":"2021-10-26T16:53:53.000Z","_content":"\n## 1.单调栈\n\n<!--more-->\n\n### 1.1 单调栈描述\n\n&ensp;单调栈里面的元素大小按照他们所在栈内的位置,满足一定的单调性.\n\n> 单调递**增**栈：单调递增栈就是从栈底到栈顶数据是从小到大; 可找到**左起**第一个比当前数字**小**的元素.\n> 单调递**减**栈：单调递减栈就是从栈底到栈顶数据是从大到小; 可找到**左起**第一个比当前数字**大**的元素.\n\n&emsp;单调递增栈，元素进栈过程，若当前进栈的元素a，如果a>栈顶元素，则直接将a进栈，如果a<=栈顶元素，则不断将栈顶元素出栈，直到满足a>栈顶元素。单调递减栈则为a<栈顶元素时进栈。\n\n&ensp;题目分析:给定一个数组,返回一个大小相同的数组,返回的数组的第i个位置的值应当是,对于原数组中的第i个元素,至少往右走多少步,才能遇到一个比自己大的元素(如果没有比自己大的元素,或为最后一个元素,则返回对应位置上为-1).\n&emsp;例如:\n&ensp;&emsp;input: 5, 3, 1, 2, 4\n&ensp;&emsp;return: -1, 3, 1, 1, -1\n&emsp;暴力解法时间复杂度O(n^2)\n&emsp;暴力解法:\n```c\nint *nextExceed(int *input, int size)\n{\n    int *result = (int *)malloc(sizeof(int) * size);\n    memset(input,-1,size*sizeof(int));\n    for (int i = 0; i < size; i++) {\n        int anchar = input[i];\n        for (int j = i + 1; j < size; j++) {\n            if (input[j] > anchar) {\n                result[j] = j - 1;\n                break;\n            }\n        }\n    }\n    return result;\n}\n```\n&emsp;单调栈:\n```c\nint *nextExceed(int *input, int size)\n{\n    int *result = (int *)malloc(sizeof(int) * size);\n    int *stack = (int *)malloc(sizeof(int) * size);\n    memset(input, -1, size * sizeof(int));\n    int top = 0;\n    for (int i = 0; i < size; i++) {\n        while (top >= 0 && input[i] > input[stack[top]]) {\n            result[stack[top]] = i - stack[top];\n            top--;\n        }\n        stack[++top] = i;\n    }\n    return result;\n}\n```\n\n&emsp;维护一个单调递**减**栈stack,stack内存的是原数组的每个index,当遇到一个比当前栈顶所对应的数**大**的时候,则栈顶元素出栈,并更新它们在返回数组中对应位置的值.\n\n&ensp;单调栈通常应用在一维数组上,和前后元素大小之间关系有关的问题.单调栈时间复杂度为`O(n)`.\n\n\n\n### 1.2 Letocde题目分析\n\n84.[柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/description/)\n\n\n\n<details>\n  <summary>柱状图中最大的矩形 c语言</summary>\n\n```c\nint largestRectangleArea(int* heights, int heightsSize) {\n    // 栈顶标记,单调递减栈\n    int top = -1;\n    int area = 0;\n    int maxArea = 0;\n    int *stack = (int *)malloc(sizeof(int) * (heightsSize + 2));\n    int *buf = (int *)malloc(sizeof(int) * (heightsSize + 2));\n\n    // 增加前哨兵\n    buf[0] = 0;\n    // 在最后增加哨兵\n    buf[heightsSize + 1] = 0;\n    for (int i = 1; i <= heightsSize; i++) {\n        buf[i] = heights[i - 1];\n    }\n\n    stack[++top] = 0;\n    for (int i = 1; i < heightsSize + 2; i++) {\n        while (top > 0 && buf[i] < buf[stack[top]]) {\n            // 注意 i - \n            area = (i - stack[top - 1] - 1) * buf[stack[top]];\n            maxArea = maxArea > area ? maxArea : area;\n            top--;\n        }\n        // 索引入栈，其他可能是元素入栈\n        stack[++top] = i;\n    }\n\n    return maxArea;\n}\n```\n\n</details>\n\n<br>\n\n\n### 1.3 单调栈的性质\n&emsp;1.单调栈里的元素具有单调性,栈中元素只能是单调递增或者单调递减\n&emsp;2.元素加入栈前,会在栈顶把破坏栈单调性的元素都出栈\n&emsp;3.使用单调栈可以找到元素向左遍历第一个比它小的元素,也可以找到元素向左遍历第一个比他大的元素\n\n### 1.3 leetcode题目\n[85.最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)\n&ensp;给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n&emsp;思路:对于每一行,构建一个histogram,然后计算.在构建新的histogram的时候,不需要全部遍历,只需对已有的histogram进行略微修改(运用DP的思想)\n\n<details>\n  <summary>maximalRectangle</summary>\n\n```c\nint maximalRectangle(char** matrix, int matrixSize, int* matrixColSize)\n{\n    int m = matrixSize;\n    if (m == 0) {\n        return 0;\n    }\n    int n = matrixColSize[0];\n    int left[m][n];\n    memset(left, 0, sizeof(left));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (matrix[i][j] == '1') {\n                left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;\n            }\n        }\n    }\n\n    int ret = 0;\n    for (int j = 0; j < n; j++) {  // 对于每一列，使用基于柱状图的方法\n        int up[m], down[m];\n        memset(up, 0, sizeof(up));\n        memset(down, 0, sizeof(down));\n        int stk[m], top = 0;\n        for (int i = 0; i < m; i++) {\n            while (top > 0 && left[stk[top - 1]][j] >= left[i][j]) {\n                top--;\n            }\n            up[i] = top == 0 ? -1 : stk[top - 1];\n            stk[top++] = i;\n        }\n        top = 0;\n        for (int i = m - 1; i >= 0; i--) {\n            while (top > 0 && left[stk[top - 1]][j] >= left[i][j]) {\n                top--;\n            }\n            down[i] = top == 0 ? m : stk[top - 1];\n            stk[top++] = i;\n        }\n\n        for (int i = 0; i < m; i++) {\n            int height = down[i] - up[i] - 1;\n            int area = height * left[i][j];\n            ret = fmax(ret, area);\n        }\n    }\n    return ret;\n}\n```\n\n</details>\n\n<br>\n\n![20211207235410](https://s2.loli.net/2021/12/07/aU8ZQBWRo9dTXMb.png)\n\n\n```c\nstack<int> st;\n//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解,单调减栈\nfor (遍历这个数组)\n{\n    if (栈空 || 栈顶元素大于等于当前比较元素) {\n        入栈;\n    } else {\n        while (栈不为空 && 栈顶元素小于当前元素) {\n            栈顶元素出栈;\n            更新结果;\n        }\n        当前数据入栈;\n    }\n}\n```\n\n<details>\n<summary>单调栈</summary>\n\n```c\nint largestRectangleArea(int* heights, int heightsSize,int *S,int top){\n    // int*S=(int*)malloc(sizeof(int)*heightsSize); // 初始化栈，栈内保存柱子序号\n    // int top=-1;\n    int start,end,h;\n    int r=0;\n    S[++top]=0; // 入栈第一根柱子\n    for(int i=1;i<=heightsSize-1;i++) { // 遍历所有柱子\n        if(heights[i] >= heights[S[top]]) { \n            S[++top]=i; // 若当前柱子大于栈顶或等于栈顶，直接入栈\n        } else { // 若当前柱子小于栈顶，则依次出栈较高的柱子并计算面积\n            end = S[top]; // 记录最右边最高的柱子位置，之后每次矩形的底边是从出栈位置到最右边最高柱子的位置\n            while(top != -1 && heights[i] < heights[S[top]] ) {\n                h = heights[S[top--]]; // 保存当前矩形的高\n                while(top != -1 && heights[S[top]] == h) top--; // 若有相同高的柱子，直接出栈\n                if (top != -1) start=S[top]; // 避免栈为空\n                else start=-1;\n\n                if(r < (end-start)*h) r=(end-start)*h; // 矩形面积是最高柱子位置减去当前栈顶柱子的位置乘高\n            }\n            S[++top]=i;\n        }\n    }\n    // 此时栈内剩余递增序列，出栈依次计算面积。计算流程同上\n    end = S[top];\n    while(top != -1) {\n        h = heights[S[top--]];\n        while( top != -1 && heights[S[top]] == h) top--;\n        if (top != -1) start=S[top];\n        else start=-1;\n\n        if(r < (end-start)*h) r=(end-start)*h;\n    }\n    return r;\n}\n\nint maximalRectangle(char** matrix, int matrixSize, int* matrixColSize){\n    int m=matrixSize;\n    int n=*matrixColSize;\n    if (m==0) return 0;\n    int *heights = (int*)malloc(sizeof(int)*n);\n    int*S=(int*)malloc(sizeof(int)*n); // 初始化栈，栈内保存柱子序号\n    int r=0;\n\n    for(int k=0;k<=n-1;k++) heights[k]=0;\n    for(int i=0;i<=m-1;i++) {\n        for(int j=0;j<=n-1;j++) {\n            if(matrix[i][j]=='1') heights[j]++;\n            else heights[j]=0;\n        }\n        int top=-1;\n        int cur=largestRectangleArea(heights,n,S,top);\n        if(cur > r) r=cur;\n    }\n    return r;\n}\n\n```\n\n</details>\n\n<details>\n<summary>StackCreate</summary>\n\n```c\ntypedef struct {\n    void **data;\n    int top;\n    int size;\n} Stack;\n\nStack *StackCreate(int stackSize)\n{\n    Stack *stack = (Stack *)malloc(sizeof(Stack));\n    if (stack == NULL) {\n        return NULL;\n    }\n\n    stack->data = (void **)malloc(sizeof(void **) * (stackSize + 1));\n    memset(stack->data, 0, sizeof(void **) * (stackSize + 1));\n    stack->top = -1;\n    stack->size = stackSize;\n    return stack;\n}\n\nvoid StackFree(Stack *obj)\n{\n    if (obj->data != NULL) {\n        free(obj->data);\n        obj->data = NULL;\n    }\n    free(obj);\n    obj = NULL;\n    return;\n}\n\nbool IsStackEmpty(Stack *obj)\n{\n    return (obj->top == -1);\n}\n\nbool IsStackFull(Stack *obj)\n{\n    return (obj->top ==  obj->size);\n}\n\nvoid StackPush(Stack *obj, void *data)  // 泛型接口，使用void *\n{\n    if (IsStackFull(obj) == true) {\n        return;\n    }\n    int top = obj->top;\n    obj->data[++top] = data;\n    obj->top = top;\n    return;\n}\n\nvoid StackPop(Stack *obj)\n{\n    if (IsStackEmpty(obj) == true) {\n        return;\n    }\n    void *data = obj->data[obj->top];\n    free(data);\n    data = NULL;\n    obj->top--;\n    return;\n}\n\nvoid *StackTop(Stack *obj)\n{\n    if (IsStackEmpty(obj) == true) {\n        return NULL;\n    }\n    return (obj->data[obj->top]);\n}\n\nvoid StackClear(Stack *obj)\n{\n    if (IsStackEmpty(obj) == true) {\n        return;\n    }\n\n    for (int i = 0; i <= obj->top; i++) {\n        void *data = obj->data[i];\n        if (data != NULL) {\n            free(data);\n            data = NULL;\n        }\n    }\n    obj->top = -1;\n    return;\n}\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\nint maximalRectangle(char **matrix, int matrixSize, int *matrixColSize)\n{\n    int **height = (int **)malloc(sizeof(int *) * matrixSize);\n    for (int i = 0; i < matrixSize; i++) {\n        height[i] = (int *)malloc(sizeof(int) * (matrixColSize[i] + 1));\n        for (int j = 0; j < matrixColSize[i]; j++) {\n            if (i == 0) {\n                height[i][j] = (matrix[i][j] == '1') ? 1 : 0;\n            } else {\n                height[i][j] = (matrix[i][j] == '1') ? (height[i - 1][j] + 1) : 0;\n            }\n        }\n        height[i][matrixColSize[i]] = 0;\n    }\n\n    Stack *monotoneStack = StackCreate(matrixSize * matrixSize);\n    int ans = 0;\n    for (int i = 0; i < matrixSize; i++) {\n        for (int j = 0; j <= matrixColSize[i]; j++) {\n            while ((IsStackEmpty(monotoneStack) != true) && \n                    (height[i][*(int *)monotoneStack->data[monotoneStack->top]] >= height[i][j])) {\n                int h = height[i][*(int *)monotoneStack->data[monotoneStack->top]];\n                StackPop(monotoneStack);\n                int sidx = ((IsStackEmpty(monotoneStack) == true) ? -1 : *(int *)(monotoneStack->data[monotoneStack->top]));\n                ans = MAX(ans, h * (j - sidx - 1));\n            }\n            int *node = (int *)malloc(sizeof(int));\n            *node = j;\n            StackPush(monotoneStack, node); \n        }\n        StackClear(monotoneStack);\n    }\n\n    StackFree(monotoneStack);\n    return ans;\n}\n```\n\n</details>\n\n<br>\n<br>\n\n85 Maximal Reactangle\nleetcode 496、503、739、239\n<br>\n42.接雨水\n\n<br>\n\n- 参考链接：\n[leetcode算法总结 ——单调栈&单调队列](https://blog.csdn.net/chongbin007/article/details/112741867?utm_term=%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97leetcode)\n\n\n\n\n\n## 2.并查集\n### 2.1 并查集介绍\n\n&ensp;并查集(DSU)主要用于解决一些元素分组的问题，管理一系列不相交的集合，并支持两种操作：\n&ensp;并查集即**合并集合**和**查找集合中元素**两种操作的算法.但实际并查集的基本操作有三个:\n&emsp;makeSet(size):建立一个新的并查集,其中包含size个单元素集合.\n&emsp;unionSet(x, y)**合并**:把元素x和元素y所在的集合合并,要求x和y所在的集合不相交,如果相交则不合并.\n&emsp;find(x)**查询**:找到元素x所在的集合的代表,该操作也可以用于判断两个元素是否位于同一个集合,只要将它们各自的代表比较一下就可以了. find(x)有两种实现方法,一种是递归,一种是非递归。\n\n&ensp;并查集的重要思想在于，用集合中的一个元素代表集合。\n\n&emsp;**算法:**\n&emsp;&emsp;用集合中的某个元素来代表这个集合,该元素称为集合的代表元.一个集合内的所有元素组织成以代表元为根的树形结构.对应每一个元素x来说,parent[x]指向x在树形结构上的父节点,如果x是根节点,则灵parent[x] = x. 对于查找操作,假设需要确定x所在的集合,也就是确定集合的代表元.可以沿着parent[x]不断在树形结构中向上移动,直到到达根节点.\n&emsp;因为创建的树可能会严重不平衡,并查集可以用两种优化策略:\n&emsp;1.按秩序合并\n&emsp;&emsp;即总将更小的树连接至更大的树上,\n&emsp;2.**路径压缩**\n&emsp;&emsp;为了加快查找速度,查找时将x到根节点路径上的所有点的parent设为根节点,该优化方法称为路径压缩.\n\n&emsp;算法用途:\n&emsp;&ensp;1.维护无向图的连通性,支持判断两个点是否在同一连通块内,和.\n&emsp;&ensp;2.判断增加一条边是否会产生环:用在求解最小生成树Kruskal算法里\n&emsp;并查集时统计图中连通块数量的一种方法.使用一个大小为N的parent数组,遍历这个图,每个节点都遍历所有相邻点,并让相邻点指向它,并设置成一个有parent节点决定的单独组.这个过程被称为union.这样每个组都有一个唯一的parent节点,这些节点的父节点为-1.\n\n合并的比较方法\n应当将简单的树向复杂的树上合并，从而使合并后到根节点距离变长的节点个数比较少。\n\n并查集的时间复杂度\n查询次数+合并次数 N或以上则平均下来单次查询或合并的平均时间复杂度O(1)\n\n```c\nint pre[1010]; // 存放第i个元素的父节点\n// 查询根节点\nint unionsearch(int root)\n{\n    int son, tmp;\n    son = root;\n    // 寻找根节点\n    while (root != pre[root]) {\n        root = pre[root]; // 路径压缩\n    }\n    while (son != root) {\n        tmp = pre[son];\n        pre[son] = root;\n        son = tmp;\n    }\n    return root;\n}\n\nvoid join(int root1, int root2) // 判断释放连通,不连通就合并\n{\n    int x, y;\n    x = unionsearch(root1);\n    y = unionsearch(root2);\n    // 如果不连通,就把它们所在的连通分支合并\n    if (x != y) {\n        pre[x] = y;\n    }\n}\n```\n\nhttps://blog.csdn.net/qq_41593390/article/details/81146850\n\nhttps://blog.csdn.net/ziachen/article/details/106315471\n\n\n朋友圈\n\n```c\nint findCircleNum(int **matrix, int size)\n{\n    int *parent = (int *)malloc(sizeof(int)*size);\n    memset(parent, -1, sizeof(int)*size);\n    int rows = size;\n    int clos = matrix[0];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (matrix[i][j] == 1 && i != j) {\n                union(parent, i, j);\n            }\n        }\n    }\n    return countCircleNum(parent, size);\n}\n\nvoid union(int *parent, int i, int j)\n{\n    int xset = find(parent, i);\n    int yset = find(parent, j);\n    if (xset != yset) {\n        // 合并i和j的两个集合\n        parent[xset] = yset;\n    }\n}\n\n/*\n 查找集合 i 的源头\n 如果集合 i 的父亲是 -1, 说明自己就是源头,返回自己的标号\n 否则查找集合 i 的父亲的源头\n*/\n\nint find(int *parent, int i)\n{\n    if (parent[i] == -1) {\n        // i 的父亲为 -1 时,i就是掌门人\n        return i;\n    }\n    // 使用路径压缩,让这条路径上所有的人的上级直接变为掌门人\n    return find(parent, parent[i]);\n}\n\nint countCircleNum(int *parent, int size)\n{\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (parent[i] == -1) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// find 非递归实现\nint find(int x)\n{\n    while (x != parent[x]) {\n        parent[x] = parent[parent[x]];\n        x = parent[x];\n    }\n    return x;\n}\n```\n\n&emsp;DFS实现\n```c\nint findCircleNum(int **matrix, int matrixSize)\n{\n    int rows = matrixSize;\n    int cols = matrix[0];\n    int *visited = (int *)malloc(sizeof(int) * matrixSize);\n    int count = 0;\n    for (int i = 0; i < rows; i++) {\n        if (visited[i] == 0) {\n            dfs(matrix, matrixSize, visite, i);\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid dfs(int **matrix,  int matrixSize, int *visited, int i)\n{\n    for (int j = 0; j < matrixSize; j++) {\n        if (matrix[i][j] == 1 && visited[j] == 0) {\n            visited[j] = 1;\n            dfs(matrxi, matrixSize, visited, j);\n        }\n    }\n}\n```\n\n&emsp;BFS实现\n```c\nint findCircleNum(int **matrix, int length)\n{\n    int* visited = (int *)malloc(sizeof(int)*length);\n    int count = 0;\n\n}\n```\n\n\n题目背景\n若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。\n题目描述\n规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。\n输入格式\n第一行：三个整数n,m,p，（n<=5000,m<=5000,p<=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。\n以下m行：每行两个数Mi，Mj，1<=Mi，Mj<=N，表示Mi和Mj具有亲戚关系。\n接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。\n输出格式\nP行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。\n\n```c\n#include <cstdio>\n#define MAXN 5005\nint fa[MAXN], rank[MAXN];\ninline void init(int n)\n{\n    for (int i = 1; i <= n; ++i) {\n        fa[i] = i;\n        rank[i] = 1;\n    }\n}\n\nint find(int x)\n{\n    return x == fa[x] ? x : (fa[x] = find(fa[x]));\n}\n\ninline void merge(int i, int j)\n{\n    int x = find(i), y = find(j);\n    if (rank[x] <= rank[y]) {\n        fa[x] = y;\n    } else {\n        fa[y] = x;\n    }\n    if (rank[x] == rank[y] && x != y) {\n        rank[y]++;\n    }\n}\n\nint main()\n{\n    int n, m, p, x, y;\n    scanf(\"%d%d%d\", &n, &m, &p);\n    init(n);\n    for (int i = 0; i < m; ++i) {\n        scanf(\"%d%d\", &x, &y);\n        merge(x, y);\n    }\n    for (int i = 0; i < p; ++i) {\n        scanf(\"%d%d\", &x, &y);\n        printf(\"%s\\n\", find(x) == find(y) ? \"Yes\" : \"No\");\n    }\n    return 0;\n}\n```\n\n\n\n### 2.2 Leetcode题目:[547.省份数量](https://leetcode-cn.com/problems/number-of-provinces/)\n\n&ensp;有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。\n\n&ensp;省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。\n\n&ensp;给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。\n\n返回矩阵中 省份 的数量。\n\n```c\nint *g_test;\n\nbool init(int mSize)\n{\n    int i;\n    if (mSize < 1) {\n        return false;\n    }\n    g_dest = (int *)malloc(mSize * sizeof(int));\n    if (g_dest == NULL) {\n        return false;\n    }\n    \n    fot (i = 0; i < mSize; i++) {\n        g_dest[i] = i;\n    }\n    return true;\n}\n\nint Find(int index)\n{\n    if (g_dest[index] == index) {\n        return index;\n    }\n    return g_dest[index] = Find(g_dest[index]);\n}\n\nint FindRoot(int i)\n{\n    while (g_dest[i] != 0) {\n        i = g_dest[i];\n    }\n    return i;\n}\n\nvoid ProcCircle(int **m, int mSize)\n{\n    int i, j;\n    int rootI, rootJ;\n    for (i = 0; i < mSize; i++) {\n        for (int j = (i + 1); j < mSize; j++) {\n            if (m[i][j] != 1) {\n                continue;\n            }\n            rootI = FindRoot(i);\n            rootJ = FindRoot(j);\n            if (rootI == rootJ) {\n                continue;\n            }\n            g_dest[rootI] = rootJ;\n        }\n    }\n    return;\n}\n\nint GetCircleNum(int mSize)\n{\n    int sum = 0;\n    for (int i = 0; i < mSize; i++) {\n        if (g_dest[i] == i) {\n            sum++;\n        }\n    }\n    return sum;\n}\n\nvoid FreeCircle()\n{\n    if (g_dest != NULL) {\n        free(g_dest);\n        g_dest = 0;\n    }\n}\n\nint findCircleNum(int **m, int mSize, int* mColSize)\n{\n    bool rslt;\n    int sum;\n    rslt = Init(mSize);\n    if (!rslt) {\n        return 0;\n    }\n\n    ProcCicle(m, mSize);\n    sum = GetCircleNum(mSize);\n\n    FreeCircle();\n    return sum;\n}\n```\n\n\n\n\n### 2.3 最小生成树\n\n&ensp;关于图的几个概念定义:\n连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。\n强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。\n连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。\n生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。\n最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。\n\n\n- 参考链接:https://blog.csdn.net/luoshixian099/article/details/51908175\n\n\n\n## 3.滑动窗口&双指针\n\n### 3.1 滑动窗口描述\n\n&ensp;滑动窗口法，也叫尺取法（可能也不一定相等，大概就是这样 =。=），可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。\n\n\n&ensp;滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。其实这里就可以看出来滑动窗口主要应用在数组和字符串上。\n\n&emsp; 滑动：说明这个窗口是移动的，也就是移动是按照一定方向来的。\n\n&emsp; 窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。\n\n&ensp; 滑动窗口是双指针的一种应用，形象点说就是维护一个窗口，在窗口滑动的过程中进行窗口内数据的更新，并判断是否符合答案。、\n初始时两个指针均指向开头，然后右指针依次向右滑动，在滑动的过程中需要收缩的时候进行左指针的移动，当右指针移出的时候结束循环即可。\n&ensp; TCP协议使用滑动窗口实现.\n\n### 3.2 Leetcode题目\n1208.进可能使字符串相等\n\nLeetcode 209. 长度最小的子数组\n给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。\n\n```c\nvoid fun(string s, string t){\n     map<char,int> need,window;\n     //在need中记录相应的信息\n      .....\n      int left=0,right=0;\n      int valid;//该变量用来判断是否得到相应的答案了\n      \n      while(right<s.size()) {\n         char c=s[right];//取出将要移入窗口内的数据\n         right++；\n         //下面进行窗口更新后一些数据的更新\n         .....\n\n         while(判断窗口是否需要收缩) {\n              //是否需要进行相应的答案更新\n              ......\n\n              char d=s[left];//将要移出窗口的数据；\n              left++;//收缩窗口\n\n              //窗口收缩后相应数据的更新\n              .......           \n         }   \n      }      \n}\n```\n\n示例: \n\n输入: s = 7, nums = [2,3,1,2,4,3]\n输出: 2\n解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。\n\n- 参考链接:\nhttps://zhuanlan.zhihu.com/p/61564531\n\n### 3.3 单调队列\n&emsp;单调队列是指：队列中的元素之间的关系具有单调性，而且，队首和队尾都可以进行出队操作，只有队尾开源进行入队操作。\n&emsp;单调队列与单调栈及其相似，把单调栈先进后出的性质改为先进先出既可。\n元素进队列的过程对于单调递增队列。\n对于一个元素a，如果a>队尾元素，那么直接将a扔进队列，如果a<=队尾元素，则将队尾元素出队列，直到满足 a>队尾元素即可。\n\n>单调递增队列(从队首到队尾满足递增)\n>单调递减队列(从队首到队尾满足递减)\n- 单调队列作用：队列里的元素满足出队的单调性。\n- 单调队列操作：去头和删尾\n\n- leetcode 题目\n[剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)\n```c\ntypedef struct {\n    int arr[20000];\n    int begin;\n    int end;\n} MaxQueue;\n\nMaxQueue* maxQueueCreate()\n{\n    MaxQueue *tmp = (MaxQueue*)malloc(sizeof(MaxQueue));\n    tmp->begin = 0;\n    tmp->end = 0;\n    return tmp;\n}\n\nint maxQueueMax_value(MaxQueue* obj)\n{\n    int ans = -1;\n    for (int i = obj->begin; i < obj->end; i++) {\n        ans = fmax(ans, obj->arr[i]);\n    }\n    return ans;\n}\n\nvoid maxQueuPus_back(MaxQueue* obj, int value)\n{\n    obj->arr[obj->end++] = value;\n}\nint maxQueuePop_front(MaxQueue* obj) \n{\n    if(obj->begin==obj->end) {\n        return -1;\n    } else {\n        return obj->arr[obj->begin++];\n    }\n}\n\nvoid maxQueueFree(MaxQueue* obj) \n{\n    obj->end=0;\n    obj->begin=0;\n}\n```\n\n239.滑动窗口最大值\n\n```c\n#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int Size=1000005;\nint a[Size],qmax[Size],qmin[Size],savemax[Size],savemin[Size];\nint main()\n{\n    int n,k,cnt=1;\n    scanf(\"%d %d\",&n,&k);\n    for(int i=1;i<=n;i++)\n    {scanf(\"%d\",&a[i]);}\n    int beg=1,top=0;//qmax队列的队首指针和队尾指针\n    int st=1,ed=0;//qmin队列的队首指针和队尾指针\n    for(int i=1;i<=n;i++) {\n        while(beg<=top&&a[i]>=a[qmax[top]])\n        {top--;}\n        qmax[++top]=i;\n        while(st<=ed&&a[i]<=a[qmin[ed]])\n        {ed--;}\n        qmin[++ed]=i;\n        if(i>=k) {\n            while(qmax[beg]<=i-k)beg++;\n            while(qmin[st]<=i-k)st++;\n            savemax[cnt]=a[qmax[beg]];\n            savemin[cnt]=a[qmin[st]];\n            cnt++;\n        }\n    }\n    for(int i=1;i< cnt;i++) {\n        printf(\"%d \",savemin[i]);\n    }\n    printf(\"\\n\");\n    for(int i=1;i< cnt;i++) {\n        printf(\"%d \",savemax[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n- 参考链接：\nhttps://www.cnblogs.com/zzcxxoo/p/13216030.html\n\n<br>\n\n## 4.前缀和(&哈希表优化)\n\n### 4.1 前缀和介绍\n&ensp;前缀和(prefix sum)定义:前缀和时一种预处理,能大大降低查询的时间复杂度.结合Hash缓存,能够进一步优化提升算法执行效率.\n&emsp;对数组nums进行前缀和初始化需要O(n)时间\n&emsp;新建数组prefixSum,数组长度定义为 nums.length+1,确保顶第 nums.length个元素存储前面0到nums.length-1个元素的和.将数组nums的累加一层放入数组prefixSum中.\n&emsp;变换公式:\n&ensp;&emsp;1)nums[某一项] = 两个相邻前缀和之差: nums[i] = prefixSum[x] - prefixSum[x-1]\n&ensp;&emsp;2)从left到right的元素和等于: prefixSum[right+1] - prefixSum[left]\n\n假设我们有一个字符串ABCDE，什么是这个单词的前缀，A、AB、ABC、ABCD、ABCDE就是这个单词的前缀，就是从第一个字母开始，依次往后拼接。E、ED、EDC、EDCB、EDCBA被称为这个单词的后缀。\n\n那么对于一个数组的前缀，例如数组a = [1,2,3,4,5]，我们维护一个由前缀的和组成的数组sum，sum[i]表示数组中a[0]~ a[i] 的和。\nsum[0] = a[0]\nsum[1] = a[0] + a[1]\nsum[2] = a[0] + a[1] + a[2]\nsum[3] = a[0] + a[1] + a[2] + a[3]\nsum[4] = a[0] + a[1] + a[2] + a[3] + a[4]\nsum数组就被称为前缀和数组。\n\n前缀和的作用\n前缀和的最主要目的就是求子数组的和的大小。例如元素a[1]到a[3]的和。\na[1] + a[2] + a[3] = sum[3] - sum[0]\n\n\n&emsp;前缀和数组初始化过程伪代码:\n&emsp;&emsp;1.安装for寻的政策边界进行初始化,避免了 int i=1 或者 <=len 等肯的各种调整.\n&emsp;&emsp;2.前缀和长度比数据长度多一个,前缀和第0个元素要初始化为0\n&emsp;&emsp;另外一种前缀和初始化方法:前缀和长度为nums.length,第0个元素存储自己的和.\n&emsp;&emsp;prefixSum[i] - prefixSum[i-1] 容易出现错误理解和技术丢失.示例:prefixSum[0] = num[1],造成nums[0]丢失.\n\n- 参考链接:\nhttps://blog.csdn.net/fgy_u/article/details/109349710\nhttps://www.jianshu.com/p/3021429f38d4\n\n<br>\n\n## 5.差分\n\n### 5.1 差分介绍\n&emsp;差分时一种和前缀和算法相对 的策略,这种策略是,令 `b(i) = a(i) - a(i-1)`,即相邻两数的差.在每一个点上记录变化数值,因为有增加有减少通过求和判断是否有超过指定容量的情况发生,超过则代表无法满足要求.\n\n该算法是前缀和算法的逆运算，可以快速的对数组的某一个区间进行计算。\n\n&ensp;对于数组array[N]中的某一段进行增减操作,通过差分可在 O(n)时间内完成.如:\n&ensp;trips = [ [2,1,5], [3,3,7]]\n&emsp;第一步:更新array[1] = 2, array[2] = -2;\n&emsp;第二步:更新array[3] = 3, array[7] = -2;\n&emsp;第三步:进行求和,得到结果array[] = {0, 2, 2, 5, 5, 3, 3, 0}\n\n\n<br>\n\n## 6.拓扑排序\n\n\n\n一、什么是拓扑排序\n在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：\n\n每个顶点出现且只出现一次。\n若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。\n有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。\n\n二、拓扑排序的应用\n拓扑排序通常用来“排序”具有依赖关系的任务。\n\n比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边<script type=\"math/tex\" id=\"MathJax-Element-1\"> </script>表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。\n\n\n三、拓扑排序的实现\n根据上面讲的方法，我们关键是要维护一个入度为0的顶点的集合。\n图的存储方式有两种：邻接矩阵和邻接表。这里我们采用邻接表来存储图，C++代码如下：\n\n```c++\n#include<iostream>\n#include <list>\n#include <queue>\nusing namespace std;\n\n/************************类声明************************/\nclass Graph {\n    int V;             // 顶点个数\n    list<int> *adj;    // 邻接表\n    queue<int> q;      // 维护一个入度为0的顶点的集合\n    int* indegree;     // 记录每个顶点的入度\npublic:\n    Graph(int V);                   // 构造函数\n    ~Graph();                       // 析构函数\n    void addEdge(int v, int w);     // 添加边\n    bool topological_sort();        // 拓扑排序\n};\n\n/************************类定义************************/\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n\n    indegree = new int[V];  // 入度全部初始化为0\n    for(int i=0; i<V; ++i)\n        indegree[i] = 0;\n}\n\nGraph::~Graph()\n{\n    delete [] adj;\n    delete [] indegree;\n}\n\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w); \n    ++indegree[w];\n}\n\nbool Graph::topological_sort()\n{\n    for(int i=0; i<V; ++i)\n        if(indegree[i] == 0)\n            q.push(i);         // 将所有入度为0的顶点入队\n\n    int count = 0;             // 计数，记录当前已经输出的顶点数 \n    while(!q.empty()) {\n        int v = q.front();      // 从队列中取出一个顶点\n        q.pop();\n\n        cout << v << \" \";      // 输出该顶点\n        ++count;\n        // 将所有v指向的顶点的入度减1，并将入度减为0的顶点入栈\n        list<int>::iterator beg = adj[v].begin();\n        for( ; beg!=adj[v].end(); ++beg)\n            if(!(--indegree[*beg]))\n                q.push(*beg);   // 若入度为0，则入栈\n    }\n\n    if(count < V)\n        return false;           // 没有输出全部顶点，有向图中有回路\n    else\n        return true;            // 拓扑排序成功\n}\n\nint main()\n{\n    Graph g(6);   // 创建图\n    g.addEdge(5, 2);\n    g.addEdge(5, 0);\n    g.addEdge(4, 0);\n    g.addEdge(4, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 1);\n\n    g.topological_sort();\n    return 0;\n}\n```\n输出结果是 4, 5, 2, 0, 3, 1。这是该图的拓扑排序序列之一。\n\n每次在入度为0的集合中取顶点，并没有特殊的取出规则，随机取出也行，这里使用的queue。取顶点的顺序不同会得到不同的拓扑排序序列，当然前提是该图存在多个拓扑排序序列。\n\n由于输出每个顶点的同时还要删除以它为起点的边，故上述拓扑排序的时间复杂度为O(V+E)O(V+E)。\n\n\n- 参考链接:\nhttps://blog.csdn.net/lisonglisonglisong/article/details/45543451\n\n\n<br>\n\n## 7.字符串\n\n字符串介绍\n&emsp;字符串可以涉及非常多的考点:如递归,栈,hash,dfs,bfs,动态规划等.需要强制记忆的是\"字符串的子串\",\"字符串的子序列\".难度比较大的是\"子序列\"问题.对于任何字符串,可通过删除其中一些字符(也可不删)来构造该字符串的子序列.对于任何字符串,选择任意连续的1到N个字符,形成[i,j]形式的子串,然后利用字符串的子串进行相关的匹配和计算.\n\n\n### leetcode题目\n- 93 复原IP地址\n- 43.字符串相乘\n- 227.基本计算器II\n\n&ensp;给出一个表达式，计算结果，就是典型的计算器类型问题，即栈的经典应用。\n&ensp;栈：添加和删除元素都在队尾进行，先进后出，后进先出，类比于子。。。，入栈和出栈。\n&ensp;思路：\n&emsp;将表达式(中缀)转化为后缀\n&emsp;将后缀计算出结果\n&emsp;具体规则为：\n&emsp;&ensp;1.中缀转后缀\n&emsp;&emsp;数字直接输出到后缀表达式\n&emsp;&emsp;栈为空时，遇到运算符，直接入栈\n&emsp;&emsp;遇到运算符，弹出所有优先级大于或等于该运算符的栈顶元素，并将该运算符入栈\n&emsp;&emsp;将栈中元素依次出栈\n&emsp;&ensp;2.计算后缀\n&emsp;&emsp;遇到数字，入栈\n&emsp;&emsp;遇到运算符，弹出栈顶两个元素，做运算，并将结果入栈\n&emsp;&emsp;重复上述步骤，直到表达式最右端\n&emsp;&emsp;\n\n<br>\n\n## 8.二分查找\n&ensp;二分查找也称折半查找(Binary Search),它使一种效率较高的查找方法,前提是数据结构必须先排好序.但是,二分查找要求线性表具有随机访问的特点(如数组),也要求线性表能够根据中间元素的特点推测它两侧元素的性质,以达到缩减问题规模的效果.\n&ensp;二分查找问题也是面试中常考问题,虽然它思想简单,但写好二分算法并不容易.\n\n### leetcode题目\n- 4.寻找两个有序数组的中位数\n- 33.搜索选择排序数组\n\n\n<br>\n\n## 9.BFS\n\nBFS（广度优先搜索） 常用来解决层序遍历,最短路径问题。\n第一次遍历到目的节点时，所经过的路径是最短路径。\n几个要点：\n\n只能用来求解无权图的最短路径问题\n队\n\n列：用来存储每一层遍历得到的节点\n标记：对于遍历过的结点，应将其标记，以防重复访问\n\n注:\n1.广度搜索时候,如果曾经加入过,后续就不用再加入\n2.加入队列时候,需要标记当前层级,方便后续直接返回目标解.\n\n\n\n\n\n- 参考链接:https://zhuanlan.zhihu.com/p/62884729\n\n### leetcode题目\n- 127.单词接龙\n- 139.单词拆分\n- 130.被包围的区域\n- 317.离建筑物最近的距离\n- 505.迷宫II\n- 529.扫雷游戏\n- 1263.推箱子\n- 1197.进击的骑士\n- 815.公交路线\n- 934.最短的桥\n\n\n<br>\n\n## 10.DFS\n&ensp;深度优先搜索算法(DFS):是一种用于遍历或搜索树或图的算法.利用深度优先搜索算法可产生目标图的拓扑排序表,拓扑排序可用于无权最长路径问题等.DFS实质是一种枚举,不过借助递归实现.\n&emsp;回溯搜索时深度优先搜索(DFS)的一种.对于某一个搜索树来说(搜索树时起记录路径和状态判断的作用),回溯和DFS,其主要的区别是,回溯法在求解过程中不保留完整的树结构,而深度优先搜索则记下完整的搜索树.回溯就是通过不同的尝试来生成问题的解,类似于穷举,但和穷举不同的时回溯会\"减枝\".为了减少存储空间,在深度优先搜索中,用标志的方法记录访问过的状态,这种处理方法使得深度优先搜索法与回溯法没什么区别.\n&emsp;DFS相对于BFS更方便写,空间复杂度更低\n&emsp;DFS基本模式:\n```c\nvoid dfs(int step)\n{\n    // 判断边界\n    ...;\n    // 尝试每一种可能\n    for (int i = 1; j <= n; ++i) {\n        // 继续下一步\n        dfs(step + 1);\n    }\n\n    // 返回\n    ...;\n}\n```\n\n```c\nvoid dfs(TreeNode root)\n{\n    if(root == NULL) {\n        return;\n    }\n    dfs(root.left);\n    dfs(root.right);\n}\n```\n\n&emsp;回溯的一般结构\n```c\nvoid backtrack(int 当前状态)\n{\n    if (当前状态为边界状态) {\n        记录或输出\n        return;\n    }\n    // 横向遍历解答树所有子节点\n    for (int i = 0; i < n; i++) {\n        // 扩展出一个子状态\n        // 修改了全局变量\n        if (子状态满足约束条件) {\n            backtrack(子状态)\n        }\n        // 恢复全局变量//回溯部分\n    }\n}\n```\n\n&emsp;回溯代码框架:\n```c\nresult = {}\ndef backtrack(路径, 选择列表)\n    if 满足结束条件\n        result.add(路径)\n        return\n    for 选择 in 选择列表\n        做选择\n        backtrack(路径,,选择列表)\n        撤销选择\n```\n\n### leetcode题目\n- 1102.得分最高的路径\n- 685.冗余链接II\n- 531.孤独像素I\n- 533.孤独像素II\n- 332.重新安排行程\n- 337.打家劫舍III\n- 113.路线总和II\n\n\n<br>\n\n## 11.动态规划\n\n\n- 参考链接:\nhttps://blog.csdn.net/qq_37763204/article/details/79394397\nhttps://blog.csdn.net/u013309870/article/details/75193592\n\n### leetcode题目\n- 213.打家劫舍II\n- 1043.\n- 416\n- 123\n\n\n<br>\n\n## 12.贪心算法\n\n<br>\n\n\n## 13.字典树\n\n<details>\n<summary>tire</summary>\n\n```c\n#define MAX 26    //26个字母\n#define SLEN 100   //节点中存储的字符串长度\n//Trie结构体定义\nstruct Trie\n{\n    struct Trie *next[MAX];\n    char s[SLEN];      //节点处存储的字符串\n    int isword;         //节点处是否为单词\n    char val;           //节点的代表字符\n} *root;\n//初始化Trie树\nstruct Trie *init()\n{\n    struct Trie *root = (struct Trie *)malloc(sizeof(struct Trie));\n    int i;\n    for (i = 0; i < MAX; i++)\n    {\n        root -> next[i] = NULL;\n    }\n    root -> isword = 0;\n    root -> val = 0;\n    return root;\n}\n//按照指定路径path 插入字符串 s\nvoid insert(char path[], char s[])\n{\n    struct Trie *t, *p = root;\n    int i, j, n = strlen(path);\n\n    for (i = 0; i < n; i++)\n    {\n        if (p -> next[path[i] - 'a'] == NULL)\n        {\n            t = (struct Trie *)malloc(sizeof(struct Trie));\n            for (j = 0; j < MAX; j++)\n            {\n                t -> next[j] = NULL;\n                t -> isword = 0;\n            }\n            t -> val = path[i];\n            p -> next[path[i] - 'a'] = t;\n        }\n        p = p -> next[path[i] - 'a'];\n    }\n    p -> isword = 1;\n    strcpy(p -> s , s);\n}\n//按照指定路径 path 查找\nchar *find(char path[], int delflag)\n{\n    struct Trie *p = root;\n    int i = 0, n = strlen(path);\n    while (p && path[i])\n    {\n        p = p -> next[path[i++] - 'a'];\n    }\n    if (p && p -> isword)\n    {\n        p -> isword = delflag;\n        return p->s;\n    }\n    return NULL;\n}\n//删除整棵Trie树\nvoid del(struct Trie *root)\n{\n    int i;\n    if (!root)\n        return;\n    for (i = 0; i < MAX; i++)\n    {\n        if (root->next[i])\n            del(root->next[i]);\n        free(root->next[i]);\n    }\n}\n\n```\n</details>\n\n\n\n\n<details>\n<summary>tire</summary>\n\n```c\n/*------------------Trie Data Structure----------------------------------*/\n/*-------------Implimented for search a word in dictionary---------------*/\n\n/*-----character - 97 used for get the character from the ASCII value-----*/\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define ALPHABET_SIZE 26\n\n/*--Node in the Trie--*/\ntypedef struct TrieNode\n{\n    struct TrieNode *children[ALPHABET_SIZE];\n    char character;\n    bool isEndOfWord;\n\n} TrieNode;\n\n/*--Create new node--*/\nTrieNode *createTrieNode()\n{\n    TrieNode *node;\n    node = malloc(sizeof(TrieNode));\n    node->isEndOfWord = false;\n    int i = 0;\n    while (i < ALPHABET_SIZE) {\n        node->children[i] = NULL;\n        i++;\n    }\n    return node;\n}\n\n/*--Insert new word to Trie--*/\nvoid insert(TrieNode *root, char *word)\n{\n    /*----Addition of the word done by recurcively----*/\n\n    // Check wheather word character pointer is NULL\n    if ((strlen(word) - 1) != 0) {\n        char character = *word;\n        if (root->children[character - 97] == NULL) {\n            TrieNode *node = NULL;\n            node = createTrieNode();\n            node->character = character;\n            root->children[character - 97] = node;\n        }\n        word++;\n        insert(root->children[character - 97], word);\n    } else {\n        root->isEndOfWord = true;\n    }\n    return;\n}\n\n/*--Search a word in the Trie--*/\nTrieNode *search(TrieNode *root, char *word)\n{\n    TrieNode *temp;\n    while (*word != '\\0') {\n        char character = *word;\n        if (root->children[character - 97] != NULL) {\n            temp = root->children[character - 97];\n            word++;\n            root = temp;\n        } else {\n            printf(\"No possible words!!\\n\");\n            return NULL;\n        }\n    }\n    return root;\n}\n\n/*---Print a word in the array--*/\nvoid printArray(char chars[], int len)\n{\n    int i;\n    for (i = 0; i < len; i++) {\n        printf(\"%c\", chars[i]);\n    }\n    printf(\"\\n\");\n}\n\n/*---Return all the related words------*/\nvoid printPathsRecur(TrieNode *node, char prefix[], int filledLen)\n{\n    if (node == NULL)\n        return;\n\n    prefix[filledLen] = node->character;\n    filledLen++;\n\n    if (node->isEndOfWord) {\n        printArray(prefix, filledLen);\n    }\n\n    int i;\n    for (i = 0; i < ALPHABET_SIZE; i++) {\n        printPathsRecur(node->children[i], prefix, filledLen);\n    }\n}\n\n/*--Travel through the Trie and return words from it--*/\nvoid traverse(char prefix[], TrieNode *root)\n{\n    TrieNode *temp = NULL;\n    temp = search(root, prefix);\n    int j = 0;\n    while (prefix[j] != '\\0') {\n        j++;\n    }\n    printPathsRecur(temp, prefix, j - 1);\n}\n\n/*------Demonstrate purposes uses text file called dictionary -------*/\n\n#define NUMBER_OF_WORDS (354935)\n#define INPUT_WORD_SIZE (100)\n\n/*----Get input from the user------*/\nchar *receiveInput(char *s)\n{\n    scanf(\"%99s\", s);\n    return s;\n}\n\nint main()\n{\n    // Read the file dictionary\n    int word_count = 0;\n    char *words[NUMBER_OF_WORDS];\n    FILE *fp = fopen(\"dictionary.txt\", \"r\");\n\n    if (fp == 0) {\n        fprintf(stderr, \"Error while opening dictionary file\");\n        exit(1);\n    }\n\n    words[word_count] = malloc(INPUT_WORD_SIZE);\n\n    while (fgets(words[word_count], INPUT_WORD_SIZE, fp)) {\n        word_count++;\n        words[word_count] = malloc(INPUT_WORD_SIZE);\n    }\n\n    // Push the words in to Trie\n    TrieNode *root = NULL;\n    root = createTrieNode();\n    int i;\n    for (i = 0; i < NUMBER_OF_WORDS; i++) {\n        insert(root, words[i]);\n    }\n\n    while (1) {\n        printf(\"Enter keyword: \");\n        char str[100];\n        receiveInput(str);\n        printf(\n            \"\\n==========================================================\\n\");\n        printf(\"\\n********************* Possible Words ********************\\n\");\n\n        // Find the word through the Trie\n        traverse(str, root);\n\n        printf(\n            \"\\n==========================================================\\n\");\n    }\n}\n```\n</details>\n\n- 参考链接：\n简单易懂的字典树https://zhuanlan.zhihu.com/p/143975546\n字典树 (Trie)https://oi-wiki.org/string/trie/\n字典树(Trie)https://www.jianshu.com/p/e431bd41d676\nhttps://blog.csdn.net/weixin_39778570/article/details/81990417\n[Trie](https://github.com/TheAlgorithms/C/blob/master/data_structures/trie/trie.c)\n\n\n### bitmap\n\n```c\n#include <stdio.h>\n#include <math.h>\n\n#define TYPE int\n#define INT_BITS (1<<3) * sizeof(TYPE)\n#define SHIFT (int)(log(INT_BITS)/log(2))\n#define MASK INT_BITS-1\n\nTYPE bitmap[10000];\n\n// 设置\nvoid setBit(int num);\n// 是否存在\nint containBit(int num);\n// 得到当前位置的第几位\nint getBit(int num);\n// 删除\nint deleteBit(int num);\n\nint main(){\n\n\tprintf(\"int_bits = %d, shift = %d, mask = %d\\n\", INT_BITS, SHIFT, MASK);\n\tsetBit(2);\n\tprintf(\"是否存在%d\\n\", containBit(2));\n\tprintf(\"是否存在%d\\n\", containBit(3));\n\tdeleteBit(2);\n\tprintf(\"是否存在%d\\n\", containBit(2));\n\tprintf(\"是否存在%d\\n\", containBit(3));\n\tsetBit(2);\n\tprintf(\"是否存在%d\\n\", containBit(2));\n\tprintf(\"是否存在%d\\n\", containBit(3));\n\n\tprintf(\"2在当前的位置%d\\n\", getBit(2));\n\tsetBit(32);\n\tprintf(\"32在当前的位置%d\\n\", getBit(32));\n\n\treturn 0;\n}\n\nvoid setBit(int num) {\n\t bitmap[num >> SHIFT] |= 1 << (num & MASK);\n\t printf(\"set --[%d]: %d\\n\", num >> SHIFT, bitmap[num >> SHIFT]);\n}\n\nint containBit(int num) {\n\treturn (bitmap[num >> SHIFT] & 1 << (num &MASK)) ==  1 << (num &MASK);\n}\n\nint getBit(int num) {\n\treturn num & MASK;\n}\n// 删除\nint deleteBit(int num) {\n\tbitmap[num >> SHIFT] &= ~(1 << (num & MASK));\n\tprintf(\"del -- [%d] : %d\\n\", num >> SHIFT, bitmap[num >> SHIFT]);\n\treturn -1;\n}\n```\n\n\n- 参考链接：\nhttps://www.cnblogs.com/cjsblog/p/11613708.html\nhttps://www.cnblogs.com/chunxia/archive/2013/04/28/3049243.html\nhttps://zhuanlan.zhihu.com/p/414067305\nhttps://ac.nowcoder.com/discuss/292850\nhttps://www.zhihu.com/question/36738189\nhttps://zhuanlan.zhihu.com/p/161036474\n\n\n","source":"_posts/2021/11/leetcode题解算法.md","raw":"---\ntitle: leetcode题解算法分析\ndate: 2021-10-27 00:47:53\nupdated: 2021-10-27 00:53:53\ncategories: \n    - tool\ntags: \n    - 实用教程\n    - Another Tag\n---\n\n## 1.单调栈\n\n<!--more-->\n\n### 1.1 单调栈描述\n\n&ensp;单调栈里面的元素大小按照他们所在栈内的位置,满足一定的单调性.\n\n> 单调递**增**栈：单调递增栈就是从栈底到栈顶数据是从小到大; 可找到**左起**第一个比当前数字**小**的元素.\n> 单调递**减**栈：单调递减栈就是从栈底到栈顶数据是从大到小; 可找到**左起**第一个比当前数字**大**的元素.\n\n&emsp;单调递增栈，元素进栈过程，若当前进栈的元素a，如果a>栈顶元素，则直接将a进栈，如果a<=栈顶元素，则不断将栈顶元素出栈，直到满足a>栈顶元素。单调递减栈则为a<栈顶元素时进栈。\n\n&ensp;题目分析:给定一个数组,返回一个大小相同的数组,返回的数组的第i个位置的值应当是,对于原数组中的第i个元素,至少往右走多少步,才能遇到一个比自己大的元素(如果没有比自己大的元素,或为最后一个元素,则返回对应位置上为-1).\n&emsp;例如:\n&ensp;&emsp;input: 5, 3, 1, 2, 4\n&ensp;&emsp;return: -1, 3, 1, 1, -1\n&emsp;暴力解法时间复杂度O(n^2)\n&emsp;暴力解法:\n```c\nint *nextExceed(int *input, int size)\n{\n    int *result = (int *)malloc(sizeof(int) * size);\n    memset(input,-1,size*sizeof(int));\n    for (int i = 0; i < size; i++) {\n        int anchar = input[i];\n        for (int j = i + 1; j < size; j++) {\n            if (input[j] > anchar) {\n                result[j] = j - 1;\n                break;\n            }\n        }\n    }\n    return result;\n}\n```\n&emsp;单调栈:\n```c\nint *nextExceed(int *input, int size)\n{\n    int *result = (int *)malloc(sizeof(int) * size);\n    int *stack = (int *)malloc(sizeof(int) * size);\n    memset(input, -1, size * sizeof(int));\n    int top = 0;\n    for (int i = 0; i < size; i++) {\n        while (top >= 0 && input[i] > input[stack[top]]) {\n            result[stack[top]] = i - stack[top];\n            top--;\n        }\n        stack[++top] = i;\n    }\n    return result;\n}\n```\n\n&emsp;维护一个单调递**减**栈stack,stack内存的是原数组的每个index,当遇到一个比当前栈顶所对应的数**大**的时候,则栈顶元素出栈,并更新它们在返回数组中对应位置的值.\n\n&ensp;单调栈通常应用在一维数组上,和前后元素大小之间关系有关的问题.单调栈时间复杂度为`O(n)`.\n\n\n\n### 1.2 Letocde题目分析\n\n84.[柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/description/)\n\n\n\n<details>\n  <summary>柱状图中最大的矩形 c语言</summary>\n\n```c\nint largestRectangleArea(int* heights, int heightsSize) {\n    // 栈顶标记,单调递减栈\n    int top = -1;\n    int area = 0;\n    int maxArea = 0;\n    int *stack = (int *)malloc(sizeof(int) * (heightsSize + 2));\n    int *buf = (int *)malloc(sizeof(int) * (heightsSize + 2));\n\n    // 增加前哨兵\n    buf[0] = 0;\n    // 在最后增加哨兵\n    buf[heightsSize + 1] = 0;\n    for (int i = 1; i <= heightsSize; i++) {\n        buf[i] = heights[i - 1];\n    }\n\n    stack[++top] = 0;\n    for (int i = 1; i < heightsSize + 2; i++) {\n        while (top > 0 && buf[i] < buf[stack[top]]) {\n            // 注意 i - \n            area = (i - stack[top - 1] - 1) * buf[stack[top]];\n            maxArea = maxArea > area ? maxArea : area;\n            top--;\n        }\n        // 索引入栈，其他可能是元素入栈\n        stack[++top] = i;\n    }\n\n    return maxArea;\n}\n```\n\n</details>\n\n<br>\n\n\n### 1.3 单调栈的性质\n&emsp;1.单调栈里的元素具有单调性,栈中元素只能是单调递增或者单调递减\n&emsp;2.元素加入栈前,会在栈顶把破坏栈单调性的元素都出栈\n&emsp;3.使用单调栈可以找到元素向左遍历第一个比它小的元素,也可以找到元素向左遍历第一个比他大的元素\n\n### 1.3 leetcode题目\n[85.最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)\n&ensp;给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n&emsp;思路:对于每一行,构建一个histogram,然后计算.在构建新的histogram的时候,不需要全部遍历,只需对已有的histogram进行略微修改(运用DP的思想)\n\n<details>\n  <summary>maximalRectangle</summary>\n\n```c\nint maximalRectangle(char** matrix, int matrixSize, int* matrixColSize)\n{\n    int m = matrixSize;\n    if (m == 0) {\n        return 0;\n    }\n    int n = matrixColSize[0];\n    int left[m][n];\n    memset(left, 0, sizeof(left));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (matrix[i][j] == '1') {\n                left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;\n            }\n        }\n    }\n\n    int ret = 0;\n    for (int j = 0; j < n; j++) {  // 对于每一列，使用基于柱状图的方法\n        int up[m], down[m];\n        memset(up, 0, sizeof(up));\n        memset(down, 0, sizeof(down));\n        int stk[m], top = 0;\n        for (int i = 0; i < m; i++) {\n            while (top > 0 && left[stk[top - 1]][j] >= left[i][j]) {\n                top--;\n            }\n            up[i] = top == 0 ? -1 : stk[top - 1];\n            stk[top++] = i;\n        }\n        top = 0;\n        for (int i = m - 1; i >= 0; i--) {\n            while (top > 0 && left[stk[top - 1]][j] >= left[i][j]) {\n                top--;\n            }\n            down[i] = top == 0 ? m : stk[top - 1];\n            stk[top++] = i;\n        }\n\n        for (int i = 0; i < m; i++) {\n            int height = down[i] - up[i] - 1;\n            int area = height * left[i][j];\n            ret = fmax(ret, area);\n        }\n    }\n    return ret;\n}\n```\n\n</details>\n\n<br>\n\n![20211207235410](https://s2.loli.net/2021/12/07/aU8ZQBWRo9dTXMb.png)\n\n\n```c\nstack<int> st;\n//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解,单调减栈\nfor (遍历这个数组)\n{\n    if (栈空 || 栈顶元素大于等于当前比较元素) {\n        入栈;\n    } else {\n        while (栈不为空 && 栈顶元素小于当前元素) {\n            栈顶元素出栈;\n            更新结果;\n        }\n        当前数据入栈;\n    }\n}\n```\n\n<details>\n<summary>单调栈</summary>\n\n```c\nint largestRectangleArea(int* heights, int heightsSize,int *S,int top){\n    // int*S=(int*)malloc(sizeof(int)*heightsSize); // 初始化栈，栈内保存柱子序号\n    // int top=-1;\n    int start,end,h;\n    int r=0;\n    S[++top]=0; // 入栈第一根柱子\n    for(int i=1;i<=heightsSize-1;i++) { // 遍历所有柱子\n        if(heights[i] >= heights[S[top]]) { \n            S[++top]=i; // 若当前柱子大于栈顶或等于栈顶，直接入栈\n        } else { // 若当前柱子小于栈顶，则依次出栈较高的柱子并计算面积\n            end = S[top]; // 记录最右边最高的柱子位置，之后每次矩形的底边是从出栈位置到最右边最高柱子的位置\n            while(top != -1 && heights[i] < heights[S[top]] ) {\n                h = heights[S[top--]]; // 保存当前矩形的高\n                while(top != -1 && heights[S[top]] == h) top--; // 若有相同高的柱子，直接出栈\n                if (top != -1) start=S[top]; // 避免栈为空\n                else start=-1;\n\n                if(r < (end-start)*h) r=(end-start)*h; // 矩形面积是最高柱子位置减去当前栈顶柱子的位置乘高\n            }\n            S[++top]=i;\n        }\n    }\n    // 此时栈内剩余递增序列，出栈依次计算面积。计算流程同上\n    end = S[top];\n    while(top != -1) {\n        h = heights[S[top--]];\n        while( top != -1 && heights[S[top]] == h) top--;\n        if (top != -1) start=S[top];\n        else start=-1;\n\n        if(r < (end-start)*h) r=(end-start)*h;\n    }\n    return r;\n}\n\nint maximalRectangle(char** matrix, int matrixSize, int* matrixColSize){\n    int m=matrixSize;\n    int n=*matrixColSize;\n    if (m==0) return 0;\n    int *heights = (int*)malloc(sizeof(int)*n);\n    int*S=(int*)malloc(sizeof(int)*n); // 初始化栈，栈内保存柱子序号\n    int r=0;\n\n    for(int k=0;k<=n-1;k++) heights[k]=0;\n    for(int i=0;i<=m-1;i++) {\n        for(int j=0;j<=n-1;j++) {\n            if(matrix[i][j]=='1') heights[j]++;\n            else heights[j]=0;\n        }\n        int top=-1;\n        int cur=largestRectangleArea(heights,n,S,top);\n        if(cur > r) r=cur;\n    }\n    return r;\n}\n\n```\n\n</details>\n\n<details>\n<summary>StackCreate</summary>\n\n```c\ntypedef struct {\n    void **data;\n    int top;\n    int size;\n} Stack;\n\nStack *StackCreate(int stackSize)\n{\n    Stack *stack = (Stack *)malloc(sizeof(Stack));\n    if (stack == NULL) {\n        return NULL;\n    }\n\n    stack->data = (void **)malloc(sizeof(void **) * (stackSize + 1));\n    memset(stack->data, 0, sizeof(void **) * (stackSize + 1));\n    stack->top = -1;\n    stack->size = stackSize;\n    return stack;\n}\n\nvoid StackFree(Stack *obj)\n{\n    if (obj->data != NULL) {\n        free(obj->data);\n        obj->data = NULL;\n    }\n    free(obj);\n    obj = NULL;\n    return;\n}\n\nbool IsStackEmpty(Stack *obj)\n{\n    return (obj->top == -1);\n}\n\nbool IsStackFull(Stack *obj)\n{\n    return (obj->top ==  obj->size);\n}\n\nvoid StackPush(Stack *obj, void *data)  // 泛型接口，使用void *\n{\n    if (IsStackFull(obj) == true) {\n        return;\n    }\n    int top = obj->top;\n    obj->data[++top] = data;\n    obj->top = top;\n    return;\n}\n\nvoid StackPop(Stack *obj)\n{\n    if (IsStackEmpty(obj) == true) {\n        return;\n    }\n    void *data = obj->data[obj->top];\n    free(data);\n    data = NULL;\n    obj->top--;\n    return;\n}\n\nvoid *StackTop(Stack *obj)\n{\n    if (IsStackEmpty(obj) == true) {\n        return NULL;\n    }\n    return (obj->data[obj->top]);\n}\n\nvoid StackClear(Stack *obj)\n{\n    if (IsStackEmpty(obj) == true) {\n        return;\n    }\n\n    for (int i = 0; i <= obj->top; i++) {\n        void *data = obj->data[i];\n        if (data != NULL) {\n            free(data);\n            data = NULL;\n        }\n    }\n    obj->top = -1;\n    return;\n}\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\nint maximalRectangle(char **matrix, int matrixSize, int *matrixColSize)\n{\n    int **height = (int **)malloc(sizeof(int *) * matrixSize);\n    for (int i = 0; i < matrixSize; i++) {\n        height[i] = (int *)malloc(sizeof(int) * (matrixColSize[i] + 1));\n        for (int j = 0; j < matrixColSize[i]; j++) {\n            if (i == 0) {\n                height[i][j] = (matrix[i][j] == '1') ? 1 : 0;\n            } else {\n                height[i][j] = (matrix[i][j] == '1') ? (height[i - 1][j] + 1) : 0;\n            }\n        }\n        height[i][matrixColSize[i]] = 0;\n    }\n\n    Stack *monotoneStack = StackCreate(matrixSize * matrixSize);\n    int ans = 0;\n    for (int i = 0; i < matrixSize; i++) {\n        for (int j = 0; j <= matrixColSize[i]; j++) {\n            while ((IsStackEmpty(monotoneStack) != true) && \n                    (height[i][*(int *)monotoneStack->data[monotoneStack->top]] >= height[i][j])) {\n                int h = height[i][*(int *)monotoneStack->data[monotoneStack->top]];\n                StackPop(monotoneStack);\n                int sidx = ((IsStackEmpty(monotoneStack) == true) ? -1 : *(int *)(monotoneStack->data[monotoneStack->top]));\n                ans = MAX(ans, h * (j - sidx - 1));\n            }\n            int *node = (int *)malloc(sizeof(int));\n            *node = j;\n            StackPush(monotoneStack, node); \n        }\n        StackClear(monotoneStack);\n    }\n\n    StackFree(monotoneStack);\n    return ans;\n}\n```\n\n</details>\n\n<br>\n<br>\n\n85 Maximal Reactangle\nleetcode 496、503、739、239\n<br>\n42.接雨水\n\n<br>\n\n- 参考链接：\n[leetcode算法总结 ——单调栈&单调队列](https://blog.csdn.net/chongbin007/article/details/112741867?utm_term=%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97leetcode)\n\n\n\n\n\n## 2.并查集\n### 2.1 并查集介绍\n\n&ensp;并查集(DSU)主要用于解决一些元素分组的问题，管理一系列不相交的集合，并支持两种操作：\n&ensp;并查集即**合并集合**和**查找集合中元素**两种操作的算法.但实际并查集的基本操作有三个:\n&emsp;makeSet(size):建立一个新的并查集,其中包含size个单元素集合.\n&emsp;unionSet(x, y)**合并**:把元素x和元素y所在的集合合并,要求x和y所在的集合不相交,如果相交则不合并.\n&emsp;find(x)**查询**:找到元素x所在的集合的代表,该操作也可以用于判断两个元素是否位于同一个集合,只要将它们各自的代表比较一下就可以了. find(x)有两种实现方法,一种是递归,一种是非递归。\n\n&ensp;并查集的重要思想在于，用集合中的一个元素代表集合。\n\n&emsp;**算法:**\n&emsp;&emsp;用集合中的某个元素来代表这个集合,该元素称为集合的代表元.一个集合内的所有元素组织成以代表元为根的树形结构.对应每一个元素x来说,parent[x]指向x在树形结构上的父节点,如果x是根节点,则灵parent[x] = x. 对于查找操作,假设需要确定x所在的集合,也就是确定集合的代表元.可以沿着parent[x]不断在树形结构中向上移动,直到到达根节点.\n&emsp;因为创建的树可能会严重不平衡,并查集可以用两种优化策略:\n&emsp;1.按秩序合并\n&emsp;&emsp;即总将更小的树连接至更大的树上,\n&emsp;2.**路径压缩**\n&emsp;&emsp;为了加快查找速度,查找时将x到根节点路径上的所有点的parent设为根节点,该优化方法称为路径压缩.\n\n&emsp;算法用途:\n&emsp;&ensp;1.维护无向图的连通性,支持判断两个点是否在同一连通块内,和.\n&emsp;&ensp;2.判断增加一条边是否会产生环:用在求解最小生成树Kruskal算法里\n&emsp;并查集时统计图中连通块数量的一种方法.使用一个大小为N的parent数组,遍历这个图,每个节点都遍历所有相邻点,并让相邻点指向它,并设置成一个有parent节点决定的单独组.这个过程被称为union.这样每个组都有一个唯一的parent节点,这些节点的父节点为-1.\n\n合并的比较方法\n应当将简单的树向复杂的树上合并，从而使合并后到根节点距离变长的节点个数比较少。\n\n并查集的时间复杂度\n查询次数+合并次数 N或以上则平均下来单次查询或合并的平均时间复杂度O(1)\n\n```c\nint pre[1010]; // 存放第i个元素的父节点\n// 查询根节点\nint unionsearch(int root)\n{\n    int son, tmp;\n    son = root;\n    // 寻找根节点\n    while (root != pre[root]) {\n        root = pre[root]; // 路径压缩\n    }\n    while (son != root) {\n        tmp = pre[son];\n        pre[son] = root;\n        son = tmp;\n    }\n    return root;\n}\n\nvoid join(int root1, int root2) // 判断释放连通,不连通就合并\n{\n    int x, y;\n    x = unionsearch(root1);\n    y = unionsearch(root2);\n    // 如果不连通,就把它们所在的连通分支合并\n    if (x != y) {\n        pre[x] = y;\n    }\n}\n```\n\nhttps://blog.csdn.net/qq_41593390/article/details/81146850\n\nhttps://blog.csdn.net/ziachen/article/details/106315471\n\n\n朋友圈\n\n```c\nint findCircleNum(int **matrix, int size)\n{\n    int *parent = (int *)malloc(sizeof(int)*size);\n    memset(parent, -1, sizeof(int)*size);\n    int rows = size;\n    int clos = matrix[0];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (matrix[i][j] == 1 && i != j) {\n                union(parent, i, j);\n            }\n        }\n    }\n    return countCircleNum(parent, size);\n}\n\nvoid union(int *parent, int i, int j)\n{\n    int xset = find(parent, i);\n    int yset = find(parent, j);\n    if (xset != yset) {\n        // 合并i和j的两个集合\n        parent[xset] = yset;\n    }\n}\n\n/*\n 查找集合 i 的源头\n 如果集合 i 的父亲是 -1, 说明自己就是源头,返回自己的标号\n 否则查找集合 i 的父亲的源头\n*/\n\nint find(int *parent, int i)\n{\n    if (parent[i] == -1) {\n        // i 的父亲为 -1 时,i就是掌门人\n        return i;\n    }\n    // 使用路径压缩,让这条路径上所有的人的上级直接变为掌门人\n    return find(parent, parent[i]);\n}\n\nint countCircleNum(int *parent, int size)\n{\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (parent[i] == -1) {\n            count++;\n        }\n    }\n    return count;\n}\n\n// find 非递归实现\nint find(int x)\n{\n    while (x != parent[x]) {\n        parent[x] = parent[parent[x]];\n        x = parent[x];\n    }\n    return x;\n}\n```\n\n&emsp;DFS实现\n```c\nint findCircleNum(int **matrix, int matrixSize)\n{\n    int rows = matrixSize;\n    int cols = matrix[0];\n    int *visited = (int *)malloc(sizeof(int) * matrixSize);\n    int count = 0;\n    for (int i = 0; i < rows; i++) {\n        if (visited[i] == 0) {\n            dfs(matrix, matrixSize, visite, i);\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid dfs(int **matrix,  int matrixSize, int *visited, int i)\n{\n    for (int j = 0; j < matrixSize; j++) {\n        if (matrix[i][j] == 1 && visited[j] == 0) {\n            visited[j] = 1;\n            dfs(matrxi, matrixSize, visited, j);\n        }\n    }\n}\n```\n\n&emsp;BFS实现\n```c\nint findCircleNum(int **matrix, int length)\n{\n    int* visited = (int *)malloc(sizeof(int)*length);\n    int count = 0;\n\n}\n```\n\n\n题目背景\n若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。\n题目描述\n规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。\n输入格式\n第一行：三个整数n,m,p，（n<=5000,m<=5000,p<=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。\n以下m行：每行两个数Mi，Mj，1<=Mi，Mj<=N，表示Mi和Mj具有亲戚关系。\n接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。\n输出格式\nP行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。\n\n```c\n#include <cstdio>\n#define MAXN 5005\nint fa[MAXN], rank[MAXN];\ninline void init(int n)\n{\n    for (int i = 1; i <= n; ++i) {\n        fa[i] = i;\n        rank[i] = 1;\n    }\n}\n\nint find(int x)\n{\n    return x == fa[x] ? x : (fa[x] = find(fa[x]));\n}\n\ninline void merge(int i, int j)\n{\n    int x = find(i), y = find(j);\n    if (rank[x] <= rank[y]) {\n        fa[x] = y;\n    } else {\n        fa[y] = x;\n    }\n    if (rank[x] == rank[y] && x != y) {\n        rank[y]++;\n    }\n}\n\nint main()\n{\n    int n, m, p, x, y;\n    scanf(\"%d%d%d\", &n, &m, &p);\n    init(n);\n    for (int i = 0; i < m; ++i) {\n        scanf(\"%d%d\", &x, &y);\n        merge(x, y);\n    }\n    for (int i = 0; i < p; ++i) {\n        scanf(\"%d%d\", &x, &y);\n        printf(\"%s\\n\", find(x) == find(y) ? \"Yes\" : \"No\");\n    }\n    return 0;\n}\n```\n\n\n\n### 2.2 Leetcode题目:[547.省份数量](https://leetcode-cn.com/problems/number-of-provinces/)\n\n&ensp;有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。\n\n&ensp;省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。\n\n&ensp;给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。\n\n返回矩阵中 省份 的数量。\n\n```c\nint *g_test;\n\nbool init(int mSize)\n{\n    int i;\n    if (mSize < 1) {\n        return false;\n    }\n    g_dest = (int *)malloc(mSize * sizeof(int));\n    if (g_dest == NULL) {\n        return false;\n    }\n    \n    fot (i = 0; i < mSize; i++) {\n        g_dest[i] = i;\n    }\n    return true;\n}\n\nint Find(int index)\n{\n    if (g_dest[index] == index) {\n        return index;\n    }\n    return g_dest[index] = Find(g_dest[index]);\n}\n\nint FindRoot(int i)\n{\n    while (g_dest[i] != 0) {\n        i = g_dest[i];\n    }\n    return i;\n}\n\nvoid ProcCircle(int **m, int mSize)\n{\n    int i, j;\n    int rootI, rootJ;\n    for (i = 0; i < mSize; i++) {\n        for (int j = (i + 1); j < mSize; j++) {\n            if (m[i][j] != 1) {\n                continue;\n            }\n            rootI = FindRoot(i);\n            rootJ = FindRoot(j);\n            if (rootI == rootJ) {\n                continue;\n            }\n            g_dest[rootI] = rootJ;\n        }\n    }\n    return;\n}\n\nint GetCircleNum(int mSize)\n{\n    int sum = 0;\n    for (int i = 0; i < mSize; i++) {\n        if (g_dest[i] == i) {\n            sum++;\n        }\n    }\n    return sum;\n}\n\nvoid FreeCircle()\n{\n    if (g_dest != NULL) {\n        free(g_dest);\n        g_dest = 0;\n    }\n}\n\nint findCircleNum(int **m, int mSize, int* mColSize)\n{\n    bool rslt;\n    int sum;\n    rslt = Init(mSize);\n    if (!rslt) {\n        return 0;\n    }\n\n    ProcCicle(m, mSize);\n    sum = GetCircleNum(mSize);\n\n    FreeCircle();\n    return sum;\n}\n```\n\n\n\n\n### 2.3 最小生成树\n\n&ensp;关于图的几个概念定义:\n连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。\n强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。\n连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。\n生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。\n最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。\n\n\n- 参考链接:https://blog.csdn.net/luoshixian099/article/details/51908175\n\n\n\n## 3.滑动窗口&双指针\n\n### 3.1 滑动窗口描述\n\n&ensp;滑动窗口法，也叫尺取法（可能也不一定相等，大概就是这样 =。=），可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。\n\n\n&ensp;滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。其实这里就可以看出来滑动窗口主要应用在数组和字符串上。\n\n&emsp; 滑动：说明这个窗口是移动的，也就是移动是按照一定方向来的。\n\n&emsp; 窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。\n\n&ensp; 滑动窗口是双指针的一种应用，形象点说就是维护一个窗口，在窗口滑动的过程中进行窗口内数据的更新，并判断是否符合答案。、\n初始时两个指针均指向开头，然后右指针依次向右滑动，在滑动的过程中需要收缩的时候进行左指针的移动，当右指针移出的时候结束循环即可。\n&ensp; TCP协议使用滑动窗口实现.\n\n### 3.2 Leetcode题目\n1208.进可能使字符串相等\n\nLeetcode 209. 长度最小的子数组\n给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。\n\n```c\nvoid fun(string s, string t){\n     map<char,int> need,window;\n     //在need中记录相应的信息\n      .....\n      int left=0,right=0;\n      int valid;//该变量用来判断是否得到相应的答案了\n      \n      while(right<s.size()) {\n         char c=s[right];//取出将要移入窗口内的数据\n         right++；\n         //下面进行窗口更新后一些数据的更新\n         .....\n\n         while(判断窗口是否需要收缩) {\n              //是否需要进行相应的答案更新\n              ......\n\n              char d=s[left];//将要移出窗口的数据；\n              left++;//收缩窗口\n\n              //窗口收缩后相应数据的更新\n              .......           \n         }   \n      }      \n}\n```\n\n示例: \n\n输入: s = 7, nums = [2,3,1,2,4,3]\n输出: 2\n解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。\n\n- 参考链接:\nhttps://zhuanlan.zhihu.com/p/61564531\n\n### 3.3 单调队列\n&emsp;单调队列是指：队列中的元素之间的关系具有单调性，而且，队首和队尾都可以进行出队操作，只有队尾开源进行入队操作。\n&emsp;单调队列与单调栈及其相似，把单调栈先进后出的性质改为先进先出既可。\n元素进队列的过程对于单调递增队列。\n对于一个元素a，如果a>队尾元素，那么直接将a扔进队列，如果a<=队尾元素，则将队尾元素出队列，直到满足 a>队尾元素即可。\n\n>单调递增队列(从队首到队尾满足递增)\n>单调递减队列(从队首到队尾满足递减)\n- 单调队列作用：队列里的元素满足出队的单调性。\n- 单调队列操作：去头和删尾\n\n- leetcode 题目\n[剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)\n```c\ntypedef struct {\n    int arr[20000];\n    int begin;\n    int end;\n} MaxQueue;\n\nMaxQueue* maxQueueCreate()\n{\n    MaxQueue *tmp = (MaxQueue*)malloc(sizeof(MaxQueue));\n    tmp->begin = 0;\n    tmp->end = 0;\n    return tmp;\n}\n\nint maxQueueMax_value(MaxQueue* obj)\n{\n    int ans = -1;\n    for (int i = obj->begin; i < obj->end; i++) {\n        ans = fmax(ans, obj->arr[i]);\n    }\n    return ans;\n}\n\nvoid maxQueuPus_back(MaxQueue* obj, int value)\n{\n    obj->arr[obj->end++] = value;\n}\nint maxQueuePop_front(MaxQueue* obj) \n{\n    if(obj->begin==obj->end) {\n        return -1;\n    } else {\n        return obj->arr[obj->begin++];\n    }\n}\n\nvoid maxQueueFree(MaxQueue* obj) \n{\n    obj->end=0;\n    obj->begin=0;\n}\n```\n\n239.滑动窗口最大值\n\n```c\n#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int Size=1000005;\nint a[Size],qmax[Size],qmin[Size],savemax[Size],savemin[Size];\nint main()\n{\n    int n,k,cnt=1;\n    scanf(\"%d %d\",&n,&k);\n    for(int i=1;i<=n;i++)\n    {scanf(\"%d\",&a[i]);}\n    int beg=1,top=0;//qmax队列的队首指针和队尾指针\n    int st=1,ed=0;//qmin队列的队首指针和队尾指针\n    for(int i=1;i<=n;i++) {\n        while(beg<=top&&a[i]>=a[qmax[top]])\n        {top--;}\n        qmax[++top]=i;\n        while(st<=ed&&a[i]<=a[qmin[ed]])\n        {ed--;}\n        qmin[++ed]=i;\n        if(i>=k) {\n            while(qmax[beg]<=i-k)beg++;\n            while(qmin[st]<=i-k)st++;\n            savemax[cnt]=a[qmax[beg]];\n            savemin[cnt]=a[qmin[st]];\n            cnt++;\n        }\n    }\n    for(int i=1;i< cnt;i++) {\n        printf(\"%d \",savemin[i]);\n    }\n    printf(\"\\n\");\n    for(int i=1;i< cnt;i++) {\n        printf(\"%d \",savemax[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n- 参考链接：\nhttps://www.cnblogs.com/zzcxxoo/p/13216030.html\n\n<br>\n\n## 4.前缀和(&哈希表优化)\n\n### 4.1 前缀和介绍\n&ensp;前缀和(prefix sum)定义:前缀和时一种预处理,能大大降低查询的时间复杂度.结合Hash缓存,能够进一步优化提升算法执行效率.\n&emsp;对数组nums进行前缀和初始化需要O(n)时间\n&emsp;新建数组prefixSum,数组长度定义为 nums.length+1,确保顶第 nums.length个元素存储前面0到nums.length-1个元素的和.将数组nums的累加一层放入数组prefixSum中.\n&emsp;变换公式:\n&ensp;&emsp;1)nums[某一项] = 两个相邻前缀和之差: nums[i] = prefixSum[x] - prefixSum[x-1]\n&ensp;&emsp;2)从left到right的元素和等于: prefixSum[right+1] - prefixSum[left]\n\n假设我们有一个字符串ABCDE，什么是这个单词的前缀，A、AB、ABC、ABCD、ABCDE就是这个单词的前缀，就是从第一个字母开始，依次往后拼接。E、ED、EDC、EDCB、EDCBA被称为这个单词的后缀。\n\n那么对于一个数组的前缀，例如数组a = [1,2,3,4,5]，我们维护一个由前缀的和组成的数组sum，sum[i]表示数组中a[0]~ a[i] 的和。\nsum[0] = a[0]\nsum[1] = a[0] + a[1]\nsum[2] = a[0] + a[1] + a[2]\nsum[3] = a[0] + a[1] + a[2] + a[3]\nsum[4] = a[0] + a[1] + a[2] + a[3] + a[4]\nsum数组就被称为前缀和数组。\n\n前缀和的作用\n前缀和的最主要目的就是求子数组的和的大小。例如元素a[1]到a[3]的和。\na[1] + a[2] + a[3] = sum[3] - sum[0]\n\n\n&emsp;前缀和数组初始化过程伪代码:\n&emsp;&emsp;1.安装for寻的政策边界进行初始化,避免了 int i=1 或者 <=len 等肯的各种调整.\n&emsp;&emsp;2.前缀和长度比数据长度多一个,前缀和第0个元素要初始化为0\n&emsp;&emsp;另外一种前缀和初始化方法:前缀和长度为nums.length,第0个元素存储自己的和.\n&emsp;&emsp;prefixSum[i] - prefixSum[i-1] 容易出现错误理解和技术丢失.示例:prefixSum[0] = num[1],造成nums[0]丢失.\n\n- 参考链接:\nhttps://blog.csdn.net/fgy_u/article/details/109349710\nhttps://www.jianshu.com/p/3021429f38d4\n\n<br>\n\n## 5.差分\n\n### 5.1 差分介绍\n&emsp;差分时一种和前缀和算法相对 的策略,这种策略是,令 `b(i) = a(i) - a(i-1)`,即相邻两数的差.在每一个点上记录变化数值,因为有增加有减少通过求和判断是否有超过指定容量的情况发生,超过则代表无法满足要求.\n\n该算法是前缀和算法的逆运算，可以快速的对数组的某一个区间进行计算。\n\n&ensp;对于数组array[N]中的某一段进行增减操作,通过差分可在 O(n)时间内完成.如:\n&ensp;trips = [ [2,1,5], [3,3,7]]\n&emsp;第一步:更新array[1] = 2, array[2] = -2;\n&emsp;第二步:更新array[3] = 3, array[7] = -2;\n&emsp;第三步:进行求和,得到结果array[] = {0, 2, 2, 5, 5, 3, 3, 0}\n\n\n<br>\n\n## 6.拓扑排序\n\n\n\n一、什么是拓扑排序\n在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：\n\n每个顶点出现且只出现一次。\n若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。\n有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。\n\n二、拓扑排序的应用\n拓扑排序通常用来“排序”具有依赖关系的任务。\n\n比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边<script type=\"math/tex\" id=\"MathJax-Element-1\"> </script>表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。\n\n\n三、拓扑排序的实现\n根据上面讲的方法，我们关键是要维护一个入度为0的顶点的集合。\n图的存储方式有两种：邻接矩阵和邻接表。这里我们采用邻接表来存储图，C++代码如下：\n\n```c++\n#include<iostream>\n#include <list>\n#include <queue>\nusing namespace std;\n\n/************************类声明************************/\nclass Graph {\n    int V;             // 顶点个数\n    list<int> *adj;    // 邻接表\n    queue<int> q;      // 维护一个入度为0的顶点的集合\n    int* indegree;     // 记录每个顶点的入度\npublic:\n    Graph(int V);                   // 构造函数\n    ~Graph();                       // 析构函数\n    void addEdge(int v, int w);     // 添加边\n    bool topological_sort();        // 拓扑排序\n};\n\n/************************类定义************************/\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n\n    indegree = new int[V];  // 入度全部初始化为0\n    for(int i=0; i<V; ++i)\n        indegree[i] = 0;\n}\n\nGraph::~Graph()\n{\n    delete [] adj;\n    delete [] indegree;\n}\n\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w); \n    ++indegree[w];\n}\n\nbool Graph::topological_sort()\n{\n    for(int i=0; i<V; ++i)\n        if(indegree[i] == 0)\n            q.push(i);         // 将所有入度为0的顶点入队\n\n    int count = 0;             // 计数，记录当前已经输出的顶点数 \n    while(!q.empty()) {\n        int v = q.front();      // 从队列中取出一个顶点\n        q.pop();\n\n        cout << v << \" \";      // 输出该顶点\n        ++count;\n        // 将所有v指向的顶点的入度减1，并将入度减为0的顶点入栈\n        list<int>::iterator beg = adj[v].begin();\n        for( ; beg!=adj[v].end(); ++beg)\n            if(!(--indegree[*beg]))\n                q.push(*beg);   // 若入度为0，则入栈\n    }\n\n    if(count < V)\n        return false;           // 没有输出全部顶点，有向图中有回路\n    else\n        return true;            // 拓扑排序成功\n}\n\nint main()\n{\n    Graph g(6);   // 创建图\n    g.addEdge(5, 2);\n    g.addEdge(5, 0);\n    g.addEdge(4, 0);\n    g.addEdge(4, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 1);\n\n    g.topological_sort();\n    return 0;\n}\n```\n输出结果是 4, 5, 2, 0, 3, 1。这是该图的拓扑排序序列之一。\n\n每次在入度为0的集合中取顶点，并没有特殊的取出规则，随机取出也行，这里使用的queue。取顶点的顺序不同会得到不同的拓扑排序序列，当然前提是该图存在多个拓扑排序序列。\n\n由于输出每个顶点的同时还要删除以它为起点的边，故上述拓扑排序的时间复杂度为O(V+E)O(V+E)。\n\n\n- 参考链接:\nhttps://blog.csdn.net/lisonglisonglisong/article/details/45543451\n\n\n<br>\n\n## 7.字符串\n\n字符串介绍\n&emsp;字符串可以涉及非常多的考点:如递归,栈,hash,dfs,bfs,动态规划等.需要强制记忆的是\"字符串的子串\",\"字符串的子序列\".难度比较大的是\"子序列\"问题.对于任何字符串,可通过删除其中一些字符(也可不删)来构造该字符串的子序列.对于任何字符串,选择任意连续的1到N个字符,形成[i,j]形式的子串,然后利用字符串的子串进行相关的匹配和计算.\n\n\n### leetcode题目\n- 93 复原IP地址\n- 43.字符串相乘\n- 227.基本计算器II\n\n&ensp;给出一个表达式，计算结果，就是典型的计算器类型问题，即栈的经典应用。\n&ensp;栈：添加和删除元素都在队尾进行，先进后出，后进先出，类比于子。。。，入栈和出栈。\n&ensp;思路：\n&emsp;将表达式(中缀)转化为后缀\n&emsp;将后缀计算出结果\n&emsp;具体规则为：\n&emsp;&ensp;1.中缀转后缀\n&emsp;&emsp;数字直接输出到后缀表达式\n&emsp;&emsp;栈为空时，遇到运算符，直接入栈\n&emsp;&emsp;遇到运算符，弹出所有优先级大于或等于该运算符的栈顶元素，并将该运算符入栈\n&emsp;&emsp;将栈中元素依次出栈\n&emsp;&ensp;2.计算后缀\n&emsp;&emsp;遇到数字，入栈\n&emsp;&emsp;遇到运算符，弹出栈顶两个元素，做运算，并将结果入栈\n&emsp;&emsp;重复上述步骤，直到表达式最右端\n&emsp;&emsp;\n\n<br>\n\n## 8.二分查找\n&ensp;二分查找也称折半查找(Binary Search),它使一种效率较高的查找方法,前提是数据结构必须先排好序.但是,二分查找要求线性表具有随机访问的特点(如数组),也要求线性表能够根据中间元素的特点推测它两侧元素的性质,以达到缩减问题规模的效果.\n&ensp;二分查找问题也是面试中常考问题,虽然它思想简单,但写好二分算法并不容易.\n\n### leetcode题目\n- 4.寻找两个有序数组的中位数\n- 33.搜索选择排序数组\n\n\n<br>\n\n## 9.BFS\n\nBFS（广度优先搜索） 常用来解决层序遍历,最短路径问题。\n第一次遍历到目的节点时，所经过的路径是最短路径。\n几个要点：\n\n只能用来求解无权图的最短路径问题\n队\n\n列：用来存储每一层遍历得到的节点\n标记：对于遍历过的结点，应将其标记，以防重复访问\n\n注:\n1.广度搜索时候,如果曾经加入过,后续就不用再加入\n2.加入队列时候,需要标记当前层级,方便后续直接返回目标解.\n\n\n\n\n\n- 参考链接:https://zhuanlan.zhihu.com/p/62884729\n\n### leetcode题目\n- 127.单词接龙\n- 139.单词拆分\n- 130.被包围的区域\n- 317.离建筑物最近的距离\n- 505.迷宫II\n- 529.扫雷游戏\n- 1263.推箱子\n- 1197.进击的骑士\n- 815.公交路线\n- 934.最短的桥\n\n\n<br>\n\n## 10.DFS\n&ensp;深度优先搜索算法(DFS):是一种用于遍历或搜索树或图的算法.利用深度优先搜索算法可产生目标图的拓扑排序表,拓扑排序可用于无权最长路径问题等.DFS实质是一种枚举,不过借助递归实现.\n&emsp;回溯搜索时深度优先搜索(DFS)的一种.对于某一个搜索树来说(搜索树时起记录路径和状态判断的作用),回溯和DFS,其主要的区别是,回溯法在求解过程中不保留完整的树结构,而深度优先搜索则记下完整的搜索树.回溯就是通过不同的尝试来生成问题的解,类似于穷举,但和穷举不同的时回溯会\"减枝\".为了减少存储空间,在深度优先搜索中,用标志的方法记录访问过的状态,这种处理方法使得深度优先搜索法与回溯法没什么区别.\n&emsp;DFS相对于BFS更方便写,空间复杂度更低\n&emsp;DFS基本模式:\n```c\nvoid dfs(int step)\n{\n    // 判断边界\n    ...;\n    // 尝试每一种可能\n    for (int i = 1; j <= n; ++i) {\n        // 继续下一步\n        dfs(step + 1);\n    }\n\n    // 返回\n    ...;\n}\n```\n\n```c\nvoid dfs(TreeNode root)\n{\n    if(root == NULL) {\n        return;\n    }\n    dfs(root.left);\n    dfs(root.right);\n}\n```\n\n&emsp;回溯的一般结构\n```c\nvoid backtrack(int 当前状态)\n{\n    if (当前状态为边界状态) {\n        记录或输出\n        return;\n    }\n    // 横向遍历解答树所有子节点\n    for (int i = 0; i < n; i++) {\n        // 扩展出一个子状态\n        // 修改了全局变量\n        if (子状态满足约束条件) {\n            backtrack(子状态)\n        }\n        // 恢复全局变量//回溯部分\n    }\n}\n```\n\n&emsp;回溯代码框架:\n```c\nresult = {}\ndef backtrack(路径, 选择列表)\n    if 满足结束条件\n        result.add(路径)\n        return\n    for 选择 in 选择列表\n        做选择\n        backtrack(路径,,选择列表)\n        撤销选择\n```\n\n### leetcode题目\n- 1102.得分最高的路径\n- 685.冗余链接II\n- 531.孤独像素I\n- 533.孤独像素II\n- 332.重新安排行程\n- 337.打家劫舍III\n- 113.路线总和II\n\n\n<br>\n\n## 11.动态规划\n\n\n- 参考链接:\nhttps://blog.csdn.net/qq_37763204/article/details/79394397\nhttps://blog.csdn.net/u013309870/article/details/75193592\n\n### leetcode题目\n- 213.打家劫舍II\n- 1043.\n- 416\n- 123\n\n\n<br>\n\n## 12.贪心算法\n\n<br>\n\n\n## 13.字典树\n\n<details>\n<summary>tire</summary>\n\n```c\n#define MAX 26    //26个字母\n#define SLEN 100   //节点中存储的字符串长度\n//Trie结构体定义\nstruct Trie\n{\n    struct Trie *next[MAX];\n    char s[SLEN];      //节点处存储的字符串\n    int isword;         //节点处是否为单词\n    char val;           //节点的代表字符\n} *root;\n//初始化Trie树\nstruct Trie *init()\n{\n    struct Trie *root = (struct Trie *)malloc(sizeof(struct Trie));\n    int i;\n    for (i = 0; i < MAX; i++)\n    {\n        root -> next[i] = NULL;\n    }\n    root -> isword = 0;\n    root -> val = 0;\n    return root;\n}\n//按照指定路径path 插入字符串 s\nvoid insert(char path[], char s[])\n{\n    struct Trie *t, *p = root;\n    int i, j, n = strlen(path);\n\n    for (i = 0; i < n; i++)\n    {\n        if (p -> next[path[i] - 'a'] == NULL)\n        {\n            t = (struct Trie *)malloc(sizeof(struct Trie));\n            for (j = 0; j < MAX; j++)\n            {\n                t -> next[j] = NULL;\n                t -> isword = 0;\n            }\n            t -> val = path[i];\n            p -> next[path[i] - 'a'] = t;\n        }\n        p = p -> next[path[i] - 'a'];\n    }\n    p -> isword = 1;\n    strcpy(p -> s , s);\n}\n//按照指定路径 path 查找\nchar *find(char path[], int delflag)\n{\n    struct Trie *p = root;\n    int i = 0, n = strlen(path);\n    while (p && path[i])\n    {\n        p = p -> next[path[i++] - 'a'];\n    }\n    if (p && p -> isword)\n    {\n        p -> isword = delflag;\n        return p->s;\n    }\n    return NULL;\n}\n//删除整棵Trie树\nvoid del(struct Trie *root)\n{\n    int i;\n    if (!root)\n        return;\n    for (i = 0; i < MAX; i++)\n    {\n        if (root->next[i])\n            del(root->next[i]);\n        free(root->next[i]);\n    }\n}\n\n```\n</details>\n\n\n\n\n<details>\n<summary>tire</summary>\n\n```c\n/*------------------Trie Data Structure----------------------------------*/\n/*-------------Implimented for search a word in dictionary---------------*/\n\n/*-----character - 97 used for get the character from the ASCII value-----*/\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define ALPHABET_SIZE 26\n\n/*--Node in the Trie--*/\ntypedef struct TrieNode\n{\n    struct TrieNode *children[ALPHABET_SIZE];\n    char character;\n    bool isEndOfWord;\n\n} TrieNode;\n\n/*--Create new node--*/\nTrieNode *createTrieNode()\n{\n    TrieNode *node;\n    node = malloc(sizeof(TrieNode));\n    node->isEndOfWord = false;\n    int i = 0;\n    while (i < ALPHABET_SIZE) {\n        node->children[i] = NULL;\n        i++;\n    }\n    return node;\n}\n\n/*--Insert new word to Trie--*/\nvoid insert(TrieNode *root, char *word)\n{\n    /*----Addition of the word done by recurcively----*/\n\n    // Check wheather word character pointer is NULL\n    if ((strlen(word) - 1) != 0) {\n        char character = *word;\n        if (root->children[character - 97] == NULL) {\n            TrieNode *node = NULL;\n            node = createTrieNode();\n            node->character = character;\n            root->children[character - 97] = node;\n        }\n        word++;\n        insert(root->children[character - 97], word);\n    } else {\n        root->isEndOfWord = true;\n    }\n    return;\n}\n\n/*--Search a word in the Trie--*/\nTrieNode *search(TrieNode *root, char *word)\n{\n    TrieNode *temp;\n    while (*word != '\\0') {\n        char character = *word;\n        if (root->children[character - 97] != NULL) {\n            temp = root->children[character - 97];\n            word++;\n            root = temp;\n        } else {\n            printf(\"No possible words!!\\n\");\n            return NULL;\n        }\n    }\n    return root;\n}\n\n/*---Print a word in the array--*/\nvoid printArray(char chars[], int len)\n{\n    int i;\n    for (i = 0; i < len; i++) {\n        printf(\"%c\", chars[i]);\n    }\n    printf(\"\\n\");\n}\n\n/*---Return all the related words------*/\nvoid printPathsRecur(TrieNode *node, char prefix[], int filledLen)\n{\n    if (node == NULL)\n        return;\n\n    prefix[filledLen] = node->character;\n    filledLen++;\n\n    if (node->isEndOfWord) {\n        printArray(prefix, filledLen);\n    }\n\n    int i;\n    for (i = 0; i < ALPHABET_SIZE; i++) {\n        printPathsRecur(node->children[i], prefix, filledLen);\n    }\n}\n\n/*--Travel through the Trie and return words from it--*/\nvoid traverse(char prefix[], TrieNode *root)\n{\n    TrieNode *temp = NULL;\n    temp = search(root, prefix);\n    int j = 0;\n    while (prefix[j] != '\\0') {\n        j++;\n    }\n    printPathsRecur(temp, prefix, j - 1);\n}\n\n/*------Demonstrate purposes uses text file called dictionary -------*/\n\n#define NUMBER_OF_WORDS (354935)\n#define INPUT_WORD_SIZE (100)\n\n/*----Get input from the user------*/\nchar *receiveInput(char *s)\n{\n    scanf(\"%99s\", s);\n    return s;\n}\n\nint main()\n{\n    // Read the file dictionary\n    int word_count = 0;\n    char *words[NUMBER_OF_WORDS];\n    FILE *fp = fopen(\"dictionary.txt\", \"r\");\n\n    if (fp == 0) {\n        fprintf(stderr, \"Error while opening dictionary file\");\n        exit(1);\n    }\n\n    words[word_count] = malloc(INPUT_WORD_SIZE);\n\n    while (fgets(words[word_count], INPUT_WORD_SIZE, fp)) {\n        word_count++;\n        words[word_count] = malloc(INPUT_WORD_SIZE);\n    }\n\n    // Push the words in to Trie\n    TrieNode *root = NULL;\n    root = createTrieNode();\n    int i;\n    for (i = 0; i < NUMBER_OF_WORDS; i++) {\n        insert(root, words[i]);\n    }\n\n    while (1) {\n        printf(\"Enter keyword: \");\n        char str[100];\n        receiveInput(str);\n        printf(\n            \"\\n==========================================================\\n\");\n        printf(\"\\n********************* Possible Words ********************\\n\");\n\n        // Find the word through the Trie\n        traverse(str, root);\n\n        printf(\n            \"\\n==========================================================\\n\");\n    }\n}\n```\n</details>\n\n- 参考链接：\n简单易懂的字典树https://zhuanlan.zhihu.com/p/143975546\n字典树 (Trie)https://oi-wiki.org/string/trie/\n字典树(Trie)https://www.jianshu.com/p/e431bd41d676\nhttps://blog.csdn.net/weixin_39778570/article/details/81990417\n[Trie](https://github.com/TheAlgorithms/C/blob/master/data_structures/trie/trie.c)\n\n\n### bitmap\n\n```c\n#include <stdio.h>\n#include <math.h>\n\n#define TYPE int\n#define INT_BITS (1<<3) * sizeof(TYPE)\n#define SHIFT (int)(log(INT_BITS)/log(2))\n#define MASK INT_BITS-1\n\nTYPE bitmap[10000];\n\n// 设置\nvoid setBit(int num);\n// 是否存在\nint containBit(int num);\n// 得到当前位置的第几位\nint getBit(int num);\n// 删除\nint deleteBit(int num);\n\nint main(){\n\n\tprintf(\"int_bits = %d, shift = %d, mask = %d\\n\", INT_BITS, SHIFT, MASK);\n\tsetBit(2);\n\tprintf(\"是否存在%d\\n\", containBit(2));\n\tprintf(\"是否存在%d\\n\", containBit(3));\n\tdeleteBit(2);\n\tprintf(\"是否存在%d\\n\", containBit(2));\n\tprintf(\"是否存在%d\\n\", containBit(3));\n\tsetBit(2);\n\tprintf(\"是否存在%d\\n\", containBit(2));\n\tprintf(\"是否存在%d\\n\", containBit(3));\n\n\tprintf(\"2在当前的位置%d\\n\", getBit(2));\n\tsetBit(32);\n\tprintf(\"32在当前的位置%d\\n\", getBit(32));\n\n\treturn 0;\n}\n\nvoid setBit(int num) {\n\t bitmap[num >> SHIFT] |= 1 << (num & MASK);\n\t printf(\"set --[%d]: %d\\n\", num >> SHIFT, bitmap[num >> SHIFT]);\n}\n\nint containBit(int num) {\n\treturn (bitmap[num >> SHIFT] & 1 << (num &MASK)) ==  1 << (num &MASK);\n}\n\nint getBit(int num) {\n\treturn num & MASK;\n}\n// 删除\nint deleteBit(int num) {\n\tbitmap[num >> SHIFT] &= ~(1 << (num & MASK));\n\tprintf(\"del -- [%d] : %d\\n\", num >> SHIFT, bitmap[num >> SHIFT]);\n\treturn -1;\n}\n```\n\n\n- 参考链接：\nhttps://www.cnblogs.com/cjsblog/p/11613708.html\nhttps://www.cnblogs.com/chunxia/archive/2013/04/28/3049243.html\nhttps://zhuanlan.zhihu.com/p/414067305\nhttps://ac.nowcoder.com/discuss/292850\nhttps://www.zhihu.com/question/36738189\nhttps://zhuanlan.zhihu.com/p/161036474\n\n\n","slug":"2021/11/leetcode题解算法","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8vu000x0guuednhaunb","content":"<h2 id=\"1-单调栈\"><a href=\"#1-单调栈\" class=\"headerlink\" title=\"1.单调栈\"></a>1.单调栈</h2><span id=\"more\"></span>\n\n<h3 id=\"1-1-单调栈描述\"><a href=\"#1-1-单调栈描述\" class=\"headerlink\" title=\"1.1 单调栈描述\"></a>1.1 单调栈描述</h3><p> 单调栈里面的元素大小按照他们所在栈内的位置,满足一定的单调性.</p>\n<blockquote>\n<p>单调递<strong>增</strong>栈：单调递增栈就是从栈底到栈顶数据是从小到大; 可找到<strong>左起</strong>第一个比当前数字<strong>小</strong>的元素.<br>单调递<strong>减</strong>栈：单调递减栈就是从栈底到栈顶数据是从大到小; 可找到<strong>左起</strong>第一个比当前数字<strong>大</strong>的元素.</p>\n</blockquote>\n<p> 单调递增栈，元素进栈过程，若当前进栈的元素a，如果a&gt;栈顶元素，则直接将a进栈，如果a&lt;=栈顶元素，则不断将栈顶元素出栈，直到满足a&gt;栈顶元素。单调递减栈则为a&lt;栈顶元素时进栈。</p>\n<p> 题目分析:给定一个数组,返回一个大小相同的数组,返回的数组的第i个位置的值应当是,对于原数组中的第i个元素,至少往右走多少步,才能遇到一个比自己大的元素(如果没有比自己大的元素,或为最后一个元素,则返回对应位置上为-1).<br> 例如:<br>  input: 5, 3, 1, 2, 4<br>  return: -1, 3, 1, 1, -1<br> 暴力解法时间复杂度O(n^2)<br> 暴力解法:</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">nextExceed</span><span class=\"params\">(<span class=\"keyword\">int</span> *input, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *result = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * size);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(input,<span class=\"number\">-1</span>,size*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> anchar = input[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; size; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (input[j] &gt; anchar) {</span><br><span class=\"line\">                result[j] = j - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p> 单调栈:</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">nextExceed</span><span class=\"params\">(<span class=\"keyword\">int</span> *input, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *result = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * size);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *<span class=\"built_in\">stack</span> = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * size);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(input, <span class=\"number\">-1</span>, size * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (top &gt;= <span class=\"number\">0</span> &amp;&amp; input[i] &gt; input[<span class=\"built_in\">stack</span>[top]]) {</span><br><span class=\"line\">            result[<span class=\"built_in\">stack</span>[top]] = i - <span class=\"built_in\">stack</span>[top];</span><br><span class=\"line\">            top--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>[++top] = i;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p> 维护一个单调递<strong>减</strong>栈stack,stack内存的是原数组的每个index,当遇到一个比当前栈顶所对应的数<strong>大</strong>的时候,则栈顶元素出栈,并更新它们在返回数组中对应位置的值.</p>\n<p> 单调栈通常应用在一维数组上,和前后元素大小之间关系有关的问题.单调栈时间复杂度为<code>O(n)</code>.</p>\n<h3 id=\"1-2-Letocde题目分析\"><a href=\"#1-2-Letocde题目分析\" class=\"headerlink\" title=\"1.2 Letocde题目分析\"></a>1.2 Letocde题目分析</h3><p>84.<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/description/\">柱状图中最大的矩形</a></p>\n<details>\n  <summary>柱状图中最大的矩形 c语言</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(<span class=\"keyword\">int</span>* heights, <span class=\"keyword\">int</span> heightsSize)</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 栈顶标记,单调递减栈</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> area = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxArea = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *<span class=\"built_in\">stack</span> = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * (heightsSize + <span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *buf = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * (heightsSize + <span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 增加前哨兵</span></span><br><span class=\"line\">    buf[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 在最后增加哨兵</span></span><br><span class=\"line\">    buf[heightsSize + <span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= heightsSize; i++) {</span><br><span class=\"line\">        buf[i] = heights[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>[++top] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; heightsSize + <span class=\"number\">2</span>; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (top &gt; <span class=\"number\">0</span> &amp;&amp; buf[i] &lt; buf[<span class=\"built_in\">stack</span>[top]]) {</span><br><span class=\"line\">            <span class=\"comment\">// 注意 i - </span></span><br><span class=\"line\">            area = (i - <span class=\"built_in\">stack</span>[top - <span class=\"number\">1</span>] - <span class=\"number\">1</span>) * buf[<span class=\"built_in\">stack</span>[top]];</span><br><span class=\"line\">            maxArea = maxArea &gt; area ? maxArea : area;</span><br><span class=\"line\">            top--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">// 索引入栈，其他可能是元素入栈</span></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>[++top] = i;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxArea;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n</details>\n\n<br>\n\n\n<h3 id=\"1-3-单调栈的性质\"><a href=\"#1-3-单调栈的性质\" class=\"headerlink\" title=\"1.3 单调栈的性质\"></a>1.3 单调栈的性质</h3><p> 1.单调栈里的元素具有单调性,栈中元素只能是单调递增或者单调递减<br> 2.元素加入栈前,会在栈顶把破坏栈单调性的元素都出栈<br> 3.使用单调栈可以找到元素向左遍历第一个比它小的元素,也可以找到元素向左遍历第一个比他大的元素</p>\n<h3 id=\"1-3-leetcode题目\"><a href=\"#1-3-leetcode题目\" class=\"headerlink\" title=\"1.3 leetcode题目\"></a>1.3 leetcode题目</h3><p><a href=\"https://leetcode-cn.com/problems/maximal-rectangle/\">85.最大矩形</a><br> 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。<br> 思路:对于每一行,构建一个histogram,然后计算.在构建新的histogram的时候,不需要全部遍历,只需对已有的histogram进行略微修改(运用DP的思想)</p>\n<details>\n  <summary>maximalRectangle</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximalRectangle</span><span class=\"params\">(<span class=\"keyword\">char</span>** matrix, <span class=\"keyword\">int</span> matrixSize, <span class=\"keyword\">int</span>* matrixColSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = matrixSize;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = matrixColSize[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left[m][n];</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(left, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(left));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"string\">'1'</span>) {</span><br><span class=\"line\">                left[i][j] = (j == <span class=\"number\">0</span> ? <span class=\"number\">0</span> : left[i][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) {  <span class=\"comment\">// 对于每一列，使用基于柱状图的方法</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> up[m], down[m];</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(up, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(up));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(down, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(down));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> stk[m], top = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (top &gt; <span class=\"number\">0</span> &amp;&amp; left[stk[top - <span class=\"number\">1</span>]][j] &gt;= left[i][j]) {</span><br><span class=\"line\">                top--;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            up[i] = top == <span class=\"number\">0</span> ? <span class=\"number\">-1</span> : stk[top - <span class=\"number\">1</span>];</span><br><span class=\"line\">            stk[top++] = i;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        top = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) {</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (top &gt; <span class=\"number\">0</span> &amp;&amp; left[stk[top - <span class=\"number\">1</span>]][j] &gt;= left[i][j]) {</span><br><span class=\"line\">                top--;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            down[i] = top == <span class=\"number\">0</span> ? m : stk[top - <span class=\"number\">1</span>];</span><br><span class=\"line\">            stk[top++] = i;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">int</span> height = down[i] - up[i] - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> area = height * left[i][j];</span><br><span class=\"line\">            ret = fmax(ret, area);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n</details>\n\n<br>\n\n<p><img src=\"https://s2.loli.net/2021/12/07/aU8ZQBWRo9dTXMb.png\" alt=\"20211207235410\"></p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\"><span class=\"comment\">//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解,单调减栈</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (遍历这个数组)</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (栈空 || 栈顶元素大于等于当前比较元素) {</span><br><span class=\"line\">        入栈;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素) {</span><br><span class=\"line\">            栈顶元素出栈;</span><br><span class=\"line\">            更新结果;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        当前数据入栈;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<details>\n<summary>单调栈</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(<span class=\"keyword\">int</span>* heights, <span class=\"keyword\">int</span> heightsSize,<span class=\"keyword\">int</span> *S,<span class=\"keyword\">int</span> top)</span></span>{</span><br><span class=\"line\">    <span class=\"comment\">// int*S=(int*)malloc(sizeof(int)*heightsSize); // 初始化栈，栈内保存柱子序号</span></span><br><span class=\"line\">    <span class=\"comment\">// int top=-1;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> start,end,h;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r=<span class=\"number\">0</span>;</span><br><span class=\"line\">    S[++top]=<span class=\"number\">0</span>; <span class=\"comment\">// 入栈第一根柱子</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=heightsSize<span class=\"number\">-1</span>;i++) { <span class=\"comment\">// 遍历所有柱子</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(heights[i] &gt;= heights[S[top]]) { </span><br><span class=\"line\">            S[++top]=i; <span class=\"comment\">// 若当前柱子大于栈顶或等于栈顶，直接入栈</span></span><br><span class=\"line\">        } <span class=\"keyword\">else</span> { <span class=\"comment\">// 若当前柱子小于栈顶，则依次出栈较高的柱子并计算面积</span></span><br><span class=\"line\">            end = S[top]; <span class=\"comment\">// 记录最右边最高的柱子位置，之后每次矩形的底边是从出栈位置到最右边最高柱子的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(top != <span class=\"number\">-1</span> &amp;&amp; heights[i] &lt; heights[S[top]] ) {</span><br><span class=\"line\">                h = heights[S[top--]]; <span class=\"comment\">// 保存当前矩形的高</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(top != <span class=\"number\">-1</span> &amp;&amp; heights[S[top]] == h) top--; <span class=\"comment\">// 若有相同高的柱子，直接出栈</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (top != <span class=\"number\">-1</span>) start=S[top]; <span class=\"comment\">// 避免栈为空</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> start=<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(r &lt; (end-start)*h) r=(end-start)*h; <span class=\"comment\">// 矩形面积是最高柱子位置减去当前栈顶柱子的位置乘高</span></span><br><span class=\"line\">            }</span><br><span class=\"line\">            S[++top]=i;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 此时栈内剩余递增序列，出栈依次计算面积。计算流程同上</span></span><br><span class=\"line\">    end = S[top];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top != <span class=\"number\">-1</span>) {</span><br><span class=\"line\">        h = heights[S[top--]];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( top != <span class=\"number\">-1</span> &amp;&amp; heights[S[top]] == h) top--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (top != <span class=\"number\">-1</span>) start=S[top];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> start=<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r &lt; (end-start)*h) r=(end-start)*h;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximalRectangle</span><span class=\"params\">(<span class=\"keyword\">char</span>** matrix, <span class=\"keyword\">int</span> matrixSize, <span class=\"keyword\">int</span>* matrixColSize)</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m=matrixSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n=*matrixColSize;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *heights = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>*S=(<span class=\"keyword\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*n); <span class=\"comment\">// 初始化栈，栈内保存柱子序号</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> r=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;=n<span class=\"number\">-1</span>;k++) heights[k]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=m<span class=\"number\">-1</span>;i++) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;=n<span class=\"number\">-1</span>;j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matrix[i][j]==<span class=\"string\">'1'</span>) heights[j]++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> heights[j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">int</span> top=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cur=largestRectangleArea(heights,n,S,top);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur &gt; r) r=cur;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n</details>\n\n<details>\n<summary>StackCreate</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> **data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">} Stack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Stack *<span class=\"title\">StackCreate</span><span class=\"params\">(<span class=\"keyword\">int</span> stackSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Stack *<span class=\"built_in\">stack</span> = (Stack *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Stack));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;data = (<span class=\"keyword\">void</span> **)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span> **) * (stackSize + <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(<span class=\"built_in\">stack</span>-&gt;data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span> **) * (stackSize + <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;size = stackSize;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StackFree</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj-&gt;data != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(obj-&gt;data);</span><br><span class=\"line\">        obj-&gt;data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj);</span><br><span class=\"line\">    obj = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsStackEmpty</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj-&gt;top == <span class=\"number\">-1</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsStackFull</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj-&gt;top ==  obj-&gt;size);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StackPush</span><span class=\"params\">(Stack *obj, <span class=\"keyword\">void</span> *data)</span>  <span class=\"comment\">// 泛型接口，使用void *</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsStackFull(obj) == <span class=\"literal\">true</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top = obj-&gt;top;</span><br><span class=\"line\">    obj-&gt;data[++top] = data;</span><br><span class=\"line\">    obj-&gt;top = top;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StackPop</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsStackEmpty(obj) == <span class=\"literal\">true</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data = obj-&gt;data[obj-&gt;top];</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(data);</span><br><span class=\"line\">    data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    obj-&gt;top--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">StackTop</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsStackEmpty(obj) == <span class=\"literal\">true</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj-&gt;data[obj-&gt;top]);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StackClear</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsStackEmpty(obj) == <span class=\"literal\">true</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj-&gt;top; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *data = obj-&gt;data[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(data);</span><br><span class=\"line\">            data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    obj-&gt;top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximalRectangle</span><span class=\"params\">(<span class=\"keyword\">char</span> **matrix, <span class=\"keyword\">int</span> matrixSize, <span class=\"keyword\">int</span> *matrixColSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> **height = (<span class=\"keyword\">int</span> **)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span> *) * matrixSize);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrixSize; i++) {</span><br><span class=\"line\">        height[i] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * (matrixColSize[i] + <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; matrixColSize[i]; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) {</span><br><span class=\"line\">                height[i][j] = (matrix[i][j] == <span class=\"string\">'1'</span>) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                height[i][j] = (matrix[i][j] == <span class=\"string\">'1'</span>) ? (height[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>) : <span class=\"number\">0</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        height[i][matrixColSize[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    Stack *monotoneStack = StackCreate(matrixSize * matrixSize);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrixSize; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= matrixColSize[i]; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((IsStackEmpty(monotoneStack) != <span class=\"literal\">true</span>) &amp;&amp; </span><br><span class=\"line\">                    (height[i][*(<span class=\"keyword\">int</span> *)monotoneStack-&gt;data[monotoneStack-&gt;top]] &gt;= height[i][j])) {</span><br><span class=\"line\">                <span class=\"keyword\">int</span> h = height[i][*(<span class=\"keyword\">int</span> *)monotoneStack-&gt;data[monotoneStack-&gt;top]];</span><br><span class=\"line\">                StackPop(monotoneStack);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> sidx = ((IsStackEmpty(monotoneStack) == <span class=\"literal\">true</span>) ? <span class=\"number\">-1</span> : *(<span class=\"keyword\">int</span> *)(monotoneStack-&gt;data[monotoneStack-&gt;top]));</span><br><span class=\"line\">                ans = MAX(ans, h * (j - sidx - <span class=\"number\">1</span>));</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">int</span> *node = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">            *node = j;</span><br><span class=\"line\">            StackPush(monotoneStack, node); </span><br><span class=\"line\">        }</span><br><span class=\"line\">        StackClear(monotoneStack);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    StackFree(monotoneStack);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n</details>\n\n<br>\n<br>\n\n<p>85 Maximal Reactangle<br>leetcode 496、503、739、239<br><br><br>42.接雨水</p>\n<br>\n\n<ul>\n<li>参考链接：<br><a href=\"https://blog.csdn.net/chongbin007/article/details/112741867?utm_term=%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97leetcode\">leetcode算法总结 ——单调栈&amp;单调队列</a></li>\n</ul>\n<h2 id=\"2-并查集\"><a href=\"#2-并查集\" class=\"headerlink\" title=\"2.并查集\"></a>2.并查集</h2><h3 id=\"2-1-并查集介绍\"><a href=\"#2-1-并查集介绍\" class=\"headerlink\" title=\"2.1 并查集介绍\"></a>2.1 并查集介绍</h3><p> 并查集(DSU)主要用于解决一些元素分组的问题，管理一系列不相交的集合，并支持两种操作：<br> 并查集即<strong>合并集合</strong>和<strong>查找集合中元素</strong>两种操作的算法.但实际并查集的基本操作有三个:<br> makeSet(size):建立一个新的并查集,其中包含size个单元素集合.<br> unionSet(x, y)<strong>合并</strong>:把元素x和元素y所在的集合合并,要求x和y所在的集合不相交,如果相交则不合并.<br> find(x)<strong>查询</strong>:找到元素x所在的集合的代表,该操作也可以用于判断两个元素是否位于同一个集合,只要将它们各自的代表比较一下就可以了. find(x)有两种实现方法,一种是递归,一种是非递归。</p>\n<p> 并查集的重要思想在于，用集合中的一个元素代表集合。</p>\n<p> <strong>算法:</strong><br>  用集合中的某个元素来代表这个集合,该元素称为集合的代表元.一个集合内的所有元素组织成以代表元为根的树形结构.对应每一个元素x来说,parent[x]指向x在树形结构上的父节点,如果x是根节点,则灵parent[x] = x. 对于查找操作,假设需要确定x所在的集合,也就是确定集合的代表元.可以沿着parent[x]不断在树形结构中向上移动,直到到达根节点.<br> 因为创建的树可能会严重不平衡,并查集可以用两种优化策略:<br> 1.按秩序合并<br>  即总将更小的树连接至更大的树上,<br> 2.<strong>路径压缩</strong><br>  为了加快查找速度,查找时将x到根节点路径上的所有点的parent设为根节点,该优化方法称为路径压缩.</p>\n<p> 算法用途:<br>  1.维护无向图的连通性,支持判断两个点是否在同一连通块内,和.<br>  2.判断增加一条边是否会产生环:用在求解最小生成树Kruskal算法里<br> 并查集时统计图中连通块数量的一种方法.使用一个大小为N的parent数组,遍历这个图,每个节点都遍历所有相邻点,并让相邻点指向它,并设置成一个有parent节点决定的单独组.这个过程被称为union.这样每个组都有一个唯一的parent节点,这些节点的父节点为-1.</p>\n<p>合并的比较方法<br>应当将简单的树向复杂的树上合并，从而使合并后到根节点距离变长的节点个数比较少。</p>\n<p>并查集的时间复杂度<br>查询次数+合并次数 N或以上则平均下来单次查询或合并的平均时间复杂度O(1)</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> pre[<span class=\"number\">1010</span>]; <span class=\"comment\">// 存放第i个元素的父节点</span></span><br><span class=\"line\"><span class=\"comment\">// 查询根节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">unionsearch</span><span class=\"params\">(<span class=\"keyword\">int</span> root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> son, tmp;</span><br><span class=\"line\">    son = root;</span><br><span class=\"line\">    <span class=\"comment\">// 寻找根节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (root != pre[root]) {</span><br><span class=\"line\">        root = pre[root]; <span class=\"comment\">// 路径压缩</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (son != root) {</span><br><span class=\"line\">        tmp = pre[son];</span><br><span class=\"line\">        pre[son] = root;</span><br><span class=\"line\">        son = tmp;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">(<span class=\"keyword\">int</span> root1, <span class=\"keyword\">int</span> root2)</span> <span class=\"comment\">// 判断释放连通,不连通就合并</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    x = unionsearch(root1);</span><br><span class=\"line\">    y = unionsearch(root2);</span><br><span class=\"line\">    <span class=\"comment\">// 如果不连通,就把它们所在的连通分支合并</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x != y) {</span><br><span class=\"line\">        pre[x] = y;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p><a href=\"https://blog.csdn.net/qq_41593390/article/details/81146850\">https://blog.csdn.net/qq_41593390/article/details/81146850</a></p>\n<p><a href=\"https://blog.csdn.net/ziachen/article/details/106315471\">https://blog.csdn.net/ziachen/article/details/106315471</a></p>\n<p>朋友圈</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> **matrix, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *parent = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*size);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(parent, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*size);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rows = size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> clos = matrix[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cols; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">1</span> &amp;&amp; i != j) {</span><br><span class=\"line\">                <span class=\"class\"><span class=\"keyword\">union</span>(<span class=\"title\">parent</span>, <span class=\"title\">i</span>, <span class=\"title\">j</span>);</span></span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> countCircleNum(parent, size);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> *parent, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> xset = find(parent, i);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> yset = find(parent, j);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xset != yset) {</span><br><span class=\"line\">        <span class=\"comment\">// 合并i和j的两个集合</span></span><br><span class=\"line\">        parent[xset] = yset;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> 查找集合 i 的源头</span></span><br><span class=\"line\"><span class=\"comment\"> 如果集合 i 的父亲是 -1, 说明自己就是源头,返回自己的标号</span></span><br><span class=\"line\"><span class=\"comment\"> 否则查找集合 i 的父亲的源头</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> *parent, <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent[i] == <span class=\"number\">-1</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// i 的父亲为 -1 时,i就是掌门人</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 使用路径压缩,让这条路径上所有的人的上级直接变为掌门人</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> find(parent, parent[i]);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> *parent, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent[i] == <span class=\"number\">-1</span>) {</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// find 非递归实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x != parent[x]) {</span><br><span class=\"line\">        parent[x] = parent[parent[x]];</span><br><span class=\"line\">        x = parent[x];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p> DFS实现</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> **matrix, <span class=\"keyword\">int</span> matrixSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rows = matrixSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cols = matrix[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *visited = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * matrixSize);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[i] == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            dfs(matrix, matrixSize, visite, i);</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> **matrix,  <span class=\"keyword\">int</span> matrixSize, <span class=\"keyword\">int</span> *visited, <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; matrixSize; j++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">1</span> &amp;&amp; visited[j] == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            visited[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(matrxi, matrixSize, visited, j);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p> BFS实现</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> **matrix, <span class=\"keyword\">int</span> length)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* visited = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*length);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<p>题目背景<br>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。<br>题目描述<br>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。<br>输入格式<br>第一行：三个整数n,m,p，（n&lt;=5000,m&lt;=5000,p&lt;=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。<br>以下m行：每行两个数Mi，Mj，1&lt;=Mi，Mj&lt;=N，表示Mi和Mj具有亲戚关系。<br>接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。<br>输出格式<br>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 5005</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> fa[MAXN], rank[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) {</span><br><span class=\"line\">        fa[i] = i;</span><br><span class=\"line\">        rank[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = find(i), y = find(j);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rank[x] &lt;= rank[y]) {</span><br><span class=\"line\">        fa[x] = y;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        fa[y] = x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rank[x] == rank[y] &amp;&amp; x != y) {</span><br><span class=\"line\">        rank[y]++;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, p, x, y;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>, &amp;n, &amp;m, &amp;p);</span><br><span class=\"line\">    init(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) {</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;x, &amp;y);</span><br><span class=\"line\">        merge(x, y);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; p; ++i) {</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;x, &amp;y);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, find(x) == find(y) ? <span class=\"string\">\"Yes\"</span> : <span class=\"string\">\"No\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"2-2-Leetcode题目-547-省份数量\"><a href=\"#2-2-Leetcode题目-547-省份数量\" class=\"headerlink\" title=\"2.2 Leetcode题目:547.省份数量\"></a>2.2 Leetcode题目:<a href=\"https://leetcode-cn.com/problems/number-of-provinces/\">547.省份数量</a></h3><p> 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>\n<p> 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>\n<p> 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p>\n<p>返回矩阵中 省份 的数量。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *g_test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> mSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mSize &lt; <span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    g_dest = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(mSize * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g_dest == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    fot (i = <span class=\"number\">0</span>; i &lt; mSize; i++) {</span><br><span class=\"line\">        g_dest[i] = i;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g_dest[index] == index) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> g_dest[index] = Find(g_dest[index]);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FindRoot</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (g_dest[i] != <span class=\"number\">0</span>) {</span><br><span class=\"line\">        i = g_dest[i];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ProcCircle</span><span class=\"params\">(<span class=\"keyword\">int</span> **m, <span class=\"keyword\">int</span> mSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rootI, rootJ;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; mSize; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = (i + <span class=\"number\">1</span>); j &lt; mSize; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m[i][j] != <span class=\"number\">1</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            rootI = FindRoot(i);</span><br><span class=\"line\">            rootJ = FindRoot(j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rootI == rootJ) {</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            g_dest[rootI] = rootJ;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> mSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mSize; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g_dest[i] == i) {</span><br><span class=\"line\">            sum++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FreeCircle</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g_dest != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(g_dest);</span><br><span class=\"line\">        g_dest = <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> **m, <span class=\"keyword\">int</span> mSize, <span class=\"keyword\">int</span>* mColSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> rslt;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">    rslt = Init(mSize);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!rslt) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    ProcCicle(m, mSize);</span><br><span class=\"line\">    sum = GetCircleNum(mSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    FreeCircle();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n\n<h3 id=\"2-3-最小生成树\"><a href=\"#2-3-最小生成树\" class=\"headerlink\" title=\"2.3 最小生成树\"></a>2.3 最小生成树</h3><p> 关于图的几个概念定义:<br>连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。<br>强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。<br>连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。<br>生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。<br>最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p>\n<ul>\n<li>参考链接:<a href=\"https://blog.csdn.net/luoshixian099/article/details/51908175\">https://blog.csdn.net/luoshixian099/article/details/51908175</a></li>\n</ul>\n<h2 id=\"3-滑动窗口-amp-双指针\"><a href=\"#3-滑动窗口-amp-双指针\" class=\"headerlink\" title=\"3.滑动窗口&amp;双指针\"></a>3.滑动窗口&amp;双指针</h2><h3 id=\"3-1-滑动窗口描述\"><a href=\"#3-1-滑动窗口描述\" class=\"headerlink\" title=\"3.1 滑动窗口描述\"></a>3.1 滑动窗口描述</h3><p> 滑动窗口法，也叫尺取法（可能也不一定相等，大概就是这样 =。=），可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。</p>\n<p> 滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。其实这里就可以看出来滑动窗口主要应用在数组和字符串上。</p>\n<p>  滑动：说明这个窗口是移动的，也就是移动是按照一定方向来的。</p>\n<p>  窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。</p>\n<p>  滑动窗口是双指针的一种应用，形象点说就是维护一个窗口，在窗口滑动的过程中进行窗口内数据的更新，并判断是否符合答案。、<br>初始时两个指针均指向开头，然后右指针依次向右滑动，在滑动的过程中需要收缩的时候进行左指针的移动，当右指针移出的时候结束循环即可。<br>  TCP协议使用滑动窗口实现.</p>\n<h3 id=\"3-2-Leetcode题目\"><a href=\"#3-2-Leetcode题目\" class=\"headerlink\" title=\"3.2 Leetcode题目\"></a>3.2 Leetcode题目</h3><p>1208.进可能使字符串相等</p>\n<p>Leetcode 209. 长度最小的子数组<br>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> t)</span></span>{</span><br><span class=\"line\">     <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; need,window;</span><br><span class=\"line\">     <span class=\"comment\">//在need中记录相应的信息</span></span><br><span class=\"line\">      .....</span><br><span class=\"line\">      <span class=\"keyword\">int</span> left=<span class=\"number\">0</span>,right=<span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> valid;<span class=\"comment\">//该变量用来判断是否得到相应的答案了</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">while</span>(right&lt;s.size()) {</span><br><span class=\"line\">         <span class=\"keyword\">char</span> c=s[right];<span class=\"comment\">//取出将要移入窗口内的数据</span></span><br><span class=\"line\">         right++；</span><br><span class=\"line\">         <span class=\"comment\">//下面进行窗口更新后一些数据的更新</span></span><br><span class=\"line\">         .....</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">while</span>(判断窗口是否需要收缩) {</span><br><span class=\"line\">              <span class=\"comment\">//是否需要进行相应的答案更新</span></span><br><span class=\"line\">              ......</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">char</span> d=s[left];<span class=\"comment\">//将要移出窗口的数据；</span></span><br><span class=\"line\">              left++;<span class=\"comment\">//收缩窗口</span></span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">//窗口收缩后相应数据的更新</span></span><br><span class=\"line\">              .......           </span><br><span class=\"line\">         }   </span><br><span class=\"line\">      }      </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>示例: </p>\n<p>输入: s = 7, nums = [2,3,1,2,4,3]<br>输出: 2<br>解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</p>\n<ul>\n<li>参考链接:<br><a href=\"https://zhuanlan.zhihu.com/p/61564531\">https://zhuanlan.zhihu.com/p/61564531</a></li>\n</ul>\n<h3 id=\"3-3-单调队列\"><a href=\"#3-3-单调队列\" class=\"headerlink\" title=\"3.3 单调队列\"></a>3.3 单调队列</h3><p> 单调队列是指：队列中的元素之间的关系具有单调性，而且，队首和队尾都可以进行出队操作，只有队尾开源进行入队操作。<br> 单调队列与单调栈及其相似，把单调栈先进后出的性质改为先进先出既可。<br>元素进队列的过程对于单调递增队列。<br>对于一个元素a，如果a&gt;队尾元素，那么直接将a扔进队列，如果a&lt;=队尾元素，则将队尾元素出队列，直到满足 a&gt;队尾元素即可。</p>\n<blockquote>\n<p>单调递增队列(从队首到队尾满足递增)<br>单调递减队列(从队首到队尾满足递减)</p>\n</blockquote>\n<ul>\n<li><p>单调队列作用：队列里的元素满足出队的单调性。</p>\n</li>\n<li><p>单调队列操作：去头和删尾</p>\n</li>\n<li><p>leetcode 题目<br><a href=\"https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/\">剑指 Offer 59 - II. 队列的最大值</a></p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[<span class=\"number\">20000</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">} MaxQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MaxQueue* <span class=\"title\">maxQueueCreate</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    MaxQueue *tmp = (MaxQueue*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(MaxQueue));</span><br><span class=\"line\">    tmp-&gt;begin = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;end = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxQueueMax_value</span><span class=\"params\">(MaxQueue* obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = obj-&gt;begin; i &lt; obj-&gt;end; i++) {</span><br><span class=\"line\">        ans = fmax(ans, obj-&gt;arr[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maxQueuPus_back</span><span class=\"params\">(MaxQueue* obj, <span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    obj-&gt;arr[obj-&gt;end++] = value;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxQueuePop_front</span><span class=\"params\">(MaxQueue* obj)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obj-&gt;begin==obj-&gt;end) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj-&gt;arr[obj-&gt;begin++];</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maxQueueFree</span><span class=\"params\">(MaxQueue* obj)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    obj-&gt;end=<span class=\"number\">0</span>;</span><br><span class=\"line\">    obj-&gt;begin=<span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ul>\n<p>239.滑动窗口最大值</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> Size=<span class=\"number\">1000005</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[Size],qmax[Size],qmin[Size],savemax[Size],savemin[Size];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,k,cnt=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;n,&amp;k);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    {<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);}</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg=<span class=\"number\">1</span>,top=<span class=\"number\">0</span>;<span class=\"comment\">//qmax队列的队首指针和队尾指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> st=<span class=\"number\">1</span>,ed=<span class=\"number\">0</span>;<span class=\"comment\">//qmin队列的队首指针和队尾指针</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) {</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(beg&lt;=top&amp;&amp;a[i]&gt;=a[qmax[top]])</span><br><span class=\"line\">        {top--;}</span><br><span class=\"line\">        qmax[++top]=i;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(st&lt;=ed&amp;&amp;a[i]&lt;=a[qmin[ed]])</span><br><span class=\"line\">        {ed--;}</span><br><span class=\"line\">        qmin[++ed]=i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k) {</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(qmax[beg]&lt;=i-k)beg++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(qmin[st]&lt;=i-k)st++;</span><br><span class=\"line\">            savemax[cnt]=a[qmax[beg]];</span><br><span class=\"line\">            savemin[cnt]=a[qmin[st]];</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt; cnt;i++) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,savemin[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt; cnt;i++) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,savemax[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>参考链接：<br><a href=\"https://www.cnblogs.com/zzcxxoo/p/13216030.html\">https://www.cnblogs.com/zzcxxoo/p/13216030.html</a></li>\n</ul>\n<br>\n\n<h2 id=\"4-前缀和-amp-哈希表优化\"><a href=\"#4-前缀和-amp-哈希表优化\" class=\"headerlink\" title=\"4.前缀和(&amp;哈希表优化)\"></a>4.前缀和(&amp;哈希表优化)</h2><h3 id=\"4-1-前缀和介绍\"><a href=\"#4-1-前缀和介绍\" class=\"headerlink\" title=\"4.1 前缀和介绍\"></a>4.1 前缀和介绍</h3><p> 前缀和(prefix sum)定义:前缀和时一种预处理,能大大降低查询的时间复杂度.结合Hash缓存,能够进一步优化提升算法执行效率.<br> 对数组nums进行前缀和初始化需要O(n)时间<br> 新建数组prefixSum,数组长度定义为 nums.length+1,确保顶第 nums.length个元素存储前面0到nums.length-1个元素的和.将数组nums的累加一层放入数组prefixSum中.<br> 变换公式:<br>  1)nums[某一项] = 两个相邻前缀和之差: nums[i] = prefixSum[x] - prefixSum[x-1]<br>  2)从left到right的元素和等于: prefixSum[right+1] - prefixSum[left]</p>\n<p>假设我们有一个字符串ABCDE，什么是这个单词的前缀，A、AB、ABC、ABCD、ABCDE就是这个单词的前缀，就是从第一个字母开始，依次往后拼接。E、ED、EDC、EDCB、EDCBA被称为这个单词的后缀。</p>\n<p>那么对于一个数组的前缀，例如数组a = [1,2,3,4,5]，我们维护一个由前缀的和组成的数组sum，sum[i]表示数组中a[0]~ a[i] 的和。<br>sum[0] = a[0]<br>sum[1] = a[0] + a[1]<br>sum[2] = a[0] + a[1] + a[2]<br>sum[3] = a[0] + a[1] + a[2] + a[3]<br>sum[4] = a[0] + a[1] + a[2] + a[3] + a[4]<br>sum数组就被称为前缀和数组。</p>\n<p>前缀和的作用<br>前缀和的最主要目的就是求子数组的和的大小。例如元素a[1]到a[3]的和。<br>a[1] + a[2] + a[3] = sum[3] - sum[0]</p>\n<p> 前缀和数组初始化过程伪代码:<br>  1.安装for寻的政策边界进行初始化,避免了 int i=1 或者 &lt;=len 等肯的各种调整.<br>  2.前缀和长度比数据长度多一个,前缀和第0个元素要初始化为0<br>  另外一种前缀和初始化方法:前缀和长度为nums.length,第0个元素存储自己的和.<br>  prefixSum[i] - prefixSum[i-1] 容易出现错误理解和技术丢失.示例:prefixSum[0] = num[1],造成nums[0]丢失.</p>\n<ul>\n<li>参考链接:<br><a href=\"https://blog.csdn.net/fgy_u/article/details/109349710\">https://blog.csdn.net/fgy_u/article/details/109349710</a><br><a href=\"https://www.jianshu.com/p/3021429f38d4\">https://www.jianshu.com/p/3021429f38d4</a></li>\n</ul>\n<br>\n\n<h2 id=\"5-差分\"><a href=\"#5-差分\" class=\"headerlink\" title=\"5.差分\"></a>5.差分</h2><h3 id=\"5-1-差分介绍\"><a href=\"#5-1-差分介绍\" class=\"headerlink\" title=\"5.1 差分介绍\"></a>5.1 差分介绍</h3><p> 差分时一种和前缀和算法相对 的策略,这种策略是,令 <code>b(i) = a(i) - a(i-1)</code>,即相邻两数的差.在每一个点上记录变化数值,因为有增加有减少通过求和判断是否有超过指定容量的情况发生,超过则代表无法满足要求.</p>\n<p>该算法是前缀和算法的逆运算，可以快速的对数组的某一个区间进行计算。</p>\n<p> 对于数组array[N]中的某一段进行增减操作,通过差分可在 O(n)时间内完成.如:<br> trips = [ [2,1,5], [3,3,7]]<br> 第一步:更新array[1] = 2, array[2] = -2;<br> 第二步:更新array[3] = 3, array[7] = -2;<br> 第三步:进行求和,得到结果array[] = {0, 2, 2, 5, 5, 3, 3, 0}</p>\n<br>\n\n<h2 id=\"6-拓扑排序\"><a href=\"#6-拓扑排序\" class=\"headerlink\" title=\"6.拓扑排序\"></a>6.拓扑排序</h2><p>一、什么是拓扑排序<br>在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>\n<p>每个顶点出现且只出现一次。<br>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。<br>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</p>\n<p>二、拓扑排序的应用<br>拓扑排序通常用来“排序”具有依赖关系的任务。</p>\n<p>比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边<script type=\"math/tex\" id=\"MathJax-Element-1\"> </script>表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</p>\n<p>三、拓扑排序的实现<br>根据上面讲的方法，我们关键是要维护一个入度为0的顶点的集合。<br>图的存储方式有两种：邻接矩阵和邻接表。这里我们采用邻接表来存储图，C++代码如下：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/************************类声明************************/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> V;             <span class=\"comment\">// 顶点个数</span></span><br><span class=\"line\">    list&lt;<span class=\"keyword\">int</span>&gt; *adj;    <span class=\"comment\">// 邻接表</span></span><br><span class=\"line\">    queue&lt;<span class=\"keyword\">int</span>&gt; q;      <span class=\"comment\">// 维护一个入度为0的顶点的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>* indegree;     <span class=\"comment\">// 记录每个顶点的入度</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Graph</span>(<span class=\"keyword\">int</span> V);                   <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">Graph</span>();                       <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span>;     <span class=\"comment\">// 添加边</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">topological_sort</span><span class=\"params\">()</span></span>;        <span class=\"comment\">// 拓扑排序</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/************************类定义************************/</span></span><br><span class=\"line\">Graph::<span class=\"built_in\">Graph</span>(<span class=\"keyword\">int</span> V)</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;V = V;</span><br><span class=\"line\">    adj = <span class=\"keyword\">new</span> list&lt;<span class=\"keyword\">int</span>&gt;[V];</span><br><span class=\"line\"></span><br><span class=\"line\">    indegree = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[V];  <span class=\"comment\">// 入度全部初始化为0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;V; ++i)</span><br><span class=\"line\">        indegree[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">Graph::~<span class=\"built_in\">Graph</span>()</span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> [] adj;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> [] indegree;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Graph::addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    adj[v].<span class=\"built_in\">push_back</span>(w); </span><br><span class=\"line\">    ++indegree[w];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Graph::topological_sort</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;V; ++i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(indegree[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>(i);         <span class=\"comment\">// 将所有入度为0的顶点入队</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;             <span class=\"comment\">// 计数，记录当前已经输出的顶点数 </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>()) {</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = q.<span class=\"built_in\">front</span>();      <span class=\"comment\">// 从队列中取出一个顶点</span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        cout &lt;&lt; v &lt;&lt; <span class=\"string\">\" \"</span>;      <span class=\"comment\">// 输出该顶点</span></span><br><span class=\"line\">        ++count;</span><br><span class=\"line\">        <span class=\"comment\">// 将所有v指向的顶点的入度减1，并将入度减为0的顶点入栈</span></span><br><span class=\"line\">        list&lt;<span class=\"keyword\">int</span>&gt;::iterator beg = adj[v].<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( ; beg!=adj[v].<span class=\"built_in\">end</span>(); ++beg)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!(--indegree[*beg]))</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(*beg);   <span class=\"comment\">// 若入度为0，则入栈</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count &lt; V)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;           <span class=\"comment\">// 没有输出全部顶点，有向图中有回路</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;            <span class=\"comment\">// 拓扑排序成功</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;   <span class=\"comment\">// 创建图</span></span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    g.<span class=\"built_in\">topological_sort</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>输出结果是 4, 5, 2, 0, 3, 1。这是该图的拓扑排序序列之一。</p>\n<p>每次在入度为0的集合中取顶点，并没有特殊的取出规则，随机取出也行，这里使用的queue。取顶点的顺序不同会得到不同的拓扑排序序列，当然前提是该图存在多个拓扑排序序列。</p>\n<p>由于输出每个顶点的同时还要删除以它为起点的边，故上述拓扑排序的时间复杂度为O(V+E)O(V+E)。</p>\n<ul>\n<li>参考链接:<br><a href=\"https://blog.csdn.net/lisonglisonglisong/article/details/45543451\">https://blog.csdn.net/lisonglisonglisong/article/details/45543451</a></li>\n</ul>\n<br>\n\n<h2 id=\"7-字符串\"><a href=\"#7-字符串\" class=\"headerlink\" title=\"7.字符串\"></a>7.字符串</h2><p>字符串介绍<br> 字符串可以涉及非常多的考点:如递归,栈,hash,dfs,bfs,动态规划等.需要强制记忆的是”字符串的子串”,”字符串的子序列”.难度比较大的是”子序列”问题.对于任何字符串,可通过删除其中一些字符(也可不删)来构造该字符串的子序列.对于任何字符串,选择任意连续的1到N个字符,形成[i,j]形式的子串,然后利用字符串的子串进行相关的匹配和计算.</p>\n<h3 id=\"leetcode题目\"><a href=\"#leetcode题目\" class=\"headerlink\" title=\"leetcode题目\"></a>leetcode题目</h3><ul>\n<li>93 复原IP地址</li>\n<li>43.字符串相乘</li>\n<li>227.基本计算器II</li>\n</ul>\n<p> 给出一个表达式，计算结果，就是典型的计算器类型问题，即栈的经典应用。<br> 栈：添加和删除元素都在队尾进行，先进后出，后进先出，类比于子。。。，入栈和出栈。<br> 思路：<br> 将表达式(中缀)转化为后缀<br> 将后缀计算出结果<br> 具体规则为：<br>  1.中缀转后缀<br>  数字直接输出到后缀表达式<br>  栈为空时，遇到运算符，直接入栈<br>  遇到运算符，弹出所有优先级大于或等于该运算符的栈顶元素，并将该运算符入栈<br>  将栈中元素依次出栈<br>  2.计算后缀<br>  遇到数字，入栈<br>  遇到运算符，弹出栈顶两个元素，做运算，并将结果入栈<br>  重复上述步骤，直到表达式最右端<br>  </p>\n<br>\n\n<h2 id=\"8-二分查找\"><a href=\"#8-二分查找\" class=\"headerlink\" title=\"8.二分查找\"></a>8.二分查找</h2><p> 二分查找也称折半查找(Binary Search),它使一种效率较高的查找方法,前提是数据结构必须先排好序.但是,二分查找要求线性表具有随机访问的特点(如数组),也要求线性表能够根据中间元素的特点推测它两侧元素的性质,以达到缩减问题规模的效果.<br> 二分查找问题也是面试中常考问题,虽然它思想简单,但写好二分算法并不容易.</p>\n<h3 id=\"leetcode题目-1\"><a href=\"#leetcode题目-1\" class=\"headerlink\" title=\"leetcode题目\"></a>leetcode题目</h3><ul>\n<li>4.寻找两个有序数组的中位数</li>\n<li>33.搜索选择排序数组</li>\n</ul>\n<br>\n\n<h2 id=\"9-BFS\"><a href=\"#9-BFS\" class=\"headerlink\" title=\"9.BFS\"></a>9.BFS</h2><p>BFS（广度优先搜索） 常用来解决层序遍历,最短路径问题。<br>第一次遍历到目的节点时，所经过的路径是最短路径。<br>几个要点：</p>\n<p>只能用来求解无权图的最短路径问题<br>队</p>\n<p>列：用来存储每一层遍历得到的节点<br>标记：对于遍历过的结点，应将其标记，以防重复访问</p>\n<p>注:<br>1.广度搜索时候,如果曾经加入过,后续就不用再加入<br>2.加入队列时候,需要标记当前层级,方便后续直接返回目标解.</p>\n<ul>\n<li>参考链接:<a href=\"https://zhuanlan.zhihu.com/p/62884729\">https://zhuanlan.zhihu.com/p/62884729</a></li>\n</ul>\n<h3 id=\"leetcode题目-2\"><a href=\"#leetcode题目-2\" class=\"headerlink\" title=\"leetcode题目\"></a>leetcode题目</h3><ul>\n<li>127.单词接龙</li>\n<li>139.单词拆分</li>\n<li>130.被包围的区域</li>\n<li>317.离建筑物最近的距离</li>\n<li>505.迷宫II</li>\n<li>529.扫雷游戏</li>\n<li>1263.推箱子</li>\n<li>1197.进击的骑士</li>\n<li>815.公交路线</li>\n<li>934.最短的桥</li>\n</ul>\n<br>\n\n<h2 id=\"10-DFS\"><a href=\"#10-DFS\" class=\"headerlink\" title=\"10.DFS\"></a>10.DFS</h2><p> 深度优先搜索算法(DFS):是一种用于遍历或搜索树或图的算法.利用深度优先搜索算法可产生目标图的拓扑排序表,拓扑排序可用于无权最长路径问题等.DFS实质是一种枚举,不过借助递归实现.<br> 回溯搜索时深度优先搜索(DFS)的一种.对于某一个搜索树来说(搜索树时起记录路径和状态判断的作用),回溯和DFS,其主要的区别是,回溯法在求解过程中不保留完整的树结构,而深度优先搜索则记下完整的搜索树.回溯就是通过不同的尝试来生成问题的解,类似于穷举,但和穷举不同的时回溯会”减枝”.为了减少存储空间,在深度优先搜索中,用标志的方法记录访问过的状态,这种处理方法使得深度优先搜索法与回溯法没什么区别.<br> DFS相对于BFS更方便写,空间复杂度更低<br> DFS基本模式:</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> step)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">// 判断边界</span></span><br><span class=\"line\">    ...;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试每一种可能</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; j &lt;= n; ++i) {</span><br><span class=\"line\">        <span class=\"comment\">// 继续下一步</span></span><br><span class=\"line\">        dfs(step + <span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回</span></span><br><span class=\"line\">    ...;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    dfs(root.left);</span><br><span class=\"line\">    dfs(root.right);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p> 回溯的一般结构</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(<span class=\"keyword\">int</span> 当前状态)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (当前状态为边界状态) {</span><br><span class=\"line\">        记录或输出</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 横向遍历解答树所有子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">        <span class=\"comment\">// 扩展出一个子状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 修改了全局变量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (子状态满足约束条件) {</span><br><span class=\"line\">            backtrack(子状态)</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">// 恢复全局变量//回溯部分</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p> 回溯代码框架:</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = {}</span><br><span class=\"line\">def backtrack(路径, 选择列表)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> 满足结束条件</span><br><span class=\"line\">        result.add(路径)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> 选择 in 选择列表</span><br><span class=\"line\">        做选择</span><br><span class=\"line\">        backtrack(路径,,选择列表)</span><br><span class=\"line\">        撤销选择</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"leetcode题目-3\"><a href=\"#leetcode题目-3\" class=\"headerlink\" title=\"leetcode题目\"></a>leetcode题目</h3><ul>\n<li>1102.得分最高的路径</li>\n<li>685.冗余链接II</li>\n<li>531.孤独像素I</li>\n<li>533.孤独像素II</li>\n<li>332.重新安排行程</li>\n<li>337.打家劫舍III</li>\n<li>113.路线总和II</li>\n</ul>\n<br>\n\n<h2 id=\"11-动态规划\"><a href=\"#11-动态规划\" class=\"headerlink\" title=\"11.动态规划\"></a>11.动态规划</h2><ul>\n<li>参考链接:<br><a href=\"https://blog.csdn.net/qq_37763204/article/details/79394397\">https://blog.csdn.net/qq_37763204/article/details/79394397</a><br><a href=\"https://blog.csdn.net/u013309870/article/details/75193592\">https://blog.csdn.net/u013309870/article/details/75193592</a></li>\n</ul>\n<h3 id=\"leetcode题目-4\"><a href=\"#leetcode题目-4\" class=\"headerlink\" title=\"leetcode题目\"></a>leetcode题目</h3><ul>\n<li>213.打家劫舍II</li>\n<li>1043.</li>\n<li>416</li>\n<li>123</li>\n</ul>\n<br>\n\n<h2 id=\"12-贪心算法\"><a href=\"#12-贪心算法\" class=\"headerlink\" title=\"12.贪心算法\"></a>12.贪心算法</h2><br>\n\n\n<h2 id=\"13-字典树\"><a href=\"#13-字典树\" class=\"headerlink\" title=\"13.字典树\"></a>13.字典树</h2><details>\n<summary>tire</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 26    <span class=\"comment\">//26个字母</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SLEN 100   <span class=\"comment\">//节点中存储的字符串长度</span></span></span><br><span class=\"line\"><span class=\"comment\">//Trie结构体定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trie</span></span></span><br><span class=\"line\"><span class=\"class\">{</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trie</span> *<span class=\"title\">next</span>[<span class=\"title\">MAX</span>];</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[SLEN];      <span class=\"comment\">//节点处存储的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> isword;         <span class=\"comment\">//节点处是否为单词</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> val;           <span class=\"comment\">//节点的代表字符</span></span><br><span class=\"line\">} *root;</span><br><span class=\"line\"><span class=\"comment\">//初始化Trie树</span></span><br><span class=\"line\"><span class=\"function\">struct Trie *<span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trie</span> *<span class=\"title\">root</span> =</span> (struct Trie *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct Trie));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        root -&gt; next[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    root -&gt; isword = <span class=\"number\">0</span>;</span><br><span class=\"line\">    root -&gt; val = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">//按照指定路径path 插入字符串 s</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">char</span> path[], <span class=\"keyword\">char</span> s[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trie</span> *<span class=\"title\">t</span>, *<span class=\"title\">p</span> =</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j, n = <span class=\"built_in\">strlen</span>(path);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p -&gt; next[path[i] - <span class=\"string\">'a'</span>] == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            t = (struct Trie *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct Trie));</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; MAX; j++)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                t -&gt; next[j] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                t -&gt; isword = <span class=\"number\">0</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            t -&gt; val = path[i];</span><br><span class=\"line\">            p -&gt; next[path[i] - <span class=\"string\">'a'</span>] = t;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        p = p -&gt; next[path[i] - <span class=\"string\">'a'</span>];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    p -&gt; isword = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(p -&gt; s , s);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">//按照指定路径 path 查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">char</span> path[], <span class=\"keyword\">int</span> delflag)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trie</span> *<span class=\"title\">p</span> =</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = <span class=\"built_in\">strlen</span>(path);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &amp;&amp; path[i])</span><br><span class=\"line\">    {</span><br><span class=\"line\">        p = p -&gt; next[path[i++] - <span class=\"string\">'a'</span>];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p &amp;&amp; p -&gt; isword)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        p -&gt; isword = delflag;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p-&gt;s;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">//删除整棵Trie树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">del</span><span class=\"params\">(struct Trie *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;next[i])</span><br><span class=\"line\">            del(root-&gt;next[i]);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(root-&gt;next[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n\n\n\n<details>\n<summary>tire</summary>\n\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*------------------Trie Data Structure----------------------------------*/</span></span><br><span class=\"line\"><span class=\"comment\">/*-------------Implimented for search a word in dictionary---------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----character - 97 used for get the character from the ASCII value-----*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALPHABET_SIZE 26</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--Node in the Trie--*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TrieNode</span></span></span><br><span class=\"line\"><span class=\"class\">{</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TrieNode</span> *<span class=\"title\">children</span>[<span class=\"title\">ALPHABET_SIZE</span>];</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> character;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isEndOfWord;</span><br><span class=\"line\"></span><br><span class=\"line\">} TrieNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--Create new node--*/</span></span><br><span class=\"line\"><span class=\"function\">TrieNode *<span class=\"title\">createTrieNode</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    TrieNode *node;</span><br><span class=\"line\">    node = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TrieNode));</span><br><span class=\"line\">    node-&gt;isEndOfWord = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; ALPHABET_SIZE) {</span><br><span class=\"line\">        node-&gt;children[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--Insert new word to Trie--*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(TrieNode *root, <span class=\"keyword\">char</span> *word)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">/*----Addition of the word done by recurcively----*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check wheather word character pointer is NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">strlen</span>(word) - <span class=\"number\">1</span>) != <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">char</span> character = *word;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;children[character - <span class=\"number\">97</span>] == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            TrieNode *node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            node = createTrieNode();</span><br><span class=\"line\">            node-&gt;character = character;</span><br><span class=\"line\">            root-&gt;children[character - <span class=\"number\">97</span>] = node;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        word++;</span><br><span class=\"line\">        insert(root-&gt;children[character - <span class=\"number\">97</span>], word);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        root-&gt;isEndOfWord = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--Search a word in the Trie--*/</span></span><br><span class=\"line\"><span class=\"function\">TrieNode *<span class=\"title\">search</span><span class=\"params\">(TrieNode *root, <span class=\"keyword\">char</span> *word)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    TrieNode *temp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*word != <span class=\"string\">'\\0'</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">char</span> character = *word;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;children[character - <span class=\"number\">97</span>] != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            temp = root-&gt;children[character - <span class=\"number\">97</span>];</span><br><span class=\"line\">            word++;</span><br><span class=\"line\">            root = temp;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"No possible words!!\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*---Print a word in the array--*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printArray</span><span class=\"params\">(<span class=\"keyword\">char</span> chars[], <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, chars[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*---Return all the related words------*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printPathsRecur</span><span class=\"params\">(TrieNode *node, <span class=\"keyword\">char</span> prefix[], <span class=\"keyword\">int</span> filledLen)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    prefix[filledLen] = node-&gt;character;</span><br><span class=\"line\">    filledLen++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;isEndOfWord) {</span><br><span class=\"line\">        printArray(prefix, filledLen);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; ALPHABET_SIZE; i++) {</span><br><span class=\"line\">        printPathsRecur(node-&gt;children[i], prefix, filledLen);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--Travel through the Trie and return words from it--*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">traverse</span><span class=\"params\">(<span class=\"keyword\">char</span> prefix[], TrieNode *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    TrieNode *temp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    temp = search(root, prefix);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (prefix[j] != <span class=\"string\">'\\0'</span>) {</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    printPathsRecur(temp, prefix, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*------Demonstrate purposes uses text file called dictionary -------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NUMBER_OF_WORDS (354935)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INPUT_WORD_SIZE (100)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*----Get input from the user------*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">receiveInput</span><span class=\"params\">(<span class=\"keyword\">char</span> *s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%99s\"</span>, s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">// Read the file dictionary</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> word_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *words[NUMBER_OF_WORDS];</span><br><span class=\"line\">    FILE *fp = fopen(<span class=\"string\">\"dictionary.txt\"</span>, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fp == <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Error while opening dictionary file\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    words[word_count] = <span class=\"built_in\">malloc</span>(INPUT_WORD_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fgets(words[word_count], INPUT_WORD_SIZE, fp)) {</span><br><span class=\"line\">        word_count++;</span><br><span class=\"line\">        words[word_count] = <span class=\"built_in\">malloc</span>(INPUT_WORD_SIZE);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Push the words in to Trie</span></span><br><span class=\"line\">    TrieNode *root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    root = createTrieNode();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NUMBER_OF_WORDS; i++) {</span><br><span class=\"line\">        insert(root, words[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter keyword: \"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> str[<span class=\"number\">100</span>];</span><br><span class=\"line\">        receiveInput(str);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(</span><br><span class=\"line\">            <span class=\"string\">\"\\n==========================================================\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n********************* Possible Words ********************\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Find the word through the Trie</span></span><br><span class=\"line\">        traverse(str, root);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(</span><br><span class=\"line\">            <span class=\"string\">\"\\n==========================================================\\n\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</details>\n\n<ul>\n<li>参考链接：<br>简单易懂的字典树<a href=\"https://zhuanlan.zhihu.com/p/143975546\">https://zhuanlan.zhihu.com/p/143975546</a><br>字典树 (Trie)<a href=\"https://oi-wiki.org/string/trie/\">https://oi-wiki.org/string/trie/</a><br>字典树(Trie)<a href=\"https://www.jianshu.com/p/e431bd41d676\">https://www.jianshu.com/p/e431bd41d676</a><br><a href=\"https://blog.csdn.net/weixin_39778570/article/details/81990417\">https://blog.csdn.net/weixin_39778570/article/details/81990417</a><br><a href=\"https://github.com/TheAlgorithms/C/blob/master/data_structures/trie/trie.c\">Trie</a></li>\n</ul>\n<h3 id=\"bitmap\"><a href=\"#bitmap\" class=\"headerlink\" title=\"bitmap\"></a>bitmap</h3><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TYPE int</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INT_BITS (1&lt;&lt;3) * sizeof(TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SHIFT (int)(log(INT_BITS)/log(2))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MASK INT_BITS-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">TYPE bitmap[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 是否存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">containBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 得到当前位置的第几位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"int_bits = %d, shift = %d, mask = %d\\n\"</span>, INT_BITS, SHIFT, MASK);</span><br><span class=\"line\">\tsetBit(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"是否存在%d\\n\"</span>, containBit(<span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"是否存在%d\\n\"</span>, containBit(<span class=\"number\">3</span>));</span><br><span class=\"line\">\tdeleteBit(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"是否存在%d\\n\"</span>, containBit(<span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"是否存在%d\\n\"</span>, containBit(<span class=\"number\">3</span>));</span><br><span class=\"line\">\tsetBit(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"是否存在%d\\n\"</span>, containBit(<span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"是否存在%d\\n\"</span>, containBit(<span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"2在当前的位置%d\\n\"</span>, getBit(<span class=\"number\">2</span>));</span><br><span class=\"line\">\tsetBit(<span class=\"number\">32</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"32在当前的位置%d\\n\"</span>, getBit(<span class=\"number\">32</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>{</span><br><span class=\"line\">\t bitmap[num &gt;&gt; SHIFT] |= <span class=\"number\">1</span> &lt;&lt; (num &amp; MASK);</span><br><span class=\"line\">\t <span class=\"built_in\">printf</span>(<span class=\"string\">\"set --[%d]: %d\\n\"</span>, num &gt;&gt; SHIFT, bitmap[num &gt;&gt; SHIFT]);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">containBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>{</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (bitmap[num &gt;&gt; SHIFT] &amp; <span class=\"number\">1</span> &lt;&lt; (num &amp;MASK)) ==  <span class=\"number\">1</span> &lt;&lt; (num &amp;MASK);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>{</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num &amp; MASK;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>{</span><br><span class=\"line\">\tbitmap[num &gt;&gt; SHIFT] &amp;= ~(<span class=\"number\">1</span> &lt;&lt; (num &amp; MASK));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"del -- [%d] : %d\\n\"</span>, num &gt;&gt; SHIFT, bitmap[num &gt;&gt; SHIFT]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<ul>\n<li>参考链接：<br><a href=\"https://www.cnblogs.com/cjsblog/p/11613708.html\">https://www.cnblogs.com/cjsblog/p/11613708.html</a><br><a href=\"https://www.cnblogs.com/chunxia/archive/2013/04/28/3049243.html\">https://www.cnblogs.com/chunxia/archive/2013/04/28/3049243.html</a><br><a href=\"https://zhuanlan.zhihu.com/p/414067305\">https://zhuanlan.zhihu.com/p/414067305</a><br><a href=\"https://ac.nowcoder.com/discuss/292850\">https://ac.nowcoder.com/discuss/292850</a><br><a href=\"https://www.zhihu.com/question/36738189\">https://www.zhihu.com/question/36738189</a><br><a href=\"https://zhuanlan.zhihu.com/p/161036474\">https://zhuanlan.zhihu.com/p/161036474</a></li>\n</ul>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"15JYAPP","length":30041,"excerpt":"<h2 id=\"1-单调栈\"><a href=\"#1-单调栈\" class=\"headerlink\" title=\"1.单调栈\"></a>1.单调栈</h2>","more":"<h3 id=\"1-1-单调栈描述\"><a href=\"#1-1-单调栈描述\" class=\"headerlink\" title=\"1.1 单调栈描述\"></a>1.1 单调栈描述</h3><p>&ensp;单调栈里面的元素大小按照他们所在栈内的位置,满足一定的单调性.</p>\n<blockquote>\n<p>单调递<strong>增</strong>栈：单调递增栈就是从栈底到栈顶数据是从小到大; 可找到<strong>左起</strong>第一个比当前数字<strong>小</strong>的元素.<br>单调递<strong>减</strong>栈：单调递减栈就是从栈底到栈顶数据是从大到小; 可找到<strong>左起</strong>第一个比当前数字<strong>大</strong>的元素.</p>\n</blockquote>\n<p>&emsp;单调递增栈，元素进栈过程，若当前进栈的元素a，如果a&gt;栈顶元素，则直接将a进栈，如果a&lt;=栈顶元素，则不断将栈顶元素出栈，直到满足a&gt;栈顶元素。单调递减栈则为a&lt;栈顶元素时进栈。</p>\n<p>&ensp;题目分析:给定一个数组,返回一个大小相同的数组,返回的数组的第i个位置的值应当是,对于原数组中的第i个元素,至少往右走多少步,才能遇到一个比自己大的元素(如果没有比自己大的元素,或为最后一个元素,则返回对应位置上为-1).<br>&emsp;例如:<br>&ensp;&emsp;input: 5, 3, 1, 2, 4<br>&ensp;&emsp;return: -1, 3, 1, 1, -1<br>&emsp;暴力解法时间复杂度O(n^2)<br>&emsp;暴力解法:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">nextExceed</span><span class=\"params\">(<span class=\"keyword\">int</span> *input, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *result = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * size);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(input,<span class=\"number\">-1</span>,size*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> anchar = input[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (input[j] &gt; anchar) &#123;</span><br><span class=\"line\">                result[j] = j - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;单调栈:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">nextExceed</span><span class=\"params\">(<span class=\"keyword\">int</span> *input, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *result = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * size);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *<span class=\"built_in\">stack</span> = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * size);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(input, <span class=\"number\">-1</span>, size * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (top &gt;= <span class=\"number\">0</span> &amp;&amp; input[i] &gt; input[<span class=\"built_in\">stack</span>[top]]) &#123;</span><br><span class=\"line\">            result[<span class=\"built_in\">stack</span>[top]] = i - <span class=\"built_in\">stack</span>[top];</span><br><span class=\"line\">            top--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>[++top] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;维护一个单调递<strong>减</strong>栈stack,stack内存的是原数组的每个index,当遇到一个比当前栈顶所对应的数<strong>大</strong>的时候,则栈顶元素出栈,并更新它们在返回数组中对应位置的值.</p>\n<p>&ensp;单调栈通常应用在一维数组上,和前后元素大小之间关系有关的问题.单调栈时间复杂度为<code>O(n)</code>.</p>\n<h3 id=\"1-2-Letocde题目分析\"><a href=\"#1-2-Letocde题目分析\" class=\"headerlink\" title=\"1.2 Letocde题目分析\"></a>1.2 Letocde题目分析</h3><p>84.<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/description/\">柱状图中最大的矩形</a></p>\n<details>\n  <summary>柱状图中最大的矩形 c语言</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(<span class=\"keyword\">int</span>* heights, <span class=\"keyword\">int</span> heightsSize)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 栈顶标记,单调递减栈</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> area = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxArea = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *<span class=\"built_in\">stack</span> = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * (heightsSize + <span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *buf = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * (heightsSize + <span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 增加前哨兵</span></span><br><span class=\"line\">    buf[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 在最后增加哨兵</span></span><br><span class=\"line\">    buf[heightsSize + <span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= heightsSize; i++) &#123;</span><br><span class=\"line\">        buf[i] = heights[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>[++top] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; heightsSize + <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (top &gt; <span class=\"number\">0</span> &amp;&amp; buf[i] &lt; buf[<span class=\"built_in\">stack</span>[top]]) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 注意 i - </span></span><br><span class=\"line\">            area = (i - <span class=\"built_in\">stack</span>[top - <span class=\"number\">1</span>] - <span class=\"number\">1</span>) * buf[<span class=\"built_in\">stack</span>[top]];</span><br><span class=\"line\">            maxArea = maxArea &gt; area ? maxArea : area;</span><br><span class=\"line\">            top--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 索引入栈，其他可能是元素入栈</span></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>[++top] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxArea;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<br>\n\n\n<h3 id=\"1-3-单调栈的性质\"><a href=\"#1-3-单调栈的性质\" class=\"headerlink\" title=\"1.3 单调栈的性质\"></a>1.3 单调栈的性质</h3><p>&emsp;1.单调栈里的元素具有单调性,栈中元素只能是单调递增或者单调递减<br>&emsp;2.元素加入栈前,会在栈顶把破坏栈单调性的元素都出栈<br>&emsp;3.使用单调栈可以找到元素向左遍历第一个比它小的元素,也可以找到元素向左遍历第一个比他大的元素</p>\n<h3 id=\"1-3-leetcode题目\"><a href=\"#1-3-leetcode题目\" class=\"headerlink\" title=\"1.3 leetcode题目\"></a>1.3 leetcode题目</h3><p><a href=\"https://leetcode-cn.com/problems/maximal-rectangle/\">85.最大矩形</a><br>&ensp;给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。<br>&emsp;思路:对于每一行,构建一个histogram,然后计算.在构建新的histogram的时候,不需要全部遍历,只需对已有的histogram进行略微修改(运用DP的思想)</p>\n<details>\n  <summary>maximalRectangle</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximalRectangle</span><span class=\"params\">(<span class=\"keyword\">char</span>** matrix, <span class=\"keyword\">int</span> matrixSize, <span class=\"keyword\">int</span>* matrixColSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = matrixSize;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = matrixColSize[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> left[m][n];</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(left, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(left));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                left[i][j] = (j == <span class=\"number\">0</span> ? <span class=\"number\">0</span> : left[i][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;  <span class=\"comment\">// 对于每一列，使用基于柱状图的方法</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> up[m], down[m];</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(up, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(up));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(down, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(down));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> stk[m], top = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (top &gt; <span class=\"number\">0</span> &amp;&amp; left[stk[top - <span class=\"number\">1</span>]][j] &gt;= left[i][j]) &#123;</span><br><span class=\"line\">                top--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            up[i] = top == <span class=\"number\">0</span> ? <span class=\"number\">-1</span> : stk[top - <span class=\"number\">1</span>];</span><br><span class=\"line\">            stk[top++] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        top = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (top &gt; <span class=\"number\">0</span> &amp;&amp; left[stk[top - <span class=\"number\">1</span>]][j] &gt;= left[i][j]) &#123;</span><br><span class=\"line\">                top--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            down[i] = top == <span class=\"number\">0</span> ? m : stk[top - <span class=\"number\">1</span>];</span><br><span class=\"line\">            stk[top++] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> height = down[i] - up[i] - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> area = height * left[i][j];</span><br><span class=\"line\">            ret = fmax(ret, area);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<br>\n\n<p><img src=\"https://s2.loli.net/2021/12/07/aU8ZQBWRo9dTXMb.png\" alt=\"20211207235410\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\"><span class=\"comment\">//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解,单调减栈</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (遍历这个数组)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (栈空 || 栈顶元素大于等于当前比较元素) &#123;</span><br><span class=\"line\">        入栈;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素) &#123;</span><br><span class=\"line\">            栈顶元素出栈;</span><br><span class=\"line\">            更新结果;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        当前数据入栈;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>单调栈</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(<span class=\"keyword\">int</span>* heights, <span class=\"keyword\">int</span> heightsSize,<span class=\"keyword\">int</span> *S,<span class=\"keyword\">int</span> top)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// int*S=(int*)malloc(sizeof(int)*heightsSize); // 初始化栈，栈内保存柱子序号</span></span><br><span class=\"line\">    <span class=\"comment\">// int top=-1;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> start,end,h;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r=<span class=\"number\">0</span>;</span><br><span class=\"line\">    S[++top]=<span class=\"number\">0</span>; <span class=\"comment\">// 入栈第一根柱子</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=heightsSize<span class=\"number\">-1</span>;i++) &#123; <span class=\"comment\">// 遍历所有柱子</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(heights[i] &gt;= heights[S[top]]) &#123; </span><br><span class=\"line\">            S[++top]=i; <span class=\"comment\">// 若当前柱子大于栈顶或等于栈顶，直接入栈</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 若当前柱子小于栈顶，则依次出栈较高的柱子并计算面积</span></span><br><span class=\"line\">            end = S[top]; <span class=\"comment\">// 记录最右边最高的柱子位置，之后每次矩形的底边是从出栈位置到最右边最高柱子的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(top != <span class=\"number\">-1</span> &amp;&amp; heights[i] &lt; heights[S[top]] ) &#123;</span><br><span class=\"line\">                h = heights[S[top--]]; <span class=\"comment\">// 保存当前矩形的高</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(top != <span class=\"number\">-1</span> &amp;&amp; heights[S[top]] == h) top--; <span class=\"comment\">// 若有相同高的柱子，直接出栈</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (top != <span class=\"number\">-1</span>) start=S[top]; <span class=\"comment\">// 避免栈为空</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> start=<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(r &lt; (end-start)*h) r=(end-start)*h; <span class=\"comment\">// 矩形面积是最高柱子位置减去当前栈顶柱子的位置乘高</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            S[++top]=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 此时栈内剩余递增序列，出栈依次计算面积。计算流程同上</span></span><br><span class=\"line\">    end = S[top];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        h = heights[S[top--]];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( top != <span class=\"number\">-1</span> &amp;&amp; heights[S[top]] == h) top--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (top != <span class=\"number\">-1</span>) start=S[top];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> start=<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r &lt; (end-start)*h) r=(end-start)*h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximalRectangle</span><span class=\"params\">(<span class=\"keyword\">char</span>** matrix, <span class=\"keyword\">int</span> matrixSize, <span class=\"keyword\">int</span>* matrixColSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m=matrixSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n=*matrixColSize;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *heights = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>*S=(<span class=\"keyword\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*n); <span class=\"comment\">// 初始化栈，栈内保存柱子序号</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> r=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;=n<span class=\"number\">-1</span>;k++) heights[k]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;=m<span class=\"number\">-1</span>;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;=n<span class=\"number\">-1</span>;j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matrix[i][j]==<span class=\"string\">&#x27;1&#x27;</span>) heights[j]++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> heights[j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> top=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cur=largestRectangleArea(heights,n,S,top);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur &gt; r) r=cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n</details>\n\n<details>\n<summary>StackCreate</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> **data;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">&#125; Stack;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Stack *<span class=\"title\">StackCreate</span><span class=\"params\">(<span class=\"keyword\">int</span> stackSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Stack *<span class=\"built_in\">stack</span> = (Stack *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Stack));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">stack</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;data = (<span class=\"keyword\">void</span> **)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span> **) * (stackSize + <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(<span class=\"built_in\">stack</span>-&gt;data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span> **) * (stackSize + <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>-&gt;size = stackSize;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StackFree</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj-&gt;data != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(obj-&gt;data);</span><br><span class=\"line\">        obj-&gt;data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj);</span><br><span class=\"line\">    obj = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsStackEmpty</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj-&gt;top == <span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsStackFull</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj-&gt;top ==  obj-&gt;size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StackPush</span><span class=\"params\">(Stack *obj, <span class=\"keyword\">void</span> *data)</span>  <span class=\"comment\">// 泛型接口，使用void *</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsStackFull(obj) == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top = obj-&gt;top;</span><br><span class=\"line\">    obj-&gt;data[++top] = data;</span><br><span class=\"line\">    obj-&gt;top = top;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StackPop</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsStackEmpty(obj) == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *data = obj-&gt;data[obj-&gt;top];</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(data);</span><br><span class=\"line\">    data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    obj-&gt;top--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">StackTop</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsStackEmpty(obj) == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj-&gt;data[obj-&gt;top]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StackClear</span><span class=\"params\">(Stack *obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IsStackEmpty(obj) == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= obj-&gt;top; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *data = obj-&gt;data[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(data);</span><br><span class=\"line\">            data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    obj-&gt;top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximalRectangle</span><span class=\"params\">(<span class=\"keyword\">char</span> **matrix, <span class=\"keyword\">int</span> matrixSize, <span class=\"keyword\">int</span> *matrixColSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> **height = (<span class=\"keyword\">int</span> **)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span> *) * matrixSize);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrixSize; i++) &#123;</span><br><span class=\"line\">        height[i] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * (matrixColSize[i] + <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; matrixColSize[i]; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                height[i][j] = (matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                height[i][j] = (matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) ? (height[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>) : <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        height[i][matrixColSize[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Stack *monotoneStack = StackCreate(matrixSize * matrixSize);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; matrixSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= matrixColSize[i]; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((IsStackEmpty(monotoneStack) != <span class=\"literal\">true</span>) &amp;&amp; </span><br><span class=\"line\">                    (height[i][*(<span class=\"keyword\">int</span> *)monotoneStack-&gt;data[monotoneStack-&gt;top]] &gt;= height[i][j])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> h = height[i][*(<span class=\"keyword\">int</span> *)monotoneStack-&gt;data[monotoneStack-&gt;top]];</span><br><span class=\"line\">                StackPop(monotoneStack);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> sidx = ((IsStackEmpty(monotoneStack) == <span class=\"literal\">true</span>) ? <span class=\"number\">-1</span> : *(<span class=\"keyword\">int</span> *)(monotoneStack-&gt;data[monotoneStack-&gt;top]));</span><br><span class=\"line\">                ans = MAX(ans, h * (j - sidx - <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> *node = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">            *node = j;</span><br><span class=\"line\">            StackPush(monotoneStack, node); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StackClear(monotoneStack);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    StackFree(monotoneStack);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<br>\n<br>\n\n<p>85 Maximal Reactangle<br>leetcode 496、503、739、239<br><br><br>42.接雨水</p>\n<br>\n\n<ul>\n<li>参考链接：<br><a href=\"https://blog.csdn.net/chongbin007/article/details/112741867?utm_term=%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97leetcode\">leetcode算法总结 ——单调栈&amp;单调队列</a></li>\n</ul>\n<h2 id=\"2-并查集\"><a href=\"#2-并查集\" class=\"headerlink\" title=\"2.并查集\"></a>2.并查集</h2><h3 id=\"2-1-并查集介绍\"><a href=\"#2-1-并查集介绍\" class=\"headerlink\" title=\"2.1 并查集介绍\"></a>2.1 并查集介绍</h3><p>&ensp;并查集(DSU)主要用于解决一些元素分组的问题，管理一系列不相交的集合，并支持两种操作：<br>&ensp;并查集即<strong>合并集合</strong>和<strong>查找集合中元素</strong>两种操作的算法.但实际并查集的基本操作有三个:<br>&emsp;makeSet(size):建立一个新的并查集,其中包含size个单元素集合.<br>&emsp;unionSet(x, y)<strong>合并</strong>:把元素x和元素y所在的集合合并,要求x和y所在的集合不相交,如果相交则不合并.<br>&emsp;find(x)<strong>查询</strong>:找到元素x所在的集合的代表,该操作也可以用于判断两个元素是否位于同一个集合,只要将它们各自的代表比较一下就可以了. find(x)有两种实现方法,一种是递归,一种是非递归。</p>\n<p>&ensp;并查集的重要思想在于，用集合中的一个元素代表集合。</p>\n<p>&emsp;<strong>算法:</strong><br>&emsp;&emsp;用集合中的某个元素来代表这个集合,该元素称为集合的代表元.一个集合内的所有元素组织成以代表元为根的树形结构.对应每一个元素x来说,parent[x]指向x在树形结构上的父节点,如果x是根节点,则灵parent[x] = x. 对于查找操作,假设需要确定x所在的集合,也就是确定集合的代表元.可以沿着parent[x]不断在树形结构中向上移动,直到到达根节点.<br>&emsp;因为创建的树可能会严重不平衡,并查集可以用两种优化策略:<br>&emsp;1.按秩序合并<br>&emsp;&emsp;即总将更小的树连接至更大的树上,<br>&emsp;2.<strong>路径压缩</strong><br>&emsp;&emsp;为了加快查找速度,查找时将x到根节点路径上的所有点的parent设为根节点,该优化方法称为路径压缩.</p>\n<p>&emsp;算法用途:<br>&emsp;&ensp;1.维护无向图的连通性,支持判断两个点是否在同一连通块内,和.<br>&emsp;&ensp;2.判断增加一条边是否会产生环:用在求解最小生成树Kruskal算法里<br>&emsp;并查集时统计图中连通块数量的一种方法.使用一个大小为N的parent数组,遍历这个图,每个节点都遍历所有相邻点,并让相邻点指向它,并设置成一个有parent节点决定的单独组.这个过程被称为union.这样每个组都有一个唯一的parent节点,这些节点的父节点为-1.</p>\n<p>合并的比较方法<br>应当将简单的树向复杂的树上合并，从而使合并后到根节点距离变长的节点个数比较少。</p>\n<p>并查集的时间复杂度<br>查询次数+合并次数 N或以上则平均下来单次查询或合并的平均时间复杂度O(1)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> pre[<span class=\"number\">1010</span>]; <span class=\"comment\">// 存放第i个元素的父节点</span></span><br><span class=\"line\"><span class=\"comment\">// 查询根节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">unionsearch</span><span class=\"params\">(<span class=\"keyword\">int</span> root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> son, tmp;</span><br><span class=\"line\">    son = root;</span><br><span class=\"line\">    <span class=\"comment\">// 寻找根节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (root != pre[root]) &#123;</span><br><span class=\"line\">        root = pre[root]; <span class=\"comment\">// 路径压缩</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (son != root) &#123;</span><br><span class=\"line\">        tmp = pre[son];</span><br><span class=\"line\">        pre[son] = root;</span><br><span class=\"line\">        son = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">(<span class=\"keyword\">int</span> root1, <span class=\"keyword\">int</span> root2)</span> <span class=\"comment\">// 判断释放连通,不连通就合并</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    x = unionsearch(root1);</span><br><span class=\"line\">    y = unionsearch(root2);</span><br><span class=\"line\">    <span class=\"comment\">// 如果不连通,就把它们所在的连通分支合并</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x != y) &#123;</span><br><span class=\"line\">        pre[x] = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://blog.csdn.net/qq_41593390/article/details/81146850\">https://blog.csdn.net/qq_41593390/article/details/81146850</a></p>\n<p><a href=\"https://blog.csdn.net/ziachen/article/details/106315471\">https://blog.csdn.net/ziachen/article/details/106315471</a></p>\n<p>朋友圈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> **matrix, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *parent = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*size);</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(parent, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*size);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rows = size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> clos = matrix[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cols; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">1</span> &amp;&amp; i != j) &#123;</span><br><span class=\"line\">                <span class=\"class\"><span class=\"keyword\">union</span>(<span class=\"title\">parent</span>, <span class=\"title\">i</span>, <span class=\"title\">j</span>);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> countCircleNum(parent, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> *parent, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> xset = find(parent, i);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> yset = find(parent, j);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xset != yset) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 合并i和j的两个集合</span></span><br><span class=\"line\">        parent[xset] = yset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> 查找集合 i 的源头</span></span><br><span class=\"line\"><span class=\"comment\"> 如果集合 i 的父亲是 -1, 说明自己就是源头,返回自己的标号</span></span><br><span class=\"line\"><span class=\"comment\"> 否则查找集合 i 的父亲的源头</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> *parent, <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent[i] == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// i 的父亲为 -1 时,i就是掌门人</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用路径压缩,让这条路径上所有的人的上级直接变为掌门人</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> find(parent, parent[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> *parent, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent[i] == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// find 非递归实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x != parent[x]) &#123;</span><br><span class=\"line\">        parent[x] = parent[parent[x]];</span><br><span class=\"line\">        x = parent[x];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;DFS实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> **matrix, <span class=\"keyword\">int</span> matrixSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rows = matrixSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cols = matrix[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *visited = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * matrixSize);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[i] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            dfs(matrix, matrixSize, visite, i);</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> **matrix,  <span class=\"keyword\">int</span> matrixSize, <span class=\"keyword\">int</span> *visited, <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; matrixSize; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">1</span> &amp;&amp; visited[j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            visited[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(matrxi, matrixSize, visited, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;BFS实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> **matrix, <span class=\"keyword\">int</span> length)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* visited = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*length);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>题目背景<br>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。<br>题目描述<br>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。<br>输入格式<br>第一行：三个整数n,m,p，（n&lt;=5000,m&lt;=5000,p&lt;=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。<br>以下m行：每行两个数Mi，Mj，1&lt;=Mi，Mj&lt;=N，表示Mi和Mj具有亲戚关系。<br>接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。<br>输出格式<br>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 5005</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> fa[MAXN], rank[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        fa[i] = i;</span><br><span class=\"line\">        rank[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = find(i), y = find(j);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rank[x] &lt;= rank[y]) &#123;</span><br><span class=\"line\">        fa[x] = y;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        fa[y] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rank[x] == rank[y] &amp;&amp; x != y) &#123;</span><br><span class=\"line\">        rank[y]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, p, x, y;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class=\"line\">    init(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">        merge(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; p; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, find(x) == find(y) ? <span class=\"string\">&quot;Yes&quot;</span> : <span class=\"string\">&quot;No&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-2-Leetcode题目-547-省份数量\"><a href=\"#2-2-Leetcode题目-547-省份数量\" class=\"headerlink\" title=\"2.2 Leetcode题目:547.省份数量\"></a>2.2 Leetcode题目:<a href=\"https://leetcode-cn.com/problems/number-of-provinces/\">547.省份数量</a></h3><p>&ensp;有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>\n<p>&ensp;省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>\n<p>&ensp;给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p>\n<p>返回矩阵中 省份 的数量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *g_test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> mSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mSize &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    g_dest = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(mSize * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g_dest == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    fot (i = <span class=\"number\">0</span>; i &lt; mSize; i++) &#123;</span><br><span class=\"line\">        g_dest[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g_dest[index] == index) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> g_dest[index] = Find(g_dest[index]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FindRoot</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (g_dest[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        i = g_dest[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ProcCircle</span><span class=\"params\">(<span class=\"keyword\">int</span> **m, <span class=\"keyword\">int</span> mSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rootI, rootJ;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; mSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = (i + <span class=\"number\">1</span>); j &lt; mSize; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m[i][j] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            rootI = FindRoot(i);</span><br><span class=\"line\">            rootJ = FindRoot(j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rootI == rootJ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            g_dest[rootI] = rootJ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> mSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mSize; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g_dest[i] == i) &#123;</span><br><span class=\"line\">            sum++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FreeCircle</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g_dest != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(g_dest);</span><br><span class=\"line\">        g_dest = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(<span class=\"keyword\">int</span> **m, <span class=\"keyword\">int</span> mSize, <span class=\"keyword\">int</span>* mColSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> rslt;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">    rslt = Init(mSize);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!rslt) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ProcCicle(m, mSize);</span><br><span class=\"line\">    sum = GetCircleNum(mSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    FreeCircle();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"2-3-最小生成树\"><a href=\"#2-3-最小生成树\" class=\"headerlink\" title=\"2.3 最小生成树\"></a>2.3 最小生成树</h3><p>&ensp;关于图的几个概念定义:<br>连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。<br>强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。<br>连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。<br>生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。<br>最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p>\n<ul>\n<li>参考链接:<a href=\"https://blog.csdn.net/luoshixian099/article/details/51908175\">https://blog.csdn.net/luoshixian099/article/details/51908175</a></li>\n</ul>\n<h2 id=\"3-滑动窗口-amp-双指针\"><a href=\"#3-滑动窗口-amp-双指针\" class=\"headerlink\" title=\"3.滑动窗口&amp;双指针\"></a>3.滑动窗口&amp;双指针</h2><h3 id=\"3-1-滑动窗口描述\"><a href=\"#3-1-滑动窗口描述\" class=\"headerlink\" title=\"3.1 滑动窗口描述\"></a>3.1 滑动窗口描述</h3><p>&ensp;滑动窗口法，也叫尺取法（可能也不一定相等，大概就是这样 =。=），可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。</p>\n<p>&ensp;滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。其实这里就可以看出来滑动窗口主要应用在数组和字符串上。</p>\n<p>&emsp; 滑动：说明这个窗口是移动的，也就是移动是按照一定方向来的。</p>\n<p>&emsp; 窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。</p>\n<p>&ensp; 滑动窗口是双指针的一种应用，形象点说就是维护一个窗口，在窗口滑动的过程中进行窗口内数据的更新，并判断是否符合答案。、<br>初始时两个指针均指向开头，然后右指针依次向右滑动，在滑动的过程中需要收缩的时候进行左指针的移动，当右指针移出的时候结束循环即可。<br>&ensp; TCP协议使用滑动窗口实现.</p>\n<h3 id=\"3-2-Leetcode题目\"><a href=\"#3-2-Leetcode题目\" class=\"headerlink\" title=\"3.2 Leetcode题目\"></a>3.2 Leetcode题目</h3><p>1208.进可能使字符串相等</p>\n<p>Leetcode 209. 长度最小的子数组<br>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> t)</span></span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; need,window;</span><br><span class=\"line\">     <span class=\"comment\">//在need中记录相应的信息</span></span><br><span class=\"line\">      .....</span><br><span class=\"line\">      <span class=\"keyword\">int</span> left=<span class=\"number\">0</span>,right=<span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> valid;<span class=\"comment\">//该变量用来判断是否得到相应的答案了</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">while</span>(right&lt;s.size()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">char</span> c=s[right];<span class=\"comment\">//取出将要移入窗口内的数据</span></span><br><span class=\"line\">         right++；</span><br><span class=\"line\">         <span class=\"comment\">//下面进行窗口更新后一些数据的更新</span></span><br><span class=\"line\">         .....</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">while</span>(判断窗口是否需要收缩) &#123;</span><br><span class=\"line\">              <span class=\"comment\">//是否需要进行相应的答案更新</span></span><br><span class=\"line\">              ......</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">char</span> d=s[left];<span class=\"comment\">//将要移出窗口的数据；</span></span><br><span class=\"line\">              left++;<span class=\"comment\">//收缩窗口</span></span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">//窗口收缩后相应数据的更新</span></span><br><span class=\"line\">              .......           </span><br><span class=\"line\">         &#125;   </span><br><span class=\"line\">      &#125;      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>示例: </p>\n<p>输入: s = 7, nums = [2,3,1,2,4,3]<br>输出: 2<br>解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</p>\n<ul>\n<li>参考链接:<br><a href=\"https://zhuanlan.zhihu.com/p/61564531\">https://zhuanlan.zhihu.com/p/61564531</a></li>\n</ul>\n<h3 id=\"3-3-单调队列\"><a href=\"#3-3-单调队列\" class=\"headerlink\" title=\"3.3 单调队列\"></a>3.3 单调队列</h3><p>&emsp;单调队列是指：队列中的元素之间的关系具有单调性，而且，队首和队尾都可以进行出队操作，只有队尾开源进行入队操作。<br>&emsp;单调队列与单调栈及其相似，把单调栈先进后出的性质改为先进先出既可。<br>元素进队列的过程对于单调递增队列。<br>对于一个元素a，如果a&gt;队尾元素，那么直接将a扔进队列，如果a&lt;=队尾元素，则将队尾元素出队列，直到满足 a&gt;队尾元素即可。</p>\n<blockquote>\n<p>单调递增队列(从队首到队尾满足递增)<br>单调递减队列(从队首到队尾满足递减)</p>\n</blockquote>\n<ul>\n<li><p>单调队列作用：队列里的元素满足出队的单调性。</p>\n</li>\n<li><p>单调队列操作：去头和删尾</p>\n</li>\n<li><p>leetcode 题目<br><a href=\"https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/\">剑指 Offer 59 - II. 队列的最大值</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[<span class=\"number\">20000</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">&#125; MaxQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MaxQueue* <span class=\"title\">maxQueueCreate</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    MaxQueue *tmp = (MaxQueue*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(MaxQueue));</span><br><span class=\"line\">    tmp-&gt;begin = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;end = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxQueueMax_value</span><span class=\"params\">(MaxQueue* obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = obj-&gt;begin; i &lt; obj-&gt;end; i++) &#123;</span><br><span class=\"line\">        ans = fmax(ans, obj-&gt;arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maxQueuPus_back</span><span class=\"params\">(MaxQueue* obj, <span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    obj-&gt;arr[obj-&gt;end++] = value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxQueuePop_front</span><span class=\"params\">(MaxQueue* obj)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obj-&gt;begin==obj-&gt;end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj-&gt;arr[obj-&gt;begin++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maxQueueFree</span><span class=\"params\">(MaxQueue* obj)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    obj-&gt;end=<span class=\"number\">0</span>;</span><br><span class=\"line\">    obj-&gt;begin=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>239.滑动窗口最大值</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> Size=<span class=\"number\">1000005</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[Size],qmax[Size],qmin[Size],savemax[Size],savemin[Size];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,k,cnt=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;a[i]);&#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beg=<span class=\"number\">1</span>,top=<span class=\"number\">0</span>;<span class=\"comment\">//qmax队列的队首指针和队尾指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> st=<span class=\"number\">1</span>,ed=<span class=\"number\">0</span>;<span class=\"comment\">//qmin队列的队首指针和队尾指针</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(beg&lt;=top&amp;&amp;a[i]&gt;=a[qmax[top]])</span><br><span class=\"line\">        &#123;top--;&#125;</span><br><span class=\"line\">        qmax[++top]=i;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(st&lt;=ed&amp;&amp;a[i]&lt;=a[qmin[ed]])</span><br><span class=\"line\">        &#123;ed--;&#125;</span><br><span class=\"line\">        qmin[++ed]=i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(qmax[beg]&lt;=i-k)beg++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(qmin[st]&lt;=i-k)st++;</span><br><span class=\"line\">            savemax[cnt]=a[qmax[beg]];</span><br><span class=\"line\">            savemin[cnt]=a[qmin[st]];</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt; cnt;i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,savemin[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt; cnt;i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,savemax[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参考链接：<br><a href=\"https://www.cnblogs.com/zzcxxoo/p/13216030.html\">https://www.cnblogs.com/zzcxxoo/p/13216030.html</a></li>\n</ul>\n<br>\n\n<h2 id=\"4-前缀和-amp-哈希表优化\"><a href=\"#4-前缀和-amp-哈希表优化\" class=\"headerlink\" title=\"4.前缀和(&amp;哈希表优化)\"></a>4.前缀和(&amp;哈希表优化)</h2><h3 id=\"4-1-前缀和介绍\"><a href=\"#4-1-前缀和介绍\" class=\"headerlink\" title=\"4.1 前缀和介绍\"></a>4.1 前缀和介绍</h3><p>&ensp;前缀和(prefix sum)定义:前缀和时一种预处理,能大大降低查询的时间复杂度.结合Hash缓存,能够进一步优化提升算法执行效率.<br>&emsp;对数组nums进行前缀和初始化需要O(n)时间<br>&emsp;新建数组prefixSum,数组长度定义为 nums.length+1,确保顶第 nums.length个元素存储前面0到nums.length-1个元素的和.将数组nums的累加一层放入数组prefixSum中.<br>&emsp;变换公式:<br>&ensp;&emsp;1)nums[某一项] = 两个相邻前缀和之差: nums[i] = prefixSum[x] - prefixSum[x-1]<br>&ensp;&emsp;2)从left到right的元素和等于: prefixSum[right+1] - prefixSum[left]</p>\n<p>假设我们有一个字符串ABCDE，什么是这个单词的前缀，A、AB、ABC、ABCD、ABCDE就是这个单词的前缀，就是从第一个字母开始，依次往后拼接。E、ED、EDC、EDCB、EDCBA被称为这个单词的后缀。</p>\n<p>那么对于一个数组的前缀，例如数组a = [1,2,3,4,5]，我们维护一个由前缀的和组成的数组sum，sum[i]表示数组中a[0]~ a[i] 的和。<br>sum[0] = a[0]<br>sum[1] = a[0] + a[1]<br>sum[2] = a[0] + a[1] + a[2]<br>sum[3] = a[0] + a[1] + a[2] + a[3]<br>sum[4] = a[0] + a[1] + a[2] + a[3] + a[4]<br>sum数组就被称为前缀和数组。</p>\n<p>前缀和的作用<br>前缀和的最主要目的就是求子数组的和的大小。例如元素a[1]到a[3]的和。<br>a[1] + a[2] + a[3] = sum[3] - sum[0]</p>\n<p>&emsp;前缀和数组初始化过程伪代码:<br>&emsp;&emsp;1.安装for寻的政策边界进行初始化,避免了 int i=1 或者 &lt;=len 等肯的各种调整.<br>&emsp;&emsp;2.前缀和长度比数据长度多一个,前缀和第0个元素要初始化为0<br>&emsp;&emsp;另外一种前缀和初始化方法:前缀和长度为nums.length,第0个元素存储自己的和.<br>&emsp;&emsp;prefixSum[i] - prefixSum[i-1] 容易出现错误理解和技术丢失.示例:prefixSum[0] = num[1],造成nums[0]丢失.</p>\n<ul>\n<li>参考链接:<br><a href=\"https://blog.csdn.net/fgy_u/article/details/109349710\">https://blog.csdn.net/fgy_u/article/details/109349710</a><br><a href=\"https://www.jianshu.com/p/3021429f38d4\">https://www.jianshu.com/p/3021429f38d4</a></li>\n</ul>\n<br>\n\n<h2 id=\"5-差分\"><a href=\"#5-差分\" class=\"headerlink\" title=\"5.差分\"></a>5.差分</h2><h3 id=\"5-1-差分介绍\"><a href=\"#5-1-差分介绍\" class=\"headerlink\" title=\"5.1 差分介绍\"></a>5.1 差分介绍</h3><p>&emsp;差分时一种和前缀和算法相对 的策略,这种策略是,令 <code>b(i) = a(i) - a(i-1)</code>,即相邻两数的差.在每一个点上记录变化数值,因为有增加有减少通过求和判断是否有超过指定容量的情况发生,超过则代表无法满足要求.</p>\n<p>该算法是前缀和算法的逆运算，可以快速的对数组的某一个区间进行计算。</p>\n<p>&ensp;对于数组array[N]中的某一段进行增减操作,通过差分可在 O(n)时间内完成.如:<br>&ensp;trips = [ [2,1,5], [3,3,7]]<br>&emsp;第一步:更新array[1] = 2, array[2] = -2;<br>&emsp;第二步:更新array[3] = 3, array[7] = -2;<br>&emsp;第三步:进行求和,得到结果array[] = {0, 2, 2, 5, 5, 3, 3, 0}</p>\n<br>\n\n<h2 id=\"6-拓扑排序\"><a href=\"#6-拓扑排序\" class=\"headerlink\" title=\"6.拓扑排序\"></a>6.拓扑排序</h2><p>一、什么是拓扑排序<br>在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>\n<p>每个顶点出现且只出现一次。<br>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。<br>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</p>\n<p>二、拓扑排序的应用<br>拓扑排序通常用来“排序”具有依赖关系的任务。</p>\n<p>比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边<script type=\"math/tex\" id=\"MathJax-Element-1\"> </script>表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</p>\n<p>三、拓扑排序的实现<br>根据上面讲的方法，我们关键是要维护一个入度为0的顶点的集合。<br>图的存储方式有两种：邻接矩阵和邻接表。这里我们采用邻接表来存储图，C++代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/************************类声明************************/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> V;             <span class=\"comment\">// 顶点个数</span></span><br><span class=\"line\">    list&lt;<span class=\"keyword\">int</span>&gt; *adj;    <span class=\"comment\">// 邻接表</span></span><br><span class=\"line\">    queue&lt;<span class=\"keyword\">int</span>&gt; q;      <span class=\"comment\">// 维护一个入度为0的顶点的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>* indegree;     <span class=\"comment\">// 记录每个顶点的入度</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Graph</span>(<span class=\"keyword\">int</span> V);                   <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">Graph</span>();                       <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span>;     <span class=\"comment\">// 添加边</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">topological_sort</span><span class=\"params\">()</span></span>;        <span class=\"comment\">// 拓扑排序</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/************************类定义************************/</span></span><br><span class=\"line\">Graph::<span class=\"built_in\">Graph</span>(<span class=\"keyword\">int</span> V)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;V = V;</span><br><span class=\"line\">    adj = <span class=\"keyword\">new</span> list&lt;<span class=\"keyword\">int</span>&gt;[V];</span><br><span class=\"line\"></span><br><span class=\"line\">    indegree = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[V];  <span class=\"comment\">// 入度全部初始化为0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;V; ++i)</span><br><span class=\"line\">        indegree[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Graph::~<span class=\"built_in\">Graph</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> [] adj;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> [] indegree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Graph::addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    adj[v].<span class=\"built_in\">push_back</span>(w); </span><br><span class=\"line\">    ++indegree[w];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Graph::topological_sort</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;V; ++i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(indegree[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>(i);         <span class=\"comment\">// 将所有入度为0的顶点入队</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;             <span class=\"comment\">// 计数，记录当前已经输出的顶点数 </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = q.<span class=\"built_in\">front</span>();      <span class=\"comment\">// 从队列中取出一个顶点</span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        cout &lt;&lt; v &lt;&lt; <span class=\"string\">&quot; &quot;</span>;      <span class=\"comment\">// 输出该顶点</span></span><br><span class=\"line\">        ++count;</span><br><span class=\"line\">        <span class=\"comment\">// 将所有v指向的顶点的入度减1，并将入度减为0的顶点入栈</span></span><br><span class=\"line\">        list&lt;<span class=\"keyword\">int</span>&gt;::iterator beg = adj[v].<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( ; beg!=adj[v].<span class=\"built_in\">end</span>(); ++beg)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!(--indegree[*beg]))</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(*beg);   <span class=\"comment\">// 若入度为0，则入栈</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count &lt; V)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;           <span class=\"comment\">// 没有输出全部顶点，有向图中有回路</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;            <span class=\"comment\">// 拓扑排序成功</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;   <span class=\"comment\">// 创建图</span></span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    g.<span class=\"built_in\">addEdge</span>(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    g.<span class=\"built_in\">topological_sort</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果是 4, 5, 2, 0, 3, 1。这是该图的拓扑排序序列之一。</p>\n<p>每次在入度为0的集合中取顶点，并没有特殊的取出规则，随机取出也行，这里使用的queue。取顶点的顺序不同会得到不同的拓扑排序序列，当然前提是该图存在多个拓扑排序序列。</p>\n<p>由于输出每个顶点的同时还要删除以它为起点的边，故上述拓扑排序的时间复杂度为O(V+E)O(V+E)。</p>\n<ul>\n<li>参考链接:<br><a href=\"https://blog.csdn.net/lisonglisonglisong/article/details/45543451\">https://blog.csdn.net/lisonglisonglisong/article/details/45543451</a></li>\n</ul>\n<br>\n\n<h2 id=\"7-字符串\"><a href=\"#7-字符串\" class=\"headerlink\" title=\"7.字符串\"></a>7.字符串</h2><p>字符串介绍<br>&emsp;字符串可以涉及非常多的考点:如递归,栈,hash,dfs,bfs,动态规划等.需要强制记忆的是”字符串的子串”,”字符串的子序列”.难度比较大的是”子序列”问题.对于任何字符串,可通过删除其中一些字符(也可不删)来构造该字符串的子序列.对于任何字符串,选择任意连续的1到N个字符,形成[i,j]形式的子串,然后利用字符串的子串进行相关的匹配和计算.</p>\n<h3 id=\"leetcode题目\"><a href=\"#leetcode题目\" class=\"headerlink\" title=\"leetcode题目\"></a>leetcode题目</h3><ul>\n<li>93 复原IP地址</li>\n<li>43.字符串相乘</li>\n<li>227.基本计算器II</li>\n</ul>\n<p>&ensp;给出一个表达式，计算结果，就是典型的计算器类型问题，即栈的经典应用。<br>&ensp;栈：添加和删除元素都在队尾进行，先进后出，后进先出，类比于子。。。，入栈和出栈。<br>&ensp;思路：<br>&emsp;将表达式(中缀)转化为后缀<br>&emsp;将后缀计算出结果<br>&emsp;具体规则为：<br>&emsp;&ensp;1.中缀转后缀<br>&emsp;&emsp;数字直接输出到后缀表达式<br>&emsp;&emsp;栈为空时，遇到运算符，直接入栈<br>&emsp;&emsp;遇到运算符，弹出所有优先级大于或等于该运算符的栈顶元素，并将该运算符入栈<br>&emsp;&emsp;将栈中元素依次出栈<br>&emsp;&ensp;2.计算后缀<br>&emsp;&emsp;遇到数字，入栈<br>&emsp;&emsp;遇到运算符，弹出栈顶两个元素，做运算，并将结果入栈<br>&emsp;&emsp;重复上述步骤，直到表达式最右端<br>&emsp;&emsp;</p>\n<br>\n\n<h2 id=\"8-二分查找\"><a href=\"#8-二分查找\" class=\"headerlink\" title=\"8.二分查找\"></a>8.二分查找</h2><p>&ensp;二分查找也称折半查找(Binary Search),它使一种效率较高的查找方法,前提是数据结构必须先排好序.但是,二分查找要求线性表具有随机访问的特点(如数组),也要求线性表能够根据中间元素的特点推测它两侧元素的性质,以达到缩减问题规模的效果.<br>&ensp;二分查找问题也是面试中常考问题,虽然它思想简单,但写好二分算法并不容易.</p>\n<h3 id=\"leetcode题目-1\"><a href=\"#leetcode题目-1\" class=\"headerlink\" title=\"leetcode题目\"></a>leetcode题目</h3><ul>\n<li>4.寻找两个有序数组的中位数</li>\n<li>33.搜索选择排序数组</li>\n</ul>\n<br>\n\n<h2 id=\"9-BFS\"><a href=\"#9-BFS\" class=\"headerlink\" title=\"9.BFS\"></a>9.BFS</h2><p>BFS（广度优先搜索） 常用来解决层序遍历,最短路径问题。<br>第一次遍历到目的节点时，所经过的路径是最短路径。<br>几个要点：</p>\n<p>只能用来求解无权图的最短路径问题<br>队</p>\n<p>列：用来存储每一层遍历得到的节点<br>标记：对于遍历过的结点，应将其标记，以防重复访问</p>\n<p>注:<br>1.广度搜索时候,如果曾经加入过,后续就不用再加入<br>2.加入队列时候,需要标记当前层级,方便后续直接返回目标解.</p>\n<ul>\n<li>参考链接:<a href=\"https://zhuanlan.zhihu.com/p/62884729\">https://zhuanlan.zhihu.com/p/62884729</a></li>\n</ul>\n<h3 id=\"leetcode题目-2\"><a href=\"#leetcode题目-2\" class=\"headerlink\" title=\"leetcode题目\"></a>leetcode题目</h3><ul>\n<li>127.单词接龙</li>\n<li>139.单词拆分</li>\n<li>130.被包围的区域</li>\n<li>317.离建筑物最近的距离</li>\n<li>505.迷宫II</li>\n<li>529.扫雷游戏</li>\n<li>1263.推箱子</li>\n<li>1197.进击的骑士</li>\n<li>815.公交路线</li>\n<li>934.最短的桥</li>\n</ul>\n<br>\n\n<h2 id=\"10-DFS\"><a href=\"#10-DFS\" class=\"headerlink\" title=\"10.DFS\"></a>10.DFS</h2><p>&ensp;深度优先搜索算法(DFS):是一种用于遍历或搜索树或图的算法.利用深度优先搜索算法可产生目标图的拓扑排序表,拓扑排序可用于无权最长路径问题等.DFS实质是一种枚举,不过借助递归实现.<br>&emsp;回溯搜索时深度优先搜索(DFS)的一种.对于某一个搜索树来说(搜索树时起记录路径和状态判断的作用),回溯和DFS,其主要的区别是,回溯法在求解过程中不保留完整的树结构,而深度优先搜索则记下完整的搜索树.回溯就是通过不同的尝试来生成问题的解,类似于穷举,但和穷举不同的时回溯会”减枝”.为了减少存储空间,在深度优先搜索中,用标志的方法记录访问过的状态,这种处理方法使得深度优先搜索法与回溯法没什么区别.<br>&emsp;DFS相对于BFS更方便写,空间复杂度更低<br>&emsp;DFS基本模式:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> step)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断边界</span></span><br><span class=\"line\">    ...;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试每一种可能</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; j &lt;= n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 继续下一步</span></span><br><span class=\"line\">        dfs(step + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回</span></span><br><span class=\"line\">    ...;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(root.left);</span><br><span class=\"line\">    dfs(root.right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;回溯的一般结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(<span class=\"keyword\">int</span> 当前状态)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (当前状态为边界状态) &#123;</span><br><span class=\"line\">        记录或输出</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 横向遍历解答树所有子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 扩展出一个子状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 修改了全局变量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (子状态满足约束条件) &#123;</span><br><span class=\"line\">            backtrack(子状态)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 恢复全局变量//回溯部分</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&emsp;回溯代码框架:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = &#123;&#125;</span><br><span class=\"line\">def backtrack(路径, 选择列表)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> 满足结束条件</span><br><span class=\"line\">        result.add(路径)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> 选择 in 选择列表</span><br><span class=\"line\">        做选择</span><br><span class=\"line\">        backtrack(路径,,选择列表)</span><br><span class=\"line\">        撤销选择</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"leetcode题目-3\"><a href=\"#leetcode题目-3\" class=\"headerlink\" title=\"leetcode题目\"></a>leetcode题目</h3><ul>\n<li>1102.得分最高的路径</li>\n<li>685.冗余链接II</li>\n<li>531.孤独像素I</li>\n<li>533.孤独像素II</li>\n<li>332.重新安排行程</li>\n<li>337.打家劫舍III</li>\n<li>113.路线总和II</li>\n</ul>\n<br>\n\n<h2 id=\"11-动态规划\"><a href=\"#11-动态规划\" class=\"headerlink\" title=\"11.动态规划\"></a>11.动态规划</h2><ul>\n<li>参考链接:<br><a href=\"https://blog.csdn.net/qq_37763204/article/details/79394397\">https://blog.csdn.net/qq_37763204/article/details/79394397</a><br><a href=\"https://blog.csdn.net/u013309870/article/details/75193592\">https://blog.csdn.net/u013309870/article/details/75193592</a></li>\n</ul>\n<h3 id=\"leetcode题目-4\"><a href=\"#leetcode题目-4\" class=\"headerlink\" title=\"leetcode题目\"></a>leetcode题目</h3><ul>\n<li>213.打家劫舍II</li>\n<li>1043.</li>\n<li>416</li>\n<li>123</li>\n</ul>\n<br>\n\n<h2 id=\"12-贪心算法\"><a href=\"#12-贪心算法\" class=\"headerlink\" title=\"12.贪心算法\"></a>12.贪心算法</h2><br>\n\n\n<h2 id=\"13-字典树\"><a href=\"#13-字典树\" class=\"headerlink\" title=\"13.字典树\"></a>13.字典树</h2><details>\n<summary>tire</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 26    <span class=\"comment\">//26个字母</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SLEN 100   <span class=\"comment\">//节点中存储的字符串长度</span></span></span><br><span class=\"line\"><span class=\"comment\">//Trie结构体定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trie</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trie</span> *<span class=\"title\">next</span>[<span class=\"title\">MAX</span>];</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[SLEN];      <span class=\"comment\">//节点处存储的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> isword;         <span class=\"comment\">//节点处是否为单词</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> val;           <span class=\"comment\">//节点的代表字符</span></span><br><span class=\"line\">&#125; *root;</span><br><span class=\"line\"><span class=\"comment\">//初始化Trie树</span></span><br><span class=\"line\"><span class=\"function\">struct Trie *<span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trie</span> *<span class=\"title\">root</span> =</span> (struct Trie *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct Trie));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root -&gt; next[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    root -&gt; isword = <span class=\"number\">0</span>;</span><br><span class=\"line\">    root -&gt; val = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//按照指定路径path 插入字符串 s</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">char</span> path[], <span class=\"keyword\">char</span> s[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trie</span> *<span class=\"title\">t</span>, *<span class=\"title\">p</span> =</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j, n = <span class=\"built_in\">strlen</span>(path);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p -&gt; next[path[i] - <span class=\"string\">&#x27;a&#x27;</span>] == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            t = (struct Trie *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct Trie));</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; MAX; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                t -&gt; next[j] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                t -&gt; isword = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            t -&gt; val = path[i];</span><br><span class=\"line\">            p -&gt; next[path[i] - <span class=\"string\">&#x27;a&#x27;</span>] = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p = p -&gt; next[path[i] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p -&gt; isword = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(p -&gt; s , s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//按照指定路径 path 查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">char</span> path[], <span class=\"keyword\">int</span> delflag)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trie</span> *<span class=\"title\">p</span> =</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, n = <span class=\"built_in\">strlen</span>(path);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &amp;&amp; path[i])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p -&gt; next[path[i++] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p &amp;&amp; p -&gt; isword)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p -&gt; isword = delflag;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p-&gt;s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//删除整棵Trie树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">del</span><span class=\"params\">(struct Trie *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;next[i])</span><br><span class=\"line\">            del(root-&gt;next[i]);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(root-&gt;next[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</details>\n\n\n\n\n<details>\n<summary>tire</summary>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*------------------Trie Data Structure----------------------------------*/</span></span><br><span class=\"line\"><span class=\"comment\">/*-------------Implimented for search a word in dictionary---------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-----character - 97 used for get the character from the ASCII value-----*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ALPHABET_SIZE 26</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--Node in the Trie--*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TrieNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TrieNode</span> *<span class=\"title\">children</span>[<span class=\"title\">ALPHABET_SIZE</span>];</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> character;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isEndOfWord;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; TrieNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--Create new node--*/</span></span><br><span class=\"line\"><span class=\"function\">TrieNode *<span class=\"title\">createTrieNode</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TrieNode *node;</span><br><span class=\"line\">    node = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TrieNode));</span><br><span class=\"line\">    node-&gt;isEndOfWord = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; ALPHABET_SIZE) &#123;</span><br><span class=\"line\">        node-&gt;children[i] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--Insert new word to Trie--*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(TrieNode *root, <span class=\"keyword\">char</span> *word)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*----Addition of the word done by recurcively----*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check wheather word character pointer is NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">strlen</span>(word) - <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> character = *word;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;children[character - <span class=\"number\">97</span>] == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            TrieNode *node = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            node = createTrieNode();</span><br><span class=\"line\">            node-&gt;character = character;</span><br><span class=\"line\">            root-&gt;children[character - <span class=\"number\">97</span>] = node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        word++;</span><br><span class=\"line\">        insert(root-&gt;children[character - <span class=\"number\">97</span>], word);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        root-&gt;isEndOfWord = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--Search a word in the Trie--*/</span></span><br><span class=\"line\"><span class=\"function\">TrieNode *<span class=\"title\">search</span><span class=\"params\">(TrieNode *root, <span class=\"keyword\">char</span> *word)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TrieNode *temp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*word != <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> character = *word;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;children[character - <span class=\"number\">97</span>] != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            temp = root-&gt;children[character - <span class=\"number\">97</span>];</span><br><span class=\"line\">            word++;</span><br><span class=\"line\">            root = temp;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No possible words!!\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*---Print a word in the array--*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printArray</span><span class=\"params\">(<span class=\"keyword\">char</span> chars[], <span class=\"keyword\">int</span> len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, chars[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*---Return all the related words------*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printPathsRecur</span><span class=\"params\">(TrieNode *node, <span class=\"keyword\">char</span> prefix[], <span class=\"keyword\">int</span> filledLen)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    prefix[filledLen] = node-&gt;character;</span><br><span class=\"line\">    filledLen++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;isEndOfWord) &#123;</span><br><span class=\"line\">        printArray(prefix, filledLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class=\"line\">        printPathsRecur(node-&gt;children[i], prefix, filledLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--Travel through the Trie and return words from it--*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">traverse</span><span class=\"params\">(<span class=\"keyword\">char</span> prefix[], TrieNode *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TrieNode *temp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    temp = search(root, prefix);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (prefix[j] != <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printPathsRecur(temp, prefix, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*------Demonstrate purposes uses text file called dictionary -------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NUMBER_OF_WORDS (354935)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INPUT_WORD_SIZE (100)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*----Get input from the user------*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">receiveInput</span><span class=\"params\">(<span class=\"keyword\">char</span> *s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%99s&quot;</span>, s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read the file dictionary</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> word_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *words[NUMBER_OF_WORDS];</span><br><span class=\"line\">    FILE *fp = fopen(<span class=\"string\">&quot;dictionary.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fp == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Error while opening dictionary file&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    words[word_count] = <span class=\"built_in\">malloc</span>(INPUT_WORD_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fgets(words[word_count], INPUT_WORD_SIZE, fp)) &#123;</span><br><span class=\"line\">        word_count++;</span><br><span class=\"line\">        words[word_count] = <span class=\"built_in\">malloc</span>(INPUT_WORD_SIZE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Push the words in to Trie</span></span><br><span class=\"line\">    TrieNode *root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    root = createTrieNode();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NUMBER_OF_WORDS; i++) &#123;</span><br><span class=\"line\">        insert(root, words[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enter keyword: &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> str[<span class=\"number\">100</span>];</span><br><span class=\"line\">        receiveInput(str);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;\\n==========================================================\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n********************* Possible Words ********************\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Find the word through the Trie</span></span><br><span class=\"line\">        traverse(str, root);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;\\n==========================================================\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n\n<ul>\n<li>参考链接：<br>简单易懂的字典树<a href=\"https://zhuanlan.zhihu.com/p/143975546\">https://zhuanlan.zhihu.com/p/143975546</a><br>字典树 (Trie)<a href=\"https://oi-wiki.org/string/trie/\">https://oi-wiki.org/string/trie/</a><br>字典树(Trie)<a href=\"https://www.jianshu.com/p/e431bd41d676\">https://www.jianshu.com/p/e431bd41d676</a><br><a href=\"https://blog.csdn.net/weixin_39778570/article/details/81990417\">https://blog.csdn.net/weixin_39778570/article/details/81990417</a><br><a href=\"https://github.com/TheAlgorithms/C/blob/master/data_structures/trie/trie.c\">Trie</a></li>\n</ul>\n<h3 id=\"bitmap\"><a href=\"#bitmap\" class=\"headerlink\" title=\"bitmap\"></a>bitmap</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TYPE int</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INT_BITS (1&lt;&lt;3) * sizeof(TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SHIFT (int)(log(INT_BITS)/log(2))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MASK INT_BITS-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">TYPE bitmap[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 是否存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">containBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 得到当前位置的第几位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;int_bits = %d, shift = %d, mask = %d\\n&quot;</span>, INT_BITS, SHIFT, MASK);</span><br><span class=\"line\">\tsetBit(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;是否存在%d\\n&quot;</span>, containBit(<span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;是否存在%d\\n&quot;</span>, containBit(<span class=\"number\">3</span>));</span><br><span class=\"line\">\tdeleteBit(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;是否存在%d\\n&quot;</span>, containBit(<span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;是否存在%d\\n&quot;</span>, containBit(<span class=\"number\">3</span>));</span><br><span class=\"line\">\tsetBit(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;是否存在%d\\n&quot;</span>, containBit(<span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;是否存在%d\\n&quot;</span>, containBit(<span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;2在当前的位置%d\\n&quot;</span>, getBit(<span class=\"number\">2</span>));</span><br><span class=\"line\">\tsetBit(<span class=\"number\">32</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;32在当前的位置%d\\n&quot;</span>, getBit(<span class=\"number\">32</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\t bitmap[num &gt;&gt; SHIFT] |= <span class=\"number\">1</span> &lt;&lt; (num &amp; MASK);</span><br><span class=\"line\">\t <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;set --[%d]: %d\\n&quot;</span>, num &gt;&gt; SHIFT, bitmap[num &gt;&gt; SHIFT]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">containBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (bitmap[num &gt;&gt; SHIFT] &amp; <span class=\"number\">1</span> &lt;&lt; (num &amp;MASK)) ==  <span class=\"number\">1</span> &lt;&lt; (num &amp;MASK);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num &amp; MASK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteBit</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\tbitmap[num &gt;&gt; SHIFT] &amp;= ~(<span class=\"number\">1</span> &lt;&lt; (num &amp; MASK));</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;del -- [%d] : %d\\n&quot;</span>, num &gt;&gt; SHIFT, bitmap[num &gt;&gt; SHIFT]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>参考链接：<br><a href=\"https://www.cnblogs.com/cjsblog/p/11613708.html\">https://www.cnblogs.com/cjsblog/p/11613708.html</a><br><a href=\"https://www.cnblogs.com/chunxia/archive/2013/04/28/3049243.html\">https://www.cnblogs.com/chunxia/archive/2013/04/28/3049243.html</a><br><a href=\"https://zhuanlan.zhihu.com/p/414067305\">https://zhuanlan.zhihu.com/p/414067305</a><br><a href=\"https://ac.nowcoder.com/discuss/292850\">https://ac.nowcoder.com/discuss/292850</a><br><a href=\"https://www.zhihu.com/question/36738189\">https://www.zhihu.com/question/36738189</a><br><a href=\"https://zhuanlan.zhihu.com/p/161036474\">https://zhuanlan.zhihu.com/p/161036474</a></li>\n</ul>"},{"title":"C/C++内存管理","date":"2021-10-06T16:47:53.000Z","updated":"2021-10-06T16:53:53.000Z","_content":"\n## 一、内存\n&emsp;在计算机中，不同应用程序之间的内存是相互独立的，通常情况下不可以相互访问。\n\n<!--more-->\n\n1、内存四区\n从下到上为：代码区、数据区、堆区、栈区。\n栈区：存储临时变量的区域，临时变量包括：局部变量、返回值、参数、返回地址。这些变量超出作用域自动弹出。超出栈大小将会栈溢出。栈从栈顶自上而下，最下端为0x0000。\n堆区：比较大的内存区域，用于动态内存分配，由开放人员申请和释放，在程序结束时未释放，将会右系统自动回收。\n数据区：主要存放全局变量、常量和静态变量；数据区又可以划分为：全局区和静态区。\n代码区：主要纯粹可执行代码。属性为只读的。\n\n## 二、malloc和free\n&emsp;在 C 语言（不是 C++)中，malloc 和 free 是系统提供的函数，成对使用，用于从堆中分配和释放内存。malloc 的全称是 memory allocation 译为“动态内存分配”。\n\n- 参考链接：\nhttps://mp.weixin.qq.com/s/mgJXEnhgvGSY4uwMRzLZeQ","source":"_posts/2021/11/内存.md","raw":"---\ntitle: C/C++内存管理\ndate: 2021-10-07 00:47:53\nupdated: 2021-10-07 00:53:53\ncategories: \n    - tool\ntags: \n    - Computer Science\n    - Another Tag\n---\n\n## 一、内存\n&emsp;在计算机中，不同应用程序之间的内存是相互独立的，通常情况下不可以相互访问。\n\n<!--more-->\n\n1、内存四区\n从下到上为：代码区、数据区、堆区、栈区。\n栈区：存储临时变量的区域，临时变量包括：局部变量、返回值、参数、返回地址。这些变量超出作用域自动弹出。超出栈大小将会栈溢出。栈从栈顶自上而下，最下端为0x0000。\n堆区：比较大的内存区域，用于动态内存分配，由开放人员申请和释放，在程序结束时未释放，将会右系统自动回收。\n数据区：主要存放全局变量、常量和静态变量；数据区又可以划分为：全局区和静态区。\n代码区：主要纯粹可执行代码。属性为只读的。\n\n## 二、malloc和free\n&emsp;在 C 语言（不是 C++)中，malloc 和 free 是系统提供的函数，成对使用，用于从堆中分配和释放内存。malloc 的全称是 memory allocation 译为“动态内存分配”。\n\n- 参考链接：\nhttps://mp.weixin.qq.com/s/mgJXEnhgvGSY4uwMRzLZeQ","slug":"2021/11/内存","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8vv00100guuc7j8chng","content":"<h2 id=\"一、内存\"><a href=\"#一、内存\" class=\"headerlink\" title=\"一、内存\"></a>一、内存</h2><p> 在计算机中，不同应用程序之间的内存是相互独立的，通常情况下不可以相互访问。</p>\n<span id=\"more\"></span>\n\n<p>1、内存四区<br>从下到上为：代码区、数据区、堆区、栈区。<br>栈区：存储临时变量的区域，临时变量包括：局部变量、返回值、参数、返回地址。这些变量超出作用域自动弹出。超出栈大小将会栈溢出。栈从栈顶自上而下，最下端为0x0000。<br>堆区：比较大的内存区域，用于动态内存分配，由开放人员申请和释放，在程序结束时未释放，将会右系统自动回收。<br>数据区：主要存放全局变量、常量和静态变量；数据区又可以划分为：全局区和静态区。<br>代码区：主要纯粹可执行代码。属性为只读的。</p>\n<h2 id=\"二、malloc和free\"><a href=\"#二、malloc和free\" class=\"headerlink\" title=\"二、malloc和free\"></a>二、malloc和free</h2><p> 在 C 语言（不是 C++)中，malloc 和 free 是系统提供的函数，成对使用，用于从堆中分配和释放内存。malloc 的全称是 memory allocation 译为“动态内存分配”。</p>\n<ul>\n<li>参考链接：<br><a href=\"https://mp.weixin.qq.com/s/mgJXEnhgvGSY4uwMRzLZeQ\">https://mp.weixin.qq.com/s/mgJXEnhgvGSY4uwMRzLZeQ</a></li>\n</ul>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"1MVTB59","length":428,"excerpt":"<h2 id=\"一、内存\"><a href=\"#一、内存\" class=\"headerlink\" title=\"一、内存\"></a>一、内存</h2><p> 在计算机中，不同应用程序之间的内存是相互独立的，通常情况下不可以相互访问。</p>","more":"<p>1、内存四区<br>从下到上为：代码区、数据区、堆区、栈区。<br>栈区：存储临时变量的区域，临时变量包括：局部变量、返回值、参数、返回地址。这些变量超出作用域自动弹出。超出栈大小将会栈溢出。栈从栈顶自上而下，最下端为0x0000。<br>堆区：比较大的内存区域，用于动态内存分配，由开放人员申请和释放，在程序结束时未释放，将会右系统自动回收。<br>数据区：主要存放全局变量、常量和静态变量；数据区又可以划分为：全局区和静态区。<br>代码区：主要纯粹可执行代码。属性为只读的。</p>\n<h2 id=\"二、malloc和free\"><a href=\"#二、malloc和free\" class=\"headerlink\" title=\"二、malloc和free\"></a>二、malloc和free</h2><p>&emsp;在 C 语言（不是 C++)中，malloc 和 free 是系统提供的函数，成对使用，用于从堆中分配和释放内存。malloc 的全称是 memory allocation 译为“动态内存分配”。</p>\n<ul>\n<li>参考链接：<br><a href=\"https://mp.weixin.qq.com/s/mgJXEnhgvGSY4uwMRzLZeQ\">https://mp.weixin.qq.com/s/mgJXEnhgvGSY4uwMRzLZeQ</a></li>\n</ul>"},{"title":"CMake","date":"2021-12-06T16:47:53.000Z","updated":"2021-10-26T16:53:53.000Z","_content":"\n\n## 1.camke简述\n&ensp;CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.\n\n<!--more-->\n\n&ensp;CMake工程简单例子\n```sh\ncmake_minimum_required(VERSION 3.12)\nproject(myproj)\nfind_package(Poco REQUIRED COMPONENTS Net Util)\nadd_executable(MyExe)\ntarget_source(MyExe PRIVATE \"main.cpp\")\ntarget_link_library(MyExe PRIVATE Poco::Net PocoUtil)\n\ntarget_complie_definition(MyExe PRIVATE std_cxx_14)\n```\n\n## 2.Target 和围绕 Target 的配置\n&ensp;C/C++工程通常都是为了生成可执行程序或者链接库，在现代 CMake 里他们被统称为`target`，创建命令分别是`add_library()`和`add_executable()`。其中链接库的类型又分为很多种，最常用的就是`SHARED`以及`STATIC`，在命令中加入关键词进行声明：add_library(MyLib SHARED)，第一个参数为target的名称，后续的配置都需要用到这个名字。\n&ensp;指定target的源文件：\n```sh\ntarget_source(MyLib PRVIATE \"main.cpp\" \"func.cpp\")\n```\n&emsp;PRIVATE关键词用于描述参数的“应用范围”，此外还有INTERFACE和PUBLIC两种可能的值\n\n&ensp;较多的源文件，可以使用 CMake 的file命令进行遍历拿到全部的源文件\n```sh\nfile(GLOB_RECURSE SRCS ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)\n```\n&emsp;命令第一个参数GLOB_RECURSE表明递归的查找子文件夹，第二个参数SRCS则是存储结果的变量名，第三个参数为目标文件的匹配模式，找到符合条件的 cpp 文件后，他们的路径会以字符串数组的形式保存在 SRCS 变量中，使用方式如下：\n```sh\ntarget_source(MyLib PRIVATE ${SRCS})\n```\n&ensp;配置target时通常还需要指定头文件目录：\n```sh\ntarget_include_directories(MyLib PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include/)\n```\n&ensp;编译时需要的语言特性：\n```sh\ntarget_compile_features(MyLib PRIVATE std_cxx_14)\n```\n&ensp;编译时的宏定义：\n```sh\ntarget_compile_definitions(MyLib PRIVATE LogLevel=3)\n```\n&ensp;参数想直接传给底层的编译器（比如 gcc, clang, cl），可以使用\n```sh\ntarget_compile_options(MyLib PRIVATE -Werror -Wall -Wextra)\n\n```\n\n## 3.Build Specification 和 Usage Requirement\n\n&ensp;C/C++通过 include 头文件的方式引入依赖，在动态或静态链接后可以调用依赖实现。一个可执行程序可能会依赖链接库，链接库也同样可能依赖其他的链接库\n&ensp;CMake 提供的解决方案是，在对 target 进行配置时，可以规定配置的类型，分为 build specification 和 usage requirement 两类，会影响配置的应用范围。Build specification 类型的配置仅在编译的时候需要满足，通过PRIVATE关键字声明；Usage requirement 类型的配置则是在使用时需要满足，即在其他项目里，使用本项目已编译好的 target 时需要满足，这种类型的配置使用INTERFACE关键词声明。在实际工程中，有很多配置在编译时以及被使用时都需要被满足的，这种配置通过PUBLIC关键词进行声明。\n\n&ensp;一个 library，在编译时静态链接了 Boost，在我们的实现文件中使用了 c++14 的特性，并用到了 Boost 的头文件和函数。随后我们对外发布了这个库，其中有头文件和预编译好的动态链接库。尽管我们的实现代码里用了 C++14，但在对外提供的头文件中只用到 C++03 的语法，也没有引入任何 Boost 的代码。这种情况下，当其他工程在使用我们的 library 时，其使用的编译器不需要开启 C++14 的支持，开发环境下也不需要安装 Boost。我们 library 的 CMake 配置中可以这么写：\n```sh\ntarget_compile_features(MyLib PRIVATE cxx_std_14)\ntarget_link_libraries(MyLib PRIVATE Boost::Format)\n```\n&emsp;PRIVATE 说明 c++14 的支持只在编译时需要用到，Boost 库的链接也仅在编译时需要。但如果我们对外提供的头文件中也使用了 C++14，那么就需要使用 PUBLIC 修饰，改为：\n```sh\ntarget_compile_features(MyLib PUBLIC cxx_std_14)\ntarget_link_libraries(MyLib PRIVATE Boost::Format)\n```\n&emsp;当 library 是 header-only 时，我们的工程是不需要单独编译的，因此也就没有 build specification，通过INTERFACE修饰配置即可\n```sh\narget_compile_features(MyLib INTERFACE cxx_std_14)\n```\n&ensp;Usage requirement 类型的配置，即通过INTERFACE或是PUBLIC修饰的配置是会传递的，比如 LibA 依赖 LibB 后，会继承 LibB 的 usage requirement，此后 LibC 依赖 LibB 时，LibA 和 libB 的 usage requirement 都会继承下来，\n\n## 4.寻找和使用链接库\n\n&ensp;C/C++标准没有规范库的安装位置和安装形式，通过 CMake 提供的方案寻找依赖，不光可以定位到头文件目录和链接库路径，还能够获取到库的 usage requirement。\n&ensp;在 CMake 中寻找第三方库的命令为find_package，其背后的工作方式有两种，一种基于 Config File 的查找，另一种则是基于 Find File 的查找。在执行find_package时，实际上 CMake 都是在找这两类文件，找到后从中获取关于库的信息。\n### 4.1 通过 Config file 找到依赖\n&ensp;Config File 是依赖的开发者提供的 cmake 脚本，通常会随预编译好的二进制一起发布，供下游的使用者使用。在 Config file 里，会对库里包含的 target 进行描述，说明版本信息以及头文件路径、链接库路径、编译选项等 usage requirement\n\n&ensp;CMake 对 Config file 的命名是有规定的，对于find_package(ABC)这样一条命令，CMake 只会去寻找ABCConfig.cmake或是abc-config.cmake。CMake 默认寻找的路径和平台有关，在 Linux 下寻找路径包括/usr/lib/cmake以及/usr/lib/local/cmake，在这两个路径下可以发现大量的 Config File，一般在安装某个库时，其自带的 Config file 会被放到这里来。\n\n### 4.2 通过 Find file 找到依赖\n\n&ensp;对于find_package(ABC)命令，如果 CMake 没有找到 Config file，他还会去试着寻找FindABC.cmake。Find file 在功能上和 Config file 相同，区别在于 Find file 是由其他人编写的，而非库的开发者。如果你使用的某个库没有提供 Config file，你可以去网上搜搜 Find file 或者自己写一个，然后加入到你的 CMake 工程中。\n\n&ensp;CMake 官方为我们写好了很多 Find file，在CMake Documentation这一页面可以看到，OpenGL，OpenMP，SDL 这些知名的库官方都为我们写好了 Find 脚本，因此直接调用 find_package 命令即可。但由于库的安装位置并不是固定的，这些 Find 脚本不一定能找到库，此时根据 CMake 报错的提示设置对应变量即可，通常是需要提供安装路径，这样就可以通过 Find file 获取到库的 usage requirement。不论是 Config file 还是 Find file，其目的都不只是找到库这么简单，而是告诉 CMake 如何使用这个库。\n库 CMake 官方也没有提供 Find file，这时候就要自己写了或者靠搜索了，写好后放到本项目的目录下，修改CMAKE_MODULE_PATH这个 CMAKE 变量：\n```sh\nlist(INSERT CMAKE_MODULE_PATH 0 ${CMAKE_SOURCE_DIR}/cmake)\n```\n&emsp;${CMAKE_SOURCE_DIR}/cmake目录下的 Find file 就可以被 CMake 找到了。\n&ensp;通过 CMake 的find_library和find_path两个命令就可以完成任务：\n```sh\nfind_library(MPI_LIBRARY\n  NAMES mpi\n  HINTS \"${CMAKE_PREFIX_PATH}/lib\" ${MPI_LIB_PATH}\n  # 如果默认路径没找到libmpi.so，还会去MPI_LIB_PATH找，下游使用者可以设置这个变量值\n)\nfind_path(MPI_INCLUDE_DIR\n  NAMES mpi.h\n  PATHS \"${CMAKE_PREFIX_PATH}/include\" ${MPI_INCLUDE_PATH}\n  # 如果默认路径没找到mpi.h，还会去MPI_INCLUDE_PATH找，下游使用者可以设置这个变量值\n)\n```\n\n### 4.3.find_package 的处理\n&ensp;find_package这个命令，这个命令可以指定很多参数，比如指定版本，指定具体的模块等等。以 SFML 多媒体库为例，其包含了 network 模块，audio 模块，graphic 模块等等，但我很多时候只用到 graphic 模块，那么其他的模块对应的链接库不需要被链接，于是 CMake 脚本可以这么写：\n```sh\n# 要求大版本号为2的SFML库的graphic模块\nfind_package(SFML 2 COMPONENTS graphics REQUIRED)\n# SFML提供的target名字为sfml-graphics\ntarget_link_libraries(MyEXE PRIVATE sfml-graphics)\n```\n\n### 5.使用 CMake 来编译\n\n&ensp;CMake 生成好编译环境后，底层的 make, ninja, MSBuild 编译命令都是不一样的，但 CMake 提供了一个统一的方法进行编译：\n```sh\ncmake --build .\n```\n&emsp;使用--buildflag，CMake 就会调用底层的编译命令，在跨平台时十分方便。\n&emsp;对于 Visual Studio，其 Debug 和 Release 环境是基于 configuration 的，因此CMAKE_BUILD_TYPE变量无效，需要在 build 时指定：\n```sh\ncmake --build . --config Release\n```\n\n\n\n\n- 参考链接:\ncmake\nhttps://ukabuer.me/blog/more-modern-cmake/\nMakefile\n","source":"_posts/2021/12/cmake.md","raw":"---\ntitle: CMake\ndate: 2021-12-07 00:47:53\nupdated: 2021-10-27 00:53:53\ncategories: \n    - tool\ntags: \n    - complier\n    - cs\n    - cmake\n---\n\n\n## 1.camke简述\n&ensp;CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.\n\n<!--more-->\n\n&ensp;CMake工程简单例子\n```sh\ncmake_minimum_required(VERSION 3.12)\nproject(myproj)\nfind_package(Poco REQUIRED COMPONENTS Net Util)\nadd_executable(MyExe)\ntarget_source(MyExe PRIVATE \"main.cpp\")\ntarget_link_library(MyExe PRIVATE Poco::Net PocoUtil)\n\ntarget_complie_definition(MyExe PRIVATE std_cxx_14)\n```\n\n## 2.Target 和围绕 Target 的配置\n&ensp;C/C++工程通常都是为了生成可执行程序或者链接库，在现代 CMake 里他们被统称为`target`，创建命令分别是`add_library()`和`add_executable()`。其中链接库的类型又分为很多种，最常用的就是`SHARED`以及`STATIC`，在命令中加入关键词进行声明：add_library(MyLib SHARED)，第一个参数为target的名称，后续的配置都需要用到这个名字。\n&ensp;指定target的源文件：\n```sh\ntarget_source(MyLib PRVIATE \"main.cpp\" \"func.cpp\")\n```\n&emsp;PRIVATE关键词用于描述参数的“应用范围”，此外还有INTERFACE和PUBLIC两种可能的值\n\n&ensp;较多的源文件，可以使用 CMake 的file命令进行遍历拿到全部的源文件\n```sh\nfile(GLOB_RECURSE SRCS ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)\n```\n&emsp;命令第一个参数GLOB_RECURSE表明递归的查找子文件夹，第二个参数SRCS则是存储结果的变量名，第三个参数为目标文件的匹配模式，找到符合条件的 cpp 文件后，他们的路径会以字符串数组的形式保存在 SRCS 变量中，使用方式如下：\n```sh\ntarget_source(MyLib PRIVATE ${SRCS})\n```\n&ensp;配置target时通常还需要指定头文件目录：\n```sh\ntarget_include_directories(MyLib PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include/)\n```\n&ensp;编译时需要的语言特性：\n```sh\ntarget_compile_features(MyLib PRIVATE std_cxx_14)\n```\n&ensp;编译时的宏定义：\n```sh\ntarget_compile_definitions(MyLib PRIVATE LogLevel=3)\n```\n&ensp;参数想直接传给底层的编译器（比如 gcc, clang, cl），可以使用\n```sh\ntarget_compile_options(MyLib PRIVATE -Werror -Wall -Wextra)\n\n```\n\n## 3.Build Specification 和 Usage Requirement\n\n&ensp;C/C++通过 include 头文件的方式引入依赖，在动态或静态链接后可以调用依赖实现。一个可执行程序可能会依赖链接库，链接库也同样可能依赖其他的链接库\n&ensp;CMake 提供的解决方案是，在对 target 进行配置时，可以规定配置的类型，分为 build specification 和 usage requirement 两类，会影响配置的应用范围。Build specification 类型的配置仅在编译的时候需要满足，通过PRIVATE关键字声明；Usage requirement 类型的配置则是在使用时需要满足，即在其他项目里，使用本项目已编译好的 target 时需要满足，这种类型的配置使用INTERFACE关键词声明。在实际工程中，有很多配置在编译时以及被使用时都需要被满足的，这种配置通过PUBLIC关键词进行声明。\n\n&ensp;一个 library，在编译时静态链接了 Boost，在我们的实现文件中使用了 c++14 的特性，并用到了 Boost 的头文件和函数。随后我们对外发布了这个库，其中有头文件和预编译好的动态链接库。尽管我们的实现代码里用了 C++14，但在对外提供的头文件中只用到 C++03 的语法，也没有引入任何 Boost 的代码。这种情况下，当其他工程在使用我们的 library 时，其使用的编译器不需要开启 C++14 的支持，开发环境下也不需要安装 Boost。我们 library 的 CMake 配置中可以这么写：\n```sh\ntarget_compile_features(MyLib PRIVATE cxx_std_14)\ntarget_link_libraries(MyLib PRIVATE Boost::Format)\n```\n&emsp;PRIVATE 说明 c++14 的支持只在编译时需要用到，Boost 库的链接也仅在编译时需要。但如果我们对外提供的头文件中也使用了 C++14，那么就需要使用 PUBLIC 修饰，改为：\n```sh\ntarget_compile_features(MyLib PUBLIC cxx_std_14)\ntarget_link_libraries(MyLib PRIVATE Boost::Format)\n```\n&emsp;当 library 是 header-only 时，我们的工程是不需要单独编译的，因此也就没有 build specification，通过INTERFACE修饰配置即可\n```sh\narget_compile_features(MyLib INTERFACE cxx_std_14)\n```\n&ensp;Usage requirement 类型的配置，即通过INTERFACE或是PUBLIC修饰的配置是会传递的，比如 LibA 依赖 LibB 后，会继承 LibB 的 usage requirement，此后 LibC 依赖 LibB 时，LibA 和 libB 的 usage requirement 都会继承下来，\n\n## 4.寻找和使用链接库\n\n&ensp;C/C++标准没有规范库的安装位置和安装形式，通过 CMake 提供的方案寻找依赖，不光可以定位到头文件目录和链接库路径，还能够获取到库的 usage requirement。\n&ensp;在 CMake 中寻找第三方库的命令为find_package，其背后的工作方式有两种，一种基于 Config File 的查找，另一种则是基于 Find File 的查找。在执行find_package时，实际上 CMake 都是在找这两类文件，找到后从中获取关于库的信息。\n### 4.1 通过 Config file 找到依赖\n&ensp;Config File 是依赖的开发者提供的 cmake 脚本，通常会随预编译好的二进制一起发布，供下游的使用者使用。在 Config file 里，会对库里包含的 target 进行描述，说明版本信息以及头文件路径、链接库路径、编译选项等 usage requirement\n\n&ensp;CMake 对 Config file 的命名是有规定的，对于find_package(ABC)这样一条命令，CMake 只会去寻找ABCConfig.cmake或是abc-config.cmake。CMake 默认寻找的路径和平台有关，在 Linux 下寻找路径包括/usr/lib/cmake以及/usr/lib/local/cmake，在这两个路径下可以发现大量的 Config File，一般在安装某个库时，其自带的 Config file 会被放到这里来。\n\n### 4.2 通过 Find file 找到依赖\n\n&ensp;对于find_package(ABC)命令，如果 CMake 没有找到 Config file，他还会去试着寻找FindABC.cmake。Find file 在功能上和 Config file 相同，区别在于 Find file 是由其他人编写的，而非库的开发者。如果你使用的某个库没有提供 Config file，你可以去网上搜搜 Find file 或者自己写一个，然后加入到你的 CMake 工程中。\n\n&ensp;CMake 官方为我们写好了很多 Find file，在CMake Documentation这一页面可以看到，OpenGL，OpenMP，SDL 这些知名的库官方都为我们写好了 Find 脚本，因此直接调用 find_package 命令即可。但由于库的安装位置并不是固定的，这些 Find 脚本不一定能找到库，此时根据 CMake 报错的提示设置对应变量即可，通常是需要提供安装路径，这样就可以通过 Find file 获取到库的 usage requirement。不论是 Config file 还是 Find file，其目的都不只是找到库这么简单，而是告诉 CMake 如何使用这个库。\n库 CMake 官方也没有提供 Find file，这时候就要自己写了或者靠搜索了，写好后放到本项目的目录下，修改CMAKE_MODULE_PATH这个 CMAKE 变量：\n```sh\nlist(INSERT CMAKE_MODULE_PATH 0 ${CMAKE_SOURCE_DIR}/cmake)\n```\n&emsp;${CMAKE_SOURCE_DIR}/cmake目录下的 Find file 就可以被 CMake 找到了。\n&ensp;通过 CMake 的find_library和find_path两个命令就可以完成任务：\n```sh\nfind_library(MPI_LIBRARY\n  NAMES mpi\n  HINTS \"${CMAKE_PREFIX_PATH}/lib\" ${MPI_LIB_PATH}\n  # 如果默认路径没找到libmpi.so，还会去MPI_LIB_PATH找，下游使用者可以设置这个变量值\n)\nfind_path(MPI_INCLUDE_DIR\n  NAMES mpi.h\n  PATHS \"${CMAKE_PREFIX_PATH}/include\" ${MPI_INCLUDE_PATH}\n  # 如果默认路径没找到mpi.h，还会去MPI_INCLUDE_PATH找，下游使用者可以设置这个变量值\n)\n```\n\n### 4.3.find_package 的处理\n&ensp;find_package这个命令，这个命令可以指定很多参数，比如指定版本，指定具体的模块等等。以 SFML 多媒体库为例，其包含了 network 模块，audio 模块，graphic 模块等等，但我很多时候只用到 graphic 模块，那么其他的模块对应的链接库不需要被链接，于是 CMake 脚本可以这么写：\n```sh\n# 要求大版本号为2的SFML库的graphic模块\nfind_package(SFML 2 COMPONENTS graphics REQUIRED)\n# SFML提供的target名字为sfml-graphics\ntarget_link_libraries(MyEXE PRIVATE sfml-graphics)\n```\n\n### 5.使用 CMake 来编译\n\n&ensp;CMake 生成好编译环境后，底层的 make, ninja, MSBuild 编译命令都是不一样的，但 CMake 提供了一个统一的方法进行编译：\n```sh\ncmake --build .\n```\n&emsp;使用--buildflag，CMake 就会调用底层的编译命令，在跨平台时十分方便。\n&emsp;对于 Visual Studio，其 Debug 和 Release 环境是基于 configuration 的，因此CMAKE_BUILD_TYPE变量无效，需要在 build 时指定：\n```sh\ncmake --build . --config Release\n```\n\n\n\n\n- 参考链接:\ncmake\nhttps://ukabuer.me/blog/more-modern-cmake/\nMakefile\n","slug":"2021/12/cmake","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8vx00140guu0nn1ag0q","content":"<h2 id=\"1-camke简述\"><a href=\"#1-camke简述\" class=\"headerlink\" title=\"1.camke简述\"></a>1.camke简述</h2><p> CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.</p>\n<span id=\"more\"></span>\n\n<p> CMake工程简单例子</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required(VERSION 3.12)</span><br><span class=\"line\">project(myproj)</span><br><span class=\"line\">find_package(Poco REQUIRED COMPONENTS Net Util)</span><br><span class=\"line\">add_executable(MyExe)</span><br><span class=\"line\">target_source(MyExe PRIVATE <span class=\"string\">\"main.cpp\"</span>)</span><br><span class=\"line\">target_link_library(MyExe PRIVATE Poco::Net PocoUtil)</span><br><span class=\"line\"></span><br><span class=\"line\">target_complie_definition(MyExe PRIVATE std_cxx_14)</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"2-Target-和围绕-Target-的配置\"><a href=\"#2-Target-和围绕-Target-的配置\" class=\"headerlink\" title=\"2.Target 和围绕 Target 的配置\"></a>2.Target 和围绕 Target 的配置</h2><p> C/C++工程通常都是为了生成可执行程序或者链接库，在现代 CMake 里他们被统称为<code>target</code>，创建命令分别是<code>add_library()</code>和<code>add_executable()</code>。其中链接库的类型又分为很多种，最常用的就是<code>SHARED</code>以及<code>STATIC</code>，在命令中加入关键词进行声明：add_library(MyLib SHARED)，第一个参数为target的名称，后续的配置都需要用到这个名字。<br> 指定target的源文件：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_source(MyLib PRVIATE <span class=\"string\">\"main.cpp\"</span> <span class=\"string\">\"func.cpp\"</span>)</span><br></pre></td></tr></tbody></table></figure>\n<p> PRIVATE关键词用于描述参数的“应用范围”，此外还有INTERFACE和PUBLIC两种可能的值</p>\n<p> 较多的源文件，可以使用 CMake 的file命令进行遍历拿到全部的源文件</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file(GLOB_RECURSE SRCS <span class=\"variable\">${CMAKE_CURRENT_SOURCE_DIR}</span>/*.cpp)</span><br></pre></td></tr></tbody></table></figure>\n<p> 命令第一个参数GLOB_RECURSE表明递归的查找子文件夹，第二个参数SRCS则是存储结果的变量名，第三个参数为目标文件的匹配模式，找到符合条件的 cpp 文件后，他们的路径会以字符串数组的形式保存在 SRCS 变量中，使用方式如下：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_source(MyLib PRIVATE <span class=\"variable\">${SRCS}</span>)</span><br></pre></td></tr></tbody></table></figure>\n<p> 配置target时通常还需要指定头文件目录：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_include_directories(MyLib PRIVATE <span class=\"variable\">${CMAKE_CURRENT_SOURCE_DIR}</span>/include/)</span><br></pre></td></tr></tbody></table></figure>\n<p> 编译时需要的语言特性：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_compile_features(MyLib PRIVATE std_cxx_14)</span><br></pre></td></tr></tbody></table></figure>\n<p> 编译时的宏定义：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_compile_definitions(MyLib PRIVATE LogLevel=3)</span><br></pre></td></tr></tbody></table></figure>\n<p> 参数想直接传给底层的编译器（比如 gcc, clang, cl），可以使用</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_compile_options(MyLib PRIVATE -Werror -Wall -Wextra)</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"3-Build-Specification-和-Usage-Requirement\"><a href=\"#3-Build-Specification-和-Usage-Requirement\" class=\"headerlink\" title=\"3.Build Specification 和 Usage Requirement\"></a>3.Build Specification 和 Usage Requirement</h2><p> C/C++通过 include 头文件的方式引入依赖，在动态或静态链接后可以调用依赖实现。一个可执行程序可能会依赖链接库，链接库也同样可能依赖其他的链接库<br> CMake 提供的解决方案是，在对 target 进行配置时，可以规定配置的类型，分为 build specification 和 usage requirement 两类，会影响配置的应用范围。Build specification 类型的配置仅在编译的时候需要满足，通过PRIVATE关键字声明；Usage requirement 类型的配置则是在使用时需要满足，即在其他项目里，使用本项目已编译好的 target 时需要满足，这种类型的配置使用INTERFACE关键词声明。在实际工程中，有很多配置在编译时以及被使用时都需要被满足的，这种配置通过PUBLIC关键词进行声明。</p>\n<p> 一个 library，在编译时静态链接了 Boost，在我们的实现文件中使用了 c++14 的特性，并用到了 Boost 的头文件和函数。随后我们对外发布了这个库，其中有头文件和预编译好的动态链接库。尽管我们的实现代码里用了 C++14，但在对外提供的头文件中只用到 C++03 的语法，也没有引入任何 Boost 的代码。这种情况下，当其他工程在使用我们的 library 时，其使用的编译器不需要开启 C++14 的支持，开发环境下也不需要安装 Boost。我们 library 的 CMake 配置中可以这么写：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_compile_features(MyLib PRIVATE cxx_std_14)</span><br><span class=\"line\">target_link_libraries(MyLib PRIVATE Boost::Format)</span><br></pre></td></tr></tbody></table></figure>\n<p> PRIVATE 说明 c++14 的支持只在编译时需要用到，Boost 库的链接也仅在编译时需要。但如果我们对外提供的头文件中也使用了 C++14，那么就需要使用 PUBLIC 修饰，改为：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_compile_features(MyLib PUBLIC cxx_std_14)</span><br><span class=\"line\">target_link_libraries(MyLib PRIVATE Boost::Format)</span><br></pre></td></tr></tbody></table></figure>\n<p> 当 library 是 header-only 时，我们的工程是不需要单独编译的，因此也就没有 build specification，通过INTERFACE修饰配置即可</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arget_compile_features(MyLib INTERFACE cxx_std_14)</span><br></pre></td></tr></tbody></table></figure>\n<p> Usage requirement 类型的配置，即通过INTERFACE或是PUBLIC修饰的配置是会传递的，比如 LibA 依赖 LibB 后，会继承 LibB 的 usage requirement，此后 LibC 依赖 LibB 时，LibA 和 libB 的 usage requirement 都会继承下来，</p>\n<h2 id=\"4-寻找和使用链接库\"><a href=\"#4-寻找和使用链接库\" class=\"headerlink\" title=\"4.寻找和使用链接库\"></a>4.寻找和使用链接库</h2><p> C/C++标准没有规范库的安装位置和安装形式，通过 CMake 提供的方案寻找依赖，不光可以定位到头文件目录和链接库路径，还能够获取到库的 usage requirement。<br> 在 CMake 中寻找第三方库的命令为find_package，其背后的工作方式有两种，一种基于 Config File 的查找，另一种则是基于 Find File 的查找。在执行find_package时，实际上 CMake 都是在找这两类文件，找到后从中获取关于库的信息。</p>\n<h3 id=\"4-1-通过-Config-file-找到依赖\"><a href=\"#4-1-通过-Config-file-找到依赖\" class=\"headerlink\" title=\"4.1 通过 Config file 找到依赖\"></a>4.1 通过 Config file 找到依赖</h3><p> Config File 是依赖的开发者提供的 cmake 脚本，通常会随预编译好的二进制一起发布，供下游的使用者使用。在 Config file 里，会对库里包含的 target 进行描述，说明版本信息以及头文件路径、链接库路径、编译选项等 usage requirement</p>\n<p> CMake 对 Config file 的命名是有规定的，对于find_package(ABC)这样一条命令，CMake 只会去寻找ABCConfig.cmake或是abc-config.cmake。CMake 默认寻找的路径和平台有关，在 Linux 下寻找路径包括/usr/lib/cmake以及/usr/lib/local/cmake，在这两个路径下可以发现大量的 Config File，一般在安装某个库时，其自带的 Config file 会被放到这里来。</p>\n<h3 id=\"4-2-通过-Find-file-找到依赖\"><a href=\"#4-2-通过-Find-file-找到依赖\" class=\"headerlink\" title=\"4.2 通过 Find file 找到依赖\"></a>4.2 通过 Find file 找到依赖</h3><p> 对于find_package(ABC)命令，如果 CMake 没有找到 Config file，他还会去试着寻找FindABC.cmake。Find file 在功能上和 Config file 相同，区别在于 Find file 是由其他人编写的，而非库的开发者。如果你使用的某个库没有提供 Config file，你可以去网上搜搜 Find file 或者自己写一个，然后加入到你的 CMake 工程中。</p>\n<p> CMake 官方为我们写好了很多 Find file，在CMake Documentation这一页面可以看到，OpenGL，OpenMP，SDL 这些知名的库官方都为我们写好了 Find 脚本，因此直接调用 find_package 命令即可。但由于库的安装位置并不是固定的，这些 Find 脚本不一定能找到库，此时根据 CMake 报错的提示设置对应变量即可，通常是需要提供安装路径，这样就可以通过 Find file 获取到库的 usage requirement。不论是 Config file 还是 Find file，其目的都不只是找到库这么简单，而是告诉 CMake 如何使用这个库。<br>库 CMake 官方也没有提供 Find file，这时候就要自己写了或者靠搜索了，写好后放到本项目的目录下，修改CMAKE_MODULE_PATH这个 CMAKE 变量：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list(INSERT CMAKE_MODULE_PATH 0 <span class=\"variable\">${CMAKE_SOURCE_DIR}</span>/cmake)</span><br></pre></td></tr></tbody></table></figure>\n<p> ${CMAKE_SOURCE_DIR}/cmake目录下的 Find file 就可以被 CMake 找到了。<br> 通过 CMake 的find_library和find_path两个命令就可以完成任务：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_library(MPI_LIBRARY</span><br><span class=\"line\">  NAMES mpi</span><br><span class=\"line\">  HINTS <span class=\"string\">\"<span class=\"variable\">${CMAKE_PREFIX_PATH}</span>/lib\"</span> <span class=\"variable\">${MPI_LIB_PATH}</span></span><br><span class=\"line\">  <span class=\"comment\"># 如果默认路径没找到libmpi.so，还会去MPI_LIB_PATH找，下游使用者可以设置这个变量值</span></span><br><span class=\"line\">)</span><br><span class=\"line\">find_path(MPI_INCLUDE_DIR</span><br><span class=\"line\">  NAMES mpi.h</span><br><span class=\"line\">  PATHS <span class=\"string\">\"<span class=\"variable\">${CMAKE_PREFIX_PATH}</span>/include\"</span> <span class=\"variable\">${MPI_INCLUDE_PATH}</span></span><br><span class=\"line\">  <span class=\"comment\"># 如果默认路径没找到mpi.h，还会去MPI_INCLUDE_PATH找，下游使用者可以设置这个变量值</span></span><br><span class=\"line\">)</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-3-find-package-的处理\"><a href=\"#4-3-find-package-的处理\" class=\"headerlink\" title=\"4.3.find_package 的处理\"></a>4.3.find_package 的处理</h3><p> find_package这个命令，这个命令可以指定很多参数，比如指定版本，指定具体的模块等等。以 SFML 多媒体库为例，其包含了 network 模块，audio 模块，graphic 模块等等，但我很多时候只用到 graphic 模块，那么其他的模块对应的链接库不需要被链接，于是 CMake 脚本可以这么写：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 要求大版本号为2的SFML库的graphic模块</span></span><br><span class=\"line\">find_package(SFML 2 COMPONENTS graphics REQUIRED)</span><br><span class=\"line\"><span class=\"comment\"># SFML提供的target名字为sfml-graphics</span></span><br><span class=\"line\">target_link_libraries(MyEXE PRIVATE sfml-graphics)</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-使用-CMake-来编译\"><a href=\"#5-使用-CMake-来编译\" class=\"headerlink\" title=\"5.使用 CMake 来编译\"></a>5.使用 CMake 来编译</h3><p> CMake 生成好编译环境后，底层的 make, ninja, MSBuild 编译命令都是不一样的，但 CMake 提供了一个统一的方法进行编译：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake --build .</span><br></pre></td></tr></tbody></table></figure>\n<p> 使用–buildflag，CMake 就会调用底层的编译命令，在跨平台时十分方便。<br> 对于 Visual Studio，其 Debug 和 Release 环境是基于 configuration 的，因此CMAKE_BUILD_TYPE变量无效，需要在 build 时指定：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake --build . --config Release</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n\n<ul>\n<li>参考链接:<br>cmake<br><a href=\"https://ukabuer.me/blog/more-modern-cmake/\">https://ukabuer.me/blog/more-modern-cmake/</a><br>Makefile</li>\n</ul>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"11CQMY8","length":4922,"excerpt":"<h2 id=\"1-camke简述\"><a href=\"#1-camke简述\" class=\"headerlink\" title=\"1.camke简述\"></a>1.camke简述</h2><p> CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.</p>","more":"<p>&ensp;CMake工程简单例子</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required(VERSION 3.12)</span><br><span class=\"line\">project(myproj)</span><br><span class=\"line\">find_package(Poco REQUIRED COMPONENTS Net Util)</span><br><span class=\"line\">add_executable(MyExe)</span><br><span class=\"line\">target_source(MyExe PRIVATE <span class=\"string\">&quot;main.cpp&quot;</span>)</span><br><span class=\"line\">target_link_library(MyExe PRIVATE Poco::Net PocoUtil)</span><br><span class=\"line\"></span><br><span class=\"line\">target_complie_definition(MyExe PRIVATE std_cxx_14)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-Target-和围绕-Target-的配置\"><a href=\"#2-Target-和围绕-Target-的配置\" class=\"headerlink\" title=\"2.Target 和围绕 Target 的配置\"></a>2.Target 和围绕 Target 的配置</h2><p>&ensp;C/C++工程通常都是为了生成可执行程序或者链接库，在现代 CMake 里他们被统称为<code>target</code>，创建命令分别是<code>add_library()</code>和<code>add_executable()</code>。其中链接库的类型又分为很多种，最常用的就是<code>SHARED</code>以及<code>STATIC</code>，在命令中加入关键词进行声明：add_library(MyLib SHARED)，第一个参数为target的名称，后续的配置都需要用到这个名字。<br>&ensp;指定target的源文件：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_source(MyLib PRVIATE <span class=\"string\">&quot;main.cpp&quot;</span> <span class=\"string\">&quot;func.cpp&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>&emsp;PRIVATE关键词用于描述参数的“应用范围”，此外还有INTERFACE和PUBLIC两种可能的值</p>\n<p>&ensp;较多的源文件，可以使用 CMake 的file命令进行遍历拿到全部的源文件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file(GLOB_RECURSE SRCS <span class=\"variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br></pre></td></tr></table></figure>\n<p>&emsp;命令第一个参数GLOB_RECURSE表明递归的查找子文件夹，第二个参数SRCS则是存储结果的变量名，第三个参数为目标文件的匹配模式，找到符合条件的 cpp 文件后，他们的路径会以字符串数组的形式保存在 SRCS 变量中，使用方式如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_source(MyLib PRIVATE <span class=\"variable\">$&#123;SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>\n<p>&ensp;配置target时通常还需要指定头文件目录：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_include_directories(MyLib PRIVATE <span class=\"variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/include/)</span><br></pre></td></tr></table></figure>\n<p>&ensp;编译时需要的语言特性：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_compile_features(MyLib PRIVATE std_cxx_14)</span><br></pre></td></tr></table></figure>\n<p>&ensp;编译时的宏定义：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_compile_definitions(MyLib PRIVATE LogLevel=3)</span><br></pre></td></tr></table></figure>\n<p>&ensp;参数想直接传给底层的编译器（比如 gcc, clang, cl），可以使用</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_compile_options(MyLib PRIVATE -Werror -Wall -Wextra)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-Build-Specification-和-Usage-Requirement\"><a href=\"#3-Build-Specification-和-Usage-Requirement\" class=\"headerlink\" title=\"3.Build Specification 和 Usage Requirement\"></a>3.Build Specification 和 Usage Requirement</h2><p>&ensp;C/C++通过 include 头文件的方式引入依赖，在动态或静态链接后可以调用依赖实现。一个可执行程序可能会依赖链接库，链接库也同样可能依赖其他的链接库<br>&ensp;CMake 提供的解决方案是，在对 target 进行配置时，可以规定配置的类型，分为 build specification 和 usage requirement 两类，会影响配置的应用范围。Build specification 类型的配置仅在编译的时候需要满足，通过PRIVATE关键字声明；Usage requirement 类型的配置则是在使用时需要满足，即在其他项目里，使用本项目已编译好的 target 时需要满足，这种类型的配置使用INTERFACE关键词声明。在实际工程中，有很多配置在编译时以及被使用时都需要被满足的，这种配置通过PUBLIC关键词进行声明。</p>\n<p>&ensp;一个 library，在编译时静态链接了 Boost，在我们的实现文件中使用了 c++14 的特性，并用到了 Boost 的头文件和函数。随后我们对外发布了这个库，其中有头文件和预编译好的动态链接库。尽管我们的实现代码里用了 C++14，但在对外提供的头文件中只用到 C++03 的语法，也没有引入任何 Boost 的代码。这种情况下，当其他工程在使用我们的 library 时，其使用的编译器不需要开启 C++14 的支持，开发环境下也不需要安装 Boost。我们 library 的 CMake 配置中可以这么写：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_compile_features(MyLib PRIVATE cxx_std_14)</span><br><span class=\"line\">target_link_libraries(MyLib PRIVATE Boost::Format)</span><br></pre></td></tr></table></figure>\n<p>&emsp;PRIVATE 说明 c++14 的支持只在编译时需要用到，Boost 库的链接也仅在编译时需要。但如果我们对外提供的头文件中也使用了 C++14，那么就需要使用 PUBLIC 修饰，改为：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target_compile_features(MyLib PUBLIC cxx_std_14)</span><br><span class=\"line\">target_link_libraries(MyLib PRIVATE Boost::Format)</span><br></pre></td></tr></table></figure>\n<p>&emsp;当 library 是 header-only 时，我们的工程是不需要单独编译的，因此也就没有 build specification，通过INTERFACE修饰配置即可</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arget_compile_features(MyLib INTERFACE cxx_std_14)</span><br></pre></td></tr></table></figure>\n<p>&ensp;Usage requirement 类型的配置，即通过INTERFACE或是PUBLIC修饰的配置是会传递的，比如 LibA 依赖 LibB 后，会继承 LibB 的 usage requirement，此后 LibC 依赖 LibB 时，LibA 和 libB 的 usage requirement 都会继承下来，</p>\n<h2 id=\"4-寻找和使用链接库\"><a href=\"#4-寻找和使用链接库\" class=\"headerlink\" title=\"4.寻找和使用链接库\"></a>4.寻找和使用链接库</h2><p>&ensp;C/C++标准没有规范库的安装位置和安装形式，通过 CMake 提供的方案寻找依赖，不光可以定位到头文件目录和链接库路径，还能够获取到库的 usage requirement。<br>&ensp;在 CMake 中寻找第三方库的命令为find_package，其背后的工作方式有两种，一种基于 Config File 的查找，另一种则是基于 Find File 的查找。在执行find_package时，实际上 CMake 都是在找这两类文件，找到后从中获取关于库的信息。</p>\n<h3 id=\"4-1-通过-Config-file-找到依赖\"><a href=\"#4-1-通过-Config-file-找到依赖\" class=\"headerlink\" title=\"4.1 通过 Config file 找到依赖\"></a>4.1 通过 Config file 找到依赖</h3><p>&ensp;Config File 是依赖的开发者提供的 cmake 脚本，通常会随预编译好的二进制一起发布，供下游的使用者使用。在 Config file 里，会对库里包含的 target 进行描述，说明版本信息以及头文件路径、链接库路径、编译选项等 usage requirement</p>\n<p>&ensp;CMake 对 Config file 的命名是有规定的，对于find_package(ABC)这样一条命令，CMake 只会去寻找ABCConfig.cmake或是abc-config.cmake。CMake 默认寻找的路径和平台有关，在 Linux 下寻找路径包括/usr/lib/cmake以及/usr/lib/local/cmake，在这两个路径下可以发现大量的 Config File，一般在安装某个库时，其自带的 Config file 会被放到这里来。</p>\n<h3 id=\"4-2-通过-Find-file-找到依赖\"><a href=\"#4-2-通过-Find-file-找到依赖\" class=\"headerlink\" title=\"4.2 通过 Find file 找到依赖\"></a>4.2 通过 Find file 找到依赖</h3><p>&ensp;对于find_package(ABC)命令，如果 CMake 没有找到 Config file，他还会去试着寻找FindABC.cmake。Find file 在功能上和 Config file 相同，区别在于 Find file 是由其他人编写的，而非库的开发者。如果你使用的某个库没有提供 Config file，你可以去网上搜搜 Find file 或者自己写一个，然后加入到你的 CMake 工程中。</p>\n<p>&ensp;CMake 官方为我们写好了很多 Find file，在CMake Documentation这一页面可以看到，OpenGL，OpenMP，SDL 这些知名的库官方都为我们写好了 Find 脚本，因此直接调用 find_package 命令即可。但由于库的安装位置并不是固定的，这些 Find 脚本不一定能找到库，此时根据 CMake 报错的提示设置对应变量即可，通常是需要提供安装路径，这样就可以通过 Find file 获取到库的 usage requirement。不论是 Config file 还是 Find file，其目的都不只是找到库这么简单，而是告诉 CMake 如何使用这个库。<br>库 CMake 官方也没有提供 Find file，这时候就要自己写了或者靠搜索了，写好后放到本项目的目录下，修改CMAKE_MODULE_PATH这个 CMAKE 变量：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list(INSERT CMAKE_MODULE_PATH 0 <span class=\"variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cmake)</span><br></pre></td></tr></table></figure>\n<p>&emsp;${CMAKE_SOURCE_DIR}/cmake目录下的 Find file 就可以被 CMake 找到了。<br>&ensp;通过 CMake 的find_library和find_path两个命令就可以完成任务：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_library(MPI_LIBRARY</span><br><span class=\"line\">  NAMES mpi</span><br><span class=\"line\">  HINTS <span class=\"string\">&quot;<span class=\"variable\">$&#123;CMAKE_PREFIX_PATH&#125;</span>/lib&quot;</span> <span class=\"variable\">$&#123;MPI_LIB_PATH&#125;</span></span><br><span class=\"line\">  <span class=\"comment\"># 如果默认路径没找到libmpi.so，还会去MPI_LIB_PATH找，下游使用者可以设置这个变量值</span></span><br><span class=\"line\">)</span><br><span class=\"line\">find_path(MPI_INCLUDE_DIR</span><br><span class=\"line\">  NAMES mpi.h</span><br><span class=\"line\">  PATHS <span class=\"string\">&quot;<span class=\"variable\">$&#123;CMAKE_PREFIX_PATH&#125;</span>/include&quot;</span> <span class=\"variable\">$&#123;MPI_INCLUDE_PATH&#125;</span></span><br><span class=\"line\">  <span class=\"comment\"># 如果默认路径没找到mpi.h，还会去MPI_INCLUDE_PATH找，下游使用者可以设置这个变量值</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-find-package-的处理\"><a href=\"#4-3-find-package-的处理\" class=\"headerlink\" title=\"4.3.find_package 的处理\"></a>4.3.find_package 的处理</h3><p>&ensp;find_package这个命令，这个命令可以指定很多参数，比如指定版本，指定具体的模块等等。以 SFML 多媒体库为例，其包含了 network 模块，audio 模块，graphic 模块等等，但我很多时候只用到 graphic 模块，那么其他的模块对应的链接库不需要被链接，于是 CMake 脚本可以这么写：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 要求大版本号为2的SFML库的graphic模块</span></span><br><span class=\"line\">find_package(SFML 2 COMPONENTS graphics REQUIRED)</span><br><span class=\"line\"><span class=\"comment\"># SFML提供的target名字为sfml-graphics</span></span><br><span class=\"line\">target_link_libraries(MyEXE PRIVATE sfml-graphics)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-使用-CMake-来编译\"><a href=\"#5-使用-CMake-来编译\" class=\"headerlink\" title=\"5.使用 CMake 来编译\"></a>5.使用 CMake 来编译</h3><p>&ensp;CMake 生成好编译环境后，底层的 make, ninja, MSBuild 编译命令都是不一样的，但 CMake 提供了一个统一的方法进行编译：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake --build .</span><br></pre></td></tr></table></figure>\n<p>&emsp;使用–buildflag，CMake 就会调用底层的编译命令，在跨平台时十分方便。<br>&emsp;对于 Visual Studio，其 Debug 和 Release 环境是基于 configuration 的，因此CMAKE_BUILD_TYPE变量无效，需要在 build 时指定：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake --build . --config Release</span><br></pre></td></tr></table></figure>\n\n\n\n\n<ul>\n<li>参考链接:<br>cmake<br><a href=\"https://ukabuer.me/blog/more-modern-cmake/\">https://ukabuer.me/blog/more-modern-cmake/</a><br>Makefile</li>\n</ul>"},{"title":"英语语法指一","date":"2021-12-01T16:47:53.000Z","updated":"2021-12-01T16:53:53.000Z","_content":"\n## 一.简单句子分析\n&ensp;**英语句子= 主干+修饰成分**\n&ensp;分析句子结构:\n&emsp;&emsp;一个中心 + 两个要点\n&emsp;&emsp;一个中心: 动词. 句子必须右动词\n&emsp;&emsp;两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者.\n&emsp;&emsp;**句子的核心是主谓结构**\n<!--more-->\n&ensp;n个主语+1个谓语 或者 1个主语+n个谓语，就可以组成简单句。其他的定状补语等都是句子的附属成分。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。\n\n\n&ensp;英语的句子结构分为三种:简单句,并列句,复合句.简单句又分为五种基本句型.\n\n{% pullquote mindmap mindmap-md %}\n\n- 英文句子\n    - 简单句\n        - 主 + 谓\n        - 主 + 谓 + 宾\n        - 主 + 谓 + 宾 + 宾补\n        - 主 + 谓 + 间宾 + 直宾\n        - 主 + 系 + 表\n    - 复合句\n        - 名词性从句\n            - 主语从句\n            - 宾语从句\n            - 同位语从句\n            - 表语从句\n        - 定语从句\n        - 状语从句\n            - 时间状语从句\n            - 地点状语从句\n            - 条件状语从句\n            - 结果状语从句\n            - 让步状语从句\n            - 目的状语从句\n    - 特殊句式\n        - 强调句\n        - 虚拟语气\n        - 倒装句\n    - 类型\n        - 陈述句\n        - 祈使句\n        - 感叹句\n        - 疑问句\n    \n{% endpullquote %}\n\n&ensp;英语语法从整体上来讲是通过五部分来组成\n&ensp;&emsp;1、简单句\n&ensp;&emsp;2、并列句、复合句\n&ensp;&emsp;3、三大从句\n&ensp;&emsp;4、特殊句式\n&ensp;&emsp;5、类型\n\n\n补语\n&emsp;补语是和表意不完全的动词息息相关的。在第三种基本句型中，联系动词将主语和补语在某个意义层面上对等起来。\n&emsp;修饰成分\n&emsp;&emsp;介词短语\n&emsp;&emsp;从句\n&emsp;&emsp;非谓语动词\n&emsp;&emsp;时间状语\n&emsp;论主语的补语，而后将宾语的补语作为一种变形来讨论\n\n### 1.1 S + V （主+谓）\n&ensp;句子不可或缺的两部分.\n&emsp;名词/代词/不定式/动名词 + 动词\n&emsp;谓语动词可以表达完整的意思，这类动词为不及物动词（vi）.\n\n### 1.2 S + V + C （主+系+表）\n主语 +系动词 +表语\n\n表语说明主语的状态和性质，可以是名词，形容词，副词，短语等。\n\n系动词包括：\n\na. be 动词，am, is, are, was, were;\n\nb. 表感官：feel(摸起来像是), smell, sound(听起来是), taste(尝起来是), look(看起来是);\n\nc. 表变化：become(成为), grow, turn(转变为), go, get, fall;\n\nd. 表状态：remain(依旧是), keep, hold, stay(仍然是), seem(似乎是).\n\nappear 显得像是\nprove 证实为\nbecome 成为\nmake 作为\n\n\n### 1.3 S + V + O （主+谓+宾）\n\n主语+谓语+宾语\n\n谓语一般为及物动词（vt.），后面必须要跟宾语才能表达完整的意思。宾语是谓语动词动作的承受者。\n\n\n### 1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)）\n\n谓语动词必须要跟两个宾语才能表达完整意思。两个宾语分别是动作的直接承受者（一般是物）和间接承受者（一般是人）。\ne.g.,\n\ngive sb sth = give sth to sb\n\ntell sb sth = tell sth to sb\n\n\n### 1.5 S + V + O + C（主+谓+宾+宾补）\n此种情况，动词虽然跟了宾语，但句子意思不完整，需要跟上一个补足语，对宾语进行解释说明，句子意思才能完整通顺。\n主语的补语用来表示主语是什么。类似地，宾语的补语用来表示宾语是什么。在 S + V + O + C 这个句型当中，宾语和补语之间虽然没有动词存在。但是句子可以变形成：S + V + that + O + V + C 的形式，也就是将原本的宾语和补语以从句的形式出现。因此，可以认为宾语和补语之间有「隐藏的」判断动词「是」的存在。\n\n\nThere be 句型\n\nThere be 句型表示人/物的存在。句子结构，就是There be + 主语+其他部分\n\n1.主语：句子所陈述的对象。\n2.谓语：主语发出的动作。一般是有动作意义的动词。\n3. 宾语：分为动词宾语和介词宾语，属于动作的承受者。\n4. 系动词：表示状态或状态变化的动词，没有实际的动作意义。如 be, 感官系动词（look, sound, smell, taste 和 feel）、保持类系动词（keep, stay 和 remain）、状态变化类系动词（become、get、turn 和 go）等。\n5. 表语：紧跟系动词后面的成分。\n6. 定语：修饰名词或代词的成分。\n7. 状语： 修饰形容词、副词、动词或句子的成分。\n8. 补语：分为宾语补足语和主语补足语。是对宾语和主语的补充说明，与其有主动或被动的逻辑关系。\n\n\n\n- 参考链接:\nhttps://liam.page/2014/06/21/basic-sentence-and-the-complement/\nhttps://www.zhihu.com/question/30030877/answer/768501967\n\n- 参考数据\n《语法俱乐部》\n\n复杂句:从简单句演化而来\n\n简单句没有什么句序的调整，所以翻译起来基本没有什么难度。\n\n英语中的修饰成分，分定语和状语两种情况。\n英语句子 = 主干(五种基本句型) + 修饰成分(定语+状语)\n\n\n## 二、并列句、复合句\n简单句通过不同的连接词就成为了不同的句子，通过并列词成了并列句，通过从属连词成了复合句。下面我们就一一讲解 ：\n\n并列句：简单句+并列词+简单句\n\n并列词一般有：and / or / but / so /while / yet / for / however\n\n1）：表示并列：and, not only...but also... , neither...nor...\n\nHer father is a doctor and her mother is a teacher .\n\n2）：表示选择：or, or else, otherwise, either...or...\n\nHurry or you won't make the train.\n\n3）：表示对比、转折: but, while , yet , however , never ,\n\nI like tea while she likes coffee .\n\n4）：表示原因：for\n\nI am thirsty , for it is hot .\n\n复合句：简单句+从属连词+简单句\n\n从属连词有：that / wether/ if\n\n复合句其实就是我们常说的三大从句，\n\n\n## 三.三大从句\n1、名词性从句\n\n当名词性从句作为句子的不同成分时，又被称呼为不同的名字。\n\n当作为主语时，称为主语从句。\n\n当称为宾语时，称为宾语从句，同样表语从句以及同位语从句。以下我们来举个栗子 ：\n\n主语从句 What she said is wrong .\n\n宾语从句 I said that she was wrong.\n\n表语从句 The fact is that he doesn’t really try.\n\n同位语从句 The news that he will come back is ture.\n\n记住一点，不管什么从句，你把它当成一个”长一点的名词”。\n\n那如果这个长名词在句子中作主语，就是主语从句，作宾语就是宾语从句。\n\n同位语从句就是相当于一个长点的名词对另外一个抽象名词进行解释说明。\n\n2、定语从句\n\n修饰限定名词，汉语中“的”前面的内容。\n\n关系代词引导的定语从句\n\n1.who指人，在从句中做主语 Yesterday I helped an old man who lost his way.\n\n2. whom指人，在定语从句中充当宾语，常可省略。\n\nMr. Ling is just the boy whom I want to see\n\n3. which指物，在定语从句中做主语或者宾语，做宾语时可省略\n\nThis is the pen (which) he bought yesterday.\n\n4. that指人时，相当于who 或者whom；指物时，相当于which。\n\n5. whose通常指人，也可指物，在定语从句中做定语。\n\n指的是谁的。Do you like the book whose cover is yellow?\n\n关系副词引导的定语从句\n\nwhen where why\n\n3、状语从句\n\n修饰动作的发生的时间、地点、原因、方式\n\n九大状语从句\n\n1、时间状语从句\n\n常用引导词：when, as, while, as soon as, before, after, since , till, until\n\n特殊引导词：the minute, the moment, the second, every time, the day，the instant,\n\nI was fat when I was a child.\n\n2、地点状语从句\n\n常用引导词：where\n\n特殊引导词：wherever, anywhere, everywhere\n\nKeep it where you can see it.\n\n3、原因状语从句\n\n常用引导词：because, since, as, for\n\n特殊引导词：seeing that, now that, in that, considering that, given that.\n\nMy friends dislike me because I’m beautiful .\n\n4、目的状语从句\n\n常用引导词：so that, in order that\n\n特殊引导词：lest, in case, for fear that，in the hope that, for the purpose that, to the end that\n\nstudy hard so that you can pass the exam.\n\n5、结果状语从句\n\n常用引导词：so … that, so… that, such … that,\n\n特殊引导词：such that, to the degree that, to the extent that, to such a degree that,\n\nHe got up so early that he caught the first bus.\n\n6、条件状语从句\n\n常用引导词：if, unless,\n\n特殊引导词：as/so long as, only if, providing/provided that, supposing that, in case that, on condition that\n\nIf you ask him, he will help you.\n\n7、方式状语从句\n\n常用引导词：as, as if, how\n\n特殊引导词：the way\n\nThink as i think\n\n8、比较状语从句\n\n常用引导词：as(同级比较), than(不同程度的比较)\n\n特殊引导词：the more … the more … ; just as …， so…; A is to B what /as X is to Y; no … more than; not A so much as B\n\nThe house is three times as big as ours.\n\n9、让步状语从句\n\n常用引导词：though, although, even if, even though\n\n特殊引导词： as(用在让步状语从句中必须要倒装)，while ( 一般用在句首 )，no matter …， in spite of the fact that, while, whatever, whoever, wherever, whenever, however, whichever\n\nThough I believe it, yet I must consider.\n\n\n\n## 四.特殊句式\n\n1、强调句\n\nIt is （名词 / 介宾）指的是被强调的内容that （........）\n\nIt was she whom we are talking about.\n\n2、倒装句\n\n正常句序 ：主谓宾\n\n倒装句序 ：谓主宾\n\nwe can win only through hard work .\n\nonly through hard work can we win .\n\n3、虚拟语气，假设不可能发生的事情\n\n1、对过去情况的虚拟\n\n从句用 had done\n\n主句用 would could might should have done\n\n2、对现在情况的虚拟\n\n从句用 did , was变成were\n\n主句用 would could might should do\n\n3、对将来情况虚拟\n\n从句用 did ，was 变成 were，should do,were to do\n\n主句用 would could might should do\n\n## 五.类型\n陈述句\n\ni like English very much . 我非常喜欢英语。\n\n疑问句\n\nis this your key ? 这是你的钥匙吗？\n\n祈使句\n\n一种是以动词原形开头，在动词原形之前加do (但只限于省略第二人称主语的句子)。\n\nmind you head 小心碰头！\n\n第二种祈使句以let开头\n\nLet's have another try\n\n感叹句\n\nwhat a brave girl ! 真是个勇敢的女孩子\n\n\n\nhttps://zhuanlan.zhihu.com/p/400448345\n\n\n\n\n\n\n","source":"_posts/2021/12/英语语法一.md","raw":"---\ntitle: 英语语法指一 \ndate: 2021-12-02 00:47:53\nupdated: 2021-12-02 00:53:53\ncategories: \n    - study\ntags: \n    - English\n    - Another Tag\n---\n\n## 一.简单句子分析\n&ensp;**英语句子= 主干+修饰成分**\n&ensp;分析句子结构:\n&emsp;&emsp;一个中心 + 两个要点\n&emsp;&emsp;一个中心: 动词. 句子必须右动词\n&emsp;&emsp;两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者.\n&emsp;&emsp;**句子的核心是主谓结构**\n<!--more-->\n&ensp;n个主语+1个谓语 或者 1个主语+n个谓语，就可以组成简单句。其他的定状补语等都是句子的附属成分。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。\n\n\n&ensp;英语的句子结构分为三种:简单句,并列句,复合句.简单句又分为五种基本句型.\n\n{% pullquote mindmap mindmap-md %}\n\n- 英文句子\n    - 简单句\n        - 主 + 谓\n        - 主 + 谓 + 宾\n        - 主 + 谓 + 宾 + 宾补\n        - 主 + 谓 + 间宾 + 直宾\n        - 主 + 系 + 表\n    - 复合句\n        - 名词性从句\n            - 主语从句\n            - 宾语从句\n            - 同位语从句\n            - 表语从句\n        - 定语从句\n        - 状语从句\n            - 时间状语从句\n            - 地点状语从句\n            - 条件状语从句\n            - 结果状语从句\n            - 让步状语从句\n            - 目的状语从句\n    - 特殊句式\n        - 强调句\n        - 虚拟语气\n        - 倒装句\n    - 类型\n        - 陈述句\n        - 祈使句\n        - 感叹句\n        - 疑问句\n    \n{% endpullquote %}\n\n&ensp;英语语法从整体上来讲是通过五部分来组成\n&ensp;&emsp;1、简单句\n&ensp;&emsp;2、并列句、复合句\n&ensp;&emsp;3、三大从句\n&ensp;&emsp;4、特殊句式\n&ensp;&emsp;5、类型\n\n\n补语\n&emsp;补语是和表意不完全的动词息息相关的。在第三种基本句型中，联系动词将主语和补语在某个意义层面上对等起来。\n&emsp;修饰成分\n&emsp;&emsp;介词短语\n&emsp;&emsp;从句\n&emsp;&emsp;非谓语动词\n&emsp;&emsp;时间状语\n&emsp;论主语的补语，而后将宾语的补语作为一种变形来讨论\n\n### 1.1 S + V （主+谓）\n&ensp;句子不可或缺的两部分.\n&emsp;名词/代词/不定式/动名词 + 动词\n&emsp;谓语动词可以表达完整的意思，这类动词为不及物动词（vi）.\n\n### 1.2 S + V + C （主+系+表）\n主语 +系动词 +表语\n\n表语说明主语的状态和性质，可以是名词，形容词，副词，短语等。\n\n系动词包括：\n\na. be 动词，am, is, are, was, were;\n\nb. 表感官：feel(摸起来像是), smell, sound(听起来是), taste(尝起来是), look(看起来是);\n\nc. 表变化：become(成为), grow, turn(转变为), go, get, fall;\n\nd. 表状态：remain(依旧是), keep, hold, stay(仍然是), seem(似乎是).\n\nappear 显得像是\nprove 证实为\nbecome 成为\nmake 作为\n\n\n### 1.3 S + V + O （主+谓+宾）\n\n主语+谓语+宾语\n\n谓语一般为及物动词（vt.），后面必须要跟宾语才能表达完整的意思。宾语是谓语动词动作的承受者。\n\n\n### 1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)）\n\n谓语动词必须要跟两个宾语才能表达完整意思。两个宾语分别是动作的直接承受者（一般是物）和间接承受者（一般是人）。\ne.g.,\n\ngive sb sth = give sth to sb\n\ntell sb sth = tell sth to sb\n\n\n### 1.5 S + V + O + C（主+谓+宾+宾补）\n此种情况，动词虽然跟了宾语，但句子意思不完整，需要跟上一个补足语，对宾语进行解释说明，句子意思才能完整通顺。\n主语的补语用来表示主语是什么。类似地，宾语的补语用来表示宾语是什么。在 S + V + O + C 这个句型当中，宾语和补语之间虽然没有动词存在。但是句子可以变形成：S + V + that + O + V + C 的形式，也就是将原本的宾语和补语以从句的形式出现。因此，可以认为宾语和补语之间有「隐藏的」判断动词「是」的存在。\n\n\nThere be 句型\n\nThere be 句型表示人/物的存在。句子结构，就是There be + 主语+其他部分\n\n1.主语：句子所陈述的对象。\n2.谓语：主语发出的动作。一般是有动作意义的动词。\n3. 宾语：分为动词宾语和介词宾语，属于动作的承受者。\n4. 系动词：表示状态或状态变化的动词，没有实际的动作意义。如 be, 感官系动词（look, sound, smell, taste 和 feel）、保持类系动词（keep, stay 和 remain）、状态变化类系动词（become、get、turn 和 go）等。\n5. 表语：紧跟系动词后面的成分。\n6. 定语：修饰名词或代词的成分。\n7. 状语： 修饰形容词、副词、动词或句子的成分。\n8. 补语：分为宾语补足语和主语补足语。是对宾语和主语的补充说明，与其有主动或被动的逻辑关系。\n\n\n\n- 参考链接:\nhttps://liam.page/2014/06/21/basic-sentence-and-the-complement/\nhttps://www.zhihu.com/question/30030877/answer/768501967\n\n- 参考数据\n《语法俱乐部》\n\n复杂句:从简单句演化而来\n\n简单句没有什么句序的调整，所以翻译起来基本没有什么难度。\n\n英语中的修饰成分，分定语和状语两种情况。\n英语句子 = 主干(五种基本句型) + 修饰成分(定语+状语)\n\n\n## 二、并列句、复合句\n简单句通过不同的连接词就成为了不同的句子，通过并列词成了并列句，通过从属连词成了复合句。下面我们就一一讲解 ：\n\n并列句：简单句+并列词+简单句\n\n并列词一般有：and / or / but / so /while / yet / for / however\n\n1）：表示并列：and, not only...but also... , neither...nor...\n\nHer father is a doctor and her mother is a teacher .\n\n2）：表示选择：or, or else, otherwise, either...or...\n\nHurry or you won't make the train.\n\n3）：表示对比、转折: but, while , yet , however , never ,\n\nI like tea while she likes coffee .\n\n4）：表示原因：for\n\nI am thirsty , for it is hot .\n\n复合句：简单句+从属连词+简单句\n\n从属连词有：that / wether/ if\n\n复合句其实就是我们常说的三大从句，\n\n\n## 三.三大从句\n1、名词性从句\n\n当名词性从句作为句子的不同成分时，又被称呼为不同的名字。\n\n当作为主语时，称为主语从句。\n\n当称为宾语时，称为宾语从句，同样表语从句以及同位语从句。以下我们来举个栗子 ：\n\n主语从句 What she said is wrong .\n\n宾语从句 I said that she was wrong.\n\n表语从句 The fact is that he doesn’t really try.\n\n同位语从句 The news that he will come back is ture.\n\n记住一点，不管什么从句，你把它当成一个”长一点的名词”。\n\n那如果这个长名词在句子中作主语，就是主语从句，作宾语就是宾语从句。\n\n同位语从句就是相当于一个长点的名词对另外一个抽象名词进行解释说明。\n\n2、定语从句\n\n修饰限定名词，汉语中“的”前面的内容。\n\n关系代词引导的定语从句\n\n1.who指人，在从句中做主语 Yesterday I helped an old man who lost his way.\n\n2. whom指人，在定语从句中充当宾语，常可省略。\n\nMr. Ling is just the boy whom I want to see\n\n3. which指物，在定语从句中做主语或者宾语，做宾语时可省略\n\nThis is the pen (which) he bought yesterday.\n\n4. that指人时，相当于who 或者whom；指物时，相当于which。\n\n5. whose通常指人，也可指物，在定语从句中做定语。\n\n指的是谁的。Do you like the book whose cover is yellow?\n\n关系副词引导的定语从句\n\nwhen where why\n\n3、状语从句\n\n修饰动作的发生的时间、地点、原因、方式\n\n九大状语从句\n\n1、时间状语从句\n\n常用引导词：when, as, while, as soon as, before, after, since , till, until\n\n特殊引导词：the minute, the moment, the second, every time, the day，the instant,\n\nI was fat when I was a child.\n\n2、地点状语从句\n\n常用引导词：where\n\n特殊引导词：wherever, anywhere, everywhere\n\nKeep it where you can see it.\n\n3、原因状语从句\n\n常用引导词：because, since, as, for\n\n特殊引导词：seeing that, now that, in that, considering that, given that.\n\nMy friends dislike me because I’m beautiful .\n\n4、目的状语从句\n\n常用引导词：so that, in order that\n\n特殊引导词：lest, in case, for fear that，in the hope that, for the purpose that, to the end that\n\nstudy hard so that you can pass the exam.\n\n5、结果状语从句\n\n常用引导词：so … that, so… that, such … that,\n\n特殊引导词：such that, to the degree that, to the extent that, to such a degree that,\n\nHe got up so early that he caught the first bus.\n\n6、条件状语从句\n\n常用引导词：if, unless,\n\n特殊引导词：as/so long as, only if, providing/provided that, supposing that, in case that, on condition that\n\nIf you ask him, he will help you.\n\n7、方式状语从句\n\n常用引导词：as, as if, how\n\n特殊引导词：the way\n\nThink as i think\n\n8、比较状语从句\n\n常用引导词：as(同级比较), than(不同程度的比较)\n\n特殊引导词：the more … the more … ; just as …， so…; A is to B what /as X is to Y; no … more than; not A so much as B\n\nThe house is three times as big as ours.\n\n9、让步状语从句\n\n常用引导词：though, although, even if, even though\n\n特殊引导词： as(用在让步状语从句中必须要倒装)，while ( 一般用在句首 )，no matter …， in spite of the fact that, while, whatever, whoever, wherever, whenever, however, whichever\n\nThough I believe it, yet I must consider.\n\n\n\n## 四.特殊句式\n\n1、强调句\n\nIt is （名词 / 介宾）指的是被强调的内容that （........）\n\nIt was she whom we are talking about.\n\n2、倒装句\n\n正常句序 ：主谓宾\n\n倒装句序 ：谓主宾\n\nwe can win only through hard work .\n\nonly through hard work can we win .\n\n3、虚拟语气，假设不可能发生的事情\n\n1、对过去情况的虚拟\n\n从句用 had done\n\n主句用 would could might should have done\n\n2、对现在情况的虚拟\n\n从句用 did , was变成were\n\n主句用 would could might should do\n\n3、对将来情况虚拟\n\n从句用 did ，was 变成 were，should do,were to do\n\n主句用 would could might should do\n\n## 五.类型\n陈述句\n\ni like English very much . 我非常喜欢英语。\n\n疑问句\n\nis this your key ? 这是你的钥匙吗？\n\n祈使句\n\n一种是以动词原形开头，在动词原形之前加do (但只限于省略第二人称主语的句子)。\n\nmind you head 小心碰头！\n\n第二种祈使句以let开头\n\nLet's have another try\n\n感叹句\n\nwhat a brave girl ! 真是个勇敢的女孩子\n\n\n\nhttps://zhuanlan.zhihu.com/p/400448345\n\n\n\n\n\n\n","slug":"2021/12/英语语法一","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl10uw8x300250guu2n9acxtw","content":"<h2 id=\"一-简单句子分析\"><a href=\"#一-简单句子分析\" class=\"headerlink\" title=\"一.简单句子分析\"></a>一.简单句子分析</h2><p> <strong>英语句子= 主干+修饰成分</strong><br> 分析句子结构:<br>  一个中心 + 两个要点<br>  一个中心: 动词. 句子必须右动词<br>  两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者.<br>  <strong>句子的核心是主谓结构</strong></p>\n<span id=\"more\"></span>\n<p> n个主语+1个谓语 或者 1个主语+n个谓语，就可以组成简单句。其他的定状补语等都是句子的附属成分。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。</p>\n<p> 英语的句子结构分为三种:简单句,并列句,复合句.简单句又分为五种基本句型.</p>\n<blockquote class=\"pullquote mindmap mindmap-md\"><ul>\n<li>英文句子<ul>\n<li>简单句<ul>\n<li>主 + 谓</li>\n<li>主 + 谓 + 宾</li>\n<li>主 + 谓 + 宾 + 宾补</li>\n<li>主 + 谓 + 间宾 + 直宾</li>\n<li>主 + 系 + 表</li>\n</ul>\n</li>\n<li>复合句<ul>\n<li>名词性从句<ul>\n<li>主语从句</li>\n<li>宾语从句</li>\n<li>同位语从句</li>\n<li>表语从句</li>\n</ul>\n</li>\n<li>定语从句</li>\n<li>状语从句<ul>\n<li>时间状语从句</li>\n<li>地点状语从句</li>\n<li>条件状语从句</li>\n<li>结果状语从句</li>\n<li>让步状语从句</li>\n<li>目的状语从句</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>特殊句式<ul>\n<li>强调句</li>\n<li>虚拟语气</li>\n<li>倒装句</li>\n</ul>\n</li>\n<li>类型<ul>\n<li>陈述句</li>\n<li>祈使句</li>\n<li>感叹句</li>\n<li>疑问句</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n\n<p> 英语语法从整体上来讲是通过五部分来组成<br>  1、简单句<br>  2、并列句、复合句<br>  3、三大从句<br>  4、特殊句式<br>  5、类型</p>\n<p>补语<br> 补语是和表意不完全的动词息息相关的。在第三种基本句型中，联系动词将主语和补语在某个意义层面上对等起来。<br> 修饰成分<br>  介词短语<br>  从句<br>  非谓语动词<br>  时间状语<br> 论主语的补语，而后将宾语的补语作为一种变形来讨论</p>\n<h3 id=\"1-1-S-V-（主-谓）\"><a href=\"#1-1-S-V-（主-谓）\" class=\"headerlink\" title=\"1.1 S + V （主+谓）\"></a>1.1 S + V （主+谓）</h3><p> 句子不可或缺的两部分.<br> 名词/代词/不定式/动名词 + 动词<br> 谓语动词可以表达完整的意思，这类动词为不及物动词（vi）.</p>\n<h3 id=\"1-2-S-V-C-（主-系-表）\"><a href=\"#1-2-S-V-C-（主-系-表）\" class=\"headerlink\" title=\"1.2 S + V + C （主+系+表）\"></a>1.2 S + V + C （主+系+表）</h3><p>主语 +系动词 +表语</p>\n<p>表语说明主语的状态和性质，可以是名词，形容词，副词，短语等。</p>\n<p>系动词包括：</p>\n<p>a. be 动词，am, is, are, was, were;</p>\n<p>b. 表感官：feel(摸起来像是), smell, sound(听起来是), taste(尝起来是), look(看起来是);</p>\n<p>c. 表变化：become(成为), grow, turn(转变为), go, get, fall;</p>\n<p>d. 表状态：remain(依旧是), keep, hold, stay(仍然是), seem(似乎是).</p>\n<p>appear 显得像是<br>prove 证实为<br>become 成为<br>make 作为</p>\n<h3 id=\"1-3-S-V-O-（主-谓-宾）\"><a href=\"#1-3-S-V-O-（主-谓-宾）\" class=\"headerlink\" title=\"1.3 S + V + O （主+谓+宾）\"></a>1.3 S + V + O （主+谓+宾）</h3><p>主语+谓语+宾语</p>\n<p>谓语一般为及物动词（vt.），后面必须要跟宾语才能表达完整的意思。宾语是谓语动词动作的承受者。</p>\n<h3 id=\"1-4-S-V-O-O（主-谓-间宾-人-直宾-物-）\"><a href=\"#1-4-S-V-O-O（主-谓-间宾-人-直宾-物-）\" class=\"headerlink\" title=\"1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)）\"></a>1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)）</h3><p>谓语动词必须要跟两个宾语才能表达完整意思。两个宾语分别是动作的直接承受者（一般是物）和间接承受者（一般是人）。<br>e.g.,</p>\n<p>give sb sth = give sth to sb</p>\n<p>tell sb sth = tell sth to sb</p>\n<h3 id=\"1-5-S-V-O-C（主-谓-宾-宾补）\"><a href=\"#1-5-S-V-O-C（主-谓-宾-宾补）\" class=\"headerlink\" title=\"1.5 S + V + O + C（主+谓+宾+宾补）\"></a>1.5 S + V + O + C（主+谓+宾+宾补）</h3><p>此种情况，动词虽然跟了宾语，但句子意思不完整，需要跟上一个补足语，对宾语进行解释说明，句子意思才能完整通顺。<br>主语的补语用来表示主语是什么。类似地，宾语的补语用来表示宾语是什么。在 S + V + O + C 这个句型当中，宾语和补语之间虽然没有动词存在。但是句子可以变形成：S + V + that + O + V + C 的形式，也就是将原本的宾语和补语以从句的形式出现。因此，可以认为宾语和补语之间有「隐藏的」判断动词「是」的存在。</p>\n<p>There be 句型</p>\n<p>There be 句型表示人/物的存在。句子结构，就是There be + 主语+其他部分</p>\n<p>1.主语：句子所陈述的对象。<br>2.谓语：主语发出的动作。一般是有动作意义的动词。<br>3. 宾语：分为动词宾语和介词宾语，属于动作的承受者。<br>4. 系动词：表示状态或状态变化的动词，没有实际的动作意义。如 be, 感官系动词（look, sound, smell, taste 和 feel）、保持类系动词（keep, stay 和 remain）、状态变化类系动词（become、get、turn 和 go）等。<br>5. 表语：紧跟系动词后面的成分。<br>6. 定语：修饰名词或代词的成分。<br>7. 状语： 修饰形容词、副词、动词或句子的成分。<br>8. 补语：分为宾语补足语和主语补足语。是对宾语和主语的补充说明，与其有主动或被动的逻辑关系。</p>\n<ul>\n<li><p>参考链接:<br><a href=\"https://liam.page/2014/06/21/basic-sentence-and-the-complement/\">https://liam.page/2014/06/21/basic-sentence-and-the-complement/</a><br><a href=\"https://www.zhihu.com/question/30030877/answer/768501967\">https://www.zhihu.com/question/30030877/answer/768501967</a></p>\n</li>\n<li><p>参考数据<br>《语法俱乐部》</p>\n</li>\n</ul>\n<p>复杂句:从简单句演化而来</p>\n<p>简单句没有什么句序的调整，所以翻译起来基本没有什么难度。</p>\n<p>英语中的修饰成分，分定语和状语两种情况。<br>英语句子 = 主干(五种基本句型) + 修饰成分(定语+状语)</p>\n<h2 id=\"二、并列句、复合句\"><a href=\"#二、并列句、复合句\" class=\"headerlink\" title=\"二、并列句、复合句\"></a>二、并列句、复合句</h2><p>简单句通过不同的连接词就成为了不同的句子，通过并列词成了并列句，通过从属连词成了复合句。下面我们就一一讲解 ：</p>\n<p>并列句：简单句+并列词+简单句</p>\n<p>并列词一般有：and / or / but / so /while / yet / for / however</p>\n<p>1）：表示并列：and, not only…but also… , neither…nor…</p>\n<p>Her father is a doctor and her mother is a teacher .</p>\n<p>2）：表示选择：or, or else, otherwise, either…or…</p>\n<p>Hurry or you won’t make the train.</p>\n<p>3）：表示对比、转折: but, while , yet , however , never ,</p>\n<p>I like tea while she likes coffee .</p>\n<p>4）：表示原因：for</p>\n<p>I am thirsty , for it is hot .</p>\n<p>复合句：简单句+从属连词+简单句</p>\n<p>从属连词有：that / wether/ if</p>\n<p>复合句其实就是我们常说的三大从句，</p>\n<h2 id=\"三-三大从句\"><a href=\"#三-三大从句\" class=\"headerlink\" title=\"三.三大从句\"></a>三.三大从句</h2><p>1、名词性从句</p>\n<p>当名词性从句作为句子的不同成分时，又被称呼为不同的名字。</p>\n<p>当作为主语时，称为主语从句。</p>\n<p>当称为宾语时，称为宾语从句，同样表语从句以及同位语从句。以下我们来举个栗子 ：</p>\n<p>主语从句 What she said is wrong .</p>\n<p>宾语从句 I said that she was wrong.</p>\n<p>表语从句 The fact is that he doesn’t really try.</p>\n<p>同位语从句 The news that he will come back is ture.</p>\n<p>记住一点，不管什么从句，你把它当成一个”长一点的名词”。</p>\n<p>那如果这个长名词在句子中作主语，就是主语从句，作宾语就是宾语从句。</p>\n<p>同位语从句就是相当于一个长点的名词对另外一个抽象名词进行解释说明。</p>\n<p>2、定语从句</p>\n<p>修饰限定名词，汉语中“的”前面的内容。</p>\n<p>关系代词引导的定语从句</p>\n<p>1.who指人，在从句中做主语 Yesterday I helped an old man who lost his way.</p>\n<p>2. whom指人，在定语从句中充当宾语，常可省略。</p>\n<p>Mr. Ling is just the boy whom I want to see</p>\n<p>3. which指物，在定语从句中做主语或者宾语，做宾语时可省略</p>\n<p>This is the pen (which) he bought yesterday.</p>\n<p>4. that指人时，相当于who 或者whom；指物时，相当于which。</p>\n<p>5. whose通常指人，也可指物，在定语从句中做定语。</p>\n<p>指的是谁的。Do you like the book whose cover is yellow?</p>\n<p>关系副词引导的定语从句</p>\n<p>when where why</p>\n<p>3、状语从句</p>\n<p>修饰动作的发生的时间、地点、原因、方式</p>\n<p>九大状语从句</p>\n<p>1、时间状语从句</p>\n<p>常用引导词：when, as, while, as soon as, before, after, since , till, until</p>\n<p>特殊引导词：the minute, the moment, the second, every time, the day，the instant,</p>\n<p>I was fat when I was a child.</p>\n<p>2、地点状语从句</p>\n<p>常用引导词：where</p>\n<p>特殊引导词：wherever, anywhere, everywhere</p>\n<p>Keep it where you can see it.</p>\n<p>3、原因状语从句</p>\n<p>常用引导词：because, since, as, for</p>\n<p>特殊引导词：seeing that, now that, in that, considering that, given that.</p>\n<p>My friends dislike me because I’m beautiful .</p>\n<p>4、目的状语从句</p>\n<p>常用引导词：so that, in order that</p>\n<p>特殊引导词：lest, in case, for fear that，in the hope that, for the purpose that, to the end that</p>\n<p>study hard so that you can pass the exam.</p>\n<p>5、结果状语从句</p>\n<p>常用引导词：so … that, so… that, such … that,</p>\n<p>特殊引导词：such that, to the degree that, to the extent that, to such a degree that,</p>\n<p>He got up so early that he caught the first bus.</p>\n<p>6、条件状语从句</p>\n<p>常用引导词：if, unless,</p>\n<p>特殊引导词：as/so long as, only if, providing/provided that, supposing that, in case that, on condition that</p>\n<p>If you ask him, he will help you.</p>\n<p>7、方式状语从句</p>\n<p>常用引导词：as, as if, how</p>\n<p>特殊引导词：the way</p>\n<p>Think as i think</p>\n<p>8、比较状语从句</p>\n<p>常用引导词：as(同级比较), than(不同程度的比较)</p>\n<p>特殊引导词：the more … the more … ; just as …， so…; A is to B what /as X is to Y; no … more than; not A so much as B</p>\n<p>The house is three times as big as ours.</p>\n<p>9、让步状语从句</p>\n<p>常用引导词：though, although, even if, even though</p>\n<p>特殊引导词： as(用在让步状语从句中必须要倒装)，while ( 一般用在句首 )，no matter …， in spite of the fact that, while, whatever, whoever, wherever, whenever, however, whichever</p>\n<p>Though I believe it, yet I must consider.</p>\n<h2 id=\"四-特殊句式\"><a href=\"#四-特殊句式\" class=\"headerlink\" title=\"四.特殊句式\"></a>四.特殊句式</h2><p>1、强调句</p>\n<p>It is （名词 / 介宾）指的是被强调的内容that （……..）</p>\n<p>It was she whom we are talking about.</p>\n<p>2、倒装句</p>\n<p>正常句序 ：主谓宾</p>\n<p>倒装句序 ：谓主宾</p>\n<p>we can win only through hard work .</p>\n<p>only through hard work can we win .</p>\n<p>3、虚拟语气，假设不可能发生的事情</p>\n<p>1、对过去情况的虚拟</p>\n<p>从句用 had done</p>\n<p>主句用 would could might should have done</p>\n<p>2、对现在情况的虚拟</p>\n<p>从句用 did , was变成were</p>\n<p>主句用 would could might should do</p>\n<p>3、对将来情况虚拟</p>\n<p>从句用 did ，was 变成 were，should do,were to do</p>\n<p>主句用 would could might should do</p>\n<h2 id=\"五-类型\"><a href=\"#五-类型\" class=\"headerlink\" title=\"五.类型\"></a>五.类型</h2><p>陈述句</p>\n<p>i like English very much . 我非常喜欢英语。</p>\n<p>疑问句</p>\n<p>is this your key ? 这是你的钥匙吗？</p>\n<p>祈使句</p>\n<p>一种是以动词原形开头，在动词原形之前加do (但只限于省略第二人称主语的句子)。</p>\n<p>mind you head 小心碰头！</p>\n<p>第二种祈使句以let开头</p>\n<p>Let’s have another try</p>\n<p>感叹句</p>\n<p>what a brave girl ! 真是个勇敢的女孩子</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/400448345\">https://zhuanlan.zhihu.com/p/400448345</a></p>\n<script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css\">","site":{"data":{}},"abbrlink":"36KZGTE","length":4930,"excerpt":"<h2 id=\"一-简单句子分析\"><a href=\"#一-简单句子分析\" class=\"headerlink\" title=\"一.简单句子分析\"></a>一.简单句子分析</h2><p> <strong>英语句子= 主干+修饰成分</strong><br> 分析句子结构:<br>  一个中心 + 两个要点<br>  一个中心: 动词. 句子必须右动词<br>  两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者.<br>  <strong>句子的核心是主谓结构</strong></p>","more":"<p>&ensp;n个主语+1个谓语 或者 1个主语+n个谓语，就可以组成简单句。其他的定状补语等都是句子的附属成分。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。</p>\n<p>&ensp;英语的句子结构分为三种:简单句,并列句,复合句.简单句又分为五种基本句型.</p>\n<blockquote class=\"pullquote mindmap mindmap-md\"><ul>\n<li>英文句子<ul>\n<li>简单句<ul>\n<li>主 + 谓</li>\n<li>主 + 谓 + 宾</li>\n<li>主 + 谓 + 宾 + 宾补</li>\n<li>主 + 谓 + 间宾 + 直宾</li>\n<li>主 + 系 + 表</li>\n</ul>\n</li>\n<li>复合句<ul>\n<li>名词性从句<ul>\n<li>主语从句</li>\n<li>宾语从句</li>\n<li>同位语从句</li>\n<li>表语从句</li>\n</ul>\n</li>\n<li>定语从句</li>\n<li>状语从句<ul>\n<li>时间状语从句</li>\n<li>地点状语从句</li>\n<li>条件状语从句</li>\n<li>结果状语从句</li>\n<li>让步状语从句</li>\n<li>目的状语从句</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>特殊句式<ul>\n<li>强调句</li>\n<li>虚拟语气</li>\n<li>倒装句</li>\n</ul>\n</li>\n<li>类型<ul>\n<li>陈述句</li>\n<li>祈使句</li>\n<li>感叹句</li>\n<li>疑问句</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n\n<p>&ensp;英语语法从整体上来讲是通过五部分来组成<br>&ensp;&emsp;1、简单句<br>&ensp;&emsp;2、并列句、复合句<br>&ensp;&emsp;3、三大从句<br>&ensp;&emsp;4、特殊句式<br>&ensp;&emsp;5、类型</p>\n<p>补语<br>&emsp;补语是和表意不完全的动词息息相关的。在第三种基本句型中，联系动词将主语和补语在某个意义层面上对等起来。<br>&emsp;修饰成分<br>&emsp;&emsp;介词短语<br>&emsp;&emsp;从句<br>&emsp;&emsp;非谓语动词<br>&emsp;&emsp;时间状语<br>&emsp;论主语的补语，而后将宾语的补语作为一种变形来讨论</p>\n<h3 id=\"1-1-S-V-（主-谓）\"><a href=\"#1-1-S-V-（主-谓）\" class=\"headerlink\" title=\"1.1 S + V （主+谓）\"></a>1.1 S + V （主+谓）</h3><p>&ensp;句子不可或缺的两部分.<br>&emsp;名词/代词/不定式/动名词 + 动词<br>&emsp;谓语动词可以表达完整的意思，这类动词为不及物动词（vi）.</p>\n<h3 id=\"1-2-S-V-C-（主-系-表）\"><a href=\"#1-2-S-V-C-（主-系-表）\" class=\"headerlink\" title=\"1.2 S + V + C （主+系+表）\"></a>1.2 S + V + C （主+系+表）</h3><p>主语 +系动词 +表语</p>\n<p>表语说明主语的状态和性质，可以是名词，形容词，副词，短语等。</p>\n<p>系动词包括：</p>\n<p>a. be 动词，am, is, are, was, were;</p>\n<p>b. 表感官：feel(摸起来像是), smell, sound(听起来是), taste(尝起来是), look(看起来是);</p>\n<p>c. 表变化：become(成为), grow, turn(转变为), go, get, fall;</p>\n<p>d. 表状态：remain(依旧是), keep, hold, stay(仍然是), seem(似乎是).</p>\n<p>appear 显得像是<br>prove 证实为<br>become 成为<br>make 作为</p>\n<h3 id=\"1-3-S-V-O-（主-谓-宾）\"><a href=\"#1-3-S-V-O-（主-谓-宾）\" class=\"headerlink\" title=\"1.3 S + V + O （主+谓+宾）\"></a>1.3 S + V + O （主+谓+宾）</h3><p>主语+谓语+宾语</p>\n<p>谓语一般为及物动词（vt.），后面必须要跟宾语才能表达完整的意思。宾语是谓语动词动作的承受者。</p>\n<h3 id=\"1-4-S-V-O-O（主-谓-间宾-人-直宾-物-）\"><a href=\"#1-4-S-V-O-O（主-谓-间宾-人-直宾-物-）\" class=\"headerlink\" title=\"1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)）\"></a>1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)）</h3><p>谓语动词必须要跟两个宾语才能表达完整意思。两个宾语分别是动作的直接承受者（一般是物）和间接承受者（一般是人）。<br>e.g.,</p>\n<p>give sb sth = give sth to sb</p>\n<p>tell sb sth = tell sth to sb</p>\n<h3 id=\"1-5-S-V-O-C（主-谓-宾-宾补）\"><a href=\"#1-5-S-V-O-C（主-谓-宾-宾补）\" class=\"headerlink\" title=\"1.5 S + V + O + C（主+谓+宾+宾补）\"></a>1.5 S + V + O + C（主+谓+宾+宾补）</h3><p>此种情况，动词虽然跟了宾语，但句子意思不完整，需要跟上一个补足语，对宾语进行解释说明，句子意思才能完整通顺。<br>主语的补语用来表示主语是什么。类似地，宾语的补语用来表示宾语是什么。在 S + V + O + C 这个句型当中，宾语和补语之间虽然没有动词存在。但是句子可以变形成：S + V + that + O + V + C 的形式，也就是将原本的宾语和补语以从句的形式出现。因此，可以认为宾语和补语之间有「隐藏的」判断动词「是」的存在。</p>\n<p>There be 句型</p>\n<p>There be 句型表示人/物的存在。句子结构，就是There be + 主语+其他部分</p>\n<p>1.主语：句子所陈述的对象。<br>2.谓语：主语发出的动作。一般是有动作意义的动词。<br>3. 宾语：分为动词宾语和介词宾语，属于动作的承受者。<br>4. 系动词：表示状态或状态变化的动词，没有实际的动作意义。如 be, 感官系动词（look, sound, smell, taste 和 feel）、保持类系动词（keep, stay 和 remain）、状态变化类系动词（become、get、turn 和 go）等。<br>5. 表语：紧跟系动词后面的成分。<br>6. 定语：修饰名词或代词的成分。<br>7. 状语： 修饰形容词、副词、动词或句子的成分。<br>8. 补语：分为宾语补足语和主语补足语。是对宾语和主语的补充说明，与其有主动或被动的逻辑关系。</p>\n<ul>\n<li><p>参考链接:<br><a href=\"https://liam.page/2014/06/21/basic-sentence-and-the-complement/\">https://liam.page/2014/06/21/basic-sentence-and-the-complement/</a><br><a href=\"https://www.zhihu.com/question/30030877/answer/768501967\">https://www.zhihu.com/question/30030877/answer/768501967</a></p>\n</li>\n<li><p>参考数据<br>《语法俱乐部》</p>\n</li>\n</ul>\n<p>复杂句:从简单句演化而来</p>\n<p>简单句没有什么句序的调整，所以翻译起来基本没有什么难度。</p>\n<p>英语中的修饰成分，分定语和状语两种情况。<br>英语句子 = 主干(五种基本句型) + 修饰成分(定语+状语)</p>\n<h2 id=\"二、并列句、复合句\"><a href=\"#二、并列句、复合句\" class=\"headerlink\" title=\"二、并列句、复合句\"></a>二、并列句、复合句</h2><p>简单句通过不同的连接词就成为了不同的句子，通过并列词成了并列句，通过从属连词成了复合句。下面我们就一一讲解 ：</p>\n<p>并列句：简单句+并列词+简单句</p>\n<p>并列词一般有：and / or / but / so /while / yet / for / however</p>\n<p>1）：表示并列：and, not only…but also… , neither…nor…</p>\n<p>Her father is a doctor and her mother is a teacher .</p>\n<p>2）：表示选择：or, or else, otherwise, either…or…</p>\n<p>Hurry or you won’t make the train.</p>\n<p>3）：表示对比、转折: but, while , yet , however , never ,</p>\n<p>I like tea while she likes coffee .</p>\n<p>4）：表示原因：for</p>\n<p>I am thirsty , for it is hot .</p>\n<p>复合句：简单句+从属连词+简单句</p>\n<p>从属连词有：that / wether/ if</p>\n<p>复合句其实就是我们常说的三大从句，</p>\n<h2 id=\"三-三大从句\"><a href=\"#三-三大从句\" class=\"headerlink\" title=\"三.三大从句\"></a>三.三大从句</h2><p>1、名词性从句</p>\n<p>当名词性从句作为句子的不同成分时，又被称呼为不同的名字。</p>\n<p>当作为主语时，称为主语从句。</p>\n<p>当称为宾语时，称为宾语从句，同样表语从句以及同位语从句。以下我们来举个栗子 ：</p>\n<p>主语从句 What she said is wrong .</p>\n<p>宾语从句 I said that she was wrong.</p>\n<p>表语从句 The fact is that he doesn’t really try.</p>\n<p>同位语从句 The news that he will come back is ture.</p>\n<p>记住一点，不管什么从句，你把它当成一个”长一点的名词”。</p>\n<p>那如果这个长名词在句子中作主语，就是主语从句，作宾语就是宾语从句。</p>\n<p>同位语从句就是相当于一个长点的名词对另外一个抽象名词进行解释说明。</p>\n<p>2、定语从句</p>\n<p>修饰限定名词，汉语中“的”前面的内容。</p>\n<p>关系代词引导的定语从句</p>\n<p>1.who指人，在从句中做主语 Yesterday I helped an old man who lost his way.</p>\n<p>2. whom指人，在定语从句中充当宾语，常可省略。</p>\n<p>Mr. Ling is just the boy whom I want to see</p>\n<p>3. which指物，在定语从句中做主语或者宾语，做宾语时可省略</p>\n<p>This is the pen (which) he bought yesterday.</p>\n<p>4. that指人时，相当于who 或者whom；指物时，相当于which。</p>\n<p>5. whose通常指人，也可指物，在定语从句中做定语。</p>\n<p>指的是谁的。Do you like the book whose cover is yellow?</p>\n<p>关系副词引导的定语从句</p>\n<p>when where why</p>\n<p>3、状语从句</p>\n<p>修饰动作的发生的时间、地点、原因、方式</p>\n<p>九大状语从句</p>\n<p>1、时间状语从句</p>\n<p>常用引导词：when, as, while, as soon as, before, after, since , till, until</p>\n<p>特殊引导词：the minute, the moment, the second, every time, the day，the instant,</p>\n<p>I was fat when I was a child.</p>\n<p>2、地点状语从句</p>\n<p>常用引导词：where</p>\n<p>特殊引导词：wherever, anywhere, everywhere</p>\n<p>Keep it where you can see it.</p>\n<p>3、原因状语从句</p>\n<p>常用引导词：because, since, as, for</p>\n<p>特殊引导词：seeing that, now that, in that, considering that, given that.</p>\n<p>My friends dislike me because I’m beautiful .</p>\n<p>4、目的状语从句</p>\n<p>常用引导词：so that, in order that</p>\n<p>特殊引导词：lest, in case, for fear that，in the hope that, for the purpose that, to the end that</p>\n<p>study hard so that you can pass the exam.</p>\n<p>5、结果状语从句</p>\n<p>常用引导词：so … that, so… that, such … that,</p>\n<p>特殊引导词：such that, to the degree that, to the extent that, to such a degree that,</p>\n<p>He got up so early that he caught the first bus.</p>\n<p>6、条件状语从句</p>\n<p>常用引导词：if, unless,</p>\n<p>特殊引导词：as/so long as, only if, providing/provided that, supposing that, in case that, on condition that</p>\n<p>If you ask him, he will help you.</p>\n<p>7、方式状语从句</p>\n<p>常用引导词：as, as if, how</p>\n<p>特殊引导词：the way</p>\n<p>Think as i think</p>\n<p>8、比较状语从句</p>\n<p>常用引导词：as(同级比较), than(不同程度的比较)</p>\n<p>特殊引导词：the more … the more … ; just as …， so…; A is to B what /as X is to Y; no … more than; not A so much as B</p>\n<p>The house is three times as big as ours.</p>\n<p>9、让步状语从句</p>\n<p>常用引导词：though, although, even if, even though</p>\n<p>特殊引导词： as(用在让步状语从句中必须要倒装)，while ( 一般用在句首 )，no matter …， in spite of the fact that, while, whatever, whoever, wherever, whenever, however, whichever</p>\n<p>Though I believe it, yet I must consider.</p>\n<h2 id=\"四-特殊句式\"><a href=\"#四-特殊句式\" class=\"headerlink\" title=\"四.特殊句式\"></a>四.特殊句式</h2><p>1、强调句</p>\n<p>It is （名词 / 介宾）指的是被强调的内容that （……..）</p>\n<p>It was she whom we are talking about.</p>\n<p>2、倒装句</p>\n<p>正常句序 ：主谓宾</p>\n<p>倒装句序 ：谓主宾</p>\n<p>we can win only through hard work .</p>\n<p>only through hard work can we win .</p>\n<p>3、虚拟语气，假设不可能发生的事情</p>\n<p>1、对过去情况的虚拟</p>\n<p>从句用 had done</p>\n<p>主句用 would could might should have done</p>\n<p>2、对现在情况的虚拟</p>\n<p>从句用 did , was变成were</p>\n<p>主句用 would could might should do</p>\n<p>3、对将来情况虚拟</p>\n<p>从句用 did ，was 变成 were，should do,were to do</p>\n<p>主句用 would could might should do</p>\n<h2 id=\"五-类型\"><a href=\"#五-类型\" class=\"headerlink\" title=\"五.类型\"></a>五.类型</h2><p>陈述句</p>\n<p>i like English very much . 我非常喜欢英语。</p>\n<p>疑问句</p>\n<p>is this your key ? 这是你的钥匙吗？</p>\n<p>祈使句</p>\n<p>一种是以动词原形开头，在动词原形之前加do (但只限于省略第二人称主语的句子)。</p>\n<p>mind you head 小心碰头！</p>\n<p>第二种祈使句以let开头</p>\n<p>Let’s have another try</p>\n<p>感叹句</p>\n<p>what a brave girl ! 真是个勇敢的女孩子</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/400448345\">https://zhuanlan.zhihu.com/p/400448345</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cl10uw8uq00010guu80qyfien","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8vg000h0guuf6sk2rwr"},{"post_id":"cl10uw8v8000b0guu4kp4apw3","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8vj000k0guuf7cb0gxr"},{"post_id":"cl10uw8vc000e0guu78qy3x9e","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8vm000n0guuaiml5f0h"},{"post_id":"cl10uw8uw00030guug70xcdow","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8vp000r0guu1zfdbsmj"},{"post_id":"cl10uw8ve000f0guu98z98h5n","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8vs000u0guuh9ybhyof"},{"post_id":"cl10uw8vi000j0guu8qo7eait","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8vv000y0guug9bzh5it"},{"post_id":"cl10uw8v200070guu7p4kfzfe","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8vw00110guuhd4x3kad"},{"post_id":"cl10uw8vl000m0guuhbx0c49k","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8vy00150guu7n12bi1m"},{"post_id":"cl10uw8vo000q0guu5ets0c17","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8vz00170guuccjs4fk2"},{"post_id":"cl10uw8vq000t0guu41xb81dr","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8w0001a0guug3md93rx"},{"post_id":"cl10uw8vu000x0guuednhaunb","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8w1001c0guudpbt4t35"},{"post_id":"cl10uw8vv00100guuc7j8chng","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8w1001f0guuftl08mxk"},{"post_id":"cl10uw8vx00140guu0nn1ag0q","category_id":"cl10uw8uz00040guubnp0a87i","_id":"cl10uw8w2001h0guug83ib7w8"},{"post_id":"cl10uw8x300250guu2n9acxtw","category_id":"cl10uw8x400260guuamts1l2k","_id":"cl10uw8xn002a0guu6g0raz77"},{"post_id":"cl10uw8v8000b0guu4kp4apw3","category_id":"cl10uw9ae002b0guu08c99vas","_id":"cl10uw9gn002e0guu92precez"},{"post_id":"cl10uw8vc000e0guu78qy3x9e","category_id":"cl10uw9ae002b0guu08c99vas","_id":"cl10uw9go002g0guu1e31fjsn"},{"post_id":"cl10uw8ve000f0guu98z98h5n","category_id":"cl10uw9ae002b0guu08c99vas","_id":"cl10uw9gp002i0guua0mzevl0"},{"post_id":"cl10uw8vi000j0guu8qo7eait","category_id":"cl10uw9ae002b0guu08c99vas","_id":"cl10uw9gq002k0guu0afk2rhn"},{"post_id":"cl10uw8vl000m0guuhbx0c49k","category_id":"cl10uw9ae002b0guu08c99vas","_id":"cl10uw9gq002l0guu4qek76h1"},{"post_id":"cl10uw8vo000q0guu5ets0c17","category_id":"cl10uw9gp002j0guuc7nlgz3a","_id":"cl10uw9gt002s0guu8hd93901"},{"post_id":"cl10uw8vo000q0guu5ets0c17","category_id":"cl10uw9gs002q0guu0p3y6ltx","_id":"cl10uw9gt002u0guuhbafg32s"},{"post_id":"cl10uw8vu000x0guuednhaunb","category_id":"cl10uw9gp002j0guuc7nlgz3a","_id":"cl10uw9gu002w0guu8jy7hxvd"},{"post_id":"cl10uw8vu000x0guuednhaunb","category_id":"cl10uw9gs002r0guu0rqsd81n","_id":"cl10uw9gu002x0guu9pdq1sw6"},{"post_id":"cl10uw8vv00100guuc7j8chng","category_id":"cl10uw9gp002j0guuc7nlgz3a","_id":"cl10uw9gv002z0guu14te1ig0"},{"post_id":"cl10uw8vv00100guuc7j8chng","category_id":"cl10uw9gs002r0guu0rqsd81n","_id":"cl10uw9gv00300guuc5wf1b6m"},{"post_id":"cl10uw8vx00140guu0nn1ag0q","category_id":"cl10uw9gp002j0guuc7nlgz3a","_id":"cl10uw9gv00310guu209naz1f"},{"post_id":"cl10uw8vx00140guu0nn1ag0q","category_id":"cl10uw9gs002q0guu0p3y6ltx","_id":"cl10uw9gv00320guufgchci8h"},{"post_id":"cl10uw8x300250guu2n9acxtw","category_id":"cl10uw9gr002p0guu2gb4hxnd","_id":"cl10uw9gv00330guu42rmgxve"},{"post_id":"cl10uw8x300250guu2n9acxtw","category_id":"cl10uw9gu002y0guubt2n2u4g","_id":"cl10uw9gv00340guu4oqxfm8p"}],"PostTag":[{"post_id":"cl10uw8uq00010guu80qyfien","tag_id":"cl10uw8v100050guu50d8g80p","_id":"cl10uw8vk000l0guu2fqi9m4b"},{"post_id":"cl10uw8uq00010guu80qyfien","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8vm000o0guu5ivx0d18"},{"post_id":"cl10uw8ve000f0guu98z98h5n","tag_id":"cl10uw8v100050guu50d8g80p","_id":"cl10uw8vp000s0guu5fzu8hxp"},{"post_id":"cl10uw8ve000f0guu98z98h5n","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8vs000v0guuee3l93ys"},{"post_id":"cl10uw8vl000m0guuhbx0c49k","tag_id":"cl10uw8v100050guu50d8g80p","_id":"cl10uw8vv000z0guudoc63oxy"},{"post_id":"cl10uw8vl000m0guuhbx0c49k","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8vw00120guueowigerg"},{"post_id":"cl10uw8uw00030guug70xcdow","tag_id":"cl10uw8v100050guu50d8g80p","_id":"cl10uw8vy00160guu7x1ng3cu"},{"post_id":"cl10uw8uw00030guug70xcdow","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8vz00180guudnctbde1"},{"post_id":"cl10uw8vq000t0guu41xb81dr","tag_id":"cl10uw8v100050guu50d8g80p","_id":"cl10uw8w0001b0guucxugck7t"},{"post_id":"cl10uw8vq000t0guu41xb81dr","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8w1001d0guu4xu6afz4"},{"post_id":"cl10uw8vu000x0guuednhaunb","tag_id":"cl10uw8v100050guu50d8g80p","_id":"cl10uw8w2001g0guu5dm5hv4v"},{"post_id":"cl10uw8vu000x0guuednhaunb","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8w2001i0guug6594bdk"},{"post_id":"cl10uw8v200070guu7p4kfzfe","tag_id":"cl10uw8v100050guu50d8g80p","_id":"cl10uw8w3001k0guu6p543rxc"},{"post_id":"cl10uw8v200070guu7p4kfzfe","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8w3001l0guu99bl60yl"},{"post_id":"cl10uw8v8000b0guu4kp4apw3","tag_id":"cl10uw8v100050guu50d8g80p","_id":"cl10uw8w4001n0guu2w9wfz46"},{"post_id":"cl10uw8v8000b0guu4kp4apw3","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8w4001o0guu05o323m9"},{"post_id":"cl10uw8vc000e0guu78qy3x9e","tag_id":"cl10uw8w1001e0guueqot7beg","_id":"cl10uw8w5001q0guufezt3yj7"},{"post_id":"cl10uw8vc000e0guu78qy3x9e","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8w5001r0guu3v728yes"},{"post_id":"cl10uw8vi000j0guu8qo7eait","tag_id":"cl10uw8w1001e0guueqot7beg","_id":"cl10uw8w5001t0guuevf57kda"},{"post_id":"cl10uw8vi000j0guu8qo7eait","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8w6001u0guub380c3rc"},{"post_id":"cl10uw8vo000q0guu5ets0c17","tag_id":"cl10uw8w3001m0guu3vzub3tl","_id":"cl10uw8w6001w0guug1uzh0q8"},{"post_id":"cl10uw8vo000q0guu5ets0c17","tag_id":"cl10uw8w4001p0guu05ynez2c","_id":"cl10uw8w7001x0guu1j8t2177"},{"post_id":"cl10uw8vv00100guuc7j8chng","tag_id":"cl10uw8w1001e0guueqot7beg","_id":"cl10uw8w7001y0guu54uo98ql"},{"post_id":"cl10uw8vv00100guuc7j8chng","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8w800200guucbk9bpsd"},{"post_id":"cl10uw8vx00140guu0nn1ag0q","tag_id":"cl10uw8w6001v0guu6pixgd25","_id":"cl10uw8w900220guu3bye81co"},{"post_id":"cl10uw8vx00140guu0nn1ag0q","tag_id":"cl10uw8w4001p0guu05ynez2c","_id":"cl10uw8w900230guubpida6zt"},{"post_id":"cl10uw8vx00140guu0nn1ag0q","tag_id":"cl10uw8w800210guufyq94v07","_id":"cl10uw8w900240guucwb92p72"},{"post_id":"cl10uw8x300250guu2n9acxtw","tag_id":"cl10uw8x500270guu55q4fvha","_id":"cl10uw8x900280guugciv8g76"},{"post_id":"cl10uw8x300250guu2n9acxtw","tag_id":"cl10uw8v9000d0guugvkw32p0","_id":"cl10uw8xn00290guu7j1hfqfk"}],"Tag":[{"name":"实用教程","_id":"cl10uw8v100050guu50d8g80p"},{"name":"Another Tag","_id":"cl10uw8v9000d0guugvkw32p0"},{"name":"Computer Science","_id":"cl10uw8w1001e0guueqot7beg"},{"name":"c/c++","_id":"cl10uw8w3001m0guu3vzub3tl"},{"name":"cs","_id":"cl10uw8w4001p0guu05ynez2c"},{"name":"complier","_id":"cl10uw8w6001v0guu6pixgd25"},{"name":"cmake","_id":"cl10uw8w800210guufyq94v07"},{"name":"English","_id":"cl10uw8x500270guu55q4fvha"}]}}