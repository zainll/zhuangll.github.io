<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Software&amp;Tool</title>
    <url>/2021/10/26/Software&amp;Tool/</url>
    <content><![CDATA[<h2 id="GitHub-Pages-Hexo使用及配置"><a href="#GitHub-Pages-Hexo使用及配置" class="headerlink" title="GitHub Pages + Hexo使用及配置"></a>GitHub Pages + Hexo使用及配置</h2><p>github上创建一个  username.github.io 的工程，username 必须为github的用户名</p>
<span id="more"></span>

<h3 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h3><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 清理缓存</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="comment"># 生成网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 启动本地服务端口</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="comment"># 发布到github</span></span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制推送备份源码分支</span></span><br><span class="line">git push -f origin backup</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/f82c76b90336">https://www.jianshu.com/p/f82c76b90336</a></p>
<p><a href="https://www.jianshu.com/p/5d0b31032d55">https://www.jianshu.com/p/5d0b31032d55</a></p>
<p><a href="https://blog.csdn.net/weixin_41922289/article/details/95639870">https://blog.csdn.net/weixin_41922289/article/details/95639870</a></p>
<p><a href="https://theme-next.org/">https://theme-next.org/</a></p>
<p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc">https://www.jianshu.com/p/3a05351a37dc</a></p>
<p><a href="https://www.zhyong.cn/posts/ca02/">https://www.zhyong.cn/posts/ca02/</a></p>
<p><a href="http://theme-next.iissnan.com/">http://theme-next.iissnan.com/</a></p>
<p><a href="https://liam.page/">https://liam.page/</a></p>
<p><a href="https://liam.page/en/">https://liam.page/en/</a></p>
<ul>
<li>Hexo博客添加helper-live2d动态模型插件<br><a href="https://blog.csdn.net/qq_30930805/article/details/">https://blog.csdn.net/qq_30930805/article/details/</a></li>
</ul>
<h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><h3 id="vscode-上传图片"><a href="#vscode-上传图片" class="headerlink" title="vscode 上传图片"></a>vscode 上传图片</h3><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 上传剪贴板中的图片到服务器。</span></span><br><span class="line">ctrl + alt + u</span><br><span class="line"><span class="comment"># 打开文件浏览器选择图片上传。</span></span><br><span class="line">ctrl + alt + e</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><a href="https://www.jianshu.com/p/868b3a2028f8">https://www.jianshu.com/p/868b3a2028f8</a><br><a href="https://zhuanlan.zhihu.com/p/131584831">https://zhuanlan.zhihu.com/p/131584831</a></li>
</ul>
<h2 id="plantuml"><a href="#plantuml" class="headerlink" title="plantuml"></a>plantuml</h2><h2 id="windows-开源软件"><a href="#windows-开源软件" class="headerlink" title="windows 开源软件"></a>windows 开源软件</h2><p> potplayer<br><a href="https://iptv-org.github.io/iptv/index.m3u">https://iptv-org.github.io/iptv/index.m3u</a></p>
<p>everyting</p>
<p>7zip</p>
<p>rustdesk  远程开源软件</p>
<p>maya</p>
<p>imagine</p>
<p>screentogif</p>
<p>ditto</p>
<p>bleachbit</p>
<p>qbittorrent</p>
<p>grammarly</p>
<p>剪切板win10自带的有很多剪切记录的快捷键Windows键➕V键</p>
<p>线上思维导图<br><a href="https://gitmind.cn/app/template">https://gitmind.cn/app/template</a><br>在线文档转换<br><a href="https://www.aconvert.com/cn/">https://www.aconvert.com/cn/</a><br>开源软件下载网站<br><a href="https://www.fosshub.com/#">https://www.fosshub.com/#</a></p>
<h3 id="windows-ternial"><a href="#windows-ternial" class="headerlink" title="windows ternial"></a>windows ternial</h3><ul>
<li>添加 git base 到ternial</li>
</ul>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="linux-各种系统"><a href="#linux-各种系统" class="headerlink" title="linux 各种系统"></a>linux 各种系统</h3><p>ubuntu、Linux Mint、suse、Manjaro</p>
<h3 id="chrome插件"><a href="#chrome插件" class="headerlink" title="chrome插件"></a>chrome插件</h3><p>油猴</p>
<h2 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h2><p><a href="http://react-guide.github.io/react-router-cn/index.html">http://react-guide.github.io/react-router-cn/index.html</a></p>
<h2 id="youtube-下载"><a href="#youtube-下载" class="headerlink" title="youtube 下载"></a>youtube 下载</h2><p><a href="https://www.ganbey.com/youtube-download-3774">https://www.ganbey.com/youtube-download-3774</a></p>
<h2 id="zlog"><a href="#zlog" class="headerlink" title="zlog"></a>zlog</h2><p><a href="https://blog.csdn.net/twd_1991/article/details/80481920">https://blog.csdn.net/twd_1991/article/details/80481920</a></p>
<p><a href="http://hardysimpson.github.io/zlog/UsersGuide-CN.html">http://hardysimpson.github.io/zlog/UsersGuide-CN.html</a></p>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p><a href="https://leetcode-cn.com/circle/article/7mxorv">https://leetcode-cn.com/circle/article/7mxorv</a></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>实用教程</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>书单&amp;电影</title>
    <url>/2021/10/27/%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul>
<li>C语言编程魔法书：基于C11标准</li>
</ul>
<span id="more"></span>

<h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><h3 id="未看"><a href="#未看" class="headerlink" title="未看"></a>未看</h3><ul>
<li>越哥说电影<ul>
<li>黑炮事件</li>
<li>乌龟也会飞: 伊拉克,美伊战争</li>
<li>牧马人: 改编自张贤亮的小说&lt;令与肉&gt;特殊时期,被批判的人遇到善良的爱人.汗水浸过的土地,相濡以沫的.传统女性,自信,高贵.</li>
<li>最爱 : 章子怡(琴琴),郭富城(得意);卖血,艾滋病村,艾滋病人的人生,爱情.贫穷,人性,善良,荒凉.</li>
<li>香火   求,乞,骗</li>
</ul>
</li>
</ul>
<p>教父三部曲</p>
<p>勇敢的心</p>
<h3 id="已看"><a href="#已看" class="headerlink" title="已看"></a>已看</h3><ul>
<li>夜色人生<br>禁酒令是黑帮斗争,爱尔兰人;</li>
<li>控方证人<br>犯罪悬疑,1958年的英国谋杀案电影</li>
<li>小岛惊魂<br>惊悚悬疑,为什么杀了两个孩子?战争?</li>
<li>千钧一发 1997年<br>基因筛选,基因歧视,依靠基因来判定一个人,文生借用优等基因人的身份,入选土卫十四飞行员.</li>
<li>致命ID<br>多重人格</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">Bob -&gt; Alice : Hello, how are you</span><br><span class="line">Alice -&gt; Bob : Fine, thank you, and you?</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<img src="http://www.plantuml.com/plantuml/svg/Kop9ICrDLIWkI4nEpKbCudBAJrBGjLDmpCbCJbMmKb38ICt9oGUBskWYH5MAIvEJKukBDPIW32k8GWKdFILDY1aLIAhJ4ZDpIejIDPIW39WQEuH5AkM9HNcPUUaQIb26aYO0">


<img src="http://www.plantuml.com/plantuml/svg/Syp9J4vLqBLJSCfFib9mB2t9ICqhoKnEBCdCprC8IYqiJIqkuGBAAUW2rJY256DHLLoGdrUSoiNbY6fONZvGNP52OaafDaCXYcrqTT5KOpSS0000"><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>实用教程</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL</title>
    <url>/2021/10/27/WSL/</url>
    <content><![CDATA[<h2 id="安装ubuntu20-04"><a href="#安装ubuntu20-04" class="headerlink" title="安装ubuntu20.04"></a>安装ubuntu20.04</h2><p>安装到非系统盘目录，下载离线安装包，复制到想要安装的目录下，解压，以管理员身份运行ubuntu2004.exe</p>
<h2 id="卸载wsl"><a href="#卸载wsl" class="headerlink" title="卸载wsl"></a>卸载wsl</h2><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">wslconfig /l</span><br><span class="line"><span class="comment"># 从列表中选择要卸载的发行版（例如Ubuntu）并键入命令</span></span><br><span class="line">wslconfig /u Ubuntu</span><br></pre></td></tr></tbody></table></figure>
<p>参考链接：<a href="https://blog.csdn.net/zhangpeterx/article/details/97616268">WSL系列操作：安装，卸载</a></p>
<span id="more"></span>

<h2 id="设置wsl"><a href="#设置wsl" class="headerlink" title="设置wsl"></a>设置wsl</h2><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 更改默认root用户登录</span></span><br><span class="line">ubuntu1804.exe config --default-user root</span><br><span class="line"><span class="comment"># 更改默认登陆目录</span></span><br><span class="line"><span class="comment"># list 中 Ubuntu-20.04 条目中添加</span></span><br><span class="line"><span class="string">"startingDirectory"</span>: <span class="string">"//wsl$/Ubuntu-20.04"</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="ubuntu-换源"><a href="#ubuntu-换源" class="headerlink" title="ubuntu 换源"></a>ubuntu 换源</h2><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.20211013</span><br><span class="line">lsb_release -c</span><br><span class="line">lsb_release -a</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>参考链接：<a href="https://blog.csdn.net/qq_33706673/article/details/106869016">ubuntu20.04更改国内镜像源</a></p>
<h2 id="Read-The-Docs-环境搭建"><a href="#Read-The-Docs-环境搭建" class="headerlink" title="Read The Docs 环境搭建"></a>Read The Docs 环境搭建</h2><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get install python3-pip</span><br><span class="line"></span><br><span class="line">pip install sphinx sphinx-autobuild sphinx_rtd_theme</span><br><span class="line">pip install recommonmark</span><br><span class="line">pip install sphinx-markdown-tables</span><br><span class="line">pip install Pyinstaller -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br><span class="line">（其中的Pyinstaller是你需要下载的库或包名，根据自己需求自行更改即可）</span><br><span class="line"></span><br><span class="line">extensions = [</span><br><span class="line">    <span class="string">'recommonmark'</span>,</span><br><span class="line">    <span class="string">'sphinx_markdown_tables'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">python3 -m pip freeze &gt; requirements.txt</span><br></pre></td></tr></tbody></table></figure>

<p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/112919704">VsCode +Read The Docs 环境搭建</a><br><br></p>
<p><a href="https://zhuanlan.zhihu.com/p/264647009">Sphinx + Read the Docs 从懵逼到入门</a><br><br></p>
<p><a href="https://zhuanlan.zhihu.com/p/388640347">ReadTheDocs搭建第一本电子书</a></p>
<p><a href="https://www.jianshu.com/p/8aae1c1453ae">https://www.jianshu.com/p/8aae1c1453ae</a></p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git push -u origin main</p>
<p><a href="https://zhuanlan.zhihu.com/p/252505037">玩转WSL(6)之Git配置</a></p>
<h2 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h2><p>winget search Microsoft.PowerShell</p>
<ul>
<li><a href="https://blog.csdn.net/The_Time_Runner/article/details/106038222">Windows Powershell和Windows Terminal的区别</a><br></li>
</ul>
<p><a href="https://docs.microsoft.com/zh-cn/windows/terminal/get-started">安装和设置 Windows 终端</a></p>
<h2 id="windows-包管理工具"><a href="#windows-包管理工具" class="headerlink" title="windows 包管理工具"></a>windows 包管理工具</h2><ul>
<li><p>winget 官方推出</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 WinGet 安装一遍</span></span><br><span class="line">winget install postman</span><br><span class="line">winget search postman</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载，再用 Scoop 安装一遍</span></span><br><span class="line">scoop install postman</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>choro</p>
</li>
<li><p>vcpkg<br><a href="https://vcpkg.io/en/getting-started.html">Get started with vcpkg</a></p>
</li>
</ul>
<br>

<ul>
<li>cget<br><a href="https://cget.readthedocs.io/en/latest/#">https://cget.readthedocs.io/en/latest/#</a></li>
</ul>
<p><a href="https://blog.csdn.net/cjmqas/article/details/79282847">开源库集成器Vcpkg全教程</a></p>
<p> Scoop </p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>实用教程</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解算法分析</title>
    <url>/2021/10/27/2021/11/leetcode%E9%A2%98%E8%A7%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1.单调栈"></a>1.单调栈</h2><h3 id="1-1-代表题目-84-柱状图中最大的矩形"><a href="#1-1-代表题目-84-柱状图中最大的矩形" class="headerlink" title="1.1 代表题目: 84.柱状图中最大的矩形"></a>1.1 代表题目: 84.<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/description/">柱状图中最大的矩形</a></h3><span id="more"></span>

<details>
  <summary>柱状图中最大的矩形 c语言</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>* heights, <span class="keyword">int</span> heightsSize)</span> </span>{</span><br><span class="line">    <span class="comment">// 栈顶标记,单调递减栈</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">stack</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (heightsSize + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">int</span> *buf = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (heightsSize + <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加前哨兵</span></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 在最后增加哨兵</span></span><br><span class="line">    buf[heightsSize + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= heightsSize; i++) {</span><br><span class="line">        buf[i] = heights[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heightsSize + <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; buf[i] &lt; buf[<span class="built_in">stack</span>[top]]) {</span><br><span class="line">            <span class="comment">// 注意 i - </span></span><br><span class="line">            area = (i - <span class="built_in">stack</span>[top - <span class="number">1</span>] - <span class="number">1</span>) * buf[<span class="built_in">stack</span>[top]];</span><br><span class="line">            maxArea = maxArea &gt; area ? maxArea : area;</span><br><span class="line">            top--;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 索引入栈，其他可能是元素入栈</span></span><br><span class="line">        <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<br>


<h3 id="1-2-单调栈描述"><a href="#1-2-单调栈描述" class="headerlink" title="1.2 单调栈描述"></a>1.2 单调栈描述</h3><p> 单调栈里面的元素大小按照他们所在栈内的位置,满足一定的单调性.</p>
<blockquote>
<p>单调递增栈：单调递增栈就是从栈底到栈顶数据是从小到大; 可找到左起第一个比当前数字小的元素.<br>单调递减栈：单调递减栈就是从栈底到栈顶数据是从大到小; 可找到左起第一个比当前数字大的元素.</p>
</blockquote>
<p> 单调递增栈，元素进栈过程，若当前进栈的元素a，如果a&gt;栈顶元素，则直接将a进栈，如果a&lt;=栈顶元素，则不断将栈顶元素出栈，直到满足a&gt;栈顶元素。单调递减栈则为a&lt;栈顶元素时进栈。</p>
<p> 题目分析:给定一个数组,返回一个大小相同的数组,返回的数组的第i个位置的值应当是,对于原数组中的第i个元素,至少往右走多少步,才能遇到一个比自己大的元素(如果没有比自己大的元素,或为最后一个元素,则返回对应位置上为-1).<br> 例如:<br>  input: 5, 3, 1, 2, 4<br>  return: -1, 3, 1, 1, -1<br> 暴力解法时间复杂度O(n^2)<br> 暴力解法:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">nextExceed</span><span class="params">(<span class="keyword">int</span> *input, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> *result = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    <span class="built_in">memset</span>(input,<span class="number">-1</span>,size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">int</span> anchar = input[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) {</span><br><span class="line">            <span class="keyword">if</span> (input[j] &gt; anchar) {</span><br><span class="line">                result[j] = j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> 单调栈:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">nextExceed</span><span class="params">(<span class="keyword">int</span> *input, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> *result = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">stack</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * size);</span><br><span class="line">    <span class="built_in">memset</span>(input, <span class="number">-1</span>, size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">0</span> &amp;&amp; input[i] &gt; input[<span class="built_in">stack</span>[top]]) {</span><br><span class="line">            result[<span class="built_in">stack</span>[top]] = i - <span class="built_in">stack</span>[top];</span><br><span class="line">            top--;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 我们维护一个单调递减栈stack,stack内存的是原数组的每个index,当遇到一个比当前栈顶所对应的树大的时候,则栈顶元素出栈,并更新它们在返回数组中对应位置的值.</p>
<p> 单调栈通常应用在一维数组上,和前后元素大小之间关系有关的问题.单调栈时间复杂度为<code>O(n)</code>.</p>
<h3 id="1-3-单调栈的性质"><a href="#1-3-单调栈的性质" class="headerlink" title="1.3 单调栈的性质"></a>1.3 单调栈的性质</h3><p> 1.单调栈里的元素具有单调性,栈中元素只能是单调递增或者单调递减<br> 2.元素加入栈前,会在栈顶把破坏栈单调性的元素都出栈<br> 3.使用单调栈可以找到元素向左遍历第一个比它小的元素,也可以找到元素向左遍历第一个比他大的元素</p>
<h3 id="1-3-leetcode题目"><a href="#1-3-leetcode题目" class="headerlink" title="1.3 leetcode题目"></a>1.3 leetcode题目</h3><p><a href="https://leetcode-cn.com/problems/maximal-rectangle/">85.最大矩形</a><br> 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。<br> 思路:对于每一行,构建一个histogram,然后计算.在构建新的histogram的时候,不需要全部遍历,只需对已有的histogram进行略微修改(运用DP的思想)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>** matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span>* matrixColSize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> m = matrixSize;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> n = matrixColSize[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> left[m][n];</span><br><span class="line">    <span class="built_in">memset</span>(left, <span class="number">0</span>, <span class="keyword">sizeof</span>(left));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                left[i][j] = (j == <span class="number">0</span> ? <span class="number">0</span> : left[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {  <span class="comment">// 对于每一列，使用基于柱状图的方法</span></span><br><span class="line">        <span class="keyword">int</span> up[m], down[m];</span><br><span class="line">        <span class="built_in">memset</span>(up, <span class="number">0</span>, <span class="keyword">sizeof</span>(up));</span><br><span class="line">        <span class="built_in">memset</span>(down, <span class="number">0</span>, <span class="keyword">sizeof</span>(down));</span><br><span class="line">        <span class="keyword">int</span> stk[m], top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; left[stk[top - <span class="number">1</span>]][j] &gt;= left[i][j]) {</span><br><span class="line">                top--;</span><br><span class="line">            }</span><br><span class="line">            up[i] = top == <span class="number">0</span> ? <span class="number">-1</span> : stk[top - <span class="number">1</span>];</span><br><span class="line">            stk[top++] = i;</span><br><span class="line">        }</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; left[stk[top - <span class="number">1</span>]][j] &gt;= left[i][j]) {</span><br><span class="line">                top--;</span><br><span class="line">            }</span><br><span class="line">            down[i] = top == <span class="number">0</span> ? m : stk[top - <span class="number">1</span>];</span><br><span class="line">            stk[top++] = i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">int</span> height = down[i] - up[i] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> area = height * left[i][j];</span><br><span class="line">            ret = fmax(ret, area);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://s2.loli.net/2021/12/07/aU8ZQBWRo9dTXMb.png" alt="20211207235410"></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="comment">//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解,单调减栈</span></span><br><span class="line"><span class="keyword">for</span> (遍历这个数组)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (栈空 || 栈顶元素大于等于当前比较元素)</span><br><span class="line">	{</span><br><span class="line">		入栈;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">		{</span><br><span class="line">			栈顶元素出栈;</span><br><span class="line">			更新结果;</span><br><span class="line">		}</span><br><span class="line">		当前数据入栈;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>单调栈</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>* heights, <span class="keyword">int</span> heightsSize,<span class="keyword">int</span> *S,<span class="keyword">int</span> top)</span></span>{</span><br><span class="line">    <span class="comment">// int*S=(int*)malloc(sizeof(int)*heightsSize); // 初始化栈，栈内保存柱子序号</span></span><br><span class="line">    <span class="comment">// int top=-1;</span></span><br><span class="line">    <span class="keyword">int</span> start,end,h;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">    S[++top]=<span class="number">0</span>; <span class="comment">// 入栈第一根柱子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=heightsSize<span class="number">-1</span>;i++){ <span class="comment">// 遍历所有柱子</span></span><br><span class="line">        <span class="keyword">if</span>(heights[i] &gt;= heights[S[top]] ) S[++top]=i; <span class="comment">// 若当前柱子大于栈顶或等于栈顶，直接入栈</span></span><br><span class="line">        <span class="keyword">else</span>{ <span class="comment">// 若当前柱子小于栈顶，则依次出栈较高的柱子并计算面积</span></span><br><span class="line">            end = S[top]; <span class="comment">// 记录最右边最高的柱子位置，之后每次矩形的底边是从出栈位置到最右边最高柱子的位置</span></span><br><span class="line">            <span class="keyword">while</span>(top != <span class="number">-1</span> &amp;&amp; heights[i] &lt; heights[S[top]] ){</span><br><span class="line">                h = heights[S[top--]]; <span class="comment">// 保存当前矩形的高</span></span><br><span class="line">                <span class="keyword">while</span>( top != <span class="number">-1</span> &amp;&amp; heights[S[top]] == h) top--; <span class="comment">// 若有相同高的柱子，直接出栈</span></span><br><span class="line">                <span class="keyword">if</span> ( top != <span class="number">-1</span>) start=S[top]; <span class="comment">// 避免栈为空</span></span><br><span class="line">                <span class="keyword">else</span> start=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(r &lt; (end-start)*h) r=(end-start)*h; <span class="comment">// 矩形面积是最高柱子位置减去当前栈顶柱子的位置乘高</span></span><br><span class="line">            }</span><br><span class="line">            S[++top]=i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 此时栈内剩余递增序列，出栈依次计算面积。计算流程同上</span></span><br><span class="line">    end = S[top];</span><br><span class="line">    <span class="keyword">while</span>(top != <span class="number">-1</span>){</span><br><span class="line">        h = heights[S[top--]];</span><br><span class="line">        <span class="keyword">while</span>( top != <span class="number">-1</span> &amp;&amp; heights[S[top]] == h) top--;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="number">-1</span>) start=S[top];</span><br><span class="line">        <span class="keyword">else</span> start=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r &lt; (end-start)*h) r=(end-start)*h;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>** matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span>* matrixColSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> m=matrixSize;</span><br><span class="line">    <span class="keyword">int</span> n=*matrixColSize;</span><br><span class="line">    <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *heights = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    <span class="keyword">int</span>*S=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n); <span class="comment">// 初始化栈，栈内保存柱子序号</span></span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n<span class="number">-1</span>;k++) heights[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m<span class="number">-1</span>;i++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n<span class="number">-1</span>;j++){</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>) heights[j]++;</span><br><span class="line">            <span class="keyword">else</span> heights[j]=<span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur=largestRectangleArea(heights,n,S,top);</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; r) r=cur;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</details>

<details>
<summary></summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">void</span> **data;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">} Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack *<span class="title">StackCreate</span><span class="params">(<span class="keyword">int</span> stackSize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Stack *<span class="built_in">stack</span> = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>-&gt;data = (<span class="keyword">void</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">void</span> **) * (stackSize + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">stack</span>-&gt;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">void</span> **) * (stackSize + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = stackSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackFree</span><span class="params">(Stack *obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;data != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">        obj-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">    obj = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsStackEmpty</span><span class="params">(Stack *obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (obj-&gt;top == <span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsStackFull</span><span class="params">(Stack *obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (obj-&gt;top ==  obj-&gt;size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span><span class="params">(Stack *obj, <span class="keyword">void</span> *data)</span>  <span class="comment">// 泛型接口，使用void *</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (IsStackFull(obj) == <span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> top = obj-&gt;top;</span><br><span class="line">    obj-&gt;data[++top] = data;</span><br><span class="line">    obj-&gt;top = top;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPop</span><span class="params">(Stack *obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (IsStackEmpty(obj) == <span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">void</span> *data = obj-&gt;data[obj-&gt;top];</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">    data = <span class="literal">NULL</span>;</span><br><span class="line">    obj-&gt;top--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">StackTop</span><span class="params">(Stack *obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (IsStackEmpty(obj) == <span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (obj-&gt;data[obj-&gt;top]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackClear</span><span class="params">(Stack *obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (IsStackEmpty(obj) == <span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= obj-&gt;top; i++) {</span><br><span class="line">        <span class="keyword">void</span> *data = obj-&gt;data[i];</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">free</span>(data);</span><br><span class="line">            data = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    obj-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span> **matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span> *matrixColSize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> **height = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *) * matrixSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrixSize; i++) {</span><br><span class="line">        height[i] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (matrixColSize[i] + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrixColSize[i]; j++) {</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">                height[i][j] = (matrix[i][j] == <span class="string">'1'</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                height[i][j] = (matrix[i][j] == <span class="string">'1'</span>) ? (height[i - <span class="number">1</span>][j] + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        height[i][matrixColSize[i]] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Stack *monotoneStack = StackCreate(matrixSize * matrixSize);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrixSize; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= matrixColSize[i]; j++) {</span><br><span class="line">            <span class="keyword">while</span> ((IsStackEmpty(monotoneStack) != <span class="literal">true</span>) &amp;&amp; </span><br><span class="line">                    (height[i][*(<span class="keyword">int</span> *)monotoneStack-&gt;data[monotoneStack-&gt;top]] &gt;= height[i][j])) {</span><br><span class="line">                <span class="keyword">int</span> h = height[i][*(<span class="keyword">int</span> *)monotoneStack-&gt;data[monotoneStack-&gt;top]];</span><br><span class="line">                StackPop(monotoneStack);</span><br><span class="line">                <span class="keyword">int</span> sidx = ((IsStackEmpty(monotoneStack) == <span class="literal">true</span>) ? <span class="number">-1</span> : *(<span class="keyword">int</span> *)(monotoneStack-&gt;data[monotoneStack-&gt;top]));</span><br><span class="line">                ans = MAX(ans, h * (j - sidx - <span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> *node = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            *node = j;</span><br><span class="line">            StackPush(monotoneStack, node); </span><br><span class="line">        }</span><br><span class="line">        StackClear(monotoneStack);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    StackFree(monotoneStack);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>


<p>85 Maximal Reactangle<br>leetcode 496、503、739、239<br>42.接雨水<br><a href="https://blog.csdn.net/chongbin007/article/details/112741867?utm_term=%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97leetcode&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-112741867&amp;spm=3001.4430">https://blog.csdn.net/chongbin007/article/details/112741867?utm_term=%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97leetcode&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-112741867&amp;spm=3001.4430</a></p>
<h2 id="2-并查集"><a href="#2-并查集" class="headerlink" title="2.并查集"></a>2.并查集</h2><h3 id="2-1-代表题目-547-省份数量"><a href="#2-1-代表题目-547-省份数量" class="headerlink" title="2.1 代表题目:547.省份数量"></a>2.1 代表题目:<a href="https://leetcode-cn.com/problems/number-of-provinces/">547.省份数量</a></h3><p> 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>
<p> 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p> 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *g_test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> mSize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (mSize &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    g_dest = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(mSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (g_dest == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    fot (i = <span class="number">0</span>; i &lt; mSize; i++) {</span><br><span class="line">        g_dest[i] = i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (g_dest[index] == index) {</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> g_dest[index] = Find(g_dest[index]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindRoot</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (g_dest[i] != <span class="number">0</span>) {</span><br><span class="line">        i = g_dest[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcCircle</span><span class="params">(<span class="keyword">int</span> **m, <span class="keyword">int</span> mSize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> rootI, rootJ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mSize; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (i + <span class="number">1</span>); j &lt; mSize; j++) {</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] != <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            rootI = FindRoot(i);</span><br><span class="line">            rootJ = FindRoot(j);</span><br><span class="line">            <span class="keyword">if</span> (rootI == rootJ) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            g_dest[rootI] = rootJ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCircleNum</span><span class="params">(<span class="keyword">int</span> mSize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mSize; i++) {</span><br><span class="line">        <span class="keyword">if</span> (g_dest[i] == i) {</span><br><span class="line">            sum++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeCircle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (g_dest != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(g_dest);</span><br><span class="line">        g_dest = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span> **m, <span class="keyword">int</span> mSize, <span class="keyword">int</span>* mColSize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">bool</span> rslt;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    rslt = Init(mSize);</span><br><span class="line">    <span class="keyword">if</span> (!rslt)  {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ProcCicle(m, mSize);</span><br><span class="line">    sum = GetCircleNum(mSize);</span><br><span class="line"></span><br><span class="line">    FreeCircle();</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-并查集介绍"><a href="#2-2-并查集介绍" class="headerlink" title="2.2 并查集介绍"></a>2.2 并查集介绍</h3><p> 并查集(DSU)主要用于解决一些元素分组的问题，管理一系列不相交的集合，并支持两种操作：<br> 并查集即<strong>合并集合</strong>和<strong>查找集合</strong>两种操作的算法.但实际并查集的基本操作有三个:<br> makeSet(size):建立一个新的并查集,其中包含size个单元素集合.<br> unionSet(x, y)<strong>合并</strong>:把元素x和元素y所在的集合合并,要求x和y所在的集合不相交,如果相交则不合并.<br> find(x)<strong>查询</strong>:找到元素x所在的集合的代表,该操作也可以用于判断两个元素是否位于同一个集合,只要将它们各自的代表比较一下就可以了. find(x)有两种实现方法,一种是递归,一种是非递归。</p>
<p> 并查集的重要思想在于，用集合中的一个元素代表集合。</p>
<p> <strong>算法:</strong><br>  用集合中的某个元素来代表这个集合,该元素称为集合的代表元.一个集合内的所有元素组织成以代表元为根的树形结构.对应每一个元素x来说,parent[x]指向x在树形结构上的父节点,如果x是根节点,则灵parent[x] = x. 对于查找操作,假设需要确定x所在的集合,也就是确定集合的代表元.可以沿着parent[x]不断在树形结构中向上移动,直到到达根节点.<br> 因为创建的树可能会严重不平衡,并查集可以用两种优化策略:<br> 1.按秩序合并<br>  即总将更小的树连接至更大的树上,<br> 2.<strong>路径压缩</strong><br>  为了加快查找速度,查找时将x到根节点路径上的所有点的parent设为根节点,该优化方法称为路径压缩.</p>
<p> 算法用途:<br>  1.维护无向图的连通性,支持判断两个点是否在同一连通块内,和.<br>  2.判断增加一条边是否会产生环:用在求解最小生成树Kruskal算法里<br> 并查集时统计图中连通块数量的一种方法.使用一个大小为N的parent数组,遍历这个图,每个节点都遍历所有相邻点,并让相邻点指向它,并设置成一个有parent节点决定的单独组.这个过程被称为union.这样每个组都有一个唯一的parent节点,这些节点的父节点为-1.</p>
<p>合并的比较方法<br>应当将简单的树向复杂的树上合并，从而使合并后到根节点距离变长的节点个数比较少。</p>
<p>并查集的时间复杂度<br>查询次数+合并次数 N或以上则平均下来单次查询或合并的平均时间复杂度O(1)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1010</span>]; <span class="comment">// 存放第i个元素的父节点</span></span><br><span class="line"><span class="comment">// 查询根节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unionsearch</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> son, tmp;</span><br><span class="line">    son = root;</span><br><span class="line">    <span class="comment">// 寻找根节点</span></span><br><span class="line">    <span class="keyword">while</span> (root != pre[root]) {</span><br><span class="line">        root = pre[root]; <span class="comment">// 路径压缩</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (son != root) {</span><br><span class="line">        tmp = pre[son];</span><br><span class="line">        pre[son] = root;</span><br><span class="line">        son = tmp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> root1, <span class="keyword">int</span> root2)</span> <span class="comment">// 判断释放连通,不连通就合并</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    x = unionsearch(root1);</span><br><span class="line">    y = unionsearch(root2);</span><br><span class="line">    <span class="comment">// 如果不连通,就把它们所在的连通分支合并</span></span><br><span class="line">    <span class="keyword">if</span> (x != y) {</span><br><span class="line">        pre[x] = y;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://blog.csdn.net/qq_41593390/article/details/81146850">https://blog.csdn.net/qq_41593390/article/details/81146850</a></p>
<p><a href="https://blog.csdn.net/ziachen/article/details/106315471">https://blog.csdn.net/ziachen/article/details/106315471</a></p>
<p>朋友圈</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span> **matrix, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> *parent = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*size);</span><br><span class="line">    <span class="built_in">memset</span>(parent, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*size);</span><br><span class="line">    <span class="keyword">int</span> rows = size;</span><br><span class="line">    <span class="keyword">int</span> clos = matrix[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) {</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span> &amp;&amp; i != j) {</span><br><span class="line">                <span class="class"><span class="keyword">union</span>(<span class="title">parent</span>, <span class="title">i</span>, <span class="title">j</span>);</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> countCircleNum(parent, size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> *parent, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> xset = find(parent, i);</span><br><span class="line">    <span class="keyword">int</span> yset = find(parent, j);</span><br><span class="line">    <span class="keyword">if</span> (xset != yset) {</span><br><span class="line">        <span class="comment">// 合并i和j的两个集合</span></span><br><span class="line">        parent[xset] = yset;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 查找集合 i 的源头</span></span><br><span class="line"><span class="comment"> 如果集合 i 的父亲是 -1, 说明自己就是源头,返回自己的标号</span></span><br><span class="line"><span class="comment"> 否则查找集合 i 的父亲的源头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> *parent, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (parent[i] == <span class="number">-1</span>) {</span><br><span class="line">        <span class="comment">// i 的父亲为 -1 时,i就是掌门人</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 使用路径压缩,让这条路径上所有的人的上级直接变为掌门人</span></span><br><span class="line">    <span class="keyword">return</span> find(parent, parent[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countCircleNum</span><span class="params">(<span class="keyword">int</span> *parent, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">if</span> (parent[i] == <span class="number">-1</span>) {</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// find 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (x != parent[x]) {</span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p> DFS实现</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span> **matrix, <span class="keyword">int</span> matrixSize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> rows = matrixSize;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> *visited = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * matrixSize);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) {</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) {</span><br><span class="line">            dfs(matrix, matrixSize, visite, i);</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> **matrix,  <span class="keyword">int</span> matrixSize, <span class="keyword">int</span> *visited, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrixSize; j++) {</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) {</span><br><span class="line">            visited[j] = <span class="number">1</span>;</span><br><span class="line">            dfs(matrxi, matrixSize, visited, j);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> BFS实现</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span> **matrix, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span>* visited = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*length);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>题目背景<br>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。<br>题目描述<br>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。<br>输入格式<br>第一行：三个整数n,m,p，（n&lt;=5000,m&lt;=5000,p&lt;=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。<br>以下m行：每行两个数Mi，Mj，1&lt;=Mi，Mj&lt;=N，表示Mi和Mj具有亲戚关系。<br>接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。<br>输出格式<br>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5005</span></span><br><span class="line"><span class="keyword">int</span> fa[MAXN], rank[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    {</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> x = find(i), y = find(j);</span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m, p, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        merge(x, y);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, find(x) == find(y) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-3-最小生成树"><a href="#2-3-最小生成树" class="headerlink" title="2.3 最小生成树"></a>2.3 最小生成树</h3><p> 关于图的几个概念定义:<br>连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。<br>强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。<br>连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。<br>生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。<br>最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p>
<ul>
<li>参考链接:<a href="https://blog.csdn.net/luoshixian099/article/details/51908175">https://blog.csdn.net/luoshixian099/article/details/51908175</a></li>
</ul>
<h2 id="3-滑动窗口-amp-双指针"><a href="#3-滑动窗口-amp-双指针" class="headerlink" title="3.滑动窗口&amp;双指针"></a>3.滑动窗口&amp;双指针</h2><h3 id="3-1-经典题目-1208-进可能使字符串相等"><a href="#3-1-经典题目-1208-进可能使字符串相等" class="headerlink" title="3.1 经典题目 1208.进可能使字符串相等"></a>3.1 经典题目 1208.进可能使字符串相等</h3><p> 滑动窗口法，也叫尺取法（可能也不一定相等，大概就是这样 =。=），可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。</p>
<p>  TCP协议使用滑动窗口实现.<br> 滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。其实这里就可以看出来滑动窗口主要应用在数组和字符串上。</p>
<p>滑动：说明这个窗口是移动的，也就是移动是按照一定方向来的。</p>
<p>窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。</p>
<p>滑动窗口是双指针的一种应用，形象点说就是维护一个窗口，在窗口滑动的过程中进行窗口内数据的更新，并判断是否符合答案。、<br>初始时两个指针均指向开头，然后右指针依次向右滑动，在滑动的过程中需要收缩的时候进行左指针的移动，当右指针移出的时候结束循环即可。</p>
<p>Leetcode 209. 长度最小的子数组<br>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span>{</span><br><span class="line">     <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need,window;</span><br><span class="line">     <span class="comment">//在need中记录相应的信息</span></span><br><span class="line">      .....</span><br><span class="line">      <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> valid;<span class="comment">//该变量用来判断是否得到相应的答案了</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span>(right&lt;s.size()){</span><br><span class="line">         <span class="keyword">char</span> c=s[right];<span class="comment">//取出将要移入窗口内的数据</span></span><br><span class="line">         right++；</span><br><span class="line">         <span class="comment">//下面进行窗口更新后一些数据的更新</span></span><br><span class="line">         .....</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(判断窗口是否需要收缩){</span><br><span class="line">              <span class="comment">//是否需要进行相应的答案更新</span></span><br><span class="line">              ......</span><br><span class="line"></span><br><span class="line">              <span class="keyword">char</span> d=s[left];<span class="comment">//将要移出窗口的数据；</span></span><br><span class="line">              left++;<span class="comment">//收缩窗口</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">//窗口收缩后相应数据的更新</span></span><br><span class="line">              .......           </span><br><span class="line">         }   </span><br><span class="line">      }      </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>示例: </p>
<p>输入: s = 7, nums = [2,3,1,2,4,3]<br>输出: 2<br>解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</p>
<ul>
<li>参考链接:<br><a href="https://zhuanlan.zhihu.com/p/61564531">https://zhuanlan.zhihu.com/p/61564531</a></li>
</ul>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title=".单调队列"></a>.单调队列</h3><p> 单调队列是指：队列中的元素之间的关系具有单调性，而且，队首和队尾都可以进行出队操作，只有队尾开源进行入队操作。<br> 单调队列与单调栈及其相似，把单调栈先进后出的性质改为先进先出既可。<br>元素进队列的过程对于单调递增队列。<br>对于一个元素a，如果a&gt;队尾元素，那么直接将a扔进队列，如果a&lt;=队尾元素，则将队尾元素出队列，直到满足 a&gt;队尾元素即可。</p>
<blockquote>
<p>单调递增队列(从队首到队尾满足递增)<br>单调递减队列(从队首到队尾满足递减)</p>
</blockquote>
<ul>
<li><p>单调队列作用：队列里的元素满足出队的单调性。</p>
</li>
<li><p>单调队列操作：去头和删尾</p>
</li>
<li><p>leetcode 题目<br><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20000</span>];</span><br><span class="line">    <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">} MaxQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">MaxQueue* <span class="title">maxQueueCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    MaxQueue *tmp = (MaxQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MaxQueue));</span><br><span class="line">    tmp-&gt;begin = <span class="number">0</span>;</span><br><span class="line">    tmp-&gt;end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxQueueMax_value</span><span class="params">(MaxQueue* obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = obj-&gt;begin; i &lt; obj-&gt;end; i++) {</span><br><span class="line">        ans = fmax(ans, obj-&gt;arr[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxQueuPus_back</span><span class="params">(MaxQueue* obj, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    obj-&gt;arr[obj-&gt;end++] = value;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxQueuePop_front</span><span class="params">(MaxQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;begin==obj-&gt;end)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> obj-&gt;arr[obj-&gt;begin++];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxQueueFree</span><span class="params">(MaxQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    obj-&gt;end=<span class="number">0</span>;</span><br><span class="line">    obj-&gt;begin=<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>239.滑动窗口最大值</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Size=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> a[Size],qmax[Size],qmin[Size],savemax[Size],savemin[Size];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n,k,cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    {<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);}</span><br><span class="line">    <span class="keyword">int</span> beg=<span class="number">1</span>,top=<span class="number">0</span>;<span class="comment">//qmax队列的队首指针和队尾指针</span></span><br><span class="line">    <span class="keyword">int</span> st=<span class="number">1</span>,ed=<span class="number">0</span>;<span class="comment">//qmin队列的队首指针和队尾指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(beg&lt;=top&amp;&amp;a[i]&gt;=a[qmax[top]])</span><br><span class="line">        {top--;}</span><br><span class="line">        qmax[++top]=i;</span><br><span class="line">        <span class="keyword">while</span>(st&lt;=ed&amp;&amp;a[i]&lt;=a[qmin[ed]])</span><br><span class="line">        {ed--;}</span><br><span class="line">        qmin[++ed]=i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(qmax[beg]&lt;=i-k)beg++;</span><br><span class="line">            <span class="keyword">while</span>(qmin[st]&lt;=i-k)st++;</span><br><span class="line">            savemax[cnt]=a[qmax[beg]];</span><br><span class="line">            savemin[cnt]=a[qmin[st]];</span><br><span class="line">            cnt++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt; cnt;i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,savemin[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt; cnt;i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,savemax[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://www.cnblogs.com/zzcxxoo/p/13216030.html">https://www.cnblogs.com/zzcxxoo/p/13216030.html</a></p>
<h2 id="4-前缀和-amp-哈希表优化"><a href="#4-前缀和-amp-哈希表优化" class="headerlink" title="4.前缀和(&amp;哈希表优化)"></a>4.前缀和(&amp;哈希表优化)</h2><h3 id="4-1-前缀和介绍"><a href="#4-1-前缀和介绍" class="headerlink" title="4.1 前缀和介绍"></a>4.1 前缀和介绍</h3><p> 前缀和(prefix sum)定义:前缀和时一种预处理,能大大降低查询的时间复杂度.结合Hash缓存,能够进一步优化提升算法执行效率.<br> 对数组nums进行前缀和初始化需要O(n)时间<br> 新建数组prefixSum,数组长度定义为 nums.length+1,确保顶第 nums.length个元素存储前面0到nums.length-1个元素的和.将数组nums的累加一层放入数组prefixSum中.<br> 变换公式:<br>  1)nums[某一项] = 两个相邻前缀和之差: nums[i] = prefixSum[x] - prefixSum[x-1]<br>  2)从left到right的元素和等于: prefixSum[right+1] - prefixSum[left]</p>
<p>假设我们有一个字符串ABCDE，什么是这个单词的前缀，A、AB、ABC、ABCD、ABCDE就是这个单词的前缀，就是从第一个字母开始，依次往后拼接。E、ED、EDC、EDCB、EDCBA被称为这个单词的后缀。</p>
<p>那么对于一个数组的前缀，例如数组a = [1,2,3,4,5]，我们维护一个由前缀的和组成的数组sum，sum[i]表示数组中a[0]~ a[i] 的和。<br>sum[0] = a[0]<br>sum[1] = a[0] + a[1]<br>sum[2] = a[0] + a[1] + a[2]<br>sum[3] = a[0] + a[1] + a[2] + a[3]<br>sum[4] = a[0] + a[1] + a[2] + a[3] + a[4]<br>sum数组就被称为前缀和数组。</p>
<p>前缀和的作用<br>前缀和的最主要目的就是求子数组的和的大小。例如元素a[1]到a[3]的和。<br>a[1] + a[2] + a[3] = sum[3] - sum[0]</p>
<p> 前缀和数组初始化过程伪代码:<br>  1.安装for寻的政策边界进行初始化,避免了 int i=1 或者 &lt;=len 等肯的各种调整.<br>  2.前缀和长度比数据长度多一个,前缀和第0个元素要初始化为0<br>  另外一种前缀和初始化方法:前缀和长度为nums.length,第0个元素存储自己的和.<br>  prefixSum[i] - prefixSum[i-1] 容易出现错误理解和技术丢失.示例:prefixSum[0] = num[1],造成nums[0]丢失.</p>
<ul>
<li>参考链接:<a href="https://blog.csdn.net/fgy_u/article/details/109349710">https://blog.csdn.net/fgy_u/article/details/109349710</a></li>
</ul>
<p><a href="https://www.jianshu.com/p/3021429f38d4">https://www.jianshu.com/p/3021429f38d4</a></p>
<h2 id="5-差分"><a href="#5-差分" class="headerlink" title="5.差分"></a>5.差分</h2><h3 id="5-1-差分介绍"><a href="#5-1-差分介绍" class="headerlink" title="5.1 差分介绍"></a>5.1 差分介绍</h3><p> 差分时一种和前缀和算法相对 的策略,这种策略是,令 b(i) = a(i) - a(i-1),即相邻两数的差.在每一个点上记录变化数值,因为有增加有减少通过求和判断是否有超过指定容量的情况发生,超过则代表无法满足要求.</p>
<p>该算法是前缀和算法的逆运算，可以快速的对数组的某一个区间进行计算。</p>
<p> 对于数组array[N]中的某一段进行增减操作,通过差分可在 O(n)时间内完成.如:<br> trips = [ [2,1,5], [3,3,7]]<br> 第一步:更新array[1] = 2, array[2] = -2;<br> 第二步:更新array[3] = 3, array[7] = -2;<br> 第三步:进行求和,得到结果array[] = {0, 2, 2, 5, 5, 3, 3, 0}</p>
<h2 id="6-拓扑排序"><a href="#6-拓扑排序" class="headerlink" title="6.拓扑排序"></a>6.拓扑排序</h2><p>一、什么是拓扑排序<br>在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<p>每个顶点出现且只出现一次。<br>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。<br>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</p>
<p>二、拓扑排序的应用<br>拓扑排序通常用来“排序”具有依赖关系的任务。</p>
<p>比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边<script type="math/tex" id="MathJax-Element-1"> </script>表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</p>
<p>三、拓扑排序的实现<br>根据上面讲的方法，我们关键是要维护一个入度为0的顶点的集合。<br>图的存储方式有两种：邻接矩阵和邻接表。这里我们采用邻接表来存储图，C++代码如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************类声明************************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> V;             <span class="comment">// 顶点个数</span></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; *adj;    <span class="comment">// 邻接表</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;      <span class="comment">// 维护一个入度为0的顶点的集合</span></span><br><span class="line">    <span class="keyword">int</span>* indegree;     <span class="comment">// 记录每个顶点的入度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="keyword">int</span> V);                   <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">Graph</span>();                       <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>;     <span class="comment">// 添加边</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">topological_sort</span><span class="params">()</span></span>;        <span class="comment">// 拓扑排序</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************类定义************************/</span></span><br><span class="line">Graph::<span class="built_in">Graph</span>(<span class="keyword">int</span> V)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">    adj = <span class="keyword">new</span> list&lt;<span class="keyword">int</span>&gt;[V];</span><br><span class="line"></span><br><span class="line">    indegree = <span class="keyword">new</span> <span class="keyword">int</span>[V];  <span class="comment">// 入度全部初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">        indegree[i] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Graph::~<span class="built_in">Graph</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">delete</span> [] adj;</span><br><span class="line">    <span class="keyword">delete</span> [] indegree;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graph::addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    adj[v].<span class="built_in">push_back</span>(w); </span><br><span class="line">    ++indegree[w];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Graph::topological_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;V; ++i)</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);         <span class="comment">// 将所有入度为0的顶点入队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;             <span class="comment">// 计数，记录当前已经输出的顶点数 </span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> v = q.<span class="built_in">front</span>();      <span class="comment">// 从队列中取出一个顶点</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">" "</span>;      <span class="comment">// 输出该顶点</span></span><br><span class="line">        ++count;</span><br><span class="line">        <span class="comment">// 将所有v指向的顶点的入度减1，并将入度减为0的顶点入栈</span></span><br><span class="line">        list&lt;<span class="keyword">int</span>&gt;::iterator beg = adj[v].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>( ; beg!=adj[v].<span class="built_in">end</span>(); ++beg)</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[*beg]))</span><br><span class="line">                q.<span class="built_in">push</span>(*beg);   <span class="comment">// 若入度为0，则入栈</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count &lt; V)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">// 没有输出全部顶点，有向图中有回路</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;            <span class="comment">// 拓扑排序成功</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">6</span>)</span></span>;   <span class="comment">// 创建图</span></span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">topological_sort</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果是 4, 5, 2, 0, 3, 1。这是该图的拓扑排序序列之一。</p>
<p>每次在入度为0的集合中取顶点，并没有特殊的取出规则，随机取出也行，这里使用的queue。取顶点的顺序不同会得到不同的拓扑排序序列，当然前提是该图存在多个拓扑排序序列。</p>
<p>由于输出每个顶点的同时还要删除以它为起点的边，故上述拓扑排序的时间复杂度为O(V+E)O(V+E)。</p>
<ul>
<li>参考链接:<a href="https://blog.csdn.net/lisonglisonglisong/article/details/45543451">https://blog.csdn.net/lisonglisonglisong/article/details/45543451</a></li>
</ul>
<h2 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7.字符串"></a>7.字符串</h2><p>字符串介绍<br> 字符串可以涉及非常多的考点:如递归,栈,hash,dfs,bfs,动态规划等.需要强制记忆的是”字符串的子串”,”字符串的子序列”.难度比较大的是”子序列”问题.对于任何字符串,可通过删除其中一些字符(也可不删)来构造该字符串的子序列.对于任何字符串,选择任意连续的1到N个字符,形成[i,j]形式的子串,然后利用字符串的子串进行相关的匹配和计算.</p>
<h2 id="8-二分查找"><a href="#8-二分查找" class="headerlink" title="8.二分查找"></a>8.二分查找</h2><p> 二分查找也称折半查找(Binary Search),它使一种效率较高的查找方法,前提是数据结构必须先排好序.但是,二分查找要求线性表具有随机访问的特点(如数组),也要求线性表能够根据中间元素的特点推测它两侧元素的性质,以达到缩减问题规模的效果.<br> 二分查找问题也是面试中常考问题,虽然它思想简单,但写好二分算法并不容易.</p>
<h2 id="9-BFS"><a href="#9-BFS" class="headerlink" title="9.BFS"></a>9.BFS</h2><p>BFS（广度优先搜索） 常用来解决层序遍历,最短路径问题。<br>第一次遍历到目的节点时，所经过的路径是最短路径。<br>几个要点：</p>
<p>只能用来求解无权图的最短路径问题<br>队列：用来存储每一层遍历得到的节点<br>标记：对于遍历过的结点，应将其标记，以防重复访问</p>
<p>注:<br>1.广度搜索时候,如果曾经加入过,后续就不用再加入<br>2.加入队列时候,需要标记当前层级,方便后续直接返回目标解.</p>
<ul>
<li>参考链接:<a href="https://zhuanlan.zhihu.com/p/62884729">https://zhuanlan.zhihu.com/p/62884729</a></li>
</ul>
<h2 id="10-DFS"><a href="#10-DFS" class="headerlink" title="10.DFS"></a>10.DFS</h2><p> 深度优先搜索算法(DFS):是一种用于遍历或搜索树或图的算法.利用深度优先搜索算法可产生目标图的拓扑排序表,拓扑排序可用于无权最长路径问题等.DFS实质是一种枚举,不过借助递归实现.<br> 回溯搜索时深度优先搜索(DFS)的一种.对于某一个搜索树来说(搜索树时起记录路径和状态判断的作用),回溯和DFS,其主要的区别是,回溯法在求解过程中不保留完整的树结构,而深度优先搜索则记下完整的搜索树.回溯就是通过不同的尝试来生成问题的解,类似于穷举,但和穷举不同的时回溯会”减枝”.为了减少存储空间,在深度优先搜索中,用标志的方法记录访问过的状态,这种处理方法使得深度优先搜索法与回溯法没什么区别.<br> DFS相对于BFS更方便写,空间复杂度更低<br> DFS基本模式:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 判断边界</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="comment">// 尝试每一种可能</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; j &lt;= n; ++i) {</span><br><span class="line">        <span class="comment">// 继续下一步</span></span><br><span class="line">        dfs(step + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    ...;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 回溯的一般结构</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> 当前状态)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (当前状态为边界状态) {</span><br><span class="line">        记录或输出</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 横向遍历解答树所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="comment">// 扩展出一个子状态</span></span><br><span class="line">        <span class="comment">// 修改了全局变量</span></span><br><span class="line">        <span class="keyword">if</span> (子状态满足约束条件) {</span><br><span class="line">            backtrack(子状态)</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 恢复全局变量//回溯部分</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 回溯代码框架:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">result = {}</span><br><span class="line">def backtrack(路径, 选择列表)</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径,,选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></tbody></table></figure>



<h2 id="11-动态规划"><a href="#11-动态规划" class="headerlink" title="11.动态规划"></a>11.动态规划</h2><ul>
<li>参考链接:<br><a href="https://blog.csdn.net/qq_37763204/article/details/79394397">https://blog.csdn.net/qq_37763204/article/details/79394397</a><br><a href="https://blog.csdn.net/u013309870/article/details/75193592">https://blog.csdn.net/u013309870/article/details/75193592</a></li>
</ul>
<h2 id="12-贪心算法"><a href="#12-贪心算法" class="headerlink" title="12.贪心算法"></a>12.贪心算法</h2><h2 id="13-字典树"><a href="#13-字典树" class="headerlink" title="13.字典树"></a>13.字典树</h2><h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_BITS (1&lt;&lt;3) * sizeof(TYPE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT (int)(log(INT_BITS)/log(2))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK INT_BITS-1</span></span><br><span class="line"></span><br><span class="line">TYPE bitmap[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBit</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="comment">// 是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">containBit</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="comment">// 得到当前位置的第几位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBit</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteBit</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"int_bits = %d, shift = %d, mask = %d\n"</span>, INT_BITS, SHIFT, MASK);</span><br><span class="line">	setBit(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"是否存在%d\n"</span>, containBit(<span class="number">2</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"是否存在%d\n"</span>, containBit(<span class="number">3</span>));</span><br><span class="line">	deleteBit(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"是否存在%d\n"</span>, containBit(<span class="number">2</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"是否存在%d\n"</span>, containBit(<span class="number">3</span>));</span><br><span class="line">	setBit(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"是否存在%d\n"</span>, containBit(<span class="number">2</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"是否存在%d\n"</span>, containBit(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2在当前的位置%d\n"</span>, getBit(<span class="number">2</span>));</span><br><span class="line">	setBit(<span class="number">32</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"32在当前的位置%d\n"</span>, getBit(<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBit</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">	 bitmap[num &gt;&gt; SHIFT] |= <span class="number">1</span> &lt;&lt; (num &amp; MASK);</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"set --[%d]: %d\n"</span>, num &gt;&gt; SHIFT, bitmap[num &gt;&gt; SHIFT]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">containBit</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> (bitmap[num &gt;&gt; SHIFT] &amp; <span class="number">1</span> &lt;&lt; (num &amp;MASK)) ==  <span class="number">1</span> &lt;&lt; (num &amp;MASK);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBit</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> num &amp; MASK;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteBit</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">	bitmap[num &gt;&gt; SHIFT] &amp;= ~(<span class="number">1</span> &lt;&lt; (num &amp; MASK));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"del -- [%d] : %d\n"</span>, num &gt;&gt; SHIFT, bitmap[num &gt;&gt; SHIFT]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p><a href="https://www.cnblogs.com/cjsblog/p/11613708.html">https://www.cnblogs.com/cjsblog/p/11613708.html</a></p>
<p><a href="https://www.cnblogs.com/chunxia/archive/2013/04/28/3049243.html">https://www.cnblogs.com/chunxia/archive/2013/04/28/3049243.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/414067305">https://zhuanlan.zhihu.com/p/414067305</a></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>tool</category>
        <category>2021</category>
        <category>11</category>
      </categories>
      <tags>
        <tag>实用教程</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++</title>
    <url>/2021/12/07/2021/12/C++/</url>
    <content><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><ul>
<li>开源 C++ 库列表<br><a href="https://zh.cppreference.com/w/cpp/links/libs">https://zh.cppreference.com/w/cpp/links/libs</a></li>
<li>C 语言<br><a href="https://zh.cppreference.com/w/c/language">https://zh.cppreference.com/w/c/language</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>tool</category>
        <category>2021</category>
        <category>12</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++内存管理</title>
    <url>/2021/10/07/2021/11/%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="一、内存"><a href="#一、内存" class="headerlink" title="一、内存"></a>一、内存</h2><p> 在计算机中，不同应用程序之间的内存是相互独立的，通常情况下不可以相互访问。</p>
<span id="more"></span>

<p>1、内存四区<br>从下到上为：代码区、数据区、堆区、栈区。<br>栈区：存储临时变量的区域，临时变量包括：局部变量、返回值、参数、返回地址。这些变量超出作用域自动弹出。超出栈大小将会栈溢出。栈从栈顶自上而下，最下端为0x0000。<br>堆区：比较大的内存区域，用于动态内存分配，由开放人员申请和释放，在程序结束时未释放，将会右系统自动回收。<br>数据区：主要存放全局变量、常量和静态变量；数据区又可以划分为：全局区和静态区。<br>代码区：主要纯粹可执行代码。属性为只读的。</p>
<h2 id="二、malloc和free"><a href="#二、malloc和free" class="headerlink" title="二、malloc和free"></a>二、malloc和free</h2><p> 在 C 语言（不是 C++)中，malloc 和 free 是系统提供的函数，成对使用，用于从堆中分配和释放内存。malloc 的全称是 memory allocation 译为“动态内存分配”。</p>
<ul>
<li>参考链接：<br><a href="https://mp.weixin.qq.com/s/mgJXEnhgvGSY4uwMRzLZeQ">https://mp.weixin.qq.com/s/mgJXEnhgvGSY4uwMRzLZeQ</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>tool</category>
        <category>2021</category>
        <category>11</category>
      </categories>
      <tags>
        <tag>Another Tag</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake</title>
    <url>/2021/12/07/2021/12/cmake/</url>
    <content><![CDATA[<h2 id="1-camke简述"><a href="#1-camke简述" class="headerlink" title="1.camke简述"></a>1.camke简述</h2><p> CMake是跨平台编译管理工具,为第三方依赖和引入,创建编译系统,程序测试及安装.Cmake工具使用CMakeLists.txt文件,跨平台执行相同编译命令,生成对应平台的可执行程序或者链接库.</p>
<span id="more"></span>

<p> CMake工程简单例子</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.12)</span><br><span class="line">project(myproj)</span><br><span class="line">find_package(Poco REQUIRED COMPONENTS Net Util)</span><br><span class="line">add_executable(MyExe)</span><br><span class="line">target_source(MyExe PRIVATE <span class="string">"main.cpp"</span>)</span><br><span class="line">target_link_library(MyExe PRIVATE Poco::Net PocoUtil)</span><br><span class="line"></span><br><span class="line">target_complie_definition(MyExe PRIVATE std_cxx_14)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-Target-和围绕-Target-的配置"><a href="#2-Target-和围绕-Target-的配置" class="headerlink" title="2.Target 和围绕 Target 的配置"></a>2.Target 和围绕 Target 的配置</h2><p> C/C++工程通常都是为了生成可执行程序或者链接库，在现代 CMake 里他们被统称为<code>target</code>，创建命令分别是<code>add_library()</code>和<code>add_executable()</code>。其中链接库的类型又分为很多种，最常用的就是<code>SHARED</code>以及<code>STATIC</code>，在命令中加入关键词进行声明：add_library(MyLib SHARED)，第一个参数为target的名称，后续的配置都需要用到这个名字。<br> 指定target的源文件：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">target_source(MyLib PRVIATE <span class="string">"main.cpp"</span> <span class="string">"func.cpp"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p> PRIVATE关键词用于描述参数的“应用范围”，此外还有INTERFACE和PUBLIC两种可能的值</p>
<p> 较多的源文件，可以使用 CMake 的file命令进行遍历拿到全部的源文件</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">file(GLOB_RECURSE SRCS <span class="variable">${CMAKE_CURRENT_SOURCE_DIR}</span>/*.cpp)</span><br></pre></td></tr></tbody></table></figure>
<p> 命令第一个参数GLOB_RECURSE表明递归的查找子文件夹，第二个参数SRCS则是存储结果的变量名，第三个参数为目标文件的匹配模式，找到符合条件的 cpp 文件后，他们的路径会以字符串数组的形式保存在 SRCS 变量中，使用方式如下：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">target_source(MyLib PRIVATE <span class="variable">${SRCS}</span>)</span><br></pre></td></tr></tbody></table></figure>
<p> 配置target时通常还需要指定头文件目录：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">target_include_directories(MyLib PRIVATE <span class="variable">${CMAKE_CURRENT_SOURCE_DIR}</span>/include/)</span><br></pre></td></tr></tbody></table></figure>
<p> 编译时需要的语言特性：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">target_compile_features(MyLib PRIVATE std_cxx_14)</span><br></pre></td></tr></tbody></table></figure>
<p> 编译时的宏定义：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">target_compile_definitions(MyLib PRIVATE LogLevel=3)</span><br></pre></td></tr></tbody></table></figure>
<p> 参数想直接传给底层的编译器（比如 gcc, clang, cl），可以使用</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">target_compile_options(MyLib PRIVATE -Werror -Wall -Wextra)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-Build-Specification-和-Usage-Requirement"><a href="#3-Build-Specification-和-Usage-Requirement" class="headerlink" title="3.Build Specification 和 Usage Requirement"></a>3.Build Specification 和 Usage Requirement</h2><p> C/C++通过 include 头文件的方式引入依赖，在动态或静态链接后可以调用依赖实现。一个可执行程序可能会依赖链接库，链接库也同样可能依赖其他的链接库<br> CMake 提供的解决方案是，在对 target 进行配置时，可以规定配置的类型，分为 build specification 和 usage requirement 两类，会影响配置的应用范围。Build specification 类型的配置仅在编译的时候需要满足，通过PRIVATE关键字声明；Usage requirement 类型的配置则是在使用时需要满足，即在其他项目里，使用本项目已编译好的 target 时需要满足，这种类型的配置使用INTERFACE关键词声明。在实际工程中，有很多配置在编译时以及被使用时都需要被满足的，这种配置通过PUBLIC关键词进行声明。</p>
<p> 一个 library，在编译时静态链接了 Boost，在我们的实现文件中使用了 c++14 的特性，并用到了 Boost 的头文件和函数。随后我们对外发布了这个库，其中有头文件和预编译好的动态链接库。尽管我们的实现代码里用了 C++14，但在对外提供的头文件中只用到 C++03 的语法，也没有引入任何 Boost 的代码。这种情况下，当其他工程在使用我们的 library 时，其使用的编译器不需要开启 C++14 的支持，开发环境下也不需要安装 Boost。我们 library 的 CMake 配置中可以这么写：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">target_compile_features(MyLib PRIVATE cxx_std_14)</span><br><span class="line">target_link_libraries(MyLib PRIVATE Boost::Format)</span><br></pre></td></tr></tbody></table></figure>
<p> PRIVATE 说明 c++14 的支持只在编译时需要用到，Boost 库的链接也仅在编译时需要。但如果我们对外提供的头文件中也使用了 C++14，那么就需要使用 PUBLIC 修饰，改为：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">target_compile_features(MyLib PUBLIC cxx_std_14)</span><br><span class="line">target_link_libraries(MyLib PRIVATE Boost::Format)</span><br></pre></td></tr></tbody></table></figure>
<p> 当 library 是 header-only 时，我们的工程是不需要单独编译的，因此也就没有 build specification，通过INTERFACE修饰配置即可</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">arget_compile_features(MyLib INTERFACE cxx_std_14)</span><br></pre></td></tr></tbody></table></figure>
<p> Usage requirement 类型的配置，即通过INTERFACE或是PUBLIC修饰的配置是会传递的，比如 LibA 依赖 LibB 后，会继承 LibB 的 usage requirement，此后 LibC 依赖 LibB 时，LibA 和 libB 的 usage requirement 都会继承下来，</p>
<h2 id="4-寻找和使用链接库"><a href="#4-寻找和使用链接库" class="headerlink" title="4.寻找和使用链接库"></a>4.寻找和使用链接库</h2><p> C/C++标准没有规范库的安装位置和安装形式，通过 CMake 提供的方案寻找依赖，不光可以定位到头文件目录和链接库路径，还能够获取到库的 usage requirement。<br> 在 CMake 中寻找第三方库的命令为find_package，其背后的工作方式有两种，一种基于 Config File 的查找，另一种则是基于 Find File 的查找。在执行find_package时，实际上 CMake 都是在找这两类文件，找到后从中获取关于库的信息。</p>
<h3 id="4-1-通过-Config-file-找到依赖"><a href="#4-1-通过-Config-file-找到依赖" class="headerlink" title="4.1 通过 Config file 找到依赖"></a>4.1 通过 Config file 找到依赖</h3><p> Config File 是依赖的开发者提供的 cmake 脚本，通常会随预编译好的二进制一起发布，供下游的使用者使用。在 Config file 里，会对库里包含的 target 进行描述，说明版本信息以及头文件路径、链接库路径、编译选项等 usage requirement</p>
<p> CMake 对 Config file 的命名是有规定的，对于find_package(ABC)这样一条命令，CMake 只会去寻找ABCConfig.cmake或是abc-config.cmake。CMake 默认寻找的路径和平台有关，在 Linux 下寻找路径包括/usr/lib/cmake以及/usr/lib/local/cmake，在这两个路径下可以发现大量的 Config File，一般在安装某个库时，其自带的 Config file 会被放到这里来。</p>
<h3 id="4-2-通过-Find-file-找到依赖"><a href="#4-2-通过-Find-file-找到依赖" class="headerlink" title="4.2 通过 Find file 找到依赖"></a>4.2 通过 Find file 找到依赖</h3><p> 对于find_package(ABC)命令，如果 CMake 没有找到 Config file，他还会去试着寻找FindABC.cmake。Find file 在功能上和 Config file 相同，区别在于 Find file 是由其他人编写的，而非库的开发者。如果你使用的某个库没有提供 Config file，你可以去网上搜搜 Find file 或者自己写一个，然后加入到你的 CMake 工程中。</p>
<p> CMake 官方为我们写好了很多 Find file，在CMake Documentation这一页面可以看到，OpenGL，OpenMP，SDL 这些知名的库官方都为我们写好了 Find 脚本，因此直接调用 find_package 命令即可。但由于库的安装位置并不是固定的，这些 Find 脚本不一定能找到库，此时根据 CMake 报错的提示设置对应变量即可，通常是需要提供安装路径，这样就可以通过 Find file 获取到库的 usage requirement。不论是 Config file 还是 Find file，其目的都不只是找到库这么简单，而是告诉 CMake 如何使用这个库。<br>库 CMake 官方也没有提供 Find file，这时候就要自己写了或者靠搜索了，写好后放到本项目的目录下，修改CMAKE_MODULE_PATH这个 CMAKE 变量：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">list(INSERT CMAKE_MODULE_PATH 0 <span class="variable">${CMAKE_SOURCE_DIR}</span>/cmake)</span><br></pre></td></tr></tbody></table></figure>
<p> ${CMAKE_SOURCE_DIR}/cmake目录下的 Find file 就可以被 CMake 找到了。<br> 通过 CMake 的find_library和find_path两个命令就可以完成任务：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">find_library(MPI_LIBRARY</span><br><span class="line">  NAMES mpi</span><br><span class="line">  HINTS <span class="string">"<span class="variable">${CMAKE_PREFIX_PATH}</span>/lib"</span> <span class="variable">${MPI_LIB_PATH}</span></span><br><span class="line">  <span class="comment"># 如果默认路径没找到libmpi.so，还会去MPI_LIB_PATH找，下游使用者可以设置这个变量值</span></span><br><span class="line">)</span><br><span class="line">find_path(MPI_INCLUDE_DIR</span><br><span class="line">  NAMES mpi.h</span><br><span class="line">  PATHS <span class="string">"<span class="variable">${CMAKE_PREFIX_PATH}</span>/include"</span> <span class="variable">${MPI_INCLUDE_PATH}</span></span><br><span class="line">  <span class="comment"># 如果默认路径没找到mpi.h，还会去MPI_INCLUDE_PATH找，下游使用者可以设置这个变量值</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-3-find-package-的处理"><a href="#4-3-find-package-的处理" class="headerlink" title="4.3.find_package 的处理"></a>4.3.find_package 的处理</h3><p> find_package这个命令，这个命令可以指定很多参数，比如指定版本，指定具体的模块等等。以 SFML 多媒体库为例，其包含了 network 模块，audio 模块，graphic 模块等等，但我很多时候只用到 graphic 模块，那么其他的模块对应的链接库不需要被链接，于是 CMake 脚本可以这么写：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 要求大版本号为2的SFML库的graphic模块</span></span><br><span class="line">find_package(SFML 2 COMPONENTS graphics REQUIRED)</span><br><span class="line"><span class="comment"># SFML提供的target名字为sfml-graphics</span></span><br><span class="line">target_link_libraries(MyEXE PRIVATE sfml-graphics)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-使用-CMake-来编译"><a href="#5-使用-CMake-来编译" class="headerlink" title="5.使用 CMake 来编译"></a>5.使用 CMake 来编译</h3><p> CMake 生成好编译环境后，底层的 make, ninja, MSBuild 编译命令都是不一样的，但 CMake 提供了一个统一的方法进行编译：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">cmake --build .</span><br></pre></td></tr></tbody></table></figure>
<p> 使用–buildflag，CMake 就会调用底层的编译命令，在跨平台时十分方便。<br> 对于 Visual Studio，其 Debug 和 Release 环境是基于 configuration 的，因此CMAKE_BUILD_TYPE变量无效，需要在 build 时指定：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">cmake --build . --config Release</span><br></pre></td></tr></tbody></table></figure>




<ul>
<li>参考链接:<br>cmake<br><a href="https://ukabuer.me/blog/more-modern-cmake/">https://ukabuer.me/blog/more-modern-cmake/</a><br>Makefile</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>tool</category>
        <category>2021</category>
        <category>12</category>
      </categories>
      <tags>
        <tag>cs</tag>
        <tag>complier</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法基础</title>
    <url>/2021/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1-程序性能"><a href="#1-程序性能" class="headerlink" title="1 程序性能"></a>1 程序性能</h2><span id="more"></span>

<p> 程序性能是指运行程序所需要的<strong>内存大小(空间复杂度)和时间(时间复杂度)</strong>,运行时间和占用空间是算法性能最关键的指标。<br> 软件程序性能衡量指标:<br> 响应时间、启动时间、执行时间、执行速度、计算资源分配、内存分配、磁盘吞吐量、网络吞吐量、负载承受能力</p>
<h3 id="1-1-空间复杂度"><a href="#1-1-空间复杂度" class="headerlink" title="1.1 空间复杂度"></a>1.1 空间复杂度</h3><p> 空间复杂度(Space complexity)，算法完全运行所需存储空间。表示算法的存储空间与数据规模之间的增长关系：常量空间、线性空间、二维空间。<br> 算法在计算机存储器上所占用的存储空间，包括<strong>存储程序本身占用的存储空间，算法输入输出数据所占的存储空间和算法在运行过程中临时占用的存储空间</strong>。</p>
<h3 id="1-2-时间复杂度"><a href="#1-2-时间复杂度" class="headerlink" title="1.2 时间复杂度"></a>1.2 时间复杂度</h3><p> 时间复杂度(Time complexity)，算法完全运行所需运算时间。时间复杂度通常用大O符合表示。</p>
<p><img src="https://i.loli.net/2021/10/27/UxWCvnRQLYz5eiG.png" alt="20211027233029"></p>
<h4 id="1-2-1-常见算法大O"><a href="#1-2-1-常见算法大O" class="headerlink" title="1.2.1 常见算法大O"></a>1.2.1 常见算法大O</h4><p>  常量阶O(1); 对数阶O(logn); 线性阶O(n); 线性对数阶O(nlogn); k次方阶O(n^k)<br><img src="https://i.loli.net/2021/10/28/GWOFcUi3qdVIlmf.png" alt="20211028010721"></p>
<h4 id="1-2-2-常见数据结构"><a href="#1-2-2-常见数据结构" class="headerlink" title="1.2.2 常见数据结构"></a>1.2.2 常见数据结构</h4><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>数据结构与算法<ul>
<li>线性表</li>
<li>数组<ul>
<li>链表<ul>
<li>单链表</li>
<li>双链表</li>
<li>循环链表</li>
<li>双向循环链表</li>
<li>静态链表</li>
</ul>
</li>
</ul>
</li>
<li>栈<pre><code>  - 顺序栈
  - 链式栈
</code></pre>
</li>
<li>队列<pre><code>  - 普通队列
  - 双端队列
  - 阻塞队列
  - 并发队列
  - 阻塞并发队列
</code></pre>
</li>
<li>散列表<ul>
<li>散列函数</li>
<li>冲突解决<ul>
<li>链表法</li>
<li>开放地址</li>
<li>其他</li>
</ul>
</li>
<li>动态扩容</li>
<li>位置</li>
</ul>
</li>
<li>树<ul>
<li>二叉树<ul>
<li>二叉查找树</li>
<li>平衡二叉树</li>
<li>平衡二叉查找树<ul>
<li>AVL树</li>
<li>红黑树</li>
</ul>
</li>
<li>完全二叉树</li>
<li>满二叉树</li>
</ul>
</li>
<li>多路查找树<ul>
<li>B树</li>
<li>B+树</li>
<li>2-3树</li>
<li>2-3-4树</li>
</ul>
</li>
<li>堆<ul>
<li>小顶堆</li>
<li>大顶堆</li>
<li>优先级队列</li>
<li>斐波那契堆</li>
<li>二项堆</li>
</ul>
</li>
<li>其他<ul>
<li>树状数组</li>
<li>线段树</li>
</ul>
</li>
</ul>
</li>
<li>图<ul>
<li>图的存储<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
</ul>
</li>
<li>拓扑排序</li>
<li>最短路径</li>
<li>关键路径</li>
<li>最小生成树</li>
<li>二分图</li>
<li>最大流</li>
</ul>
</li>
<li>复杂度分析<ul>
<li>空间复杂度</li>
<li>时间复杂度</li>
</ul>
</li>
<li>基本算法思想<ul>
<li>贪心算法</li>
<li>递归算法</li>
<li>分治法</li>
<li>动态规划</li>
<li>回溯法</li>
<li>枚举法</li>
</ul>
</li>
<li>排序<ul>
<li>O(n^2)<ul>
<li>冒泡排序</li>
<li>插入排序</li>
<li>选择排序</li>
<li>希尔排序</li>
</ul>
</li>
<li>O(nlogn)<ul>
<li>归并排序</li>
<li>快速排序</li>
<li>堆排序</li>
</ul>
</li>
<li>O(n)<ul>
<li>计数排序</li>
<li>基数排序</li>
<li>桶排序</li>
</ul>
</li>
</ul>
</li>
<li>搜索<ul>
<li>深度优先搜索</li>
<li>广度优先搜索</li>
<li>A*启发式搜索</li>
</ul>
</li>
<li>查找<ul>
<li>线性表查找</li>
<li>树结构查找</li>
<li>散列表查找</li>
</ul>
</li>
<li>字符串匹配<ul>
<li>朴素</li>
<li>KMP</li>
<li>Robin-Karp</li>
<li>Boyer-Moore</li>
<li>AC自动机</li>
<li>Trie</li>
<li>后缀数组</li>
</ul>
</li>
<li>其他<ul>
<li>数论</li>
<li>计算几何</li>
<li>概率分析</li>
<li>并查集</li>
<li>拓扑网络</li>
<li>矩阵运算</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h3 id="本章参考："><a href="#本章参考：" class="headerlink" title="本章参考："></a>本章参考：</h3><ul>
<li>复杂度速查表<br><a href="https://liam.page/2016/06/20/big-O-cheat-sheet/">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></li>
</ul>
<h2 id="2-基本数据结构"><a href="#2-基本数据结构" class="headerlink" title="2 基本数据结构"></a>2 基本数据结构</h2><h3 id="2-1-线性表"><a href="#2-1-线性表" class="headerlink" title="2.1 线性表"></a>2.1 线性表</h3><p> 线性表是n个具有相同特性的数据元素的有序序列。线性表除第一个和最后一个数据元素之外，其他数据元素都是首尾相接的。<br> 数据在实际的物理存储中有两种形式：分散存储和集中存储,常见数据结构有栈、队列、字符串、链表等。<br> 两种情况下数据的存储问题：<br>  数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；<br>  数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”</p>
<h4 id="2-1-1-数组"><a href="#2-1-1-数组" class="headerlink" title="2.1.1 数组"></a>2.1.1 数组</h4><p> 数组是一批相同数据的集合。数组的三部分：<code>地址 大小 和 空间</code>。数组的保存形式为线性表。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>]; <span class="comment">// /[]内必须是常量/常量表达式(3+8)，不能是一个变量(x...)</span></span><br><span class="line"><span class="comment">// 数组初始化</span></span><br><span class="line"><span class="keyword">int</span> arr1[<span class="number">3</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="keyword">char</span> arr6[] = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">int</span> *ptr = <span class="literal">NULL</span>;<span class="comment">//定义一个整型的指针变量，初始化为NULL</span></span><br><span class="line"><span class="keyword">char</span> *ptr = <span class="literal">NULL</span>;<span class="comment">//定义一个字符的指针变量，初始化为NULL</span></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">// C 传递数组给函数</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> *param)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> param[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> param[])</span></span></span><br><span class="line"><span class="function"><span class="comment">// C 从函数返回数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>array</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> used;</span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(struct <span class="built_in">array</span> *<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="built_in">array</span>-&gt;used; idx++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%02d]: %08d\n"</span>, idx, <span class="built_in">array</span>-&gt;arr[idx]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(struct <span class="built_in">array</span> *<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">array</span>-&gt;arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">array</span>-&gt;size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(struct <span class="built_in">array</span> *<span class="built_in">array</span>, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;used &gt;= <span class="built_in">array</span>-&gt;size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; <span class="built_in">array</span>-&gt;used; idx++) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;arr[idx] &gt; elem)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="built_in">array</span>-&gt;used)</span><br><span class="line">        memmove(&amp;<span class="built_in">array</span>-&gt;arr[idx+<span class="number">1</span>], &amp;<span class="built_in">array</span>-&gt;arr[idx],</span><br><span class="line">            (<span class="built_in">array</span>-&gt;used - idx) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span>-&gt;arr[idx] = elem;</span><br><span class="line">    <span class="built_in">array</span>-&gt;used++;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(struct <span class="built_in">array</span> *<span class="built_in">array</span>, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt;= <span class="built_in">array</span>-&gt;used)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    memmove(&amp;<span class="built_in">array</span>-&gt;arr[idx], &amp;<span class="built_in">array</span>-&gt;arr[idx+<span class="number">1</span>],</span><br><span class="line">        (<span class="built_in">array</span>-&gt;used - idx - <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">array</span>-&gt;used--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(struct <span class="built_in">array</span> *<span class="built_in">array</span>, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="built_in">array</span>-&gt;used; idx++) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;arr[idx] == elem)</span><br><span class="line">            <span class="keyword">return</span> idx;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;arr[idx] &gt; elem)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array</span> <span class="title">ten_int</span> =</span> {<span class="number">10</span>, <span class="number">0</span>, <span class="literal">NULL</span>};</span><br><span class="line"></span><br><span class="line">    alloc(&amp;ten_int);</span><br><span class="line">    <span class="keyword">if</span> (!ten_int.arr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    insert(&amp;ten_int, <span class="number">1</span>);</span><br><span class="line">    insert(&amp;ten_int, <span class="number">3</span>);</span><br><span class="line">    insert(&amp;ten_int, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== insert 1, 3, 2\n"</span>);</span><br><span class="line">    dump(&amp;ten_int);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = search(&amp;ten_int, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2 is at position %d\n"</span>, idx);</span><br><span class="line">    idx = search(&amp;ten_int, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"9 is at position %d\n"</span>, idx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== delete [6] element \n"</span>);</span><br><span class="line">    <span class="keyword">delete</span>(&amp;ten_int, <span class="number">6</span>);</span><br><span class="line">    dump(&amp;ten_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== delete [0] element \n"</span>);</span><br><span class="line">    <span class="keyword">delete</span>(&amp;ten_int, <span class="number">0</span>);</span><br><span class="line">    dump(&amp;ten_int);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<br>

<p><strong>二分搜索</strong><br> 基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）<br> 二分搜索的时间复杂度为 <em><strong>对数时间O(logn)</strong></em></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid, count = <span class="number">0</span>, count1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) {</span><br><span class="line">        count++;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) {</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid]) {</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == a[mid]) {</span><br><span class="line">            count1++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count1 == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-1-2-单链表"><a href="#2-1-2-单链表" class="headerlink" title="2.1.2 单链表"></a>2.1.2 单链表</h4><p>  单链表元素之间有一个单独的指针链接。这种结构的链表可以使得从第一个元素遍历到最后一个元素</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListElmt_</span> {</span></span><br><span class="line">    <span class="keyword">void</span> *data;  <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListElmt_</span> * <span class="title">next</span>;</span> <span class="comment">// next指针</span></span><br><span class="line">} ListElmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List_</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">void</span> *data);</span><br><span class="line">    ListElmt *head;</span><br><span class="line">    ListElmt *tail;</span><br><span class="line">} List;</span><br></pre></td></tr></tbody></table></figure>
<p> 单链表操作：插入、删除、<br> 如何判断单链表存在回环？<br>  设有两个指针p1，p2。在美学循环的时候，p1先走一步，p2走两步，直到p2碰到空指针或者两者相等时循环结束，如果两个指针相等则说明存在回环。</p>
<details>
<summary>singleList</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SINGLELIST_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SINGLELIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">}listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">size_t</span> typesize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>(*dup)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line">    <span class="keyword">int</span>(*match)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line">    <span class="keyword">void</span>(*<span class="built_in">free</span>)(<span class="keyword">void</span>*);</span><br><span class="line">}linkedList;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br><span class="line"></span><br><span class="line"><span class="function">linkedList *<span class="title">listCreate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function">linkedList *<span class="title">listAddNodeHead</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function">linkedList *<span class="title">listAddNodeTail</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function">linkedList *<span class="title">listInsertNode</span><span class="params">(linkedList *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">bool</span> after)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(linkedList *<span class="built_in">list</span>, listNode *node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span>;</span><br><span class="line"><span class="function">linkedList* <span class="title">listRewind</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">listLength</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !__SINGLELIST_H__</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"singleList.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">linkedList * <span class="title">listCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linkedList *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listEmpty(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != <span class="built_in">list</span>-&gt;head)</span><br><span class="line">    {</span><br><span class="line">        listNode *pNode = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = pNode-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">list</span>-&gt;<span class="built_in">free</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(pNode-&gt;value);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">free</span>(pNode-&gt;value);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(pNode);</span><br><span class="line">        pNode = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">linkedList * <span class="title">listAddNodeHead</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> * value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span> || <span class="literal">NULL</span> == value)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *node = <span class="literal">NULL</span>;</span><br><span class="line">    node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*node));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == node)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line"></span><br><span class="line">    ++<span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">linkedList * <span class="title">listAddNodeTail</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span> || <span class="literal">NULL</span> == value)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *node = <span class="literal">NULL</span>;</span><br><span class="line">    node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*node));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == node)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>-&gt;head</span><br><span class="line">        &amp;&amp; <span class="built_in">list</span>-&gt;len == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        listNode *tail = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        listNode *pre = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> != tail)</span><br><span class="line">        {</span><br><span class="line">            pre = tail;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ++<span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">linkedList * <span class="title">listInsertNode</span><span class="params">(linkedList *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">bool</span> after)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span> || <span class="literal">NULL</span> == old_node)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *pNode = <span class="literal">NULL</span>;</span><br><span class="line">    pNode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*pNode));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pNode)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNode-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (after)</span><br><span class="line">    {</span><br><span class="line">        pNode-&gt;next = old_node-&gt;next;</span><br><span class="line">        old_node-&gt;next = pNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        listNode *pre = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next != old_node)</span><br><span class="line">        {</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pre)</span><br><span class="line">        {</span><br><span class="line">            pre-&gt;next = pNode;</span><br><span class="line">            pNode-&gt;next = old_node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ++<span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(linkedList *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span> || <span class="literal">NULL</span> == node)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *pre = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    listNode *cur = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != cur &amp;&amp; cur != node)</span><br><span class="line">    {</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pre)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pre-&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    --<span class="built_in">list</span>-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">list</span>-&gt;<span class="built_in">free</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        node = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">listNode * <span class="title">listSearchKey</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *node = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != node)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">list</span>-&gt;match)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(key, node-&gt;value) == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">listNode * <span class="title">listIndex</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span></span><br><span class="line">        || index &gt; <span class="built_in">list</span>-&gt;len)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *pNode = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; index; ++i)</span><br><span class="line">    {</span><br><span class="line">        pNode = pNode-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">linkedList* <span class="title">listRewind</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *head = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    listNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    listNode *next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != head)</span><br><span class="line">    {</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = pre;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">listLength</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<details>
<summary>single_list</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">single_list_head</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">head</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(struct single_list_head *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> head-&gt;head == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(struct single_list_head *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">tmp</span> =</span> head-&gt;head;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tmp) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%02d]: %08d\n"</span>, idx++, tmp-&gt;val);</span><br><span class="line">    tmp = tmp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(struct single_list **prev, struct single_list *elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!prev)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    elem-&gt;next = *prev;</span><br><span class="line">    *prev = elem;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_head</span><span class="params">(struct single_list_head *head, struct single_list *elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    insert(&amp;head-&gt;head, elem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct single_list* <span class="title">del</span><span class="params">(struct single_list **prev)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (*prev == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    tmp = *prev;</span><br><span class="line">    *prev = (*prev)-&gt;next;</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">struct single_list* <span class="title">delete_head</span><span class="params">(struct single_list_head* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> del(&amp;head-&gt;head);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">struct single_list** <span class="title">search</span><span class="params">(struct single_list_head* head, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> **<span class="title">prev</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (prev = &amp;head-&gt;head, tmp = *prev;</span><br><span class="line">         tmp &amp;&amp; (tmp-&gt;val &lt; target);</span><br><span class="line">         prev = &amp;tmp-&gt;next, tmp = *prev)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(struct single_list_head* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list_head</span> <span class="title">tmp</span> =</span> {<span class="literal">NULL</span>};</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">elem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_empty(head)) {</span><br><span class="line">    elem = delete_head(head);</span><br><span class="line">    insert_head(&amp;tmp, elem);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    head-&gt;head = tmp.head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_cyclic</span><span class="params">(struct single_list_head* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">s1</span>, *<span class="title">s2</span>;</span></span><br><span class="line"></span><br><span class="line">    s1 = s2 = head-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(s1 &amp;&amp; s2) {</span><br><span class="line">    s1 = s1-&gt;next;</span><br><span class="line">    s2 = s2-&gt;next ? s2-&gt;next-&gt;next:s2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1 == s2)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct single_list* <span class="title">middle</span><span class="params">(struct single_list_head* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">s1</span>, *<span class="title">s2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> <span class="title">pseudo_head</span>;</span></span><br><span class="line"></span><br><span class="line">    pseudo_head.next = head-&gt;head;</span><br><span class="line">    s1 = s2 = &amp;pseudo_head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="keyword">if</span> (!s2 || !s2-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> s1;</span><br><span class="line">    s1 = s1-&gt;next;</span><br><span class="line">    s2 = s2-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list_head</span> <span class="title">head</span> =</span> {<span class="literal">NULL</span>};</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> <span class="title">lists</span>[10];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> **<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; <span class="number">10</span>; idx++) {</span><br><span class="line">    lists[idx].val = idx;</span><br><span class="line">    lists[idx].next = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    insert_head(&amp;head, &amp;lists[<span class="number">6</span>]);</span><br><span class="line">    insert_head(&amp;head, &amp;lists[<span class="number">5</span>]);</span><br><span class="line">    insert_head(&amp;head, &amp;lists[<span class="number">4</span>]);</span><br><span class="line">    insert_head(&amp;head, &amp;lists[<span class="number">1</span>]);</span><br><span class="line">    insert_head(&amp;head, &amp;lists[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== insert 0, 1, 4, 5, 6\n"</span>);</span><br><span class="line">    dump(&amp;head);</span><br><span class="line"></span><br><span class="line">    prev = search(&amp;head, <span class="number">2</span>);</span><br><span class="line">    insert(prev, &amp;lists[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== insert 2\n"</span>);</span><br><span class="line">    dump(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"middle elem is %d\n"</span>, middle(&amp;head)-&gt;val);</span><br><span class="line"></span><br><span class="line">    prev = search(&amp;head, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> ((*prev) &amp;&amp; ((*prev)-&gt;val == <span class="number">2</span>))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The list contains 2\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The list not contains 2\n"</span>);</span><br><span class="line"></span><br><span class="line">    del(prev);</span><br><span class="line">    prev = search(&amp;head, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After remove 2\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((*prev) &amp;&amp; ((*prev)-&gt;val == <span class="number">2</span>))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The list contains 2\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The list not contains 2\n"</span>);</span><br><span class="line">    dump(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After reverse \n"</span>);</span><br><span class="line">    reverse(&amp;head);</span><br><span class="line">    dump(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"middle elem is %d\n"</span>, middle(&amp;head)-&gt;val);</span><br><span class="line"></span><br><span class="line">    lists[<span class="number">0</span>].next = &amp;lists[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"list is%s cyclic\n"</span>, is_cyclic(&amp;head)?<span class="string">""</span>:<span class="string">" not"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<details>
<summary>LinkedListAlgo</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1) 单链表反转</span></span><br><span class="line"><span class="comment"> * 2) 链表中环的检测</span></span><br><span class="line"><span class="comment"> * 3) 两个有序的链表合并</span></span><br><span class="line"><span class="comment"> * 4) 删除链表倒数第 n 个结点</span></span><br><span class="line"><span class="comment"> * 5) 求链表的中间结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Author: Smallfly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SinglyLinkedNode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SinglyLinkedNode</span>* <span class="title">next</span>;</span></span><br><span class="line">} SinglyLinkedNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(SinglyLinkedNode** head_ref, <span class="keyword">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(SinglyLinkedNode* head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 反转单链表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(SinglyLinkedNode** head_ref)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">    SinglyLinkedNode *current = *head_ref;</span><br><span class="line">    <span class="keyword">while</span> (current) {</span><br><span class="line">        SinglyLinkedNode *next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!next) {</span><br><span class="line">            <span class="comment">// 到达尾结点时，将地址存入 head_ref</span></span><br><span class="line">            *head_ref = current;</span><br><span class="line">        }</span><br><span class="line">        current-&gt;next = prev;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_reverse</span><span class="params">()</span> </span>{</span><br><span class="line">    SinglyLinkedNode* head = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;head, <span class="number">3</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">2</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    reverse(&amp;head);</span><br><span class="line">    printLinkedList(head);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 检测单链表是否有环 */</span></span><br><span class="line"><span class="comment">// 这里使用一级指针也可以</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkCircle</span><span class="params">(SinglyLinkedNode** head_ref)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    SinglyLinkedNode *slow = *head_ref, *fast = *head_ref;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_checkCircle</span><span class="params">()</span> </span>{</span><br><span class="line">    SinglyLinkedNode* head = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;head, <span class="number">3</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">2</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result1 = checkCircle(&amp;head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"has circle: %d\n"</span>, result1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// make circle linklist</span></span><br><span class="line">    SinglyLinkedNode* current = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SinglyLinkedNode));</span><br><span class="line">    current-&gt;data = <span class="number">0</span>;</span><br><span class="line">    SinglyLinkedNode* h = current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">        SinglyLinkedNode* node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SinglyLinkedNode));</span><br><span class="line">        node-&gt;data = i;</span><br><span class="line">        current-&gt;next = node;</span><br><span class="line">        <span class="comment">//reset current node</span></span><br><span class="line">        current = node;</span><br><span class="line">    }</span><br><span class="line">    current-&gt;next = h;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result2 = checkCircle(&amp;h);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"has circle: %d\n"</span>, result2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 有序链表合并 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveNode</span><span class="params">(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SinglyLinkedNode* <span class="title">mergeSortedLinkedList</span><span class="params">(SinglyLinkedNode* la, SinglyLinkedNode* lb)</span> </span>{</span><br><span class="line">    <span class="comment">// 辅助结点，next 指针持有合并后的有序链表</span></span><br><span class="line">    SinglyLinkedNode dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有序链表的尾结点</span></span><br><span class="line">    SinglyLinkedNode* tail = &amp;dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 如果有一个链表为空，直接与另一个链表接起来</span></span><br><span class="line">        <span class="keyword">if</span> (!la) {</span><br><span class="line">            tail-&gt;next = lb;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!lb) {</span><br><span class="line">            tail-&gt;next = la;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将头结点较小的优先添加到 tail</span></span><br><span class="line">        <span class="keyword">if</span> (la-&gt;data &lt;= lb-&gt;data) {</span><br><span class="line">            moveNode(&amp;(tail-&gt;next), &amp;la);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            moveNode(&amp;(tail-&gt;next), &amp;lb);</span><br><span class="line">        }</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 src_ref 的头结点，添加到 dest_ref 的头部。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveNode</span><span class="params">(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*src_ref == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    SinglyLinkedNode* new_node = *src_ref;</span><br><span class="line">    </span><br><span class="line">    *src_ref = new_node-&gt;next;</span><br><span class="line">    </span><br><span class="line">    new_node-&gt;next = *dest_ref;</span><br><span class="line">    *dest_ref = new_node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_mergeSortedLinkedList</span><span class="params">()</span> </span>{</span><br><span class="line">    SinglyLinkedNode* a = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;a, <span class="number">10</span>);</span><br><span class="line">    insertNode(&amp;a, <span class="number">5</span>);</span><br><span class="line">    insertNode(&amp;a, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode* b = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;b, <span class="number">8</span>);</span><br><span class="line">    insertNode(&amp;b, <span class="number">6</span>);</span><br><span class="line">    insertNode(&amp;b, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode* result = mergeSortedLinkedList(a, b);</span><br><span class="line">    printLinkedList(result);</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode* result2 = mergeSortedLinkedList(a, <span class="literal">NULL</span>);</span><br><span class="line">    printLinkedList(result2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 删除倒数第 K 个结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteLastKth</span><span class="params">(SinglyLinkedNode** head_ref, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span> || k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快指针向前移动 k-1</span></span><br><span class="line">    SinglyLinkedNode* fast = *head_ref;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; k &amp;&amp; fast != <span class="literal">NULL</span>) {</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        ++i;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果快指针为空，说明结点个数小于 k</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode* slow = *head_ref;</span><br><span class="line">    SinglyLinkedNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        prev = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 prev 为空，头结点刚好是第 k 个结点</span></span><br><span class="line">    <span class="keyword">if</span> (!prev) {</span><br><span class="line">        (*head_ref) = (*head_ref)-&gt;next;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        prev-&gt;next = slow-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(slow);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_deleteLastKth</span><span class="params">()</span> </span>{</span><br><span class="line">    SinglyLinkedNode* head = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;head, <span class="number">1</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">2</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">3</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">4</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 删除头结点</span></span><br><span class="line">    deleteLastKth(&amp;head, <span class="number">5</span>);</span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 删除中间结点</span></span><br><span class="line">    deleteLastKth(&amp;head, <span class="number">2</span>);</span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 求中间结点  */</span></span><br><span class="line"><span class="function">SinglyLinkedNode* <span class="title">findMiddleNode</span><span class="params">(SinglyLinkedNode* head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    SinglyLinkedNode* slow = head;</span><br><span class="line">    SinglyLinkedNode* fast = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 慢指针走一步，快指针两步</span></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_findMiddleNode</span><span class="params">()</span> </span>{</span><br><span class="line">    SinglyLinkedNode* head = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;head, <span class="number">1</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">2</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">3</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">4</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode* middleNode = findMiddleNode(head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, middleNode-&gt;data);</span><br><span class="line">    printLinkedList(head);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 工具方法 */</span></span><br><span class="line"><span class="comment">// 插入新结点到链表头部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(SinglyLinkedNode** head_ref, <span class="keyword">int</span> data)</span> </span>{</span><br><span class="line">    SinglyLinkedNode* new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SinglyLinkedNode));</span><br><span class="line">    new_node-&gt;data = data;</span><br><span class="line">    new_node-&gt;next = *head_ref;</span><br><span class="line">    *head_ref = new_node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(SinglyLinkedNode* node)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--- start ---\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (node) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"data: %d\n"</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--- end ---\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跑测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">    </span><br><span class="line">    test_reverse();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    test_checkCircle();</span></span><br><span class="line"><span class="comment">//    test_mergeSortedLinkedList();</span></span><br><span class="line"><span class="comment">//    test_deleteLastKth();  </span></span><br><span class="line"><span class="comment">//    test_findMiddleNode();</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<details>
<summary>linklist_jinshaohui</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: lisklist.c</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-10-07  </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stlistNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">}listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*反转链表*/</span></span><br><span class="line"><span class="function">listNode <span class="title">reverseList</span><span class="params">(listNode *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    listNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">    listNode *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">    next = head-&gt;next;</span><br><span class="line">    head-&gt;next = prev;</span><br><span class="line">    prev = head;</span><br><span class="line">    head = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断链表是否有环*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hasCycle</span><span class="params">(listNode *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    listNode * fast = head;</span><br><span class="line">    listNode * low = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">    low = low-&gt;next;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (low == fast)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*合并有序链表*/</span></span><br><span class="line"><span class="function">listNode *<span class="title">mergeTwoLists</span><span class="params">(listNode *l1,listNode *l2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    listNode head = {<span class="number">0</span>};</span><br><span class="line">    listNode *pRes = &amp;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">    pRes-&gt;next = l2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">    pRes-&gt;next = l1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">    {</span><br><span class="line">    pRes-&gt;next = l1;</span><br><span class="line">    l1 = l1-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">    pRes-&gt;next = l2;</span><br><span class="line">    l2 = l2-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    pRes = pRes-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *删除链表倒数第n个节点，并返回链表头节点 */</span></span><br><span class="line"><span class="function">listNode * <span class="title">removeNthFromEnd</span><span class="params">(listNode*headi,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    listNode *fast = head;</span><br><span class="line">    listNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">    listNpde *next = head;</span><br><span class="line">    <span class="keyword">int</span> k = n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*快指针往后移动k-1*/</span></span><br><span class="line">    <span class="keyword">while</span>((k &gt; <span class="number">1</span>) &amp;&amp; (fast != <span class="literal">NULL</span>)) {</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        k--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*说明链表数目不足n个*/</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        prev = next;</span><br><span class="line">        next = next-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prev == <span class="literal">NULL</span>) {</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*求链表的中间节点*/</span></span><br><span class="line"><span class="function">listNode *<span class="title">middleNode</span><span class="params">(listNode *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    listNode * fast = head;</span><br><span class="line">    listNode * low = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        low = low-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<h4 id="2-1-3-双链表"><a href="#2-1-3-双链表" class="headerlink" title="2.1.3 双链表"></a>2.1.3 双链表</h4><p>  双向链表的元素通过两个指针链接，一个指向直接后继，一个指向直接前驱。双向链表可以正向遍历，也可反向遍历。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DListElmt_</span> {</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DListElmt_</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DListElmt_</span> *<span class="title">next</span>;</span></span><br><span class="line">} DListElmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DList_</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">void</span> *data);</span><br><span class="line">    DListElmt *head;</span><br><span class="line">    DListElmt *tail;</span><br><span class="line">} DList;</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>Dlist</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Dlist.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DlistNode</span>          //双向链表中每一个节点</span></span><br><span class="line"><span class="class">{</span>          </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DlistNode</span> *<span class="title">prev</span>;</span>   <span class="comment">//节点前项指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DlistNode</span> *<span class="title">next</span>;</span>   <span class="comment">//节点后项指针</span></span><br><span class="line">    <span class="keyword">int</span>    data;              <span class="comment">//数据</span></span><br><span class="line">}stDlistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dlisthead</span>          //定义链表总体</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> size;                 <span class="comment">//链表长度</span></span><br><span class="line">    stDlistNode *head;        <span class="comment">//头指针</span></span><br><span class="line">    stDlistNode *tail;        <span class="comment">//尾部指针</span></span><br><span class="line">}stDlistHead;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dlist.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./Dlist.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlist_init</span><span class="params">(stDlistHead *dlist)</span>    <span class="comment">//链表初始化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dlist-&gt;size = <span class="number">0</span>;</span><br><span class="line">    dlist-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    dlist-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlist_destory</span><span class="params">(stDlistHead *dlist)</span>    <span class="comment">//删除链表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stDlistNode *pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dlist-&gt;size &gt; <span class="number">0</span>) {</span><br><span class="line">        pNode = dlist-&gt;head;</span><br><span class="line">        dlist-&gt;head = dlist-&gt;head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pNode);</span><br><span class="line">        dlist-&gt;size--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dlist,<span class="number">0</span>,<span class="keyword">sizeof</span>(stDlistHead));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlist_insert_head</span><span class="params">(stDlistHead *dlist,stDlistNode *pNode,<span class="keyword">int</span> data)</span>    <span class="comment">//插入头结点，操作的链表，操作的节点，数据</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>) {   <span class="comment">//当只传递一个数据时</span></span><br><span class="line">        pNode = (stDlistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stDlistNode));    <span class="comment">//新建节点，为节点分配空间（malloc（）可能需要#include&lt;malloc.h&gt;）</span></span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNode-&gt;data = data;    </span><br><span class="line">    pNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    pNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dlist-&gt;size == <span class="number">0</span>) {  <span class="comment">//如果链表长度为0，即链表当前无节点，</span></span><br><span class="line">        dlist-&gt;head = pNode;</span><br><span class="line">        dlist-&gt;tail = pNode;</span><br><span class="line">    } <span class="keyword">else</span> {                 <span class="comment">//如果链表已有节点，则令新插入节点为头节点</span></span><br><span class="line">        pNode-&gt;next = dlist-&gt;head;</span><br><span class="line">        dlist-&gt;head-&gt;prev = pNode;</span><br><span class="line">        dlist-&gt;head = pNode;    </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dlist-&gt;size++;    <span class="comment">//每成功调用一次，链表长度+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">stDlistNode * <span class="title">dlist_remove_tail</span><span class="params">(stDlistHead *dlist)</span>    <span class="comment">//删除尾部节点,并返回删除节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stDlistNode *pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dlist-&gt;size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNode = dlist-&gt;tail;</span><br><span class="line">    <span class="keyword">if</span>(dlist-&gt;size &gt; <span class="number">1</span>) {</span><br><span class="line">        dlist-&gt;tail = dlist-&gt;tail-&gt;prev;</span><br><span class="line">        dlist-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        dlist-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">        dlist-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    dlist-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlist_remove_node</span><span class="params">(stDlistHead * dlist,stDlistNode *pNode)</span>     <span class="comment">//删除指定节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> ((dlist == <span class="literal">NULL</span>)||(pNode == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dlist-&gt;head == pNode) {</span><br><span class="line">        dlist-&gt;head = dlist-&gt;head-&gt;next;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (dlist-&gt;tail == pNode) {</span><br><span class="line">        dlist-&gt;tail = pNode-&gt;prev;</span><br><span class="line">        dlist-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        pNode-&gt;prev-&gt;next = pNode-&gt;next;</span><br><span class="line">        pNode-&gt;next-&gt;prev = pNode-&gt;prev;</span><br><span class="line">    }</span><br><span class="line">    dlist-&gt;size--;</span><br><span class="line">    pNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    pNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dlist-&gt;size == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">memset</span>(dlist,<span class="number">0</span>,<span class="keyword">sizeof</span>(stDlistHead));     <span class="comment">//将dlist占用内存块的所有值置为0，也就是清空head,tail指针内容</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function">stDlistNode * <span class="title">dlist_search</span><span class="params">(stDlistHead * dlist,<span class="keyword">int</span> data)</span>     <span class="comment">//根据值搜索节点，并返回</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stDlistNode *pNode = dlist-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;data == data) {</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        }</span><br><span class="line">        pNode = pNode-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlist_dump</span><span class="params">(stDlistHead *dlist)</span>    <span class="comment">//显示链表中的数据</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> no = <span class="number">0</span>;</span><br><span class="line">    stDlistNode *pNode = dlist-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n [%d] = %d"</span>,no++,pNode-&gt;data);</span><br><span class="line">        pNode = pNode-&gt;next;    <span class="comment">//将pNode的下一个节点赋值给pNode，推进循环</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lru_dlist</span><span class="params">(stDlistHead *dlist,<span class="keyword">int</span> data)</span>     <span class="comment">//LRU（最近最少使用）缓存淘汰算法</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stDlistNode *pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pNode = dlist_search(dlist,data);    </span><br><span class="line">    <span class="keyword">if</span> (pNode != <span class="literal">NULL</span>) {    <span class="comment">//如果在链表中找到这个值，则删除储存这个值的节点，之后吧这个节点放在头部</span></span><br><span class="line">        dlist_remove_node(dlist,pNode);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(dlist-&gt;size &gt;= <span class="number">4</span>)    {    <span class="comment">//没在链表中找到，且链表长度大于4，则从链表中删除尾部节点，将新数据放在头部</span></span><br><span class="line">        pNode = dlist_remove_tail(dlist);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dlist_insert_head(dlist ,pNode,data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stDlistHead dlist = {<span class="number">0</span>};</span><br><span class="line">    stDlistNode * pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    dlist_init(&amp;dlist);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n inset 1,2,3"</span>);</span><br><span class="line">    dlist_insert_head(&amp;dlist,<span class="literal">NULL</span>,<span class="number">1</span>);</span><br><span class="line">    dlist_insert_head(&amp;dlist,<span class="literal">NULL</span>,<span class="number">2</span>);</span><br><span class="line">    dlist_insert_head(&amp;dlist,<span class="literal">NULL</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line"></span><br><span class="line">    pNode = dlist_remove_tail(&amp;dlist);</span><br><span class="line">    <span class="keyword">if</span>(pNode != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n remove %d"</span>,pNode-&gt;data);</span><br><span class="line">    }</span><br><span class="line">    dlist_insert_head(&amp;dlist,pNode,<span class="number">4</span>);</span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line"></span><br><span class="line">    Lru_dlist(&amp;dlist,<span class="number">5</span>);</span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line">    Lru_dlist(&amp;dlist,<span class="number">6</span>);</span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line">    Lru_dlist(&amp;dlist,<span class="number">7</span>);</span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line">    Lru_dlist(&amp;dlist,<span class="number">5</span>);</span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dlist.size &gt; <span class="number">0</span>) {</span><br><span class="line">        pNode = dlist_remove_tail(&amp;dlist);</span><br><span class="line">        <span class="keyword">if</span>(pNode != <span class="literal">NULL</span>) { </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n remove %d"</span>,pNode-&gt;data);</span><br><span class="line">            <span class="built_in">free</span> (pNode);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<details>
<summary>linux/list</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// linux内核源码双向链表实现include/linux/list.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIST_HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LIST_HEAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化节点：设置name节点的前继节点和后继节点都是指向name本身。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义表头(节点)：新建双向链表表头name，并设置name的前继节点和后继节点都是指向name本身。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line"><span class="meta">    struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化节点：将list节点的前继节点和后继节点都是指向list本身。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加节点：将new插入到prev和next之间。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">                  struct list_head *prev,</span><br><span class="line">                  struct list_head *next)</span><br><span class="line">{</span><br><span class="line">    next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加new节点：将new添加到head之后，是new称为head的后继节点。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(struct list_head *<span class="keyword">new</span>, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head, head-&gt;next);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加new节点：将new添加到head之前，即将new添加到双链表的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *<span class="keyword">new</span>, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head-&gt;prev, head);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双链表中删除entry节点。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(struct list_head * prev, struct list_head * next)</span><br><span class="line">{</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双链表中删除entry节点。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双链表中删除entry节点。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del_entry(struct list_head *entry)</span><br><span class="line">{</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双链表中删除entry节点，并将entry节点的前继节点和后继节点都指向entry本身。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del_init</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __list_del_entry(entry);</span><br><span class="line">    INIT_LIST_HEAD(entry);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用new节点取代old节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_replace</span><span class="params">(struct list_head *old,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = old-&gt;next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = old-&gt;prev;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_empty</span><span class="params">(<span class="keyword">const</span> struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取"MEMBER成员"在"结构体TYPE"中的位置偏移</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据"结构体(type)变量"中的"域成员变量(member)的指针(ptr)"来获取指向整个结构体变量的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) ({          \</span></span><br><span class="line"><span class="meta">    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \</span></span><br><span class="line"><span class="meta">    (type *)( (char *)__mptr - offsetof(type,member) );})</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历双向链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
</details>

<h4 id="2-1-4-跳表"><a href="#2-1-4-跳表" class="headerlink" title="2.1.4 跳表"></a>2.1.4 跳表</h4><p> 跳表对标的是平衡树(AVL Tree), 插入/删除/搜索都是 O(logn)的数据结构。</p>
<details>
<summary>skiplist</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: skiplist.h</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-10-31</span></span><br><span class="line"><span class="comment"> &gt; Desc:    </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SKIP_LIST_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SKIP_LIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> key;    <span class="comment">/*key是唯一的*/</span></span><br><span class="line">    <span class="keyword">int</span> value;  <span class="comment">/*存储的内容*/</span></span><br><span class="line">    <span class="keyword">int</span> max_level; <span class="comment">/*当前节点最大层数*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>[0];</span><span class="comment">/*level层链表结构*/</span></span><br><span class="line">}node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">skiplist</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    node *head;</span><br><span class="line">}skiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据当前结构体元素的地址，获取到结构体首地址*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container(ptr,type,member) ({\</span></span><br><span class="line"><span class="meta">  const typeof( ((type *)0)-&gt;member) *__mptr = (ptr);\</span></span><br><span class="line"><span class="meta">  (type *) ( (char *)__mptr - offsetof(type,member));})</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./skiplist.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建node节点*/</span></span><br><span class="line"><span class="function">node* <span class="title">skip_list_create_node</span><span class="params">(<span class="keyword">int</span> level,<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    node * tmp = <span class="literal">NULL</span>;</span><br><span class="line">    tmp =(node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node) + level*<span class="keyword">sizeof</span>(node *));</span><br><span class="line">    assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(node) + level*<span class="keyword">sizeof</span>(node*));</span><br><span class="line">    tmp-&gt;key = key;</span><br><span class="line">    tmp-&gt;value = value;</span><br><span class="line">    tmp-&gt;max_level = level;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建跳表的表头，max_level层数*/</span></span><br><span class="line"><span class="function">skiplist * <span class="title">skip_list_create</span><span class="params">(<span class="keyword">int</span> max_level)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    skiplist * <span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span> = (skiplist *)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(skiplist));</span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;level = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = skip_list_create_node(max_level,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*skiplist 销毁*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">skip_list_destory</span><span class="params">(skiplist * <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    node * tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">list</span> == <span class="literal">NULL</span>) || (<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>)) {</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">list</span>-&gt;head-&gt;next[<span class="number">0</span>] != <span class="literal">NULL</span>) {</span><br><span class="line">        tmp = <span class="built_in">list</span>-&gt;head-&gt;next[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;next[<span class="number">0</span>] = tmp-&gt;next[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>-&gt;head);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入元素获得层数，是随机产生的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">skip_list_level</span><span class="params">(skiplist * <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;head-&gt;max_level; i++) {</span><br><span class="line">        <span class="keyword">if</span> ((rand()%<span class="number">2</span>) == <span class="number">1</span>) {</span><br><span class="line">            level++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">skip_list_insert</span><span class="params">(skiplist *<span class="built_in">list</span>,<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    node **update = <span class="literal">NULL</span>;<span class="comment">/*用来更新每层的指针*/</span></span><br><span class="line">    node *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    node *prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*申请update空间用于保存每层的指针*/</span></span><br><span class="line">    update = (node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node *)*<span class="built_in">list</span>-&gt;head-&gt;max_level);</span><br><span class="line">    <span class="keyword">if</span> (update == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*逐层查询节点的*/</span></span><br><span class="line">    prev = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (i = (<span class="built_in">list</span>-&gt;level <span class="number">-1</span>); i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="comment">/*初始化每level层的头指针*/</span></span><br><span class="line">        <span class="keyword">while</span>(((tmp = prev-&gt;next[i]) != <span class="literal">NULL</span>) &amp;&amp; (tmp-&gt;key &lt; key)) {</span><br><span class="line">            prev  = tmp;</span><br><span class="line">        }</span><br><span class="line">        update[i] = prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*当前key已经存在，返回错误*/</span></span><br><span class="line">    <span class="keyword">if</span> ((tmp!= <span class="literal">NULL</span>) &amp;&amp; (tmp-&gt;key == key)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*获取插入元素的随机层数，并更新跳表的最大层数*/</span></span><br><span class="line">    level = skip_list_level(<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">/*创建当前数据节点*/</span></span><br><span class="line">    tmp = skip_list_create_node(level,key,value);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*更新最大层数*/</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="built_in">list</span>-&gt;level) {</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="built_in">list</span>-&gt;level;i &lt; level; i ++) {</span><br><span class="line">            update[i] = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">list</span>-&gt;level = level;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*逐层更新节点的指针*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; level; i++) {</span><br><span class="line">        tmp-&gt;next[i] = update[i]-&gt;next[i];</span><br><span class="line">        update[i]-&gt;next[i] = tmp; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">skip_list_delete</span><span class="params">(skiplist * <span class="built_in">list</span>, <span class="keyword">int</span> key ,<span class="keyword">int</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    node **update = <span class="literal">NULL</span>;<span class="comment">/*用来更新每层的指针*/</span></span><br><span class="line">    node *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    node *prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> == <span class="literal">NULL</span>) &amp;&amp; (value == <span class="literal">NULL</span>)&amp;&amp; (<span class="built_in">list</span>-&gt;count == <span class="number">0</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*申请update空间用于保存每层的指针*/</span></span><br><span class="line">    update = (node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node *)*<span class="built_in">list</span>-&gt;level);</span><br><span class="line">    <span class="keyword">if</span> (update == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*逐层查询节点的*/</span></span><br><span class="line">    prev = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (i = (<span class="built_in">list</span>-&gt;level <span class="number">-1</span>); i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="comment">/*初始化每level层的头指针*/</span></span><br><span class="line">        <span class="keyword">while</span>(((tmp = prev-&gt;next[i]) != <span class="literal">NULL</span>) &amp;&amp; (tmp-&gt;key &lt; key)) {</span><br><span class="line">            prev = tmp;</span><br><span class="line">        }</span><br><span class="line">        update[i] = prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((tmp != <span class="literal">NULL</span>) &amp;&amp; (tmp-&gt;key == key)) {</span><br><span class="line">        *value = tmp-&gt;value;</span><br><span class="line">        <span class="comment">/*逐层删除*/</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;level; i++) {</span><br><span class="line">            <span class="keyword">if</span>(update[i]-&gt;next[i] == tmp) {</span><br><span class="line">                update[i]-&gt;next[i] = tmp-&gt;next[i];       </span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        tmp = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*更新level的层数*/</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head-&gt;next[i] == <span class="literal">NULL</span> ) {</span><br><span class="line">                <span class="built_in">list</span>-&gt;level--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span>-&gt;count--;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;<span class="comment">/*未找到节点*/</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询当前key是否在跳表中，如果存在返回查询的value数值，不存在返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">skip_list_search</span><span class="params">(skiplist *<span class="built_in">list</span>,<span class="keyword">int</span> key,<span class="keyword">int</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    node *prev = <span class="literal">NULL</span>;</span><br><span class="line">    node *tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">list</span> == <span class="literal">NULL</span>) || (<span class="built_in">list</span>-&gt;count == <span class="number">0</span>) || (value == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    prev = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">while</span>(((tmp = prev-&gt;next[i]) != <span class="literal">NULL</span>) &amp;&amp; (tmp-&gt;key &lt;= key)) {</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;key == key) {</span><br><span class="line">                    *value = tmp-&gt;value;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            prev = tmp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">skip_list_dump</span><span class="params">(skiplist *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    node *ptmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n----------------------------------------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n skip list level[%d],count[%d]"</span>,<span class="built_in">list</span>-&gt;level,<span class="built_in">list</span>-&gt;count);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) {</span><br><span class="line">        ptmp = <span class="built_in">list</span>-&gt;head-&gt;next[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n level[%d]:"</span>,i);</span><br><span class="line">        <span class="keyword">while</span>(ptmp != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d-%d "</span>,ptmp-&gt;key,ptmp-&gt;value);</span><br><span class="line">            ptmp = ptmp-&gt;next[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n----------------------------------------------"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    skiplist *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span> = skip_list_create(<span class="number">5</span>);</span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 请输入key 和 value，当key = 1000时，退出输入："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;key,&amp;value);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="number">1000</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        res = skip_list_insert(<span class="built_in">list</span>,key,value);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n skip list insert %d,failed,res=%d."</span>,key,res);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    skip_list_dump(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 通过key 查询value的数值，当key = 1000时，退出查询"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;key);</span><br><span class="line">        <span class="keyword">if</span>(key == <span class="number">1000</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        res = skip_list_search(<span class="built_in">list</span>,key,&amp;value);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n skip list search %d,failed,res=%d."</span>,key,res);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n skip list search %d,sucessful,value=%d."</span>,key,value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    skip_list_dump(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 通过key 删除节点，当key = 1000时，退出删除"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;key);</span><br><span class="line">        <span class="keyword">if</span>(key == <span class="number">1000</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        res = skip_list_delete(<span class="built_in">list</span>,key,&amp;value);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n skip list search %d,failed,res=%d."</span>,key,res);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n skip list search %d,sucessful,value=%d."</span>,key,value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    skip_list_dump(<span class="built_in">list</span>);</span><br><span class="line">    skip_list_destory(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<h4 id="2-1-5-栈"><a href="#2-1-5-栈" class="headerlink" title="2.1.5 栈"></a>2.1.5 栈</h4><p> 栈按照后进先出(LIFO)的顺序存储和检索数据的数据结构，检索元素的顺序和存储元素顺序相反。<br> 可通过链表来实现栈stack,允许插入和删除的为栈顶(<code>top</code>),另一端为栈底(<code>bottom</code>),栈中每个元素为<code>frame</code>,栈只支持三个操作:<code>pop</code>,<code>top</code>,<code>push</code>.</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> List Stack;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_init list_init;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="keyword">void</span> **data)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_peek(stack) ((stack)-&gt;head == NULL ? NULL : (stack)-&gt;head-&gt;data);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_size list_size;</span></span><br></pre></td></tr></tbody></table></figure>
<p> c语言顺序栈</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 元素elem进栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">int</span> top, <span class="keyword">char</span> elem)</span> </span>{</span><br><span class="line">    a[++top] = elem;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 数据元素出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">int</span> top)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<details>
<summary>arrayStack</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: arrayStack</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-10-12</span></span><br><span class="line"><span class="comment"> &gt; Desc:   数组实现顺序栈 </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAY_STACJ_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_STACJ_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">array_stack</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">/*栈的大小*/</span></span><br><span class="line">    <span class="keyword">int</span> pos;<span class="comment">/*当前存储元素的个数，即栈顶元素下表*/</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>;<span class="comment">/*数据存储区*/</span></span><br><span class="line">}stArrayStack;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arrayStack_size(arrayStack) (arrayStack-&gt;size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arrayStack_is_empty(arrayStack) (arrayStack-&gt;pos == -1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arrayStack_is_full(arrayStack)  (arrayStack-&gt;pos == (arrayStack-&gt;size-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./arrayStack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建并初始化顺序栈*/</span></span><br><span class="line"><span class="function">stArrayStack * <span class="title">arrayStack_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stArrayStack *parrStack = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    parrStack = (stArrayStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stArrayStack));</span><br><span class="line">    <span class="keyword">if</span> (parrStack == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    parrStack-&gt;size = size;</span><br><span class="line">    parrStack-&gt;pos = <span class="number">-1</span>;</span><br><span class="line">    parrStack-&gt;<span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*size);</span><br><span class="line">    <span class="keyword">if</span>(parrStack-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(parrStack);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parrStack;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*销毁顺序栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrayStack_destory</span><span class="params">(stArrayStack * parrStack)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(parrStack == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parrStack-&gt;<span class="built_in">array</span> != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(parrStack-&gt;<span class="built_in">array</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(parrStack);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayStack_pop</span><span class="params">(stArrayStack *parrStack)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(arrayStack_is_empty(parrStack)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    data = parrStack-&gt;<span class="built_in">array</span>[parrStack-&gt;pos];</span><br><span class="line">    parrStack-&gt;pos--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayStack_push</span><span class="params">(stArrayStack *parrStack,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(arrayStack_is_full(parrStack)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    parrStack-&gt;pos++;</span><br><span class="line">    parrStack-&gt;<span class="built_in">array</span>[parrStack-&gt;pos] = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayStack_push_new</span><span class="params">(stArrayStack*parrStack,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> *ptmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果栈不满，直接插入*/</span></span><br><span class="line">    <span class="keyword">if</span>(!arrayStack_is_full(parrStack)) {</span><br><span class="line">        <span class="keyword">return</span> arrayStack_push(parrStack,data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果栈已经满，申请内存*/</span></span><br><span class="line">    ptmp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span>*parrStack-&gt;size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (ptmp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(ptmp,parrStack-&gt;<span class="built_in">array</span>,parrStack-&gt;size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(parrStack-&gt;<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    parrStack-&gt;<span class="built_in">array</span> = ptmp;</span><br><span class="line">    parrStack-&gt;size = <span class="number">2</span>*parrStack-&gt;size;</span><br><span class="line">    parrStack-&gt;pos++;</span><br><span class="line">    parrStack-&gt;<span class="built_in">array</span>[parrStack-&gt;pos] = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrayStack_dump</span><span class="params">(stArrayStack *parrStack)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arrayStack_is_empty(parrStack)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n arrayStack is empty."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\narrayStack size = %d,pos= %d,"</span>,</span><br><span class="line">    parrStack-&gt;size,parrStack-&gt;pos);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= parrStack-&gt;pos; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\narry[%d] = %d"</span>,i,parrStack-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    stArrayStack * parrStack = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n create size = 4 arrayStack."</span>);</span><br><span class="line"></span><br><span class="line">    parrStack = arrayStack_create(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (parrStack == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n create size = 4 arrayStack faided."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        ret = arrayStack_push(parrStack,i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n push size = %d arrayStack faided."</span>,i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    arrayStack_dump(parrStack);</span><br><span class="line">    </span><br><span class="line">    ret = arrayStack_push_new(parrStack,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n push size = %d arrayStack faided."</span>,<span class="number">4</span>);</span><br><span class="line">    }</span><br><span class="line">    arrayStack_dump(parrStack);</span><br><span class="line">    arrayStack_destory(parrStack);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<p> 链栈</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> {</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> *<span class="title">next</span>;</span></span><br><span class="line">}lineStack;</span><br><span class="line"></span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>, <span class="keyword">char</span> a)</span></span>{</span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) {</span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"弹栈元素：%c "</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈顶元素：%c\n"</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈已空\n"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈内没有元素"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>linklist_stack</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: linklist_stack</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-10-12</span></span><br><span class="line"><span class="comment"> &gt; Desc:    </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_LINK_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_LINK_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">linkliststack</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">linkliststack</span> *<span class="title">next</span>;</span></span><br><span class="line">}linklist_stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_is_empty(liststack) (liststack-&gt;next == NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./linklist_stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">linklist_stack * <span class="title">stack_create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linklist_stack * <span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span> = (linklist_stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist_stack));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_destory</span><span class="params">(linklist_stack* <span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linklist_stack * ptmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack_is_empty(<span class="built_in">stack</span>)) {</span><br><span class="line">        ptmp = <span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;next = <span class="built_in">stack</span>-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(ptmp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(linklist_stack *<span class="built_in">stack</span>,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linklist_stack * ptmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ptmp = (linklist_stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist_stack));</span><br><span class="line">    <span class="keyword">if</span> (ptmp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ptmp-&gt;data = data;</span><br><span class="line">    ptmp-&gt;next = <span class="built_in">stack</span>-&gt;next;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = ptmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(linklist_stack*<span class="built_in">stack</span>,<span class="keyword">int</span> *data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linklist_stack *ptmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(<span class="built_in">stack</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    }</span><br><span class="line">    *data = <span class="built_in">stack</span>-&gt;next-&gt;data;</span><br><span class="line">    ptmp = <span class="built_in">stack</span>-&gt;next;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = ptmp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(ptmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_dump</span><span class="params">(linklist_stack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linklist_stack * ptmp = <span class="built_in">stack</span>-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(ptmp != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n data = %d"</span>,ptmp-&gt;data);</span><br><span class="line">        ptmp = ptmp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    linklist_stack * <span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = stack_create();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n stack create falied."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">        ret = stack_push(<span class="built_in">stack</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n stack push %d falied."</span>,i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stack_dump(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        ret = stack_pop(<span class="built_in">stack</span>,&amp;data);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n stack pop%d falied."</span>, i);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n data = %d,"</span>,data);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stack_destory(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<h4 id="2-1-6-队列"><a href="#2-1-6-队列" class="headerlink" title="2.1.6 队列"></a>2.1.6 队列</h4><p> 队列，在前端(<code>front</code>)进行删除操作，后端(<code>rear</code>)进行插入操作; 按照先进先出(<code>FIFO</code>)的顺序存储和检索数据的高效数据结构，按照元素的存储顺序检索元素。<br> 队列也可通过数组和链表实现。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> List Queue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> queue_init list_init;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> queue_destroy list_destroy;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_enqueue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_dequeue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="keyword">void</span> **data)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> queue_peek(queue) ((queue)-&gt;head == NULL ? NULL : (queue)-&gt;head-&gt;data);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> queue_size list_size;</span></span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>array_queue</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: array_queue</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-10-12</span></span><br><span class="line"><span class="comment"> &gt; Desc:    </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAY_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">array_queue</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">/*队列的大小*/</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">/*当前存储数据的大小*/</span></span><br><span class="line">    <span class="keyword">int</span> head;<span class="comment">/*队列的头*/</span></span><br><span class="line">    <span class="keyword">int</span> tail;<span class="comment">/*队列的尾*/</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>;<span class="comment">/*数据存储区*/</span></span><br><span class="line">}array_queue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> array_queue_is_empty(array_queue) (array_queue-&gt;num == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> array_queue_is_full(array_queue)  ((array_queue-&gt;num) == (array_queue-&gt;size))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./array_queue.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">array_queue * <span class="title">array_queue_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    array_queue * <span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> = (array_queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(array_queue));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*size);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size  = size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;num   = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head  = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_queue_destory</span><span class="params">(array_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;<span class="built_in">array</span> != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;<span class="built_in">array</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队列 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">array_queue_enqueue</span><span class="params">(array_queue *<span class="built_in">queue</span>,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/*队列为空，或者队列满时，返回-1*/</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">queue</span> == <span class="literal">NULL</span>) || (array_queue_is_full(<span class="built_in">queue</span>))) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;num++;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[<span class="built_in">queue</span>-&gt;tail] = data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = (<span class="built_in">queue</span>-&gt;tail + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">array_queue_dequeue</span><span class="params">(array_queue * <span class="built_in">queue</span>,<span class="keyword">int</span> *data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/*队列为空，数据存储为空，队列为空时返回-1*/</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">queue</span> == <span class="literal">NULL</span>) || (data == <span class="literal">NULL</span>) || (array_queue_is_empty(<span class="built_in">queue</span>))) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    *data = <span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[<span class="built_in">queue</span>-&gt;head];</span><br><span class="line">    <span class="built_in">queue</span>-&gt;num--;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = (<span class="built_in">queue</span>-&gt;head + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_queue_dump</span><span class="params">(array_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">queue</span> == <span class="literal">NULL</span>) || (array_queue_is_empty(<span class="built_in">queue</span>))) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n queue is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n size:%d,num:%d,head:%d,tali:%d"</span>,</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size,<span class="built_in">queue</span>-&gt;num,<span class="built_in">queue</span>-&gt;head,<span class="built_in">queue</span>-&gt;tail);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>-&gt;num; i ++) {</span><br><span class="line">        pos = (<span class="built_in">queue</span>-&gt;head + i) %<span class="built_in">queue</span>-&gt;size;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n array[%d] = %d"</span>,pos,<span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[pos]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    array_queue * <span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> = array_queue_create(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n queue is create failed."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*队列时空时，出队返回错误*/</span></span><br><span class="line">    ret = array_queue_dequeue(<span class="built_in">queue</span>, &amp;data);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n queue %d dequeue failed."</span>,ret);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*队列大小是4，入队5个，最后一个报错*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        ret = array_queue_enqueue(<span class="built_in">queue</span>,i);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n queue %d enqueue failed."</span>,i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    array_queue_dump(<span class="built_in">queue</span>);</span><br><span class="line">    </span><br><span class="line">    ret = array_queue_dequeue(<span class="built_in">queue</span>, &amp;data);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n queue %d dequeue failed."</span>,i);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n queue %d dequue."</span>,data);</span><br><span class="line">    array_queue_dump(<span class="built_in">queue</span>);</span><br><span class="line">    data = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n queue %d enqueue."</span>,data);</span><br><span class="line">    ret = array_queue_enqueue(<span class="built_in">queue</span>,data);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n queue %d enqueue failed."</span>,data);</span><br><span class="line">    }</span><br><span class="line">    array_queue_dump(<span class="built_in">queue</span>);</span><br><span class="line">    </span><br><span class="line">    array_queue_destory(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<details>
<summary>list_queue</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINK_LIST_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK_LIST_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_queue_node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">list_queue_node</span> *<span class="title">next</span>;</span></span><br><span class="line">}queue_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_queue</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    queue_node *head;</span><br><span class="line">    queue_node *tail;</span><br><span class="line">}list_queue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_queue_is_empty(queue) ((queue-&gt;num) == 0)</span></span><br><span class="line"><span class="function">list_queue *<span class="title">list_queue_create</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list_queue_enqueue</span><span class="params">(list_queue *<span class="built_in">queue</span>,<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list_queue_dequeue</span><span class="params">(list_queue *<span class="built_in">queue</span>,<span class="keyword">void</span> **data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./list_queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建队列头*/</span></span><br><span class="line"><span class="function">list_queue *<span class="title">list_queue_create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    list_queue * <span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> = (list_queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(list_queue));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;num  = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*入队*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list_queue_enqueue</span><span class="params">(list_queue *<span class="built_in">queue</span>,<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    queue_node *ptmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    ptmp = (queue_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(queue_node));</span><br><span class="line">    <span class="keyword">if</span> (ptmp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ptmp-&gt;data = data;</span><br><span class="line">    ptmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;head = ptmp;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;tail-&gt;next = ptmp;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = ptmp;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;num++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list_queue_dequeue</span><span class="params">(list_queue *<span class="built_in">queue</span>,<span class="keyword">void</span> **data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    queue_node * ptmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">queue</span> == <span class="literal">NULL</span>) || (data == <span class="literal">NULL</span>) || list_queue_is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    *data = <span class="built_in">queue</span>-&gt;head-&gt;data;</span><br><span class="line">    ptmp = <span class="built_in">queue</span>-&gt;head;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="built_in">queue</span>-&gt;head-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;num--;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<details>
<summary>ring_queue</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ring_queue</span> {</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> head, tail;</span><br><span class="line">    <span class="keyword">int</span> *_q;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_queue</span><span class="params">(struct ring_queue* <span class="built_in">queue</span>, <span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span> || cap &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;_q)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;_q = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(cap * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;_q)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="built_in">queue</span>-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;cap = cap;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_queue</span><span class="params">(struct ring_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">queue</span>-&gt;cap = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="built_in">queue</span>-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;_q);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _valid_index(<span class="keyword">int</span> curr, <span class="keyword">int</span> step, <span class="keyword">int</span> cap)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> (curr + step) % cap;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _next(<span class="keyword">int</span> curr, <span class="keyword">int</span> cap)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> _valid_index(curr, <span class="number">1</span>, cap);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(struct ring_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">queue</span>-&gt;head == <span class="built_in">queue</span>-&gt;tail);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_full</span><span class="params">(struct ring_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> next_tail = _next(<span class="built_in">queue</span>-&gt;tail, <span class="built_in">queue</span>-&gt;cap);</span><br><span class="line">    <span class="keyword">return</span> (next_tail == <span class="built_in">queue</span>-&gt;head);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enqueue</span><span class="params">(struct ring_queue* <span class="built_in">queue</span>, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (is_full(<span class="built_in">queue</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;_q[<span class="built_in">queue</span>-&gt;tail] = elem;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = _next(<span class="built_in">queue</span>-&gt;tail, <span class="built_in">queue</span>-&gt;cap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">(struct ring_queue* <span class="built_in">queue</span>, <span class="keyword">int</span> *elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">queue</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elem)</span><br><span class="line">    *elem = <span class="built_in">queue</span>-&gt;_q[<span class="built_in">queue</span>-&gt;head];</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = _next(<span class="built_in">queue</span>-&gt;head, <span class="built_in">queue</span>-&gt;cap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(struct ring_queue* <span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">queue</span>-&gt;tail - <span class="built_in">queue</span>-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">    size += <span class="built_in">queue</span>-&gt;cap;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(struct ring_queue* <span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i, idx;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Queue has %d elements with %d capacity\n"</span>,</span><br><span class="line">    size(<span class="built_in">queue</span>), <span class="built_in">queue</span>-&gt;cap);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size(<span class="built_in">queue</span>); i++) {</span><br><span class="line">        idx = _valid_index(<span class="built_in">queue</span>-&gt;head, i, <span class="built_in">queue</span>-&gt;cap);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%02d]: %08d\n"</span>, idx, <span class="built_in">queue</span>-&gt;_q[idx]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ring_queue</span> <span class="title">queue</span> =</span> {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>};</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc_queue(&amp;<span class="built_in">queue</span>, <span class="number">8</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to allocate a queue\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"A new queue is %s\n"</span>, is_empty(&amp;<span class="built_in">queue</span>)?<span class="string">"empty"</span>:<span class="string">"not empty"</span>);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;<span class="built_in">queue</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After enqueue 1 element, queue is %s\n"</span>, is_empty(&amp;<span class="built_in">queue</span>)?<span class="string">"empty"</span>:<span class="string">"not empty"</span>);</span><br><span class="line">    dequeue(&amp;<span class="built_in">queue</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After dequeue 1 element, queue is %s\n"</span>, is_empty(&amp;<span class="built_in">queue</span>)?<span class="string">"empty"</span>:<span class="string">"not empty"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    enqueue(&amp;<span class="built_in">queue</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After enqueue 7 element, queue is %s\n"</span>, is_full(&amp;<span class="built_in">queue</span>)?<span class="string">"full"</span>:<span class="string">"not full"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">        dequeue(&amp;<span class="built_in">queue</span>, <span class="literal">NULL</span>);</span><br><span class="line">        enqueue(&amp;<span class="built_in">queue</span>, i);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After enqueue/dequeue 4 element, queue is %s\n"</span>,</span><br><span class="line">    is_full(&amp;<span class="built_in">queue</span>)?<span class="string">"full"</span>:<span class="string">"not full"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Head is %d, Tail is %d\n"</span>, <span class="built_in">queue</span>.head, <span class="built_in">queue</span>.tail);</span><br><span class="line"></span><br><span class="line">    dump(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    free_queue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<p> 队列应用：进程通信<br> 消息队列提供了从一个进程向另一个进程发送一个数据块的方法.每个数据库都认为含有一个类型,接收进程可以独立地接收含有不同类型的数据结构.</p>
<p> linux内核 &lt;sys/msg.h&gt; 头文件中定义了消息队列结构</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">msg_first</span>;</span> <span class="comment">// 指向队列中第一个消息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">msg_last</span>;</span> <span class="comment">// 队列中最后一个消息</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> Linux消息队列函数接口</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建和访问一个消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 把消息添加到消息队列中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">const</span> <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_sz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 从一个消息对立获取消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_st, <span class="keyword">long</span> <span class="keyword">int</span> msgtype, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 控制消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">int</span> command, struct msgid_ds *buf)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-1-7-leetcode题目"><a href="#2-1-7-leetcode题目" class="headerlink" title="2.1.7 leetcode题目"></a>2.1.7 leetcode题目</h4><ul>
<li><p>重复N次的元素&lt;数组&gt;</p>
</li>
<li><p>两数相加&lt;链表&gt;</p>
</li>
<li><p>基本计算器&lt;栈&gt;</p>
</li>
<li><p>设计循环队列&lt;队列&gt;</p>
</li>
</ul>
<h3 id="2-2-哈希表"><a href="#2-2-哈希表" class="headerlink" title="2.2 哈希表"></a>2.2 哈希表</h3><p> 哈希表是一种最有效的检索方法，散列，从本质上看，一个哈希表包含一个数组，通过特殊的索引（键）来访问数组中的元素。哈希表主要思想是通过一个哈希函数，在所有可能的键和值直接建立映射表。<br> 每个记录的关键字k通过一种函数H(k)计算出函数值.此函数为哈希函数或散列函数.</p>
<h4 id="2-2-1-哈希函数设计"><a href="#2-2-1-哈希函数设计" class="headerlink" title="2.2.1 哈希函数设计"></a>2.2.1 哈希函数设计</h4><ul>
<li><p>直接地址法<br>关键字是整数类型的数据,直接地址的哈希函数H直接利用关键字求得哈希地址.<br>H(k) = aK*i + b</p>
</li>
<li><p>数字分析法<br>取关键字数中分布均匀的若干作为哈希地址</p>
</li>
<li><p>平方取中法<br>取关键字平方中间几位作为散列地址</p>
</li>
<li><p>折叠法<br>把关键字分割成位数相同的几段，段的位数取决于哈希地址的位数，然后将它们叠加和作为哈希地址</p>
</li>
<li><p>除留取余法<br>关键字K除以一个合适的不大于哈希表长度的正整数P,所得余数作为哈希地址.<br>H(K) = K MOD P</p>
</li>
</ul>
<details>
<summary>uthash用法</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: listhash.h</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-11-06</span></span><br><span class="line"><span class="comment"> &gt; Desc: 根据linux内核模块hashtab编写用户层hashtab接口</span></span><br><span class="line"><span class="comment">         linux-4.19.1\security\selinux\ss\hashtab.c</span></span><br><span class="line"><span class="comment">     linux-4.19.1\security\selinux\ss\hashtab.h</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __HASHTAB_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HASHTAB_H__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hashtab_node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">void</span> * key;</span><br><span class="line">    <span class="keyword">void</span> * data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">hashtab_node</span> *<span class="title">next</span>;</span></span><br><span class="line">}hashtab_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hashtab</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    hashtab_node **htables; <span class="comment">/*哈希桶*/</span></span><br><span class="line">    <span class="keyword">int</span> size;              <span class="comment">/*哈希桶的最大数量*/</span></span><br><span class="line">    <span class="keyword">int</span> nel;               <span class="comment">/*哈希桶中元素的个数*/</span></span><br><span class="line">    <span class="keyword">int</span> (*hash_value)(struct _hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">/*哈希函数*/</span></span><br><span class="line">    <span class="keyword">int</span> (*keycmp)(struct _hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key1,<span class="keyword">const</span> <span class="keyword">void</span> *key2);<span class="comment">/*哈希key比较函数，当哈希数值一致时使用*/</span></span><br><span class="line">    <span class="keyword">void</span> (*hash_node_free)(hashtab_node *node);</span><br><span class="line">}hashtab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHTAB_MAX_NODES  (0xffffffff)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*hash_key_func)</span><span class="params">(struct _hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">/*哈希函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*keycmp_func)</span><span class="params">(struct _hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key1,<span class="keyword">const</span> <span class="keyword">void</span> *key2)</span></span>;<span class="comment">/*哈希key比较函数，当哈希数值一致时使用*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*hash_node_free_func)</span><span class="params">(hashtab_node *node)</span></span>;</span><br><span class="line"><span class="comment">/*根据当前结构体元素的地址，获取到结构体首地址*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container(ptr,type,member) ({\</span></span><br><span class="line"><span class="meta">  const typeof( ((type *)0)-&gt;member) *__mptr = (ptr);\</span></span><br><span class="line"><span class="meta">  (type *) ( (char *)__mptr - offsetof(type,member));})</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">hashtab * <span class="title">hashtab_create</span><span class="params">(<span class="keyword">int</span> size,hash_key_func hash_value,</span></span></span><br><span class="line"><span class="params"><span class="function">        keycmp_func keycmp,hash_node_free_func hash_node_free)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashtab_destory</span><span class="params">(hashtab *h)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashtab_insert</span><span class="params">(hashtab * h,<span class="keyword">void</span> *key,<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function">hashtab_node *<span class="title">hashtab_delete</span><span class="params">(hashtab *h, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">hashtab_search</span><span class="params">(hashtab*h,<span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"listhash.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MEMORY_TEST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mcheck.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">hashtab * <span class="title">hashtab_create</span><span class="params">(<span class="keyword">int</span> size,hash_key_func hash_value,</span></span></span><br><span class="line"><span class="params"><span class="function">    keycmp_func keycmp,hash_node_free_func hash_node_free)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    hashtab * h = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((size &lt; <span class="number">0</span>) || (hash_value == <span class="literal">NULL</span>) || (keycmp == <span class="literal">NULL</span>)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    h = (hashtab *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(hashtab));</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    h-&gt;htables = (hashtab_node **)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(hashtab_node*));</span><br><span class="line">    <span class="keyword">if</span> (h-&gt;htables == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    h-&gt;size = size;</span><br><span class="line">    h-&gt;nel = <span class="number">0</span>;</span><br><span class="line">    h-&gt;hash_value = hash_value;</span><br><span class="line">    h-&gt;keycmp = keycmp;</span><br><span class="line">    h-&gt;hash_node_free = hash_node_free;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        h-&gt;htables[i] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashtab_destory</span><span class="params">(hashtab *h)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    hashtab_node * cur = <span class="literal">NULL</span>;</span><br><span class="line">    hashtab_node * tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;h-&gt;size; i++) {</span><br><span class="line">        cur = h-&gt;htables[i];</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) {</span><br><span class="line">            tmp = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            h-&gt;hash_node_free(tmp);</span><br><span class="line">        }</span><br><span class="line">        h-&gt;htables[i] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(h-&gt;htables);</span><br><span class="line">    <span class="built_in">free</span>(h);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashtab_insert</span><span class="params">(hashtab * h,<span class="keyword">void</span> *key,<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hvalue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    hashtab_node *cur = <span class="literal">NULL</span>; </span><br><span class="line">    hashtab_node *prev = <span class="literal">NULL</span>; </span><br><span class="line">    hashtab_node *newnode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((h == <span class="literal">NULL</span>) || (key == <span class="literal">NULL</span>) || (data == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取hash 数值*/</span></span><br><span class="line">    hvalue = h-&gt;hash_value(h,key);</span><br><span class="line">    cur = h-&gt;htables[hvalue];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class="line">    <span class="keyword">while</span>((cur != <span class="literal">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt; <span class="number">0</span>)) {</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果key和当前key比对一致，直接返回，数据已经存在*/</span></span><br><span class="line">    <span class="keyword">if</span> ((cur != <span class="literal">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) == <span class="number">0</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    newnode = (hashtab_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(hashtab_node));</span><br><span class="line">    <span class="keyword">if</span> (newnode == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    newnode-&gt;key = key;</span><br><span class="line">    newnode-&gt;data = data;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) {</span><br><span class="line">        newnode-&gt;next = h-&gt;htables[hvalue];</span><br><span class="line">        h-&gt;htables[hvalue] = newnode;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        newnode-&gt;next = prev-&gt;next;</span><br><span class="line">        prev-&gt;next = newnode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    h-&gt;nel++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">hashtab_node *<span class="title">hashtab_delete</span><span class="params">(hashtab *h, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> hvalue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    hashtab_node *cur = <span class="literal">NULL</span>; </span><br><span class="line">    hashtab_node *prev = <span class="literal">NULL</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((h == <span class="literal">NULL</span>) || (key == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取hash 数值*/</span></span><br><span class="line">    hvalue = h-&gt;hash_value(h,key);</span><br><span class="line">    cur = h-&gt;htables[hvalue];</span><br><span class="line">    <span class="comment">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class="line">    <span class="keyword">while</span>((cur != <span class="literal">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt;= <span class="number">0</span>)) {</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;keycmp(h,key,cur-&gt;key) == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) {</span><br><span class="line">                        h-&gt;htables[hvalue] = cur-&gt;next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                        prev-&gt;next = cur-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        }</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">hashtab_search</span><span class="params">(hashtab*h,<span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> hvalue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    hashtab_node *cur = <span class="literal">NULL</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((h == <span class="literal">NULL</span>) || (key == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取hash 数值*/</span></span><br><span class="line">    hvalue = h-&gt;hash_value(h,key);</span><br><span class="line">    cur = h-&gt;htables[hvalue];</span><br><span class="line">    <span class="comment">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class="line">    <span class="keyword">while</span>((cur != <span class="literal">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt;= <span class="number">0</span>)) {</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;keycmp(h,key,cur-&gt;key) == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> cur-&gt;data;</span><br><span class="line">        }</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashtab_dump</span><span class="params">(hashtab *h)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    hashtab_node * cur = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n----开始--size[%d],nel[%d]------------"</span>,h-&gt;size,h-&gt;nel);</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; h-&gt;size; i ++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n htables[%d]:"</span>,i);</span><br><span class="line">        cur = h-&gt;htables[i];</span><br><span class="line">        <span class="keyword">while</span>((cur != <span class="literal">NULL</span>)) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"key[%s],data[%s] "</span>,cur-&gt;key,cur-&gt;data);    </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n----结束--size[%d],nel[%d]------------"</span>,h-&gt;size,h-&gt;nel);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> key[<span class="number">80</span>];</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">80</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">siample_hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*str) {</span><br><span class="line">        hash = hash*seed + *str++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash &amp; (<span class="number">0x7FFFFFFF</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashtab_hvalue</span><span class="params">(hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (siample_hash(key) % h-&gt;size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashtab_keycmp</span><span class="params">(hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key1,<span class="keyword">const</span> <span class="keyword">void</span> *key2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(key1,key2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashtab_node_free</span><span class="params">(hashtab_node*node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_node</span> * <span class="title">ptmp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    ptmp = container(node-&gt;key,struct test_node,key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptmp);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *pres = <span class="literal">NULL</span>;</span><br><span class="line">    hashtab_node * node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_node</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    hashtab *h = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> MEMORY_TEST</span></span><br><span class="line">    setenv(<span class="string">"MALLOC_TRACE"</span>,<span class="string">"1.txt"</span>,<span class="number">1</span>);</span><br><span class="line">    mtrace();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    h = hashtab_create(<span class="number">5</span>,hashtab_hvalue,hashtab_keycmp,hashtab_node_free);</span><br><span class="line">    assert(h!= <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        p = (struct test_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct test_node));</span><br><span class="line">        assert(p != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 请输入key 和value，当可以等于\"quit\"时退出"</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;key);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p-&gt;key,<span class="string">"quit"</span>) == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        res = hashtab_insert(h,p-&gt;key,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s],data[%s] insert failed %d"</span>,p-&gt;key,p-&gt;data,res);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s],data[%s] insert success %d"</span>,p-&gt;key,p-&gt;data,res);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hashtab_dump(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        p = (struct test_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct test_node));</span><br><span class="line">        assert(p != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 请输入key 查询value的数值，当可以等于\"quit\"时退出"</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p-&gt;key,<span class="string">"quit"</span>) == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        pres = hashtab_search(h,p-&gt;key);</span><br><span class="line">        <span class="keyword">if</span> (pres == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s] search data failed"</span>,p-&gt;key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s],search data[%s] success"</span>,p-&gt;key,pres);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line">    hashtab_dump(h);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        p = (struct test_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct test_node));</span><br><span class="line">        assert(p != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 请输入key 删除节点的数值，当可以等于\"quit\"时退出"</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p-&gt;key,<span class="string">"quit"</span>) == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        node = hashtab_delete(h,p-&gt;key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s] delete node failed "</span>,p-&gt;key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s],delete data[%s] success"</span>,node-&gt;key,node-&gt;data);</span><br><span class="line">            h-&gt;hash_node_free(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        hashtab_dump(h);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hashtab_destory(h);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> MEMORY_TEST</span></span><br><span class="line">        muntrace();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<details>
<summary>hash_table</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* One implementation of hash table with linear probing. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_SHIFT 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_SIZE (1 &lt;&lt; HASH_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_MASK (HASH_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  used;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> entry[HASH_SIZE];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_reset</span><span class="params">(struct hash_table *table)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    table-&gt;used = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_SIZE; i++)</span><br><span class="line">    table-&gt;entry[i] = ~<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hash_function</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> value &amp; HASH_MASK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_hash_table</span><span class="params">(struct hash_table *table)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_SIZE; i++) {</span><br><span class="line">    <span class="keyword">if</span> (table-&gt;entry[i] == ~<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%2u:       nil \n"</span>, i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%2u:%10lu -&gt; %2u\n"</span>,</span><br><span class="line">    i, table-&gt;entry[i],</span><br><span class="line">    hash_function(table-&gt;entry[i]));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_function_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    srandom(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> val = random();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%10lu -&gt; %2u\n"</span>, val, hash_function(val));;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">next_probe</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> prev_key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (prev_key + <span class="number">1</span>) &amp; HASH_MASK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next_probe_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key1, key2;</span><br><span class="line"></span><br><span class="line">    key1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_SIZE; i++) {</span><br><span class="line">        key2 = next_probe(key1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2u -&gt; %2u\n"</span>, key1, key2);</span><br><span class="line">        key1 = key2;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_add</span><span class="params">(struct hash_table *table, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key = hash_function(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (table-&gt;used &gt;= HASH_SIZE)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (table-&gt;entry[key] != ~<span class="number">0</span>)</span><br><span class="line">    key = next_probe(key);</span><br><span class="line"></span><br><span class="line">    table-&gt;entry[key] = value;</span><br><span class="line">    table-&gt;used++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hash_table_slot</span><span class="params">(struct hash_table *table, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key = hash_function(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_SIZE; i++) {</span><br><span class="line">        <span class="keyword">if</span> (table-&gt;entry[key] == value || table-&gt;entry[key] == ~<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        key = next_probe(key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hash_table_find</span><span class="params">(struct hash_table *table, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> table-&gt;entry[hash_table_slot(table, value)] == value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_del</span><span class="params">(struct hash_table *table, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hash_table_find(table, value))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    i = j = hash_table_slot(table, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        table-&gt;entry[i] = ~<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            j = next_probe(j);</span><br><span class="line">            <span class="keyword">if</span> (table-&gt;entry[j] == ~<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            k = hash_function(table-&gt;entry[j]);</span><br><span class="line">        } <span class="keyword">while</span> ((i &lt;= j) ? (i &lt; k &amp;&amp; k &lt;= j) : (i &lt; k || k &lt;= j));</span><br><span class="line"></span><br><span class="line">        table-&gt;entry[i] = table-&gt;entry[j];</span><br><span class="line">        i = j;</span><br><span class="line">    }</span><br><span class="line">    table-&gt;used++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_add_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> <span class="title">table</span>;</span></span><br><span class="line"></span><br><span class="line">    hash_table_reset(&amp;table);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">87645</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Table has%s 87645\n"</span>,</span><br><span class="line">    hash_table_find(&amp;table, <span class="number">87645</span>) ? <span class="string">""</span>:<span class="string">"n't"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Table has%s 87647\n"</span>,</span><br><span class="line">    hash_table_find(&amp;table, <span class="number">87647</span>) ? <span class="string">""</span>:<span class="string">"n't"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_del_test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> <span class="title">table</span>;</span></span><br><span class="line"></span><br><span class="line">    hash_table_reset(&amp;table);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x1ff0</span>);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x2ff0</span>);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x3ff0</span>);</span><br><span class="line">    dump_hash_table(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== Remove 0x1ff0\n"</span>);</span><br><span class="line">    hash_table_del(&amp;table, <span class="number">0x1ff0</span>);</span><br><span class="line">    dump_hash_table(&amp;table);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_del_test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> <span class="title">table</span>;</span></span><br><span class="line"></span><br><span class="line">    hash_table_reset(&amp;table);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x1ff0</span>);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x1ff1</span>);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x1ff2</span>);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x2ff0</span>);</span><br><span class="line">    dump_hash_table(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== Remove 0x1ff0\n"</span>);</span><br><span class="line">    hash_table_del(&amp;table, <span class="number">0x1ff0</span>);</span><br><span class="line">    dump_hash_table(&amp;table);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//hash_function_test();</span></span><br><span class="line">    <span class="comment">//next_probe_test();</span></span><br><span class="line">    <span class="comment">//hash_table_add_test();</span></span><br><span class="line">    hash_table_del_test2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<h4 id="2-2-2-哈希冲突"><a href="#2-2-2-哈希冲突" class="headerlink" title="2.2.2 哈希冲突"></a>2.2.2 哈希冲突</h4><p> 理想情况下,哈希函数在关键字和地址之间建立一对一关系.但H(k1) = H(k2),即为冲突.</p>
<p> 解决哈希冲突常用方法:</p>
<ul>
<li>链地址法<br>将哈希值相同的元素构成一个同义词的单链表,并将单链表头指针存放在哈希表的地i个单元中,查找,插入和删除主要在同义词链表中.</li>
<li>线性探测</li>
<li>二次探测</li>
</ul>
<h4 id="2-2-3-uthash"><a href="#2-2-3-uthash" class="headerlink" title="2.2.3 uthash"></a>2.2.3 uthash</h4><p> uthash的插入、查找、删除的操作时间都是常量</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uthash.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span> id;            <span class="comment">/* we'll use this field as the key */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh; <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">users</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_user</span><span class="params">(struct my_struct *s)</span> </span>{</span><br><span class="line">    HASH_ADD_INT(users, id, s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>uthash用法</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>   <span class="comment">/* gets */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  <span class="comment">/* atoi, malloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  <span class="comment">/* strcpy */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uthash.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span> id;                    <span class="comment">/* key */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh;         <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">users</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_user</span><span class="params">(<span class="keyword">int</span> user_id, <span class="keyword">char</span> *name)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* id already in the hash? */</span></span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">NULL</span>) {</span><br><span class="line">        s = (struct my_struct *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *s);</span><br><span class="line">        s-&gt;id = user_id;</span><br><span class="line">        HASH_ADD_INT( users, id, s );  <span class="comment">/* id: name of key field */</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;name, name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct my_struct *<span class="title">find_user</span><span class="params">(<span class="keyword">int</span> user_id)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* s: output pointer */</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_user</span><span class="params">(struct my_struct *user)</span> </span>{</span><br><span class="line">    HASH_DEL(users, user);  <span class="comment">/* user: pointer to deletee */</span></span><br><span class="line">    <span class="built_in">free</span>(user);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_all</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">current_user</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_ITER(hh, users, current_user, tmp) {</span><br><span class="line">        HASH_DEL(users, current_user);  <span class="comment">/* delete it (users advances to next) */</span></span><br><span class="line">        <span class="built_in">free</span>(current_user);             <span class="comment">/* free it */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_users</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(s=users; s != <span class="literal">NULL</span>; s=(struct my_struct*)(s-&gt;hh.next)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"user id %d: name %s\n"</span>, s-&gt;id, s-&gt;name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">name_sort</span><span class="params">(struct my_struct *a, struct my_struct *b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a-&gt;name,b-&gt;name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id_sort</span><span class="params">(struct my_struct *a, struct my_struct *b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (a-&gt;id - b-&gt;id);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_by_name</span><span class="params">()</span> </span>{</span><br><span class="line">    HASH_SORT(users, name_sort);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_by_id</span><span class="params">()</span> </span>{</span><br><span class="line">    HASH_SORT(users, id_sort);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> in[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> id=<span class="number">1</span>, running=<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_users;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (running) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 1. add user\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 2. add/rename user by id\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 3. find user\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 4. delete user\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 5. delete all users\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 6. sort items by name\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 7. sort items by id\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 8. print users\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 9. count users\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"10. quit\n"</span>);</span><br><span class="line">        gets(in);</span><br><span class="line">        <span class="keyword">switch</span>(atoi(in)) {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"name?\n"</span>);</span><br><span class="line">                add_user(id++, gets(in));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"id?\n"</span>);</span><br><span class="line">                gets(in); id = atoi(in);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"name?\n"</span>);</span><br><span class="line">                add_user(id, gets(in));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"id?\n"</span>);</span><br><span class="line">                s = find_user(atoi(gets(in)));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"user: %s\n"</span>, s ? s-&gt;name : <span class="string">"unknown"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"id?\n"</span>);</span><br><span class="line">                s = find_user(atoi(gets(in)));</span><br><span class="line">                <span class="keyword">if</span> (s) delete_user(s);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"id unknown\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                delete_all();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                sort_by_name();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                sort_by_id();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                print_users();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                num_users=HASH_COUNT(users);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"there are %u users\n"</span>, num_users);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                running=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    delete_all();  <span class="comment">/* free any structures */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<ul>
<li>参考链接<br>官网:<a href="https://troydhanson.github.io/uthash/">https://troydhanson.github.io/uthash/</a><br><a href="https://blog.csdn.net/fan_h_l/article/details/107241520">https://blog.csdn.net/fan_h_l/article/details/107241520</a><br><a href="https://blog.csdn.net/whatday/article/details/95926766">https://blog.csdn.net/whatday/article/details/95926766</a><br><a href="https://www.cnblogs.com/pam-sh/p/12827658.html">https://www.cnblogs.com/pam-sh/p/12827658.html</a></li>
</ul>
<h4 id="2-2-4-leetcode题目"><a href="#2-2-4-leetcode题目" class="headerlink" title="2.2.4 leetcode题目"></a>2.2.4 leetcode题目</h4><ul>
<li><p>设计哈希集合 </p>
</li>
<li><p>设计哈希映射</p>
</li>
<li><p>根据字符出现频率排序</p>
</li>
</ul>
<h3 id="2-3-树与二叉树"><a href="#2-3-树与二叉树" class="headerlink" title="2.3 树与二叉树"></a>2.3 树与二叉树</h3><p> 树(tree)是一种用来模拟树状结构的抽象数据结构(ADT);</p>
<p> 树的特点:</p>
<ul>
<li>没有父节点的节点称为根节点</li>
<li>每个非根节点有且只有一个父节点</li>
<li>除了根结点外,每个子节点可分为多个不相交的子树</li>
<li>树中没有环路</li>
</ul>
<h4 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h4><ul>
<li>节点的度: 一个节点含有子树的个数</li>
<li>树的度: 树中最大的节点度</li>
<li>叶节点: 度为零的节点</li>
<li>父节点</li>
<li>子节点</li>
<li>兄弟节点</li>
<li>节点的层次</li>
<li>深度: 任意节点n,n的深度为从n到一片树叶的最长路径长,根的深度为0</li>
<li>高度: 对任意节点n,n的高度为从n到一片树叶的最长路径长,所有树叶的高度为0.</li>
<li>森林</li>
</ul>
<p> 树由称为结点的元素按照层次结构的方式组织而成。最顶端称为根。与根直接相连的结点称为根的子结点。子节点本身也可以有子结点。除根结点外，每个结点都有唯一的父结点。</p>
<h4 id="2-3-2-树的种类"><a href="#2-3-2-树的种类" class="headerlink" title="2.3.2 树的种类"></a>2.3.2 树的种类</h4><ul>
<li><p>无序树</p>
</li>
<li><p>有序树</p>
<ul>
<li><p>二叉树: 每个节点最多含有两个子树的树.</p>
<ul>
<li>完全二叉树: 对于一颗深度为d的二叉树,除第d层外,其他各层节点数目均达最大值,且第d层所有节点从左向右连续紧密排列.<ul>
<li>满二叉树:所有叶节点都最底层的完全二叉树.</li>
</ul>
</li>
<li>平衡二叉树(AVL):当且仅当任何节点的两颗子树的高度差不大于1的二叉树.</li>
<li>排序二叉树:二叉查找树</li>
</ul>
</li>
<li><p>霍夫曼树:带权路径最短的二叉树(又称最优二叉树).</p>
</li>
<li><p>B树:一种堆读写操作进行优化的自平衡二叉查找树,能够保持数据有序,拥有多余两个子树.</p>
</li>
</ul>
</li>
</ul>
<br>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>二叉树</td>
<td>二叉查找树(BST) 笛卡尔树 MVP树 Top tree T树</td>
</tr>
<tr>
<td>自平衡二叉查找树</td>
<td>AVL树 红黑树 加权平衡树 AA树</td>
</tr>
<tr>
<td>B树</td>
<td>B树 B+树</td>
</tr>
<tr>
<td>堆</td>
<td>二项堆 斐波那契堆</td>
</tr>
<tr>
<td>Trie</td>
<td>后缀树 基数树 三叉查找树</td>
</tr>
</tbody></table>
<p> 树有多种结构形式，包括二叉树、。</p>
<h4 id="2-3-3-二叉树"><a href="#2-3-3-二叉树" class="headerlink" title="2.3.3 二叉树"></a>2.3.3 二叉树</h4><p> 二叉树两个条件:</p>
<ul>
<li>本身是有序树</li>
<li>树中包含的各个节点的度不能超过2,即只能是0,1或者2</li>
</ul>
<p> 二叉树中结点包含三部分：一个数据成员两个左右指针。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode_</span> {</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode_</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode_</span> *<span class="title">right</span>;</span></span><br><span class="line">}BiTreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTree_</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> (*compare)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">void</span> *data);</span><br><span class="line">    BiTreeNode *root;</span><br><span class="line">}BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*树根*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span>{</span></span><br><span class="line">    Node * root;</span><br><span class="line">}Tree;</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>二叉树</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"list_queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">treenode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">treenode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">treenode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">}Tnode,Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_create</span><span class="params">(Tree **Root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n输入节点数值((当输入为100时，当前节点创建完成))):"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">100</span>) {</span><br><span class="line">        *Root = <span class="literal">NULL</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        *Root = (Tnode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tnode));</span><br><span class="line">        <span class="keyword">if</span> (*Root == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        (*Root)-&gt;data = a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n create %d 的左孩子:"</span>,a);</span><br><span class="line">        binarytree_create(&amp;((*Root)-&gt;lchild));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n create %d 的右孩子:"</span>,a);</span><br><span class="line">        binarytree_create(&amp;((*Root)-&gt;rchild));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_destory</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    binarytree_destory(root-&gt;lchild);</span><br><span class="line">    binarytree_destory(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*先序遍历:根结点--》左子树---》右子树*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_preorder</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d "</span>,root-&gt;data);</span><br><span class="line">    binarytree_preorder(root-&gt;lchild);</span><br><span class="line">    binarytree_preorder(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*中序遍历:左子树--》跟节点---》右子树*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_inorder</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    binarytree_inorder(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d "</span>,root-&gt;data);</span><br><span class="line">    binarytree_inorder(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*后序遍历:左子树---》右子树-》根节点*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_postorder</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    binarytree_postorder(root-&gt;lchild);</span><br><span class="line">    binarytree_postorder(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d "</span>,root-&gt;data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_levelorder</span><span class="params">(Tree * root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    list_queue *<span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line">    Tnode * node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> = list_queue_create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*根节点先入队*/</span></span><br><span class="line">    list_queue_enqueue(<span class="built_in">queue</span>,(<span class="keyword">void</span> *)root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!list_queue_is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        list_queue_dequeue(<span class="built_in">queue</span>,(<span class="keyword">void</span> *)&amp;node);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d "</span>,node-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;lchild != <span class="literal">NULL</span>) {</span><br><span class="line">            list_queue_enqueue(<span class="built_in">queue</span>,(<span class="keyword">void</span> *)node-&gt;lchild);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;rchild != <span class="literal">NULL</span>) {</span><br><span class="line">            list_queue_enqueue(<span class="built_in">queue</span>,(<span class="keyword">void</span> *)node-&gt;rchild);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*打印叶子节点*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_printfleaf</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((root-&gt;lchild == <span class="literal">NULL</span>) &amp;&amp; (root-&gt;rchild == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d "</span>,root-&gt;data);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        binarytree_printfleaf(root-&gt;lchild);</span><br><span class="line">        binarytree_printfleaf(root-&gt;rchild);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*打印叶子的个数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarytree_getleafnum</span><span class="params">(Tree*root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((root-&gt;lchild == <span class="literal">NULL</span>) &amp;&amp; (root-&gt;rchild == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> binarytree_getleafnum(root-&gt;lchild) + binarytree_getleafnum(root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">/*打印数的高度*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarytree_gethigh</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> lhigh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rhigh = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    lhigh = binarytree_gethigh(root-&gt;lchild);</span><br><span class="line">    rhigh = binarytree_gethigh(root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((lhigh &gt; rhigh)?(lhigh + <span class="number">1</span>):(rhigh + <span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree *root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    setenv(<span class="string">"MALLOC_TRACE"</span>,<span class="string">"1.txt"</span>,<span class="number">1</span>);</span><br><span class="line">    mtrace();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n创建二叉树:"</span>);</span><br><span class="line">    binarytree_create(&amp;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n先序遍历二叉树:"</span>);</span><br><span class="line">    binarytree_preorder(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n中序遍历二叉树:"</span>);</span><br><span class="line">    binarytree_inorder(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n后序遍历二叉树:"</span>);</span><br><span class="line">    binarytree_postorder(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n层次遍历二叉树:"</span>);</span><br><span class="line">    binarytree_levelorder(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n打印二叉树叶子节点:"</span>);</span><br><span class="line">    binarytree_printfleaf(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n打印二叉树叶子节点个数:%d"</span>,binarytree_getleafnum(root));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n打印二叉树高度:%d"</span>,binarytree_gethigh(root));</span><br><span class="line"></span><br><span class="line">    binarytree_destory(root);</span><br><span class="line"></span><br><span class="line">    muntrace();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<details>
<summary>binarytree</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Implement binary tree in array */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_NODES (1 &lt;&lt; 8)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_tree</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nodes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">n</span>[<span class="title">MAX_TREE_NODES</span>];</span></span><br><span class="line">    };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_binary_tree</span><span class="params">(struct binary_tree *tree)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_TREE_NODES; i++) {</span><br><span class="line">        tree-&gt;n[i] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct node* <span class="title">create_node</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n)</span><br><span class="line">        n-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fake_a_tree</span><span class="params">(struct binary_tree* tree)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* data is in ordered */</span></span><br><span class="line">    <span class="keyword">int</span> i, data[<span class="number">10</span>] = {<span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>};</span><br><span class="line"></span><br><span class="line">    init_binary_tree(tree);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* root start at 1 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        tree-&gt;n[i+<span class="number">1</span>] = create_node(data[i]);</span><br><span class="line"></span><br><span class="line">    tree-&gt;nodes = <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _in_order(struct binary_tree* tree, <span class="keyword">int</span> index)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!tree-&gt;n[index])</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* left child at (index &lt;&lt; 1) */</span></span><br><span class="line">    _in_order(tree, index &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%2d]: %4d\n"</span>, index, tree-&gt;n[index]-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* right child at (index &lt;&lt; 1) + 1 */</span></span><br><span class="line">    _in_order(tree, (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(struct binary_tree* tree)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    _in_order(tree, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binary_tree</span> <span class="title">tree</span>;</span></span><br><span class="line"></span><br><span class="line">    fake_a_tree(&amp;tree);</span><br><span class="line">    in_order(&amp;tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<p> 二叉树性质:</p>
<ul>
<li>二叉树中,第i层最多有 2^(i-1)个节点</li>
<li>如果二叉树的深度为K,则二叉树最多有<code>2^K - 1</code>个节点</li>
<li>二叉树中，终端结点树(叶子节点树)为n0，度为2的节点树为n1，则 n0=n1+1</li>
</ul>
<p><strong>满二叉树</strong><br> 如果二叉树中除了叶子节点，每个节点的度都为2，则此二叉树为满二叉树。</p>
<p><strong>完全二叉树</strong><br> 如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p>
<p> 树的周游算法包含先序遍历、中序遍历、后序遍历和层序遍历。</p>
<ul>
<li>先序遍历：先访问根结点，然后左子树，最后右子结点。深度优先思想。</li>
<li>中序遍历：先访问左子结点，然后根结点，最后右子结点。</li>
<li>后序遍历：先访问左子结点，然后右子结点，最后根结点。</li>
<li>层序遍历：先访问树的根结点，然后依次向下层处理，按照从左向右的顺序访问每层结点。广度优先的策略。</li>
</ul>
<h4 id="2-3-4-二叉查找树-BST"><a href="#2-3-4-二叉查找树-BST" class="headerlink" title="2.3.4 二叉查找树(BST)"></a>2.3.4 二叉查找树(BST)</h4><p> 二叉查找树也称二叉搜索树,有序二叉树或排序二叉树,具有性质:</p>
<ul>
<li>若任意节点左子树不为空,则左子树上所有节点的值均小于它的根节点的值</li>
<li>若任意节点的右子树不为空,则右子树所有节点的值均大于根节点的值</li>
<li>任意节点的左,右子树也分别为二叉查找树</li>
<li>没有键值相等的节点</li>
</ul>
<p> 一颗二叉搜索树要插入一个结点，要从根结点开始，一层一层往下，适当地移动左或右子结点上，当到达树的分支尽头时，执行插入操作。<br> 二叉搜索树是一种用于查找操作的高效数据结构，在最坏情况下，只需查找一个分支上的数据即可。<strong>查找,插入</strong>操作的复杂度是 <code>O(logn)</code>，<strong>搜索,插入,删除</strong>复杂度等于树高,期望<code>O(logn)</code>,最坏为<code>O(n)</code>,(树退化为线性表)n为树中结点数。<br> 保持一棵树的平衡是指对于给定数量的结点，要使得树的高度尽可能短。</p>
<p> 二叉查找树是由二叉树组成的专用于查找和搜索目的的一种数据结构。二叉搜索树中查找一个结点，从根结点开始一层一层向下查找，当遇到一个比目标结点值大的结点时，顺着该结点左子树继续查找，如果遇到的结点值小于目标结点，则顺着该结点的右子树查找，直到找到目标结点为止。</p>
<p> <strong>查找算法</strong><br>  1.若b是空树,则搜索失败,否则;<br>  2.若x等于b的根节点的数据域之值,则查找成功;<br>  3.若x小于b的根节点的数据域之值,则搜索左子树<br>  4.查找右子树</p>
<p> <strong>插入算法</strong><br>  1.若b是空树,则将s所指节点作为根节点插入;否则<br>  2.若<code>s-&gt;data</code>等于b的根节点的数据域值,则返回,否则;<br>  3.若<code>s-&gt;data</code>小于b的根节点的数据域之值,则把s所值节点插入到左子树中,否则<br>  4.把s所指节点插入到右子树中,(新插入节点总是叶子节点)</p>
<p> <strong>删除算法</strong><br>  1.若*p节点为叶子节点,即PL(左子树)和PR(右子树)均为空树.由于删去叶子节点不破坏整棵树的结构,则只需修改其双亲节点的指针即可.</p>
<details>
<summary>binarysearch</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">} BTree, *BTreePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** 插入 **********************/</span></span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(BTreePtr *T, ElemType e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    BTreePtr p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*T == <span class="literal">NULL</span>) {</span><br><span class="line">        *T = (BTreePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTree));</span><br><span class="line">        (*T)-&gt;data = e;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        p = *T;</span><br><span class="line">        <span class="keyword">while</span> ( p != <span class="literal">NULL</span>) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e &gt; p-&gt;data) {</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;rchild == <span class="literal">NULL</span>) {</span><br><span class="line">                    p-&gt;rchild = (BTreePtr) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BTree));</span><br><span class="line">                    p-&gt;rchild-&gt;data = e;</span><br><span class="line">                    <span class="keyword">return</span> TRUE;</span><br><span class="line">                }</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) {</span><br><span class="line">                    p-&gt;lchild = (BTreePtr) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BTree));</span><br><span class="line">                    p-&gt;lchild-&gt;data = e;</span><br><span class="line">                    <span class="keyword">return</span> TRUE;</span><br><span class="line">                }</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**************** 删除 **********************/</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BTreePtr T, ElemType e)</span> </span>{</span><br><span class="line">    BTreePtr p, pp, minP, minPP, child;</span><br><span class="line">    child = <span class="literal">NULL</span>;</span><br><span class="line">    p = T;</span><br><span class="line">    pp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( (p != <span class="literal">NULL</span>) &amp;&amp; (p-&gt;data != e) ) {</span><br><span class="line">        pp = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e &gt; p-&gt;data) {</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;lchild != <span class="literal">NULL</span>) &amp;&amp; (p-&gt;rchild != <span class="literal">NULL</span>) {</span><br><span class="line">        minPP = p;</span><br><span class="line">        minP = p-&gt;rchild;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (minP-&gt;lchild != <span class="literal">NULL</span>) {</span><br><span class="line">            minPP = minP;</span><br><span class="line">            minP = minP-&gt;lchild;</span><br><span class="line">        }</span><br><span class="line">        p-&gt;data = minP-&gt;data;</span><br><span class="line">        minPP-&gt;lchild = minP-&gt;rchild;</span><br><span class="line">        <span class="built_in">free</span>(minP);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有一个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;lchild != <span class="literal">NULL</span>) || (p-&gt;rchild != <span class="literal">NULL</span>)) { <span class="comment">//应该将原有的pp同child连接在一起</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild) {</span><br><span class="line">            child = p-&gt;lchild;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">           child = p-&gt;rchild;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pp-&gt;data&gt;p-&gt;data) {</span><br><span class="line">            pp-&gt;lchild=child;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            pp-&gt;rchild=child;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有节点</span></span><br><span class="line">    <span class="keyword">if</span> (pp-&gt;lchild == p) {<span class="comment">//这里面临pp除p以外的节点为null的情况</span></span><br><span class="line">        pp-&gt;lchild = child;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        pp-&gt;rchild = child;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**************** 查找 **********************/</span></span><br><span class="line">Status Find(BTreePtr T, ElemType e) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((T != <span class="literal">NULL</span>) &amp;&amp; (T-&gt;data != e)) {</span><br><span class="line">        <span class="keyword">if</span> (e &gt; T-&gt;data) {</span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (T) {</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** 最大值 **********************/</span></span><br><span class="line">ElemType FindMax(BTreePtr T) {</span><br><span class="line">    ElemType max;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span>) {</span><br><span class="line">        max = T-&gt;data;</span><br><span class="line">        T = T-&gt;rchild;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** 最小值 **********************/</span></span><br><span class="line">ElemType FindMin(BTreePtr T) {</span><br><span class="line">    ElemType min;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span>) {</span><br><span class="line">        min = T-&gt;data;</span><br><span class="line">        T = T-&gt;lchild;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PreOrderTraverse(BTreePtr T)<span class="comment">//前序遍历二叉树</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(T) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,T-&gt;data);</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DestroyTree(BTreePtr T) {</span><br><span class="line">    <span class="keyword">if</span> (T) {</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;lchild) {</span><br><span class="line">            DestroyTree(T-&gt;lchild);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rchild) {</span><br><span class="line">            DestroyTree(T-&gt;rchild);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************** 执行测试 *************************/</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span><br><span class="line">{</span><br><span class="line">    BTreePtr T;</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> a[] = {<span class="number">33</span>, <span class="number">16</span>, <span class="number">50</span>, <span class="number">13</span>, <span class="number">18</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">25</span>, <span class="number">51</span>, <span class="number">66</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">55</span>};</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) {</span><br><span class="line">        Insert(&amp;T, a[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Max is %d\n"</span>, FindMax(T));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Min is %d\n"</span>, FindMin(T));</span><br><span class="line">    Delete(T, <span class="number">18</span>);</span><br><span class="line">    Delete(T, <span class="number">13</span>);</span><br><span class="line">    PreOrderTraverse(T);</span><br><span class="line">    DestroyTree(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<details>
<summary>bst</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">child_dir</span> {</span></span><br><span class="line">    left_child,</span><br><span class="line">    right_child,</span><br><span class="line">    root,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">root</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">r</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(struct node *node, <span class="keyword">int</span> level, <span class="keyword">enum</span> child_dir dir)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    dump(node-&gt;right, level + <span class="number">1</span>, right_child);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == left_child)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%*s\n"</span>, level*<span class="number">3</span>, <span class="string">"|"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%*s - %05lu\n"</span>, level*<span class="number">3</span>, <span class="string">" "</span>, node-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == right_child)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%*s\n"</span>, level*<span class="number">3</span>, <span class="string">"|"</span>);</span><br><span class="line"></span><br><span class="line">    dump(node-&gt;left, level + <span class="number">1</span>, left_child);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct node* <span class="title">find</span><span class="params">(struct root *root, <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">n</span> =</span> root-&gt;r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n) {</span><br><span class="line">        <span class="keyword">if</span> (n-&gt;data == data)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; n-&gt;data)</span><br><span class="line">            n = n-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            n = n-&gt;right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct node* <span class="title">new_node</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line"></span><br><span class="line">    n-&gt;data = data;</span><br><span class="line">    n-&gt;left = n-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(struct root *root, struct node *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;r) {</span><br><span class="line">        root-&gt;r = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    parent = root-&gt;r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="comment">/* Don't support duplicate data */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;data == parent-&gt;data)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;data &lt; parent-&gt;data) {</span><br><span class="line">        <span class="keyword">if</span> (!parent-&gt;left) {</span><br><span class="line">            parent-&gt;left = <span class="keyword">new</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        parent = parent-&gt;left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (!parent-&gt;right) {</span><br><span class="line">                parent-&gt;right = <span class="keyword">new</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            parent = parent-&gt;right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct node* <span class="title">delete</span><span class="params">(struct root *root, <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">n</span> =</span> root-&gt;r, **p = &amp;root-&gt;r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">child</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &amp;&amp; n-&gt;data != data) {</span><br><span class="line">        <span class="keyword">if</span> (data &lt; n-&gt;data) {</span><br><span class="line">            p = &amp;n-&gt;left;</span><br><span class="line">            n = n-&gt;left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p = &amp;n-&gt;right;</span><br><span class="line">            n = n-&gt;right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n-&gt;left &amp;&amp; n-&gt;right) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">rn</span> =</span> n-&gt;right, **rp = &amp;n-&gt;right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rn-&gt;left) {</span><br><span class="line">            rp = &amp;rn-&gt;left;</span><br><span class="line">            rn = rn-&gt;left;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        n-&gt;data = rn-&gt;data;</span><br><span class="line">        n = rn;</span><br><span class="line">        p = rp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    child = n-&gt;left ? n-&gt;left : n-&gt;right;</span><br><span class="line">    *p = child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">root</span> <span class="title">tree</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    tree.r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">5</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">2</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">18</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">13</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">21</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    dump(tree.r, <span class="number">0</span>, root);</span><br><span class="line"></span><br><span class="line">    n = find(&amp;tree, <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &amp;&amp; n-&gt;data == <span class="number">18</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Get 18\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">root</span> <span class="title">tree</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    tree.r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">5</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">2</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">18</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">13</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">21</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    dump(tree.r, <span class="number">0</span>, root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>(&amp;tree, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Delete 20\n"</span>);</span><br><span class="line">    dump(tree.r, <span class="number">0</span>, root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>(&amp;tree, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Delete 9\n"</span>);</span><br><span class="line">    dump(tree.r, <span class="number">0</span>, root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//insert_test();</span></span><br><span class="line">    delete_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<h4 id="2-3-5-平衡树"><a href="#2-3-5-平衡树" class="headerlink" title="2.3.5 平衡树"></a>2.3.5 平衡树</h4><p> 平衡树是一类改进的二叉查找树,一般二叉查找树的查询复杂度与目标节点到树根的距离(深度)有关,因此当深度较大时,查询均摊复杂度会上升.<br> <strong>平衡指所有叶子的深度趋于平衡</strong>,更广义指树上所有可能查找的均摊复杂度偏低.<strong>平衡树的操作时基于树旋转操作,通过旋转可使树趋于平衡</strong>.<br> 对一颗查找树进行查询,新增,删除等操作,所花的时间与树的高度h成比例,并不与树的容量n成比例.</p>
<ul>
<li><strong>AVL树</strong></li>
</ul>
<p> 在<strong>AVL树中,任一节点对于的两颗子树的最大高度差为1,因此也称为高度平衡树</strong>.查找,插入和删除的平均和最坏时间复杂度是O(logn),增加和删除元素的操作则可能需要借由一层或多次旋转,以实现树的重新平衡.<br> <strong>高度为h的AVL树,总节点数最多为2^h-1</strong>; 当前节点数为N时,高度h最多为:</p>
<blockquote>
<p>log(5*0.5 * (N + 1)) - 2</p>
</blockquote>
<br>

<ul>
<li><strong>红黑树</strong></li>
</ul>
<p> 红黑树是一种自平衡二叉查找树,典型的用途是实现关联数组.红黑树实现复制,查找,插入和删除时间复杂度为O(logn)<br> 红黑树相对于AVL树,牺牲了部分平衡性以换取插入\删除操作时少量的旋转操作,整体性能优于AVL树.</p>
<p> 红黑树与AVL树的相比:<br>  AVL树在插入,删除节点时要把树调整到完全平衡,红黑树只要调整到大致平衡,因此通常红黑树的插入,删除节点性能稍好.<br>  AVL的查找性能通常比红黑树好<br>  如果节点的增删操作远小于查找操作,则应选择AVL;反之,红黑树可能更好.</p>
<p> 红黑树是每个节点都带有颜色属性的二叉树,颜色为红色或黑色.在二叉查找树强制一般要求以外,对于任何有效的红黑树我们怎讲了弱小额外要求:<br>  1.节点是红或黑色<br>  2.根是黑色<br>  3.所有叶子都是黑色(叶子是NIL节点)<br>  4.每个红色节点必须右两个黑色的子节点.(从每个叶子到根的所有路径上不能右两个连续的红色节点.)<br>  5.从任一节点到其每个叶子的所有简单路径都包含相同苏后面的黑色节点.<br> 红黑树关键特性:<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>.红黑树是大致平衡的.插入,删除和查找某个值最坏情况下与树的高度成比例.</p>
<ul>
<li><strong>B+树</strong></li>
</ul>
<p> B+树通常用于数据库和操作系统的文件系统中.<strong>B+树的特点是能够保持数据稳定有序,其插入与修改拥有较文档的对数时间复杂度</strong>.B+树元素自底向上插入,与二叉树相反.<br> B+树是内部节点可右在预定范围内的可变量目的子节点.因此,B+树不需要像其他自平衡二叉查找树那样重新平衡.</p>
<ul>
<li><strong>字典树</strong></li>
</ul>
<details>
<summary>Trie</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">children</span>[26];</span></span><br><span class="line">    Status end;</span><br><span class="line">} Trie, *TriePtr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(TriePtr *T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    (*T) = (TriePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    (*T)-&gt;data = <span class="string">'/'</span>;</span><br><span class="line">    (*T)-&gt;end = FALSE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(TriePtr T, <span class="keyword">char</span> *str)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c = *str++) {</span><br><span class="line">        index = c - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;children[index] == <span class="literal">NULL</span>) {</span><br><span class="line">            TriePtr Node;</span><br><span class="line">            Node = (TriePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">            Node-&gt;data = c;</span><br><span class="line">            Node-&gt;end = FALSE;</span><br><span class="line">            T-&gt;children[index] = Node;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        T = T-&gt;children[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T-&gt;end = TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Search</span><span class="params">(TriePtr T, <span class="keyword">char</span> *str)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c = *str++) {</span><br><span class="line">        index = c - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;children[index] == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        T = T-&gt;children[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;end) {</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    TriePtr T;</span><br><span class="line">    Init(&amp;T);</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">"hi"</span>;</span><br><span class="line"></span><br><span class="line">    Insert(T, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str is search %d\n"</span>, Search(T, str));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2 is search %d\n"</span>, Search(T, str2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<h4 id="2-3-6-堆树和优先队列"><a href="#2-3-6-堆树和优先队列" class="headerlink" title="2.3.6 堆树和优先队列"></a>2.3.6 堆树和优先队列</h4><p> 堆(heap)也称为优先队列,堆遵守队列操作模式,在堆底插入元素,在堆顶取出元素,但堆中元素的排列不是按照到来的先后顺序,而是按照一定的有序顺序排列的.<br> 堆的本质是一个完全二叉树,可使用二叉树表示堆,也可使用数组来表示.<br> 堆的特性:<br>  必须是完全二叉树<br>  用数组实现<br>  任一节点的值是其子树所有节点的最大值或最小值<br>   最大值时,称为最大堆,也称大顶堆<br>   最小时,称为最小堆,也称小顶堆.<br> <strong>堆不能保证整棵树都是有序的,堆中的插入和删除操作时时间复杂度为O(log2n)</strong></p>
<p> 堆是一颗二叉树，通常其子结点存储的值比父结点的值小，所以，根结点为树中最大的结点(大顶堆)。同样，根结点也可以是树中最小的结点(小顶堆)。能够快速确定包含最大(小)值的特点。<br> 堆时左平衡的树，随着结点增加，树会逐级从左至右增长。一个较好地表示左平衡二叉树的方式是，将结点通过层序遍历方式连续存储到一个数组中。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap_</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> (*compare)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> **tree;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>heap</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Implement heap */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_HEAP_SIZE (1 &lt;&lt; 8)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> elements;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">elem</span>[<span class="title">MAX_HEAP_SIZE</span>];</span></span><br><span class="line">    };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_heap</span><span class="params">(struct heap *heap)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_HEAP_SIZE; i++) {</span><br><span class="line">        heap-&gt;elem[i] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_heap</span><span class="params">(struct heap *heap, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">elem</span>;</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt; heap-&gt;elements)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    elem = heap-&gt;elem[index];</span><br><span class="line">    level = fls(index);</span><br><span class="line"></span><br><span class="line">    dump_heap(heap, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(index % <span class="number">2</span>) &amp;&amp; index != <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%*s\n"</span>, level*<span class="number">3</span>, <span class="string">"|"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%*s - %05d\n"</span>, level*<span class="number">3</span>, <span class="string">" "</span>, elem-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index % <span class="number">2</span> &amp;&amp; index != <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%*s\n"</span>, level*<span class="number">3</span>, <span class="string">"|"</span>);</span><br><span class="line"></span><br><span class="line">    dump_heap(heap, index * <span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(struct heap *heap, <span class="keyword">int</span> elements)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= elements; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%02d]: %4d\n"</span>, i, heap-&gt;elem[i]-&gt;data);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct element* <span class="title">create_element</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">elem</span>;</span></span><br><span class="line"></span><br><span class="line">    elem = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct element));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elem)</span><br><span class="line">        elem-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fake_a_heap</span><span class="params">(struct heap *heap)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* data is in ordered */</span></span><br><span class="line">    <span class="keyword">int</span> i, data[<span class="number">10</span>] = {<span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>};</span><br><span class="line"></span><br><span class="line">    init_heap(heap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* root start at 1 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        heap-&gt;elem[i+<span class="number">1</span>] = create_element(data[i]);</span><br><span class="line"></span><br><span class="line">    heap-&gt;elements = <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(struct heap *heap, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    tmp = heap-&gt;elem[j];</span><br><span class="line">    heap-&gt;elem[j] = heap-&gt;elem[i];</span><br><span class="line">    heap-&gt;elem[i] = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(struct heap *heap, <span class="keyword">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> **<span class="title">elem</span> =</span> heap-&gt;elem;</span><br><span class="line">    <span class="keyword">int</span> elements = heap-&gt;elements;</span><br><span class="line">    <span class="keyword">int</span> left, right, max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        left = parent * <span class="number">2</span>;</span><br><span class="line">        right = left + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        max = parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= elements &amp;&amp; elem[max]-&gt;data &lt; elem[left]-&gt;data)</span><br><span class="line">            max = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= elements &amp;&amp; elem[max]-&gt;data &lt; elem[right]-&gt;data)</span><br><span class="line">            max = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (max == parent)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap(heap, max, parent);</span><br><span class="line">        parent = max;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(struct heap *heap)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = heap-&gt;elements / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        heapify(heap, i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heap_sort</span><span class="params">(struct heap *heap)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> elements = heap-&gt;elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap-&gt;elements) {</span><br><span class="line">        swap(heap, <span class="number">1</span>, heap-&gt;elements);</span><br><span class="line">        heap-&gt;elements--;</span><br><span class="line">        heapify(heap, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> elements;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap</span> <span class="title">heap</span>;</span></span><br><span class="line">    <span class="keyword">int</span> elements;</span><br><span class="line"></span><br><span class="line">    fake_a_heap(&amp;heap);</span><br><span class="line">    dump_heap(&amp;heap, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After Heapify:\n"</span>);</span><br><span class="line">    build_heap(&amp;heap);</span><br><span class="line">    dump_heap(&amp;heap, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After Heap sort:\n"</span>);</span><br><span class="line">    elements = heap_sort(&amp;heap);</span><br><span class="line">    dump(&amp;heap, elements);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<p> 堆排序，要排序的数据首先存储在一个堆中。从堆中一次取出一个结点。放置到有序数据集的尾部。当取出每个结点时，它的下一个结点就会浮现到堆的顶部。</p>
<p> 优先队列是从堆衍生的数据结构。在优先队列中，数据保存在一个堆中，可快速确定下一个最高优先级的结点。</p>
<p> 优先队列将数据按照优先级顺序排列。一个优先队列由许多有序元素构成，所以优先级最高的元素可以有效而快速的确定。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Heap PQueue;</span><br></pre></td></tr></tbody></table></figure>


<h4 id="2-3-7-leetcode题目"><a href="#2-3-7-leetcode题目" class="headerlink" title="2.3.7 leetcode题目"></a>2.3.7 leetcode题目</h4><ul>
<li>先序遍历构造二叉树</li>
<li>从中序与后序遍历构造二叉树</li>
<li>二叉树的层次遍历</li>
<li>从二叉搜索树到更大和树</li>
<li>二叉搜索树的最近公共祖先</li>
<li>前K个高频单词&lt;堆&gt;</li>
</ul>
<h3 id="2-4-图"><a href="#2-4-图" class="headerlink" title="2.4 图"></a>2.4 图</h3><p> 图(Graph)是由顶点的有穷非空集合和顶点之间的边的集合组成,通常表示为:<code>G(V,E)</code>.其中,G表示一个图,V是入G中顶点的集合,E是图G中的集合.</p>
<p> 图是一种灵活的数据结构，用来定义对象之间关联或联系的模型。对象由顶点表示，而对象直接的关系或关联则通过顶点之间的边来表示。<br> 图的访问方式：广度优先和深度优先。</p>
<h4 id="2-4-1-基础知识"><a href="#2-4-1-基础知识" class="headerlink" title="2.4.1 基础知识"></a>2.4.1 基础知识</h4><p> 图由两种类型的元素组成：顶点和边，顶点代表对象，边则建立起对象之间的关系或关联。图的边可关联值或权重信息。</p>
<ul>
<li>一组顶点：用V(vertex)表示顶点集合</li>
<li>一组边：用E(edge)表示边的集合<br> 图分为有向图和无向图。有向图，边是由两个顶点组成的有序对，具有特定的方向。边也可称为弧。无向图中，边是没有方向的。</li>
<li>(v, w)表示无向边，即v和w是互通的</li>
<li>&lt; v, w &gt;表示有向边，该边始于v，终于w<br> 图可分为连通图和非连通图</li>
<li>连通图：所有的点都右路径相连</li>
<li>非连通图：存在某两个点没有路径相连</li>
<li>强连通图： </li>
</ul>
<p> 图中的顶点度</p>
<ul>
<li>度</li>
<li>入度</li>
<li>出度</li>
</ul>
<h4 id="2-4-2-图表示"><a href="#2-4-2-图表示" class="headerlink" title="2.4.2 图表示"></a>2.4.2 图表示</h4><p> 图的表示方法是G=(V, E)，V代表顶点的集合，而E和V之间是二元关系。<br> 图中由两个重要关系邻接(adjacency)和关联(incidence)。邻接是两个顶点之间的关系。关联是顶点和边之间的关系。<br>邻接矩阵表示</p>
<ul>
<li></li>
</ul>
<h2 id="邻接链表表示"><a href="#邻接链表表示" class="headerlink" title="邻接链表表示"></a>邻接链表表示</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjList_</span> {</span></span><br><span class="line">    <span class="keyword">void</span> *vertex;</span><br><span class="line">    Set adjacent;</span><br><span class="line">}AdjList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Graph_</span> {</span></span><br><span class="line">    <span class="keyword">int</span> vcount;</span><br><span class="line">    <span class="keyword">int</span> ecount;</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    List adjlists;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>graph</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vertex</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex</span> *<span class="title">v</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> *<span class="title">next</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vertex</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> *<span class="title">adj</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_GRAPH_VERTEX (1 &lt;&lt; 8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex</span> *<span class="title">vxs</span>[<span class="title">MAX_GRAPH_VERTEX</span>];</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_graph</span><span class="params">(struct graph *graph)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_GRAPH_VERTEX; i++)</span><br><span class="line">        graph-&gt;vxs[i] = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct vertex *<span class="title">create_vertex</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex</span> *<span class="title">v</span>;</span></span><br><span class="line"></span><br><span class="line">    v = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct vertex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v) {</span><br><span class="line">        v-&gt;data = data;</span><br><span class="line">        v-&gt;adj = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct vertex_adjs *<span class="title">create_vertex_adj</span><span class="params">(struct vertex *v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> *<span class="title">v_adj</span>;</span></span><br><span class="line"></span><br><span class="line">    v_adj = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct vertex_adjs));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v_adj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    v_adj-&gt;v = v;</span><br><span class="line">    v_adj-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> v_adj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_adj</span><span class="params">(struct vertex *v, struct vertex *adj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> **<span class="title">v_adj</span>;</span></span><br><span class="line"></span><br><span class="line">    v_adj = &amp;v-&gt;adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*v_adj)</span><br><span class="line">    v_adj = &amp;(*v_adj)-&gt;next;</span><br><span class="line"></span><br><span class="line">    *v_adj = create_vertex_adj(adj);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_raw</span><span class="params">(struct graph *graph)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_GRAPH_VERTEX; i++) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vertex</span> *<span class="title">v</span> =</span> graph-&gt;vxs[i];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> *<span class="title">adj</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Vertex[%02d]: %8d -&gt;"</span>, i, v-&gt;data);</span><br><span class="line"></span><br><span class="line">        adj = v-&gt;adj;</span><br><span class="line">        <span class="keyword">while</span> (adj) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %8d,"</span>, adj-&gt;v-&gt;data);</span><br><span class="line">            adj = adj-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  1 ----- 2 ----- 3</span></span><br><span class="line"><span class="comment">  |     / |     /</span></span><br><span class="line"><span class="comment">  |    /  |    / </span></span><br><span class="line"><span class="comment">  |   /   |   /  </span></span><br><span class="line"><span class="comment">  |  /    |  /   </span></span><br><span class="line"><span class="comment">  | /     | /    </span></span><br><span class="line"><span class="comment">  4 ----- 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fake_a_graph</span><span class="params">(struct graph *graph)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    init_graph(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    graph-&gt;vxs[i] = create_vertex(i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* connect 1 -&gt; 2, 1 -&gt; 4 */</span></span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">0</span>], graph-&gt;vxs[<span class="number">1</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">0</span>], graph-&gt;vxs[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">/* connect 2 -&gt; 1, 2 -&gt; 3, 2 -&gt; 5, 2 -&gt; 4 */</span></span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">1</span>], graph-&gt;vxs[<span class="number">0</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">1</span>], graph-&gt;vxs[<span class="number">2</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">1</span>], graph-&gt;vxs[<span class="number">4</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">1</span>], graph-&gt;vxs[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">/* connect 3 -&gt; 2, 3 -&gt; 5 */</span></span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">2</span>], graph-&gt;vxs[<span class="number">1</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">2</span>], graph-&gt;vxs[<span class="number">4</span>]);</span><br><span class="line">    <span class="comment">/* connect 4 -&gt; 1, 4 -&gt; 2, 4 -&gt; 5 */</span></span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">3</span>], graph-&gt;vxs[<span class="number">0</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">3</span>], graph-&gt;vxs[<span class="number">1</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">3</span>], graph-&gt;vxs[<span class="number">4</span>]);</span><br><span class="line">    <span class="comment">/* connect 5 -&gt; 4, 5 -&gt; 2, 5 -&gt; 3 */</span></span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">4</span>], graph-&gt;vxs[<span class="number">3</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">4</span>], graph-&gt;vxs[<span class="number">1</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">4</span>], graph-&gt;vxs[<span class="number">3</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">graph</span> <span class="title">g</span>;</span></span><br><span class="line"></span><br><span class="line">    fake_a_graph(&amp;g);</span><br><span class="line">    dump_raw(&amp;g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<h4 id="2-4-3-图遍历"><a href="#2-4-3-图遍历" class="headerlink" title="2.4.3 图遍历"></a>2.4.3 图遍历</h4><p> 图的搜索方法：深度优先搜索和广度优先搜索。<br> 深度优先遍历(DFS)<br> 思路: 从图中某点v出发:<br>   1.访问顶点v<br>   2.从v的未被访问的邻接点中选取一个顶点w,从w出发进行深度优先遍历.<br>   3.重复上述两步,直到图中所有和v有路径相通的顶点都被访问.<br> 伪代码: </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Vertex v)</span> </span>{</span><br><span class="line">    vistied[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (v 的每个邻接点 w) {</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) {</span><br><span class="line">            DFS(w);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<details>
<summary>dfs</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Graph.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NODES 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[MAX_NODES];  <span class="comment">// array to store visiting order</span></span><br><span class="line">                         <span class="comment">// indexed by vertex 0..nV-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfsPathCheck</span><span class="params">(Graph g, <span class="keyword">int</span> nV, Vertex v, Vertex dest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Vertex w;</span><br><span class="line">    <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; nV; w++)</span><br><span class="line">        <span class="keyword">if</span> (adjacent(g, v, w) &amp;&amp; visited[w] == <span class="number">-1</span>)</span><br><span class="line">        {</span><br><span class="line">            visited[w] = v;</span><br><span class="line">            <span class="keyword">if</span> (w == dest)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dfsPathCheck(g, nV, w, dest))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findPathDFS</span><span class="params">(Graph g, <span class="keyword">int</span> nV, Vertex src, Vertex dest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Vertex v;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; nV; v++) visited[v] = <span class="number">-1</span>;</span><br><span class="line">    visited[src] = src;</span><br><span class="line">    <span class="keyword">return</span> dfsPathCheck(g, nV, src, dest);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> V = <span class="number">6</span>;</span><br><span class="line">    Graph g = newGraph(V);</span><br><span class="line"></span><br><span class="line">    Edge e;</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">1</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">4</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">5</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">5</span>;</span><br><span class="line">    e.w = <span class="number">4</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">4</span>;</span><br><span class="line">    e.w = <span class="number">2</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">4</span>;</span><br><span class="line">    e.w = <span class="number">3</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">5</span>;</span><br><span class="line">    e.w = <span class="number">3</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">1</span>;</span><br><span class="line">    e.w = <span class="number">2</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">3</span>;</span><br><span class="line">    e.w = <span class="number">2</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> src = <span class="number">0</span>, dest = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (findPathDFS(g, V, src, dest))</span><br><span class="line">    {</span><br><span class="line">        Vertex v = dest;</span><br><span class="line">        <span class="keyword">while</span> (v != src)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d - "</span>, v);</span><br><span class="line">            v = visited[v];</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, src);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<p> 广度优先遍历(BFS)<br> 思路:<br>   1.顶点v入队列<br>   2.当队列非空时则继续执行,否则算法结束.<br>   3.出队列取得队头顶点v’,访问顶点v 并标记顶点v已被访问.<br>   4.查找顶点v的第一个邻接顶点col<br>   5.若v的邻接顶点col未被访问过的,则col继续.<br>   6.查找顶点v的另一个新的邻接顶点col,转到步骤5入队列,直到顶点v的所有未被访问过的邻接点处理完,转到步骤2.</p>
<details>
<summary>bfs_queue</summary>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Graph.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NODES 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[MAX_NODES];  <span class="comment">// array to store visiting order</span></span><br><span class="line">                         <span class="comment">// indexed by vertex 0..nV-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findPathBFS</span><span class="params">(Graph g, <span class="keyword">int</span> nV, Vertex src, Vertex dest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Vertex v;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; nV; v++) visited[v] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    visited[src] = src;</span><br><span class="line">    <span class="built_in">queue</span> Q = newQueue();</span><br><span class="line">    QueueEnqueue(Q, src);</span><br><span class="line">    <span class="keyword">while</span> (!QueueIsEmpty(Q)) {</span><br><span class="line">        v = QueueDequeue(Q);</span><br><span class="line">        Vertex w;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; nV; w++) (</span><br><span class="line">            <span class="keyword">if</span> (adjacent(g, v, w) &amp;&amp; visited[w] == <span class="number">-1</span>) {</span><br><span class="line">                visited[w] = v;</span><br><span class="line">                <span class="keyword">if</span> (w == dest)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    QueueEnqueue(Q, w);</span><br><span class="line">            }</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> V = <span class="number">10</span>;</span><br><span class="line">    Graph g = newGraph(V);</span><br><span class="line"></span><br><span class="line">    Edge e;</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">1</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">2</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">5</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">1</span>;</span><br><span class="line">    e.w = <span class="number">5</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">2</span>;</span><br><span class="line">    e.w = <span class="number">3</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">3</span>;</span><br><span class="line">    e.w = <span class="number">4</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">3</span>;</span><br><span class="line">    e.w = <span class="number">5</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">3</span>;</span><br><span class="line">    e.w = <span class="number">8</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">4</span>;</span><br><span class="line">    e.w = <span class="number">5</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">4</span>;</span><br><span class="line">    e.w = <span class="number">7</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">4</span>;</span><br><span class="line">    e.w = <span class="number">8</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">5</span>;</span><br><span class="line">    e.w = <span class="number">6</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">7</span>;</span><br><span class="line">    e.w = <span class="number">8</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">7</span>;</span><br><span class="line">    e.w = <span class="number">9</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">8</span>;</span><br><span class="line">    e.w = <span class="number">9</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> src = <span class="number">0</span>, dest = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (findPathBFS(g, V, src, dest)) {</span><br><span class="line">        Vertex v = dest;</span><br><span class="line">        <span class="keyword">while</span> (v != src) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d - "</span>, v);</span><br><span class="line">            v = visited[v];</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, src);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<p> 深度优先搜索和广度优先搜索,时间复杂度都为O(n^2)</p>
<p>深度优先:从初始点出发,不断向前走,如果碰到死路,就往回走一步,尝试另一条路,直到发现目标位置.<br>广度优先:从初始点出发,把所有可能的路径都走一遍,如果里面没有目标位置,则尝试把所有两步能够到的位置都走一遍,看有没有目标位置.</p>
<h4 id="2-4-4-最短路径"><a href="#2-4-4-最短路径" class="headerlink" title="2.4.4 最短路径"></a>2.4.4 最短路径</h4><p><strong>迪杰斯特拉Dijkstra算法</strong><br> Dijkstra算法适用于权值为正的图.<br> Dijkstra算法属于单源算法,即只能求出某点到其它点最短距离,并不能得出任意两点之间的最短距离.<br> 在源点可达的情况下,Dijkstra算法的时间复杂度时 <code>O(ElogV)</code><br> 算法步骤:<br>  1.将所有边初始化为无穷大<br>  2.旋转一个开始的顶点,添加到优先队列中.<br>  3.对于该点的所有邻接顶点进行判断,如果到该点的距离小于原先的值,则该值进行更新.<br>  4.将该点所有邻接顶点添加到优先队列中.<br>  5.从优先队列中挑选除一个路径值最小的顶点,将其弹出,作为新的顶点,重复步骤3,4,5<br>  6.直到所有点都被处理过一次.</p>
<p><strong>弗洛伊德Floyd算法</strong><br> Floyd算法是一个经典的动态规划算法.首先目标是寻找从点<code>i</code>到<code>j</code>的最短路径.<br> <strong>Floyd算法可以求出任意两点的最短距离.时间复杂度:</strong><code>O(你^3)</code><br> 从任意节点i到任意节点j的最短路径不外乎2种可能:<br>  1.是之间从i到j<br>  2是从i到经过若干个节点k到j<br> 设Dist(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，则设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] &gt; (A[i][k] + A[k][j])) {</span><br><span class="line">                A[i][j] = A[i][k] + A[k][j];</span><br><span class="line">                path[i][j] = k;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h4 id="2-4-5-拓扑排序"><a href="#2-4-5-拓扑排序" class="headerlink" title="2.4.5 拓扑排序"></a>2.4.5 拓扑排序</h4><p> 拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列.且该序列必须满足下面两个条件:</p>
<ul>
<li>每个顶点出现且只出现一次</li>
<li>若存在一条顶点A到顶点B的路径,那么在序列中顶点A出现在顶点B的前面.<br> 有向无环图(DAG)才有拓扑排序，非DAG图没有拓扑排序。<br> 拓扑排序步骤：</li>
<li>从DAG图中选择一个 没有前缀(即入度为0)的顶点并输出</li>
<li>从图中删除该顶点和所有以它为起点的有向边</li>
<li>重复1和2直到当前的DAG图为空或当前图中不存在无前缀的顶点为止。后一种情况说明有向图中必然存在环。</li>
</ul>
<h4 id="2-4-6-leetcode题目"><a href="#2-4-6-leetcode题目" class="headerlink" title="2.4.6 leetcode题目"></a>2.4.6 leetcode题目</h4><ul>
<li>判断二分图</li>
<li>克隆图</li>
<li>找到小镇的法官</li>
<li>钥匙和房间</li>
<li>最短路径访问所有节点</li>
</ul>
<br>

<h2 id="3-常见算法"><a href="#3-常见算法" class="headerlink" title="3 常见算法"></a>3 常见算法</h2><h3 id="3-1-递归思想"><a href="#3-1-递归思想" class="headerlink" title="3.1 递归思想"></a>3.1 递归思想</h3><h4 id="3-1-1-递归思想"><a href="#3-1-1-递归思想" class="headerlink" title="3.1.1 递归思想"></a>3.1.1 递归思想</h4><p> 递归思想是:将大问题分解为小问题来求解,然后再将小问题分解为更小的问题.逐层分解,直到问题规模被分解到可以直接计算结果.<br> 如果把一层一层分解过程画成图,它其实就是一棵树,称为递归树.</p>
<!--more-->

<p> 斐波那契数列</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (N &lt; = <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fib(N<span class="number">-1</span>) + fib(N<span class="number">-2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> 递归的过程中,符合<strong>后进先出</strong>规则,所以用一个堆栈的数据结构.函数递归过程中会自动产生栈帧,当函数栈帧的深度越来越大,栈也也越来越大,如果递归没有终止条件,则会爆栈.递归算法第一步要思考的就是<strong>递归终止条件</strong>.<br> 递归思想的两个延申算法:分治算法和动态规划.<br> 递归的一般结构:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (符合边界条件) {</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ..;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 某种形式的调用</span></span><br><span class="line">    func();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> 阶乘函数:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>参考链接:<a href="https://www.jianshu.com/p/b2d2edb4ba5b">https://www.jianshu.com/p/b2d2edb4ba5b</a></li>
</ul>
<h4 id="3-1-2-递归基本步骤"><a href="#3-1-2-递归基本步骤" class="headerlink" title="3.1.2 递归基本步骤:"></a>3.1.2 递归基本步骤:</h4><p>  1.定义一个函数,明确函数功能<br>  2.寻找问题与子问题之间的关系(递推公式)<br>  3.将递推公式在定义的函数中实现<br>  4.推导时间复杂度,判定是否可以接受,无法接受更换算法.</p>
<h4 id="3-1-3-代表题目"><a href="#3-1-3-代表题目" class="headerlink" title="3.1.3 代表题目"></a>3.1.3 代表题目</h4><ul>
<li>爬楼梯 70</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> *mem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> mem[n] = {};</span><br><span class="line">    <span class="keyword">return</span> climb(n, mem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climb</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *mem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mem[n] &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> mem[n];</span><br><span class="line">    }</span><br><span class="line">    mem[<span class="number">0</span>] = climb(n<span class="number">-1</span>, mem) + climb(n<span class="number">-2</span>, mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>青蛙跳台阶 10-II</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> num[n+<span class="number">1</span>] = {<span class="number">-1</span>};</span><br><span class="line">    <span class="keyword">return</span> jump(n, num);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (num[n] != <span class="number">-1</span>) {</span><br><span class="line">        <span class="keyword">return</span> num[n];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    num[n] = (jump(n<span class="number">-1</span>, num) + jump(n<span class="number">-2</span>, num) % <span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> num[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-1-4-触类旁通"><a href="#3-1-4-触类旁通" class="headerlink" title="3.1.4 触类旁通"></a>3.1.4 触类旁通</h4><ul>
<li>反转二叉树 226<br> 1).对于根节点<code>1</code>来说,假设<code>2,3</code>节点下的节点都已经翻转,那么只要翻转<code>2,2</code>节点即满足需求.<br> 2).对于<code>2,3</code>节点来说,也是翻转其左右节点即可.<br> 依此类推,对每一个节点,依次翻转其左右节点,所以我们可知问题与子问题的关系是翻转(根节点) = 翻转(根节点的左节点) + 翻转(根节点的右节点),即<blockquote>
<p>invert(root) = invert(root-&gt;left) + invert(root-&gt;right)<br> 加号是追加到root上的意思</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">invertTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TreeNode *left = (struct TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    TreeNode *right = (struct TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    left = invertTree(root.left);</span><br><span class="line">    rgith = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>路径总和 112<br> 给定一个二叉树和一个目标和,判断该树中是否存在根节点到叶子节点的路径,这条路径上所有节点值相加等于目标和.</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">NULL</span> &amp;&amp; root.right == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> root.data == sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> remain = sum - root.data;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, remain) || hashPashSum(root.right, remain);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>细胞分裂</p>
</li>
</ul>
<p><a href="https://www.jianshu.com/p/b2d2edb4ba5b">https://www.jianshu.com/p/b2d2edb4ba5b</a></p>
<h3 id="3-2-分治法"><a href="#3-2-分治法" class="headerlink" title="3.2 分治法"></a>3.2 分治法</h3><p> 把复杂问题分成两个或者更多相同或相似的子问题，再把子问题分成更小的子问题…，直到可以直接求解，原问题的解为子问题解的合并。<br> 分治法应用：排序算法(快速排序、归并排序);傅里叶变换()。</p>
<h4 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h4><p> 分治法思想:将一个难以直接解决的大问题,分割成一些规模小的相同问题,分而治之.</p>
<p> 分治法:把一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题…,直到最后子问题可以简单的直接求解,原问题的解即子问题的解的<strong>合并</strong>.分治法思想:排序(快速排序,归并排序),傅里叶变换(快速傅里叶变换<br> 1):数学归纳是使用分治思想.<br> 2):分治思想不一定使用递归结构.<br> 递归结构是循环结构的一种,也是分治思想应用最多的一种程序结构,但不一定使用它.分治法的核心是<strong>如何分</strong></p>
<h4 id="3-2-2-策略"><a href="#3-2-2-策略" class="headerlink" title="3.2.2 策略"></a>3.2.2 策略</h4><p> 分治策略:对于一个规模为n的问题,若该问题可以容易解决则直接解决,否则将其分解为k个规模较小的子问题,子问题之间相互独立且与原问题形式相同,可递归求解.分治通常用递归实现.</p>
<h4 id="3-2-3-应用场景"><a href="#3-2-3-应用场景" class="headerlink" title="3.2.3 应用场景"></a>3.2.3 应用场景</h4><p> 分治法特征:</p>
<ul>
<li>问题缩小到一定程度可容易解决.</li>
<li>问题可分解为若干个规模较小的相同问题,即问题具有最优子结构性质.</li>
<li>子问题的解可合并为该问题的解.</li>
<li>问题分解的子问题相互独立,子问题之间不包含公告子问题.</li>
</ul>
<h4 id="3-2-4-步骤"><a href="#3-2-4-步骤" class="headerlink" title="3.2.4 步骤"></a>3.2.4 步骤</h4><p> 分治法一层递归步骤:</p>
<ul>
<li><ol>
<li><strong>分解</strong>:将原问题分解为若干规模较小,相互独立,与原问题形式相同的子问题.</li>
</ol>
</li>
<li><ol start="2">
<li><strong>解决</strong>:若子问题可直接求解,则直接求解,否则递归解各个子问题.</li>
</ol>
</li>
<li><ol start="3">
<li><strong>合并</strong>:将各个子问题的解合并为原问题的解.</li>
</ol>
</li>
</ul>
<p> </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<br>

<h4 id="3-2-5-应用"><a href="#3-2-5-应用" class="headerlink" title="3.2.5 应用"></a>3.2.5 应用</h4><blockquote>
<p>分治思维方式：二分搜索;大整数乘法;合并排序;快速排序。</p>
</blockquote>
<p> 求x的n次幂<br> 对数复杂度O(logn)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">        result = power(x, n/<span class="number">2</span>) * power(x, n / <span class="number">2</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        result = power(x, (n + <span class="number">1</span>) / <span class="number">2</span>) * power(x, (n - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-2-6-leetcode题目"><a href="#3-2-6-leetcode题目" class="headerlink" title="3.2.6 leetcode题目"></a>3.2.6 leetcode题目</h4><ul>
<li>搜索二维矩阵II</li>
<li>求众数</li>
<li>合并k个排序链表</li>
</ul>
<h3 id="3-3-排序算法"><a href="#3-3-排序算法" class="headerlink" title="3.3 排序算法"></a>3.3 排序算法</h3><p> 各种排序算法，主要包括：插入排序、快速排序、归并排序、计数排序和技术排序。二分查找，</p>
<h4 id="3-3-1-冒泡排序"><a href="#3-3-1-冒泡排序" class="headerlink" title="3.3.1 冒泡排序"></a>3.3.1 冒泡排序</h4><p> 重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。<br> <strong>冒泡排序算法复杂度是O(n^2)</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> out = size - <span class="number">1</span>; out &gt; <span class="number">0</span>; out--) {</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> in = <span class="number">0</span>; in &lt; out; in++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[in] &gt; arr[in + <span class="number">1</span>]) {</span><br><span class="line">                swap(arr, in, in + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a,b) \</span></span><br><span class="line"><span class="meta">do{\</span></span><br><span class="line"><span class="meta">    (a) ^= (b);\</span></span><br><span class="line"><span class="meta">    (b) ^= (a);\</span></span><br><span class="line"><span class="meta">    (a) ^= (b);\</span></span><br><span class="line"><span class="meta">}while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*冒泡排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> swap_flg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {<span class="comment">/*排序的趟数*/</span> </span><br><span class="line">        swap_flg = <span class="number">0</span>;<span class="comment">/*每次设置交换标识为0*/</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) {          <span class="comment">/*本趟排序的遍历元素个数*/</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) {</span><br><span class="line">                SWAP(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">                swap_flg = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/*本趟数，无数据交换的话，说明已经有序，直接退出*/</span></span><br><span class="line">        <span class="keyword">if</span> (swap_flg == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">//整数或浮点数皆可使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i, j; T temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) {</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-2-选择排序"><a href="#3-3-2-选择排序" class="headerlink" title="3.3.2 选择排序"></a>3.3.2 选择排序</h4><p> 选择排序算法时间复杂度为O(n^2)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> size = arr.lenght;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> out = <span class="number">0</span>; out &lt; size; out++) {</span><br><span class="line">        <span class="keyword">int</span> mixIndex = out;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> in = out - <span class="number">1</span>; in &lt; size; in++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[mixIndex] &gt; arr[in]) {</span><br><span class="line">                mixIndex = in;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mixIndex != out) {</span><br><span class="line">            swap(arr, mixIndex, out);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选择排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)  {</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; size; j++) {</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min]) {</span><br><span class="line">                min = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min != i) {</span><br><span class="line">            SWAP(a[i],a[min]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-3-插入排序"><a href="#3-3-3-插入排序" class="headerlink" title="3.3.3 插入排序"></a>3.3.3 插入排序</h4><p> 插入排序每次从无序数据集合中取出一个元素，插入到已经排好序的数据集中适当位置，使数据集仍然有序。插入排序不需要额外空间。时间复杂度O(n2)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> size = arr.lenght;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> out = <span class="number">1</span>; out &lt; size; out++) {</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[out];</span><br><span class="line">        <span class="keyword">int</span> in = out;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">while</span> (in - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[in - <span class="number">1</span>] &gt; temp) {</span><br><span class="line">            arr[in] = arr[in - <span class="number">1</span>];</span><br><span class="line">            in--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (in != out) {</span><br><span class="line">            arr[in] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i ++)<span class="comment">/*需要插入的元素个数*/</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> key = a[i];<span class="comment">/*保存插入的元素数据*/</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/* i 之前的元素都是有序的，找到比key小的插入到他后面，</span></span><br><span class="line"><span class="comment">        * 比key大的，需要往后挪一个位置*/</span></span><br><span class="line">        <span class="keyword">while</span>((j &gt;= <span class="number">0</span>) &amp;&amp; (a[j] &gt; key)) {</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        a[j + <span class="number">1</span>] = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">issort</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">int</span> size, <span class="keyword">int</span> esize, <span class="keyword">int</span> (*compare)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> *a = data;</span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((key = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(esize)) == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; size; j++) {</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; compare(&amp;a[i * esize], key) &gt; <span class="number">0</span>) {</span><br><span class="line">            mamcpy(&amp;a[(i + <span class="number">1</span>) * esize], &amp;a[i * esize], esize);</span><br><span class="line">            i--;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;a[(i + <span class="number">1</span>) * esize], key, esize);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-3-4-希尔排序"><a href="#3-3-4-希尔排序" class="headerlink" title="3.3.4 希尔排序"></a>3.3.4 希尔排序</h4><p> 希尔排序时间复杂度O(n*(logn)^2)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> size = arr.lenght;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt;= size / <span class="number">3</span>) {</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (h &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> out = h; out &lt; size; out++) {</span><br><span class="line">            <span class="keyword">int</span> temp = arr[out];</span><br><span class="line">            <span class="keyword">int</span> in = out;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">while</span> (in - h &gt;= <span class="number">0</span> &amp;&amp; arr[in - h] &gt; temp) {</span><br><span class="line">                arr[in] = arr[in - h];</span><br><span class="line">                in = in - h;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (in != out) {</span><br><span class="line">                arr[in] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        h = (h - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-3-5-归并排序"><a href="#3-3-5-归并排序" class="headerlink" title="3.3.5 归并排序"></a>3.3.5 归并排序</h4><p> 归并排序是一种分支排序算法。归并排序需要额外存储空间来完成排序。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span>  x &lt; y ? x : y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> *a = arr;</span><br><span class="line">    <span class="keyword">int</span> *b = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> seg, start;</span><br><span class="line">    <span class="keyword">for</span> (seg = <span class="number">1</span>; seg &lt; len; seg += seg) {</span><br><span class="line">        <span class="keyword">for</span> (start )</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; size; idx++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%08d\n"</span>, arr[idx]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __merge(<span class="keyword">int</span> *arr, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> *tmp;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((r - p + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tmp)</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = p, j = q + <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= q &amp;&amp; j &lt;= r;) {</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt;= arr[j])</span><br><span class="line">    tmp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    tmp[k++] = arr[j++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == q + <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= r;)</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= q;)</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(arr + p, tmp, (r - p + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __merge_sort(<span class="keyword">int</span> *arr, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    q = (p + r) / <span class="number">2</span>;</span><br><span class="line">    __merge_sort(arr, p, q);</span><br><span class="line">    __merge_sort(arr, q + <span class="number">1</span>, r);</span><br><span class="line">    __merge(arr, p, q, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __merge_sort(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_verify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> test[<span class="number">10</span>] = {<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">67</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>};</span><br><span class="line"></span><br><span class="line">    __merge(test, <span class="number">0</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    dump(test, <span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> test[<span class="number">10</span>] = {<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">67</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>};</span><br><span class="line"></span><br><span class="line">    merge_sort(test, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    dump(test, <span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//merge_verify();</span></span><br><span class="line">    merge_sort_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-3-6-快速排序"><a href="#3-3-6-快速排序" class="headerlink" title="3.3.6 快速排序"></a>3.3.6 快速排序</h4><p> 快速排序是一种分治排序算法。不需要额外存储空间，时间复杂度O(nlgn)</p>
<p> 快速排序三个步骤：</p>
<ul>
<li>分：设定一个分割值并将数据分为两部分。</li>
<li>治：分别在两部分使用递归方式继续使用快速排序方法。</li>
<li>和：对分割部分排序直至完成。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Range</span> {</span></span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">} Range;</span><br><span class="line"></span><br><span class="line"><span class="function">Range <span class="title">now_Range</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Range r;</span><br><span class="line">    r.start = s;</span><br><span class="line">    r.end = e;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = new_Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid = arr[(range.start + range.end) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = range.start;</span><br><span class="line">        <span class="keyword">int</span> right = range.end;</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid) {</span><br><span class="line">                ++left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; mid) {</span><br><span class="line">                --right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) {</span><br><span class="line">                swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; right) {</span><br><span class="line">            r[p++] = new_Range(range.start, right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (range.end &gt; left) {</span><br><span class="line">            r[p++] = new_Range(left, range.end);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) {</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high;</span><br><span class="line">        <span class="keyword">int</span> k = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="comment">// 从右向左找第一个小于k的数</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= k) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) {</span><br><span class="line">                arr[i++] = arr[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 从左向右找第一个大于等于k的数</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; k) {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) {</span><br><span class="line">                arr[j--] = arr[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        arr[i] = k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        QuickSort(arr, low, i - <span class="number">1</span>); <span class="comment">// 排序k左边</span></span><br><span class="line">        QuickSort(arr, i + <span class="number">1</span>, high); <span class="comment">// 排序k右边</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">( <span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, p, tmp;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    p = a[n / <span class="number">2</span>];   <span class="comment">// Get the middle element as pivot ..</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>, j = n <span class="number">-1</span>;; i++, j--) {</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt; p)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; a[j])</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> ( i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        tmp = a[i]; a[i] = a[j]; a[j] = tmp;    <span class="comment">//swap both ..</span></span><br><span class="line">    }   </span><br><span class="line"></span><br><span class="line">    quick_sort( a, i); </span><br><span class="line">    quick_sort( a + i, n - i); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; size; idx++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%08d\n"</span>, arr[idx]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//int pivot = arr[r];</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    i = j = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; j &lt; r; j++) {</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[r]) {</span><br><span class="line">            <span class="keyword">if</span>(i != j) {</span><br><span class="line">                swap(arr + i, arr + j);</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    swap(arr + i, arr + r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __quick_sort(<span class="keyword">int</span> *arr, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    q = partition(arr, p, r);</span><br><span class="line">    __quick_sort(arr, p, q<span class="number">-1</span>);</span><br><span class="line">    __quick_sort(arr, q+<span class="number">1</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __quick_sort(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> test[<span class="number">10</span>] = {<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">67</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>};</span><br><span class="line"></span><br><span class="line">    quick_sort(test, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    dump(test, <span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    quick_sort_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> key = arr[low];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">/*从左向右找比key大的值*/</span></span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; key) {</span><br><span class="line">            <span class="keyword">if</span> (i == high) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*从右向左找比key小的值*/</span></span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; key)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (j == low) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/*交换i,j对应的值*/</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*中枢值与j对应值交换*/</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[low];</span><br><span class="line">    arr[low] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">    <span class="built_in">Qsort</span>(arr, low, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Qsort</span>(arr, j + <span class="number">1</span>, high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>qsort/sort函数</strong><br> 在c语言库函数中已经实现了qsort函数,<br> qsort函数用法:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">int</span> nelem, <span class="keyword">int</span> width, <span class="keyword">int</span> (*fcmp)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="comment">// 参数:1 带排序数组首地址, nelem 数组中待排元素数量  width 各元素所在空间大小  *fcmp 指向函数的指针</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// int 数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">}</span><br><span class="line">qsort(arr, n, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// char 数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">com</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">char</span> *)a - *(<span class="keyword">char</span> *)b;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">char</span> word[<span class="number">100</span>];</span><br><span class="line">qsort(word, <span class="number">100</span>, <span class="keyword">sizeof</span>(word[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// double 类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">double</span> *)a &gt; *(<span class="keyword">double</span>*)b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">double</span> in[<span class="number">100</span>];</span><br><span class="line">qsort(in, <span class="number">100</span>, <span class="keyword">sizeof</span>(in[<span class="number">00</span>]), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sample</span> {</span></span><br><span class="line">    <span class="keyword">double</span> data;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">}st[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (*(Sample *)a).data &gt; (*(Sampel *)b).data ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">qsort(s, <span class="number">100</span>, <span class="keyword">sizeof</span>(s[<span class="number">0</span>]), cmp);</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Sample</span> *<span class="title">c</span> =</span> (Sample *)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Sample</span> *<span class="title">d</span> =</span> (Sample *)b;</span><br><span class="line">    <span class="keyword">if</span>(c-&gt;x != d-&gt;x) {</span><br><span class="line">        <span class="keyword">return</span> c-&gt;x - d-&gt;x;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> d-&gt;y - c-&gt;y;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">qsort(s,<span class="number">100</span>,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),cmp);</span><br><span class="line"></span><br><span class="line">truct Sample</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">}s[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照结构体中字符串str的字典顺序排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>((*(Sample *)a)-&gt;str , (*(Sample *)b)-&gt;str);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">qsort(s,<span class="number">100</span>,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),cmp);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-3-7-堆排序"><a href="#3-3-7-堆排序" class="headerlink" title="3.3.7 堆排序"></a>3.3.7 堆排序</h4><p> 桶排序算法基本原理：把数组中的所有元素分为若干个数据块，也就是若干个桶，然后对每个桶里的数据进行排序，最后将所有桶里的数据依次排列。<br> 存在两个问题：<br> (1)怎样划分数据块，也就是分几个桶，每个桶放哪几个数据。<br> (2)对每个数据块里的数据怎样排序。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sdtio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">} KeyNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> keys[], <span class="keyword">int</span> size, <span class="keyword">int</span> bucket_size)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    KeyNode **bucket_table = (KeyNode **)mallov(bucket_size * <span class="keyword">sizeof</span>(KeyNode*));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; bucket_size;i++) {</span><br><span class="line">        bucket_table[i] = (KeyNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(KeyNode));</span><br><span class="line">        bucket_table[i]-&gt;key = <span class="number">0</span>;</span><br><span class="line">        bucket_table[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; size;j++) {</span><br><span class="line">        KeyNode *node = (KeyNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(KeyNode));</span><br><span class="line">        node-&gt;key = keys[j];</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> index = keys[j]/<span class="number">10</span>;</span><br><span class="line">        KeyNode *p = bucket_table[index];</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;key == <span class="number">0</span>) {</span><br><span class="line">            bucket_table[index]-&gt;next = node;</span><br><span class="line">            (bucket_table[index]-&gt;key)++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;key &lt;= node-&gt;key)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            node-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = node;</span><br><span class="line">            (bucket_table[index]-&gt;key)++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//print result</span></span><br><span class="line">    KeyNode * k = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; bucket_size;i++)</span><br><span class="line">    <span class="keyword">for</span>(k = bucket_table[i]-&gt;next;k!=<span class="literal">NULL</span>;k=k-&gt;next)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,k-&gt;key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> raw[] = {<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>};</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(raw)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    bucket_sort(raw,size,<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapify</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> lef_child = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right_child = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> max = i;</span><br><span class="line">    <span class="keyword">if</span> (lef_child &lt; size &amp;&amp; A[lef_child] &gt; A[max]) {</span><br><span class="line">        max = lef_child;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (right_child &lt; size &amp;&amp; A[right_child] &gt; A[max]) {</span><br><span class="line">        max = right_child;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (max != i) {</span><br><span class="line">        Swap(A, i max);</span><br><span class="line">        Heapify(A, max, size);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> heap_size = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heap_size / w - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        Heapify(A, i, heap_size);</span><br><span class="line">        <span class="keyword">return</span> heap_size;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> heap_size = BuildHeap(A, n);</span><br><span class="line">    <span class="keyword">while</span> (heap_size &gt; <span class="number">1</span>) {</span><br><span class="line">        Swap(A, <span class="number">0</span>, heap_size);</span><br><span class="line">        Heap(A, <span class="number">0</span>, heap_size);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-8-leetcode排序"><a href="#3-3-8-leetcode排序" class="headerlink" title="3.3.8 leetcode排序"></a>3.3.8 leetcode排序</h4><h3 id="3-4-贪心算法"><a href="#3-4-贪心算法" class="headerlink" title="3.4 贪心算法"></a>3.4 贪心算法</h3><h4 id="3-4-1-基本概念"><a href="#3-4-1-基本概念" class="headerlink" title="3.4.1 基本概念"></a>3.4.1 基本概念</h4><p> 贪心算法:在对问题求解时,总是做出在当前是最好的选择,即不考虑整体最优,仅考虑局部最优解.<br> 贪心算法没有固定算法框架,算法关键是贪心策略的选择.他想算法不是所有问题都得到最优解,选择贪心策略必须具备无后效性,即某个状态以后的过程不会影响一起的状态,只与当前状态有关.</p>
<h4 id="3-4-2-描述"><a href="#3-4-2-描述" class="headerlink" title="3.4.2 描述"></a>3.4.2 描述</h4><p> 贪心算法实现步骤:<br> 1.建立数学模型描述问题<br> 2.把求解的问题分成若干个子问题<br> 3.对每个子问题求解,得到子问题的局部最优解<br> 4.把子问题的解局部最优解合成原来问题的一个解.<br> 实现算法过程:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (能朝给定总目标前进一步)</span><br><span class="line">{</span><br><span class="line">    利用可行的决策,求出可行解的一个解元素;</span><br><span class="line">}</span><br><span class="line">由所有解元素组合成问题的一个可行解</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-4-3-应用"><a href="#3-4-3-应用" class="headerlink" title="3.4.3 应用"></a>3.4.3 应用</h4><p><strong>最小生成树算法</strong><br> 贪心算法经典实践:最小生成树算法<br> 设<code>G=(V, E)</code>是无向连通带权图,即一个网络,E中的每一条边<code>(v,w)</code> 的全为 <code>c[v][w]</code>.如果G的字体 G’ 是一颗包含 G 的所有顶点的数,则称 G’ 为 G 的生成树.生成树上各边权的总和称为生成树的耗费.在 G 的所有生成树中,耗费最小的生成树称为 G 的最小生成树.<br> 最小生成树的性质:<br>  设<code>G=(V, E)</code>是连通带权图, U是V的真子集.如果(u,v)属于E,且u属于E,v属于V-U,且在所有这样的边中,(u,v)的权c[u][v]最小,那么一定存在G的一颗最小生成树,它亦是(u,v)为其中一条边,这个性质有时也称为MST性质.</p>
<p><strong>Prim算法</strong><br>  设<code>G=(V, E)</code>是连通带权图, V={1,2,…,n}.构造G的最小生成树Prim算法的基本思想是:**首先置S={1},然后,只有S是V的真子集,就进行如下的贪心选择:选取满足添加i属于S,j属于V-S,且c[i][j]最小的边,将顶点j添加到S中.这个过程一直进行到S=V时为止.在这个过程中选取到的所有边恰好构成G的一颗最小生成树.</p>
<h4 id="3-4-4-leetcode题目"><a href="#3-4-4-leetcode题目" class="headerlink" title="3.4.4 leetcode题目"></a>3.4.4 leetcode题目</h4><ul>
<li>柠檬水找零</li>
<li>分发饼干</li>
</ul>
<h3 id="3-5-动态规划"><a href="#3-5-动态规划" class="headerlink" title="3.5 动态规划"></a>3.5 动态规划</h3><p> 动态规划(<code>DP</code>):是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.常用于重叠子问题和最优子结构性质的问题,动态规划时间通常远小于朴素解法.</p>
<h4 id="3-5-1-基本概念"><a href="#3-5-1-基本概念" class="headerlink" title="3.5.1 基本概念"></a>3.5.1 基本概念</h4><p> 动态规划:要解一个给定问题,需要解其不同部分(即子问题),再根据子问题的解以得出原问题的解.通常子问题非常相似,子问题解算出后,将其记录.<br> 动态规划过程是:每次决策依赖于当前状态,又随即引起状态转移.一个决策序列就是在变化的状态中产生除留的,这种多阶段最优化决策解决过程称为动态规划.<br> 动态规划与分治法的区别是子问题通常不是独立的.</p>
<h4 id="3-5-2-描述算法"><a href="#3-5-2-描述算法" class="headerlink" title="3.5.2 描述算法"></a>3.5.2 描述算法</h4><p> 可采用动态规划的问题3个性质:<br> 1) <strong>最优化原理</strong>:如果问题的最优解所包含的子问题的解也是最优的,则称该问题具有最优子结构,即满足最优化原理.<br> 2) <strong>无后效性</strong>:即某阶段状态确定后,就不受之后的决策影响,即某状态以后过程不影响以前的状态,只与当前状态有关.<br> 3) <strong>有重叠子问题</strong>:</p>
<br>
 动态规划所处理的问题是一个多阶段决策问题,由初始状态开始,通过中间阶段决策的选择,达到结束状态.形成一个决策序列.

<p> 动态规划求解三要素:</p>
<blockquote>
<p>(1) 问题的节点<br>(2) 每个阶段的状态<br>(3) 从前一个阶段转化到后一个阶段之间的递推关系</p>
</blockquote>
<p> <strong>最优决策表</strong></p>
<blockquote>
<p>f(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}</p>
</blockquote>
<h4 id="3-5-3-背包问题"><a href="#3-5-3-背包问题" class="headerlink" title="3.5.3 背包问题"></a>3.5.3 背包问题</h4><p> 问题描述:<br> 有N件物品和一个体积为V的背包.(每种物品只有一件)第i件物品的体积是volume[i],价值是value[i],求解哪些物品装入背包可使这些物品的体积综合不超过背包体积,且价值总和最大.<br> 解题思路:<br> p[i][j]代表前i件物品组合在容量为j的背包的最优解.将前i件物品放入容量为v的背包中这个子问题,若只考虑第i件物品的策略(放或不放),那么可以转化为一个只牵扯前i-1物品的问题.如果不放第i件物品,那么问题就转化为”前i-1件物品放入容量为v的背包中,价值为p[i-1][v];如果放第i件物品,那么问题就转化为”前i-1物品放入剩下的容量为v-volume[i]的背包中”,此时能获得的最大价值就是p[i-1][j-volume]再加上通过放入第i件物品获得的价值value[i].</p>
<p> <strong>状态转移方程:</strong></p>
<blockquote>
<p>p[i][j] = max{p[i-1][j-vol] + value[i], p[i-1][j]}<br> 伪代码描述:</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1.</span>..N</span><br><span class="line">    <span class="keyword">for</span> j = V..<span class="number">.0</span></span><br><span class="line">        p[j] = max{p[j-volume[i]] + value[i], p[j]};</span><br></pre></td></tr></tbody></table></figure>


<h4 id="3-5-4-最长公共子序列"><a href="#3-5-4-最长公共子序列" class="headerlink" title="3.5.4 最长公共子序列"></a>3.5.4 最长公共子序列</h4><p> 问题描述:<br> 一个散列S,如果分别是两个或多个已知数列的子序列,且是所有匹配此条件序列中最长的,则S称为已知序列的最长公共子序列(LCS)<br> 给定两个序列X,Y,求两个序列的最长公共子序列.<br> 截图思路:<br> </p>
<p> 伪代码:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">LCSLength</span><span class="params">(X[<span class="number">1.</span>.m], Y[<span class="number">1.</span>.n])</span></span></span><br><span class="line"><span class="function">    C </span>= <span class="built_in">array</span>(<span class="number">0.</span>.m, <span class="number">0.</span>.n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0.</span>.m</span><br><span class="line">        C[i, <span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0.</span>.n</span><br><span class="line">        C[<span class="number">0</span>, j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1.</span>.m</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1.</span>.n</span><br><span class="line">            <span class="keyword">if</span> X[i] = Y[j]</span><br><span class="line">                C[i, j] := C[i<span class="number">-1</span>, j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i, j] := max(C[i, j<span class="number">-1</span>], C[i<span class="number">-1</span>,j])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C[m, n]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-5-5-leetcode题目"><a href="#3-5-5-leetcode题目" class="headerlink" title="3.5.5 leetcode题目"></a>3.5.5 leetcode题目</h4><ul>
<li>最大子序和</li>
<li>编辑距离</li>
<li>大礼包</li>
<li>最长上升子序列</li>
</ul>
<h3 id="3-6-回溯法"><a href="#3-6-回溯法" class="headerlink" title="3.6 回溯法"></a>3.6 回溯法</h3><h4 id="3-6-1-基本概念"><a href="#3-6-1-基本概念" class="headerlink" title="3.6.1 基本概念"></a>3.6.1 基本概念</h4><p> 回溯算法实际上一个类似枚举的搜索尝试过程,主要是在<strong>搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就”回溯”返回,尝试别的路径</strong>.<br> 回溯法是一种迭代搜索法,按选优条件详情搜索,以达到目标.但当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择,这种走不通就退回再走的技术为回溯法,而满足回溯条件的某个状态的点称为”回溯法”.<br> 许多复杂度,规模较大的问题都看看而已使用回溯法,有”同意解题方法”的美称.</p>
<p> 在包含问题的所有解的解空间树中,按照深度优先的策略,从根节点出发深度探索解空间树.当探索到某一节点时,要先判断该节点是否包含问题的解,如果包含,就从该节点出发继续探索下去,如果该节点不包含问题的解,则逐层向其足协节点回溯.(其实回溯法就是堆隐式图的深度优先搜索算法).<br> 若用回溯法求问题的所有解时,要回溯的根,且根节点的所有可行的子树都要已被搜索遍才结束,而若使用回溯法求任一个解时,只要搜索到问题的一个解就可以结束.<br> 回溯法一般解题步骤:<br> 1.<strong>针对所给问题,确定问题的解空间</strong>;首先应明确定义问题的解空间,解空间应至少包含问题的一个(最优)解.<br> 2.<strong>确定节点的扩展搜索规则</strong><br> 3.<strong>以深度优先方式搜索解空间,并在搜索过程中用剪枝函数避免无效搜索</strong></p>
<p> 伪代码:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iterativeBacktrack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (f(n, t) &lt;= g(n, t)) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = f(n,t); i &lt;= g(n,t); i++) {</span><br><span class="line">                x[t] = h(i);</span><br><span class="line">                <span class="keyword">if</span> (constraint(t) &amp;&amp; bound(t)) {</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span> (solution(t)) {</span><br><span class="line">                        output(x);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        t++;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    t--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-6-2-八皇后问题"><a href="#3-6-2-八皇后问题" class="headerlink" title="3.6.2 八皇后问题"></a>3.6.2 八皇后问题</h4><p> 问题描述<br> 八皇后问题使一个以国际象棋为背景的问题:如何能够在 8<em>8 的国际象棋棋盘上放着八个皇后,使得任何一个皇后都无法直接吃掉其他的皇后?为了达到此目的,任两个皇后都不能处于同一条横行,纵行或斜线上.<br> 转化规则:其实八皇后问题可以推广为更一般的n皇后摆放问题;这时棋盘大小变为n</em>n,而皇后个数也变成n.当且仅当n = 1 或 n &gt;= 4 时间问题有解.</p>
<p> 伪代码描述</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queens</span><span class="params">(<span class="keyword">int</span> Queens)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-6-3-leetcode题目"><a href="#3-6-3-leetcode题目" class="headerlink" title="3.6.3 leetcode题目"></a>3.6.3 leetcode题目</h4><ul>
<li>N皇后</li>
<li>括号生成</li>
<li>单词搜索</li>
<li>解数独</li>
</ul>
<h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4 参考链接"></a>4 参考链接</h2><ul>
<li>复杂度速查表<br><a href="https://liam.page/2016/06/20/big-O-cheat-sheet/">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></li>
<li>线性表<br><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8</a><ul>
<li>单链表<br><a href="https://www.jianshu.com/p/73f0d8f807aa">https://www.jianshu.com/p/73f0d8f807aa</a></li>
</ul>
</li>
</ul>
<p><a href="http://cocofe.cn/">http://cocofe.cn/</a></p>
<ul>
<li>数据结构<br><a href="https://github.com/wangzheng0822/algo/">https://github.com/wangzheng0822/algo/</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>实用教程</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法指一</title>
    <url>/2021/12/02/2021/12/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E4%B8%80/</url>
    <content><![CDATA[<h2 id="一-简单句子分析"><a href="#一-简单句子分析" class="headerlink" title="一.简单句子分析"></a>一.简单句子分析</h2><p> <strong>英语句子= 主干+修饰成分</strong><br> 分析句子结构:<br>  一个中心 + 两个要点<br>  一个中心: 动词. 句子必须右动词<br>  两个要点: 主语 + 谓语. 谓语是动词,主语为动作的执行者或接受者.<br>  <strong>句子的核心是主谓结构</strong></p>
<span id="more"></span>
<p> n个主语+1个谓语 或者 1个主语+n个谓语，就可以组成简单句。其他的定状补语等都是句子的附属成分。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。</p>
<p> 英语的句子结构分为三种:简单句,并列句,复合句.简单句又分为五种基本句型.</p>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>英文句子<ul>
<li>简单句<ul>
<li>主 + 谓</li>
<li>主 + 谓 + 宾</li>
<li>主 + 谓 + 宾 + 宾补</li>
<li>主 + 谓 + 间宾 + 直宾</li>
<li>主 + 系 + 表</li>
</ul>
</li>
<li>复合句<ul>
<li>名词性从句<ul>
<li>主语从句</li>
<li>宾语从句</li>
<li>同位语从句</li>
<li>表语从句</li>
</ul>
</li>
<li>定语从句</li>
<li>状语从句<ul>
<li>时间状语从句</li>
<li>地点状语从句</li>
<li>条件状语从句</li>
<li>结果状语从句</li>
<li>让步状语从句</li>
<li>目的状语从句</li>
</ul>
</li>
</ul>
</li>
<li>特殊句式<ul>
<li>强调句</li>
<li>虚拟语气</li>
<li>倒装句</li>
</ul>
</li>
<li>类型<ul>
<li>陈述句</li>
<li>祈使句</li>
<li>感叹句</li>
<li>疑问句</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<p> 英语语法从整体上来讲是通过五部分来组成<br>  1、简单句<br>  2、并列句、复合句<br>  3、三大从句<br>  4、特殊句式<br>  5、类型</p>
<p>补语<br> 补语是和表意不完全的动词息息相关的。在第三种基本句型中，联系动词将主语和补语在某个意义层面上对等起来。<br> 修饰成分<br>  介词短语<br>  从句<br>  非谓语动词<br>  时间状语<br> 论主语的补语，而后将宾语的补语作为一种变形来讨论</p>
<h3 id="1-1-S-V-（主-谓）"><a href="#1-1-S-V-（主-谓）" class="headerlink" title="1.1 S + V （主+谓）"></a>1.1 S + V （主+谓）</h3><p> 句子不可或缺的两部分.<br> 名词/代词/不定式/动名词 + 动词<br> 谓语动词可以表达完整的意思，这类动词为不及物动词（vi）.</p>
<h3 id="1-2-S-V-C-（主-系-表）"><a href="#1-2-S-V-C-（主-系-表）" class="headerlink" title="1.2 S + V + C （主+系+表）"></a>1.2 S + V + C （主+系+表）</h3><p>主语 +系动词 +表语</p>
<p>表语说明主语的状态和性质，可以是名词，形容词，副词，短语等。</p>
<p>系动词包括：</p>
<p>a. be 动词，am, is, are, was, were;</p>
<p>b. 表感官：feel(摸起来像是), smell, sound(听起来是), taste(尝起来是), look(看起来是);</p>
<p>c. 表变化：become(成为), grow, turn(转变为), go, get, fall;</p>
<p>d. 表状态：remain(依旧是), keep, hold, stay(仍然是), seem(似乎是).</p>
<p>appear 显得像是<br>prove 证实为<br>become 成为<br>make 作为</p>
<h3 id="1-3-S-V-O-（主-谓-宾）"><a href="#1-3-S-V-O-（主-谓-宾）" class="headerlink" title="1.3 S + V + O （主+谓+宾）"></a>1.3 S + V + O （主+谓+宾）</h3><p>主语+谓语+宾语</p>
<p>谓语一般为及物动词（vt.），后面必须要跟宾语才能表达完整的意思。宾语是谓语动词动作的承受者。</p>
<h3 id="1-4-S-V-O-O（主-谓-间宾-人-直宾-物-）"><a href="#1-4-S-V-O-O（主-谓-间宾-人-直宾-物-）" class="headerlink" title="1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)）"></a>1.4 S + V + O + O（主+谓+间宾(人)+直宾(物)）</h3><p>谓语动词必须要跟两个宾语才能表达完整意思。两个宾语分别是动作的直接承受者（一般是物）和间接承受者（一般是人）。<br>e.g.,</p>
<p>give sb sth = give sth to sb</p>
<p>tell sb sth = tell sth to sb</p>
<h3 id="1-5-S-V-O-C（主-谓-宾-宾补）"><a href="#1-5-S-V-O-C（主-谓-宾-宾补）" class="headerlink" title="1.5 S + V + O + C（主+谓+宾+宾补）"></a>1.5 S + V + O + C（主+谓+宾+宾补）</h3><p>此种情况，动词虽然跟了宾语，但句子意思不完整，需要跟上一个补足语，对宾语进行解释说明，句子意思才能完整通顺。<br>主语的补语用来表示主语是什么。类似地，宾语的补语用来表示宾语是什么。在 S + V + O + C 这个句型当中，宾语和补语之间虽然没有动词存在。但是句子可以变形成：S + V + that + O + V + C 的形式，也就是将原本的宾语和补语以从句的形式出现。因此，可以认为宾语和补语之间有「隐藏的」判断动词「是」的存在。</p>
<p>There be 句型</p>
<p>There be 句型表示人/物的存在。句子结构，就是There be + 主语+其他部分</p>
<p>1.主语：句子所陈述的对象。<br>2.谓语：主语发出的动作。一般是有动作意义的动词。<br>3. 宾语：分为动词宾语和介词宾语，属于动作的承受者。<br>4. 系动词：表示状态或状态变化的动词，没有实际的动作意义。如 be, 感官系动词（look, sound, smell, taste 和 feel）、保持类系动词（keep, stay 和 remain）、状态变化类系动词（become、get、turn 和 go）等。<br>5. 表语：紧跟系动词后面的成分。<br>6. 定语：修饰名词或代词的成分。<br>7. 状语： 修饰形容词、副词、动词或句子的成分。<br>8. 补语：分为宾语补足语和主语补足语。是对宾语和主语的补充说明，与其有主动或被动的逻辑关系。</p>
<ul>
<li><p>参考链接:<br><a href="https://liam.page/2014/06/21/basic-sentence-and-the-complement/">https://liam.page/2014/06/21/basic-sentence-and-the-complement/</a><br><a href="https://www.zhihu.com/question/30030877/answer/768501967">https://www.zhihu.com/question/30030877/answer/768501967</a></p>
</li>
<li><p>参考数据<br>《语法俱乐部》</p>
</li>
</ul>
<p>复杂句:从简单句演化而来</p>
<p>简单句没有什么句序的调整，所以翻译起来基本没有什么难度。</p>
<p>英语中的修饰成分，分定语和状语两种情况。<br>英语句子 = 主干(五种基本句型) + 修饰成分(定语+状语)</p>
<h2 id="二、并列句、复合句"><a href="#二、并列句、复合句" class="headerlink" title="二、并列句、复合句"></a>二、并列句、复合句</h2><p>简单句通过不同的连接词就成为了不同的句子，通过并列词成了并列句，通过从属连词成了复合句。下面我们就一一讲解 ：</p>
<p>并列句：简单句+并列词+简单句</p>
<p>并列词一般有：and / or / but / so /while / yet / for / however</p>
<p>1）：表示并列：and, not only…but also… , neither…nor…</p>
<p>Her father is a doctor and her mother is a teacher .</p>
<p>2）：表示选择：or, or else, otherwise, either…or…</p>
<p>Hurry or you won’t make the train.</p>
<p>3）：表示对比、转折: but, while , yet , however , never ,</p>
<p>I like tea while she likes coffee .</p>
<p>4）：表示原因：for</p>
<p>I am thirsty , for it is hot .</p>
<p>复合句：简单句+从属连词+简单句</p>
<p>从属连词有：that / wether/ if</p>
<p>复合句其实就是我们常说的三大从句，</p>
<h2 id="三-三大从句"><a href="#三-三大从句" class="headerlink" title="三.三大从句"></a>三.三大从句</h2><p>1、名词性从句</p>
<p>当名词性从句作为句子的不同成分时，又被称呼为不同的名字。</p>
<p>当作为主语时，称为主语从句。</p>
<p>当称为宾语时，称为宾语从句，同样表语从句以及同位语从句。以下我们来举个栗子 ：</p>
<p>主语从句 What she said is wrong .</p>
<p>宾语从句 I said that she was wrong.</p>
<p>表语从句 The fact is that he doesn’t really try.</p>
<p>同位语从句 The news that he will come back is ture.</p>
<p>记住一点，不管什么从句，你把它当成一个”长一点的名词”。</p>
<p>那如果这个长名词在句子中作主语，就是主语从句，作宾语就是宾语从句。</p>
<p>同位语从句就是相当于一个长点的名词对另外一个抽象名词进行解释说明。</p>
<p>2、定语从句</p>
<p>修饰限定名词，汉语中“的”前面的内容。</p>
<p>关系代词引导的定语从句</p>
<p>1.who指人，在从句中做主语 Yesterday I helped an old man who lost his way.</p>
<p>2. whom指人，在定语从句中充当宾语，常可省略。</p>
<p>Mr. Ling is just the boy whom I want to see</p>
<p>3. which指物，在定语从句中做主语或者宾语，做宾语时可省略</p>
<p>This is the pen (which) he bought yesterday.</p>
<p>4. that指人时，相当于who 或者whom；指物时，相当于which。</p>
<p>5. whose通常指人，也可指物，在定语从句中做定语。</p>
<p>指的是谁的。Do you like the book whose cover is yellow?</p>
<p>关系副词引导的定语从句</p>
<p>when where why</p>
<p>3、状语从句</p>
<p>修饰动作的发生的时间、地点、原因、方式</p>
<p>九大状语从句</p>
<p>1、时间状语从句</p>
<p>常用引导词：when, as, while, as soon as, before, after, since , till, until</p>
<p>特殊引导词：the minute, the moment, the second, every time, the day，the instant,</p>
<p>I was fat when I was a child.</p>
<p>2、地点状语从句</p>
<p>常用引导词：where</p>
<p>特殊引导词：wherever, anywhere, everywhere</p>
<p>Keep it where you can see it.</p>
<p>3、原因状语从句</p>
<p>常用引导词：because, since, as, for</p>
<p>特殊引导词：seeing that, now that, in that, considering that, given that.</p>
<p>My friends dislike me because I’m beautiful .</p>
<p>4、目的状语从句</p>
<p>常用引导词：so that, in order that</p>
<p>特殊引导词：lest, in case, for fear that，in the hope that, for the purpose that, to the end that</p>
<p>study hard so that you can pass the exam.</p>
<p>5、结果状语从句</p>
<p>常用引导词：so … that, so… that, such … that,</p>
<p>特殊引导词：such that, to the degree that, to the extent that, to such a degree that,</p>
<p>He got up so early that he caught the first bus.</p>
<p>6、条件状语从句</p>
<p>常用引导词：if, unless,</p>
<p>特殊引导词：as/so long as, only if, providing/provided that, supposing that, in case that, on condition that</p>
<p>If you ask him, he will help you.</p>
<p>7、方式状语从句</p>
<p>常用引导词：as, as if, how</p>
<p>特殊引导词：the way</p>
<p>Think as i think</p>
<p>8、比较状语从句</p>
<p>常用引导词：as(同级比较), than(不同程度的比较)</p>
<p>特殊引导词：the more … the more … ; just as …， so…; A is to B what /as X is to Y; no … more than; not A so much as B</p>
<p>The house is three times as big as ours.</p>
<p>9、让步状语从句</p>
<p>常用引导词：though, although, even if, even though</p>
<p>特殊引导词： as(用在让步状语从句中必须要倒装)，while ( 一般用在句首 )，no matter …， in spite of the fact that, while, whatever, whoever, wherever, whenever, however, whichever</p>
<p>Though I believe it, yet I must consider.</p>
<h2 id="四-特殊句式"><a href="#四-特殊句式" class="headerlink" title="四.特殊句式"></a>四.特殊句式</h2><p>1、强调句</p>
<p>It is （名词 / 介宾）指的是被强调的内容that （……..）</p>
<p>It was she whom we are talking about.</p>
<p>2、倒装句</p>
<p>正常句序 ：主谓宾</p>
<p>倒装句序 ：谓主宾</p>
<p>we can win only through hard work .</p>
<p>only through hard work can we win .</p>
<p>3、虚拟语气，假设不可能发生的事情</p>
<p>1、对过去情况的虚拟</p>
<p>从句用 had done</p>
<p>主句用 would could might should have done</p>
<p>2、对现在情况的虚拟</p>
<p>从句用 did , was变成were</p>
<p>主句用 would could might should do</p>
<p>3、对将来情况虚拟</p>
<p>从句用 did ，was 变成 were，should do,were to do</p>
<p>主句用 would could might should do</p>
<h2 id="五-类型"><a href="#五-类型" class="headerlink" title="五.类型"></a>五.类型</h2><p>陈述句</p>
<p>i like English very much . 我非常喜欢英语。</p>
<p>疑问句</p>
<p>is this your key ? 这是你的钥匙吗？</p>
<p>祈使句</p>
<p>一种是以动词原形开头，在动词原形之前加do (但只限于省略第二人称主语的句子)。</p>
<p>mind you head 小心碰头！</p>
<p>第二种祈使句以let开头</p>
<p>Let’s have another try</p>
<p>感叹句</p>
<p>what a brave girl ! 真是个勇敢的女孩子</p>
<p><a href="https://zhuanlan.zhihu.com/p/400448345">https://zhuanlan.zhihu.com/p/400448345</a></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>study</category>
        <category>2021</category>
        <category>12</category>
      </categories>
      <tags>
        <tag>Another Tag</tag>
        <tag>English</tag>
      </tags>
  </entry>
</search>
