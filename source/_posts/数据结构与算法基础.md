---
title: 数据结构与算法基础
date: 2021-10-27 00:47:53
updated: 2021-10-27 00:53:53
password: liuz0000
abstract: 这是一篇加密博文，请输入密码后查看
message: 这里需要密码才能访问。
wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.
categories: 
    - tool
tags: 
    - 实用教程
    - Another Tag
---

## 1 程序性能

<!--more-->

&ensp;程序性能是指运行程序所需要的**内存大小(空间复杂度)和时间(时间复杂度)**,运行时间和占用空间是算法性能最关键的指标。
&ensp;软件程序性能衡量指标:
&emsp;响应时间、启动时间、执行时间、执行速度、计算资源分配、内存分配、磁盘吞吐量、网络吞吐量、负载承受能力


### 1.1 空间复杂度
&ensp;空间复杂度(Space complexity)，算法完全运行所需存储空间。表示算法的存储空间与数据规模之间的增长关系：常量空间、线性空间、二维空间。
&ensp;算法在计算机存储器上所占用的存储空间，包括**存储程序本身占用的存储空间，算法输入输出数据所占的存储空间和算法在运行过程中临时占用的存储空间**。


### 1.2 时间复杂度
&ensp;时间复杂度(Time complexity)，算法完全运行所需运算时间。时间复杂度通常用大O符合表示。

![20211027233029](https://i.loli.net/2021/10/27/UxWCvnRQLYz5eiG.png)

#### 1.2.1 常见算法大O
&emsp; 常量阶O(1); 对数阶O(logn); 线性阶O(n); 线性对数阶O(nlogn); k次方阶O(n^k)
![20211028010721](https://i.loli.net/2021/10/28/GWOFcUi3qdVIlmf.png)

#### 1.2.2 常见数据结构

{% pullquote mindmap mindmap-md %}
- 数据结构与算法
	- 线性表
		- 数组
        - 链表
            - 单链表
            - 双链表
            - 循环链表
            - 双向循环链表
            - 静态链表
		- 栈
            - 顺序栈
            - 链式栈
		- 队列
            - 普通队列
            - 双端队列
            - 阻塞队列
            - 并发队列
            - 阻塞并发队列
    - 散列表
        - 散列函数
        - 冲突解决
            - 链表法
            - 开放地址
            - 其他
        - 动态扩容
        - 位置
    - 树
        - 二叉树
            - 二叉查找树
            - 平衡二叉树
            - 平衡二叉查找树
                - AVL树
                - 红黑树
            - 完全二叉树
            - 满二叉树
        - 多路查找树
            - B树
            - B+树
            - 2-3树
            - 2-3-4树
        - 堆
            - 小顶堆
            - 大顶堆
            - 优先级队列
            - 斐波那契堆
            - 二项堆
        - 其他
            - 树状数组
            - 线段树
    - 图
        - 图的存储
            - 邻接矩阵
            - 邻接表
        - 拓扑排序
        - 最短路径
        - 关键路径
        - 最小生成树
        - 二分图
        - 最大流
    - 复杂度分析
        - 空间复杂度
        - 时间复杂度
    - 基本算法思想
        - 贪心算法
        - 分治法
        - 动态规划
        - 回溯法
        - 枚举法
    - 排序
        - O(n^2)
            - 冒泡排序
            - 插入排序
            - 选择排序
            - 希尔排序
        - O(nlogn)
            - 归并排序
            - 快速排序
            - 堆排序
        - O(n)
            - 计数排序
            - 基数排序
            - 桶排序
    - 搜索
        - 深度优先搜索
        - 广度优先搜索
        - A*启发式搜索
    - 查找
        - 线性表查找
        - 树结构查找
        - 散列表查找
    - 字符串匹配
        - 朴素
        - KMP
        - Robin-Karp
        - Boyer-Moore
        - AC自动机
        - Trie
        - 后缀数组
    - 其他
        - 数论
        - 计算几何
        - 概率分析
        - 并查集
        - 拓扑网络
        - 矩阵运算
        - 现在规划
{% endpullquote %}

### 本章参考：
- 复杂度速查表
https://liam.page/2016/06/20/big-O-cheat-sheet/

## 2 基本数据结构

基本数据结构:
&emsp;字符,字符串:char,string
&emsp;整型:short,int,long;unsigned
&emsp;浮点型:float,double
&emsp;结构体:struct
&emsp;枚举:enum
&emsp;联合体:union
&ensp;自定义数据结构
&emsp;线性表
&emsp;&ensp;数组:array
&emsp;&ensp;链表:数据域,指针域;单链表,循环链表,双链表
&emsp;&ensp;队列
&emsp;&ensp;栈
&emsp;&ensp;堆 

### 2.1 线性表
&ensp;线性表是n个具有相同特性的数据元素的有序序列。线性表除第一个和最后一个数据元素之外，其他数据元素都是首尾相接的。
&ensp;数据在实际的物理存储中有两种形式：分散存储和集中存储,常见数据结构有栈、队列、字符串、链表等。
&ensp;两种情况下数据的存储问题：
&emsp; 数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；
&emsp; 数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”

#### 2.1.1 数组
&emsp;数组是一批相同数据的集合。数组的三部分：地址 大小 和 空间。数组的保存形式为线性表。
```c
int arr[10]; // /[]内必须是常量/常量表达式(3+8)，不能是一个变量(x...)
// 数组初始化
int arr1[3] = {1, 2, 3};
char arr6[] = "abcdef";
// 指针
int *ptr = NULL;//定义一个整型的指针变量，初始化为NULL
char *ptr = NULL;//定义一个字符的指针变量，初始化为NULL
// 二维数组
int arr[3][5] = { 0 };
// C 传递数组给函数
// 
void myFunction(int *param)
void myFunction(int param[10])
void myFunction(int param[])
// C 从函数返回数组
int * myFunction()
{
...
}
```
<br>

**二分搜索**
&emsp;基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）
&emsp;二分搜索的时间复杂度为 ***对数时间O(logn)***
```c
int binary_search(int key, int a[], int n)
{
    int low = 0;
    int high = n - 1;
    int mid, count = 0, count1 = 0;

    while(low < high) {
        count++;
        mid = (low + high) / 2;
        if (key < a[mid]) {
            high = mid - 1;
        } else if (key > a[mid]) {
            low = mid + 1;
        } else if (key == a[mid]) {
            count1++;
            break;
        }
    }

    if (count1 == 0) {
        return 1;
    }

    return 0;
}
```

#### 2.1.2 单链表
&emsp; 单链表元素之间有一个单独的指针链接。这种结构的链表可以使得从第一个元素遍历到最后一个元素
```c
typedef struct ListElmt_ {
    void *data;  // 数据成员
    struct ListElmt_ * next; // next指针
} ListElmt;

typedef struct List_ {
    int size;
    int (*match)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    ListElmt *head;
    ListElmt *tail;
} List;
```
&emsp;单链表操作：插入、删除、
#### 2.1.3 双链表
&emsp; 双向链表的元素通过两个指针链接。双向链表可以正向遍历，也可反向遍历。
```c
typedef struct DListElmt_ {
    void *data;
    struct DListElmt_ *prev;
    struct DListElmt_ *next;
} DListElmt;

typedef struct DList_ {
    int size;
    int (*match)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    DListElmt *head;
    DListElmt *tail;
} DList;
```

#### 2.1.4 跳表
&emsp;跳表对标的是平衡树(AVL Tree), 插入/删除/搜索都是 O(logn)的数据结构。

#### 2.1.5 栈
&emsp;栈按照后进先出(LIFO)的顺序存储和检索数据的数据结构，检索元素的顺序和存储元素顺序相反。
&emsp;可通过链表来实现栈stack,允许插入和删除的为栈顶(`top`),另一端为栈底(`bottom`),栈中每个元素为`frame`,栈只支持三个操作:`pop`,`top`,`push`.
```c
typedef List Stack;

#define stack_init list_init;
int stack_push(Stack *stack, const void *data);
int stack_pop(Stack *stack, void **data);
#define stack_peek(stack) ((stack)->head == NULL ? NULL : (stack)->head->data);
#define stack_size list_size;
```
&emsp;c语言顺序栈
```c
// 元素elem进栈
int push(char *a, int top, char elem) {
    a[++top] = elem;
    return top;
}

// 数据元素出栈
int pop(char *a, int top)
{
    if (top == -1) {
        return -1;
    }

    top--;
    return top;
}
```

&emsp;链栈
```c
typedef struct lineStack {
    char data;
    struct lineStack *next;
}lineStack;

lineStack* push(lineStack * stack, char a){
    lineStack * line=(lineStack*)malloc(sizeof(lineStack));
    line->data=a;
    line->next=stack;
    stack=line;
    return stack;
}

lineStack * pop(lineStack * stack){
    if (stack) {
        lineStack * p=stack;
        stack=stack->next;
        printf("弹栈元素：%c ",p->data);
        if (stack) {
            printf("栈顶元素：%c\n",stack->data);
        }else{
            printf("栈已空\n");
        }
        free(p);
    }else{
        printf("栈内没有元素");
        return stack;
    }
    return stack;
}
```

#### 2.1.6 队列
&emsp;队列，在前端(`front`)进行删除操作，后端(`rear`)进行插入操作; 按照先进先出(`FIFO`)的顺序存储和检索数据的高效数据结构，按照元素的存储顺序检索元素。
&emsp;队列也可通过数组和链表实现。
```c
typedef List Queue;

#define queue_init list_init;
#define queue_destroy list_destroy;
int queue_enqueue(Queue *queue, const void *data);
int queue_dequeue(Queue *queue, void **data);
#define queue_peek(queue) ((queue)->head == NULL ? NULL : (queue)->head->data);
#define queue_size list_size;
```

&ensp;队列应用：进程通信
&emsp;消息队列提供了从一个进程向另一个进程发送一个数据块的方法.每个数据库都认为含有一个类型,接收进程可以独立地接收含有不同类型的数据结构.

&emsp;linux内核 <sys/msg.h> 头文件中定义了消息队列结构
```c
struct msqid_ds {
    struct ipc_perm msg_perm;
    struct msg* msg_first; // 指向队列中第一个消息
    struct msg* msg_last; // 队列中最后一个消息
    ...
}
```
&emsp;Linux消息队列函数接口
```c
// 创建和访问一个消息队列
int msgget(key_t key, int msgflg);
// 把消息添加到消息队列中
int msgsnd(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);
// 从一个消息对立获取消息
int msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg);
// 控制消息队列
int msgctl(int msgid, int command, struct msgid_ds *buf);
```

#### 2.1.7 leetcode题目
- 重复N次的元素<数组>

- 两数相加<链表>

- 基本计算器<栈>

- 设计循环队列<队列>

### 2.2 哈希表
&ensp;哈希表是一种最有效的检索方法，散列，从本质上看，一个哈希表包含一个数组，通过特殊的索引（键）来访问数组中的元素。哈希表主要思想是通过一个哈希函数，在所有可能的键和值直接建立映射表。
&ensp;每个记录的关键字k通过一种函数H(k)计算出函数值.此函数为哈希函数或散列函数.

#### 2.2.1 哈希函数设计
- 直接地址法
关键字是整数类型的数据,直接地址的哈希函数H直接利用关键字求得哈希地址.
H(k) = aK*i + b

- 数字分析法
取关键字数中分布均匀的若干作为哈希地址

- 平方取中法
取关键字平方中间几位作为散列地址

- 折叠法

- 除留取余法
关键字K除以一个合适的不大于哈希表长度的正整数P,所得余数作为哈希地址.
H(K) = K MOD P

#### 2.2.2 哈希冲突
&ensp;理想情况下,哈希函数在关键字和地址之间建立一对一关系.但H(k1) = H(k2),即为冲突.

&emsp;解决哈希冲突常用方法:
- 链地址法
将哈希值相同的元素构成一个同义词的单链表,并将单链表头指针存放在哈希表的地i个单元中,查找,插入和删除主要在同义词链表中.

#### 2.2.3 uthash

&ensp;uthash的插入、查找、删除的操作时间都是常量

```c

#include "uthash.h"

struct my_struct {
    int id;            /* we'll use this field as the key */
    char name[10];
    UT_hash_handle hh; /* makes this structure hashable */
};

struct my_struct *users = NULL;

void add_user(struct my_struct *s) {
    HASH_ADD_INT(users, id, s );
}
```

<details>
<summary>uthash用法</summary>

```c
#include <stdio.h>   /* gets */
#include <stdlib.h>  /* atoi, malloc */
#include <string.h>  /* strcpy */
#include "uthash.h"

struct my_struct {
    int id;                    /* key */
    char name[10];
    UT_hash_handle hh;         /* makes this structure hashable */
};

struct my_struct *users = NULL;

void add_user(int user_id, char *name) {
    struct my_struct *s;

    HASH_FIND_INT(users, &user_id, s);  /* id already in the hash? */
    if (s==NULL) {
      s = (struct my_struct *)malloc(sizeof *s);
      s->id = user_id;
      HASH_ADD_INT( users, id, s );  /* id: name of key field */
    }
    strcpy(s->name, name);
}

struct my_struct *find_user(int user_id) {
    struct my_struct *s;

    HASH_FIND_INT( users, &user_id, s );  /* s: output pointer */
    return s;
}

void delete_user(struct my_struct *user) {
    HASH_DEL(users, user);  /* user: pointer to deletee */
    free(user);
}

void delete_all() {
  struct my_struct *current_user, *tmp;

  HASH_ITER(hh, users, current_user, tmp) {
    HASH_DEL(users, current_user);  /* delete it (users advances to next) */
    free(current_user);             /* free it */
  }
}

void print_users() {
    struct my_struct *s;

    for(s=users; s != NULL; s=(struct my_struct*)(s->hh.next)) {
        printf("user id %d: name %s\n", s->id, s->name);
    }
}

int name_sort(struct my_struct *a, struct my_struct *b) {
    return strcmp(a->name,b->name);
}

int id_sort(struct my_struct *a, struct my_struct *b) {
    return (a->id - b->id);
}

void sort_by_name() {
    HASH_SORT(users, name_sort);
}

void sort_by_id() {
    HASH_SORT(users, id_sort);
}

int main(int argc, char *argv[]) {
    char in[10];
    int id=1, running=1;
    struct my_struct *s;
    unsigned num_users;

    while (running) {
        printf(" 1. add user\n");
        printf(" 2. add/rename user by id\n");
        printf(" 3. find user\n");
        printf(" 4. delete user\n");
        printf(" 5. delete all users\n");
        printf(" 6. sort items by name\n");
        printf(" 7. sort items by id\n");
        printf(" 8. print users\n");
        printf(" 9. count users\n");
        printf("10. quit\n");
        gets(in);
        switch(atoi(in)) {
            case 1:
                printf("name?\n");
                add_user(id++, gets(in));
                break;
            case 2:
                printf("id?\n");
                gets(in); id = atoi(in);
                printf("name?\n");
                add_user(id, gets(in));
                break;
            case 3:
                printf("id?\n");
                s = find_user(atoi(gets(in)));
                printf("user: %s\n", s ? s->name : "unknown");
                break;
            case 4:
                printf("id?\n");
                s = find_user(atoi(gets(in)));
                if (s) delete_user(s);
                else printf("id unknown\n");
                break;
            case 5:
                delete_all();
                break;
            case 6:
                sort_by_name();
                break;
            case 7:
                sort_by_id();
                break;
            case 8:
                print_users();
                break;
            case 9:
                num_users=HASH_COUNT(users);
                printf("there are %u users\n", num_users);
                break;
            case 10:
                running=0;
                break;
        }
    }

    delete_all();  /* free any structures */
    return 0;
}
```

</details>

- 参考链接
官网:https://troydhanson.github.io/uthash/
https://blog.csdn.net/fan_h_l/article/details/107241520
https://blog.csdn.net/whatday/article/details/95926766
https://www.cnblogs.com/pam-sh/p/12827658.html

#### 2.2.4 leetcode题目
- 设计哈希集合 

- 设计哈希映射

- 根据字符出现频率排序

### 2.3 树与二叉树
&emsp;树(tree)是一种用来模拟树状结构的抽象数据结构(ADT);

&emsp;树的特点:
- 没有父节点的节点称为根节点
- 每个非根节点有且只有一个父节点
- 除了根结点外,每个子节点可分为多个不相交的子树
- 树中没有环路

#### 2.3.1 概述
- 节点的度: 一个节点含有子树的个数
- 树的度: 树中最大的节点度
- 叶节点: 度为零的节点
- 父节点
- 子节点
- 兄弟节点
- 节点的层次
- 深度: 任意节点n,n的深度为从n到一片树叶的最长路径长,根的深度为0
- 高度: 对任意节点n,n的高度为从n到一片树叶的最长路径长,所有树叶的高度为0.
- 森林

&emsp;树由称为结点的元素按照层次结构的方式组织而成。最顶端称为根。与根直接相连的结点称为根的子结点。子节点本身也可以有子结点。除根结点外，每个结点都有唯一的父结点。

#### 2.3.2 树的种类
- 无序树
- 有序树
   - 二叉树: 每个节点最多含有两个子树的树.
      - 完全二叉树: 对于一颗深度为d的二叉树,除第d层外,其他各层节点数目均达最大值,且第d层所有节点从左向右连续紧密排列.
         - 满二叉树:所有叶节点都最底层的完全二叉树.
      - 平衡二叉树(AVL):当且仅当任何节点的两颗子树的高度差不大于1的二叉树.
      - 排序二叉树:二叉查找树

    - 霍夫曼树:带权路径最短的二叉树(又称最优二叉树).
    - B树:一种堆读写操作进行优化的自平衡二叉查找树,能够保持数据有序,拥有多余两个子树.

<br>

|||
|---|---|
|二叉树|二叉查找树(BST) 笛卡尔树 MVP树 Top tree T树|
|自平衡二叉查找树|AVL树 红黑树 |
|B树|B树 B+树|

&emsp;树有多种结构形式，包括二叉树、。

#### 2.3.3 二叉树

&ensp;二叉树两个条件:
- 本身是有序树
- 树中包含的各个节点的度不能超过2,即只能是0,1或者2

&emsp;二叉树中结点包含三部分：一个数据成员两个左右指针。

```c
typedef struct BiTreeNode_ {
    void *data;
    struct BiTreeNode_ *left;
    struct BiTreeNode_ *right;
}BiTreeNode;

typedef struct BiTree_ {
    int size;
    int (*compare)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    BiTreeNode *root;
}BiTree;

/*树根*/
typedef struct tree{
	Node * root;
}Tree;
```
&ensp;二叉树性质:
- 二叉树中,第i层最多有 2^(i-1)个节点
- 如果二叉树的深度为K,则二叉树最多有`2^K - 1`个节点

满二叉树

完全二叉树


&emsp;树的周游算法包含先序遍历、中序遍历、后序遍历和层序遍历。
- 先序遍历：先访问根结点，然后左子树，最后右子结点。深度优先思想。
- 中序遍历：先访问左子结点，然后根结点，最后右子结点。
- 后序遍历：先访问左子结点，然后右子结点，最后根结点。
- 层序遍历：先访问树的根结点，然后依次向下层处理，按照从左向右的顺序访问每层结点。广度优先的策略。


#### 2.3.4 二叉查找树(BST)

&ensp;二叉查找树也称二叉搜索树,有序二叉树或排序二叉树,具有性质:
- 若任意节点左子树不为空,则左子树上所有节点的值均小于它的根节点的值
- 若任意节点的右子树不为空,则右子树所有节点的值均大于根节点的值
- 任意节点的左,右子树也分别为二叉查找树
- 没有键值相等的节点


&emsp;一颗二叉搜索树要插入一个结点，要从根结点开始，一层一层往下，适当地移动左或右子结点上，当到达树的分支尽头时，执行插入操作。
&emsp;二叉搜索树是一种用于查找操作的高效数据结构，在最坏情况下，只需查找一个分支上的数据即可。**查找,插入**操作的复杂度是 `O(logn)`，**搜索,插入,删除**复杂度等于树高,期望`O(logn)`,最坏为`O(n)`,(树退化为线性表)n为树中结点数。
&emsp;保持一棵树的平衡是指对于给定数量的结点，要使得树的高度尽可能短。


&emsp;二叉查找树是由二叉树组成的专用于查找和搜索目的的一种数据结构。二叉搜索树中查找一个结点，从根结点开始一层一层向下查找，当遇到一个比目标结点值大的结点时，顺着该结点左子树继续查找，如果遇到的结点值小于目标结点，则顺着该结点的右子树查找，直到找到目标结点为止。

&ensp;**查找算法**
&emsp;&emsp;1.若b是空树,则搜索失败,否则;
&emsp;&emsp;2.若x等于b的根节点的数据域之值,则查找成功;
&emsp;&emsp;3.若x小于b的根节点的数据域之值,则搜索左子树
&emsp;&emsp;4.查找右子树

&ensp;**插入算法**
&emsp;&emsp;1.若b是空树,则将s所指节点作为根节点插入;否则
&emsp;&emsp;2.若`s->data`等于b的根节点的数据域值,则返回,否则;
&emsp;&emsp;3.若`s->data`小于b的根节点的数据域之值,则把s所值节点插入到左子树中,否则
&emsp;&emsp;4.把s所指节点插入到右子树中,(新插入节点总是叶子节点)

&ensp;**删除算法**
&emsp;&emsp;1.若*p节点为叶子节点,即PL(左子树)和PR(右子树)均为空树.由于删去叶子节点不破坏整棵树的结构,则只需修改其双亲节点的指针即可.

#### 2.3.5 平衡树

&ensp;平衡树是一类改进的二叉查找树,一般二叉查找树的查询复杂度与目标节点到树根的距离(深度)有关,因此当深度较大时,查询均摊复杂度会上升.
&ensp;**平衡指所有叶子的深度趋于平衡**,更广义指树上所有可能查找的均摊复杂度偏低.**平衡树的操作时基于树旋转操作,通过旋转可使树趋于平衡**.
&ensp;对一颗查找树进行查询,新增,删除等操作,所花的时间与树的高度h成比例,并不与树的容量n成比例.

- **AVL树**

&emsp;在**AVL树中,任一节点对于的两颗子树的最大高度差为1,因此也称为高度平衡树**.查找,插入和删除的平均和最坏时间复杂度是O(logn),增加和删除元素的操作则可能需要借由一层或多次旋转,以实现树的重新平衡.
&emsp;**高度为h的AVL树,总节点数最多为2^h-1**; 当前节点数为N时,高度h最多为:
> log(5*0.5 * (N + 1)) - 2

<br>

- **红黑树**

&ensp;红黑树是一种自平衡二叉查找树,典型的用途是实现关联数组.红黑树实现复制,查找,插入和删除时间复杂度为O(logn)
&ensp;红黑树相对于AVL树,牺牲了部分平衡性以换取插入\删除操作时少量的旋转操作,整体性能优于AVL树.

&emsp;红黑树与AVL树的相比:
&emsp;&emsp;AVL树在插入,删除节点时要把树调整到完全平衡,红黑树只要调整到大致平衡,因此通常红黑树的插入,删除节点性能稍好.
&emsp;&emsp;AVL的查找性能通常比红黑树好
&emsp;&emsp;如果节点的增删操作远小于查找操作,则应选择AVL;反之,红黑树可能更好.

&ensp;红黑树是每个节点都带有颜色属性的二叉树,颜色为红色或黑色.在二叉查找树强制一般要求以外,对于任何有效的红黑树我们怎讲了弱小额外要求:
&emsp;&emsp;1.节点是红或黑色
&emsp;&emsp;2.根是黑色
&emsp;&emsp;3.所有叶子都是黑色(叶子是NIL节点)
&emsp;&emsp;4.每个红色节点必须右两个黑色的子节点.(从每个叶子到根的所有路径上不能右两个连续的红色节点.)
&emsp;&emsp;5.从任一节点到其每个叶子的所有简单路径都包含相同苏后面的黑色节点.
&ensp;红黑树关键特性:**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**.红黑树是大致平衡的.插入,删除和查找某个值最坏情况下与树的高度成比例.

- **B+树**

&ensp;B+树通常用于数据库和操作系统的文件系统中.**B+树的特点是能够保持数据稳定有序,其插入与修改拥有较文档的对数时间复杂度**.B+树元素自底向上插入,与二叉树相反.
&ensp;B+树是内部节点可右在预定范围内的可变量目的子节点.因此,B+树不需要像其他自平衡二叉查找树那样重新平衡.

#### 2.3.6 堆树和优先队列

&ensp;堆(heap)也称为优先队列,堆遵守队列操作模式,在堆底插入元素,在堆顶取出元素,但堆中元素的排列不是按照到来的先后顺序,而是按照一定的有序顺序排列的.
&ensp;堆的本质是一个完全二叉树,可使用二叉树表示堆,也可使用数组来表示.
&ensp;堆的特性:
&emsp;&emsp;必须是完全二叉树
&emsp;&emsp;用数组实现
&emsp;&emsp;任一节点的值是其子树所有节点的最大值或最小值
&emsp;&emsp;&emsp;最大值时,称为最大堆,也称大顶堆
&emsp;&emsp;&emsp;最小时,称为最小堆,也称小顶堆.
&emsp;**堆不能保证整棵树都是有序的,堆中的插入和删除操作时时间复杂度为O(log2n)**


&emsp;堆是一颗二叉树，通常其子结点存储的值比父结点的值小，所以，根结点为树中最大的结点(大顶堆)。同样，根结点也可以是树中最小的结点(小顶堆)。能够快速确定包含最大(小)值的特点。
&emsp;堆时左平衡的树，随着结点增加，树会逐级从左至右增长。一个较好地表示左平衡二叉树的方式是，将结点通过层序遍历方式连续存储到一个数组中。

```c
typedef struct Heap_ {
    int size;
    int (*compare)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    void **tree;
}
```



&emsp;堆排序，要排序的数据首先存储在一个堆中。从堆中一次取出一个结点。放置到有序数据集的尾部。当取出每个结点时，它的下一个结点就会浮现到堆的顶部。


&emsp;优先队列是从堆衍生的数据结构。在优先队列中，数据保存在一个堆中，可快速确定下一个最高优先级的结点。

&emsp;优先队列将数据按照优先级顺序排列。一个优先队列由许多有序元素构成，所以优先级最高的元素可以有效而快速的确定。

```c
typedef Heap PQueue;
```


#### 2.3.7 leetcode题目

- 先序遍历构造二叉树
- 从中序与后序遍历构造二叉树
- 二叉树的层次遍历
- 从二叉搜索树到更大和树
- 二叉搜索树的最近公共祖先
- 前K个高频单词<堆>

### 2.4 图

&ensp;图(Graph)是由顶点的有穷非空集合和顶点之间的边的集合组成,通常表示为:`G(V,E)`.其中,G表示一个图,V是入G中顶点的集合,E是图G中的集合.

&emsp;图是一种灵活的数据结构，用来定义对象之间关联或联系的模型。对象由顶点表示，而对象直接的关系或关联则通过顶点之间的边来表示。
&emsp;图的访问方式：广度优先和深度优先。

#### 2.4.1 基础知识
&emsp;图由两种类型的元素组成：顶点和边，顶点代表对象，边则建立起对象之间的关系或关联。图的边可关联值或权重信息。
&emsp;图分为有向图和无向图。有向图，边是由两个顶点组成的有序对，具有特定的方向。边也可称为弧。无向图中，边是没有方向的。

&ensp;图可分为连通图和非连通图

#### 2.4.2 图表示
&emsp;图的表示方法是G=(V, E)，V代表顶点的集合，而E和V之间是二元关系。
&emsp;图中由两个重要关系邻接(adjacency)和关联(incidence)。邻接是两个顶点之间的关系。关联是顶点和边之间的关系。
邻接矩阵表示
邻接链表表示

```c
typedef struct AdjList_ {
    void *vertex;
    Set adjacent;
}AdjList;

typedef struct Graph_ {
    int vcount;
    int ecount;
    int (*match)(const void *key1, const void *key2);
    List adjlists;
}
```

#### 2.4.3 图遍历
&ensp;图的搜索方法：深度优先搜索和广度优先搜索。
&emsp;深度优先遍历(DFS)
&emsp;思路: 从图中某点v出发:
&emsp;&emsp;&emsp;1.访问顶点v
&emsp;&emsp;&emsp;2.从v的未被访问的邻接点中选取一个顶点w,从w出发进行深度优先遍历.
&emsp;&emsp;&emsp;3.重复上述两步,直到图中所有和v有路径相通的顶点都被访问.
&emsp;伪代码: 
```c
// 
void DFS(Vertex v) {
    vistied[v] = true;
    for (v 的每个邻接点 w) {
        if (!visited[w]) {
            DFS(w);
        }
    }
}
```

&ensp;广度优先遍历(BFS)
&emsp;思路: 
&emsp;&emsp;&emsp;1.顶点v入队列
&emsp;&emsp;&emsp;2.当队列非空时则继续执行,否则算法结束.
&emsp;&emsp;&emsp;3.出队列取得队头顶点v',访问顶点v 并标记顶点v已被访问.
&emsp;&emsp;&emsp;4.查找顶点v的第一个邻接顶点col
&emsp;&emsp;&emsp;5.若v的邻接顶点col未被访问过的,则col继续.
&emsp;&emsp;&emsp;6.查找顶点v的另一个新的邻接顶点col,转到步骤5入队列,直到顶点v的所有未被访问过的邻接点处理完,转到步骤2.

&ensp;深度优先搜索和广度优先搜索,时间复杂度都为O(n^2)

深度优先:从初始点出发,不断向前走,如果碰到死路,就往回走一步,尝试另一条路,直到发现目标位置.
广度优先:从初始点出发,把所有可能的路径都走一遍,如果里面没有目标位置,则尝试把所有两步能够到的位置都走一遍,看有没有目标位置.

#### 2.4.4 最短路径
**迪杰斯特拉Dijkstra算法**
&ensp;Dijkstra算法适用于权值为正的图.
&ensp;Dijkstra算法属于单源算法,即只能求出某点到其它点最短距离,并不能得出任意两点之间的最短距离.
&ensp;在源点可达的情况下,Dijkstra算法的时间复杂度时 `O(ElogV)`
&ensp;算法步骤:
&emsp;&emsp;1.将所有边初始化为无穷大
&emsp;&emsp;2.旋转一个开始的顶点,添加到优先队列中.
&emsp;&emsp;3.对于该点的所有邻接顶点进行判断,如果到该点的距离小于原先的值,则该值进行更新.
&emsp;&emsp;4.将该点所有邻接顶点添加到优先队列中.
&emsp;&emsp;5.从优先队列中挑选除一个路径值最小的顶点,将其弹出,作为新的顶点,重复步骤3,4,5
&emsp;&emsp;6.直到所有点都被处理过一次.

**弗洛伊德Floyd算法**
&ensp;Floyd算法是一个经典的动态规划算法.首先目标是寻找从点`i`到`j`的最短路径.
&ensp;**Floyd算法可以求出任意两点的最短距离.时间复杂度:**`O(你^3)`
&ensp;从任意节点i到任意节点j的最短路径不外乎2种可能:
&emsp;&emsp;1.是之间从i到j
&emsp;&emsp;2是从i到经过若干个节点k到j

```c
for (int k = 0; k < n; k++) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (A[i][j] > (A[i][k] + A[k][j])) {
                A[i][j] = A[i][k] + A[k][j];
                path[i][j] = k;
            }
        }
    }
}
```


#### 2.4.5 拓扑排序
&ensp;拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列.且该序列必须满足下面两个条件:
- 每个顶点出现且只出现一次
- 若存在一条顶点A到顶点B的路径,那么在序列中顶点A出现在顶点B的前面.


#### 2.4.6 leetcode题目
- 判断二分图
- 克隆图
- 找到小镇的法官
- 钥匙和房间
- 最短路径访问所有节点

## 3 常见算法

### 3.1 递归思想
#### 3.1.1 递归思想
&ensp;递归思想是:将大问题分解为小问题来求解,然后再将小问题分解为更小的问题.逐层分解,直到问题规模被分解到可以直接计算结果.
&ensp;如果把一层一层分解过程画成图,它其实就是一棵树,称为递归树.

<!--more-->

&ensp;斐波那契数列
```c
int fib(int N)
{
    if (N < = 1) {
        return N;
    }
    
    return fib(N-1) + fib(N-2);
}
```
&ensp;递归的过程中,符合**后进先出**规则,所以用一个堆栈的数据结构.函数递归过程中会自动产生栈帧,当函数栈帧的深度越来越大,栈也也越来越大,如果递归没有终止条件,则会爆栈.递归算法第一步要思考的就是**递归终止条件**.
&ensp;递归思想的两个延申算法:分治算法和动态规划.
&ensp;递归的一般结构:
```c
void func()
{
    if (符合边界条件) {
        ...
        return ..;
    }
    // 某种形式的调用
    func();
}
```
&ensp;阶乘函数:
```c
int factorial(int n)
{
    if (n <= 1) {
        return 1;
    }

    return n * factorial(n-1);
}
```

- 参考链接:https://www.jianshu.com/p/b2d2edb4ba5b

#### 3.1.2 递归基本步骤:
&ensp;&emsp;1.定义一个函数,明确函数功能
&ensp;&emsp;2.寻找问题与子问题之间的关系(递推公式)
&ensp;&emsp;3.将递推公式在定义的函数中实现
&ensp;&emsp;4.推导时间复杂度,判定是否可以接受,无法接受更换算法.

#### 3.1.3 代表题目
- 爬楼梯 70

```c
int climbStairs(int n)
{
    int *mem = (int *)malloc(sizeof(int) * (n+1));
    int mem[n] = {};
    return climb(n, mem);
}

int climb(int n, int *mem)
{
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 2;
    }
    if (mem[n] > 0) {
        return mem[n];
    }
    mem[0] = climb(n-1, mem) + climb(n-2, mem);

    return mem[n];
}
```

- 青蛙跳台阶 10-II

```c
int numWays(int n)
{
    int num[n+1] = {-1};
    return jump(n, num);
}

int jump(int n, int *num)
{
    if (num[n] != -1) {
        return num[n];
    }
    if (n == 1 || n == 0) {
        return 1;
    }

    num[n] = (jump(n-1, num) + jump(n-2, num) % 1e9+7);
    return num[n];
}
```

#### 3.1.4 触类旁通
- 反转二叉树 226
&emsp;1).对于根节点`1`来说,假设`2,3`节点下的节点都已经翻转,那么只要翻转`2,2`节点即满足需求.
&emsp;2).对于`2,3`节点来说,也是翻转其左右节点即可.
&emsp;依此类推,对每一个节点,依次翻转其左右节点,所以我们可知问题与子问题的关系是翻转(根节点) = 翻转(根节点的左节点) + 翻转(根节点的右节点),即
> invert(root) = invert(root->left) + invert(root->right)
&emsp;加号是追加到root上的意思

```c
typedef struct TreeNode {
    int data;
    TreeNode *left;
    TreeNode *right;
}

TreeNode invertTree(TreeNode *root)
{
    if (root == NULL) {
        return NULL;
    }

    TreeNode *left = (struct TreeNode *)malloc(sizeof(TreeNode));
    TreeNode *right = (struct TreeNode *)malloc(sizeof(TreeNode));
    left = invertTree(root.left);
    rgith = invertTree(root.right);
    root.left = right;
    root.right = left;
    return root;
}

```

- 路径总和 112
&emsp;给定一个二叉树和一个目标和,判断该树中是否存在根节点到叶子节点的路径,这条路径上所有节点值相加等于目标和.
```c
typedef struct TreeNode {
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
}
bool hasPathSum(TreeNode *root, int sum)
{
    if (root == NULL) {
        return false;
    }
    if (root.left == NULL && root.right == NULL) {
        return root.data == sum;
    }

    int remain = sum - root.data;
    return hasPathSum(root.left, remain) || hashPashSum(root.right, remain);
}
```

- 细胞分裂

https://www.jianshu.com/p/b2d2edb4ba5b




### 3.2 分治法
&emsp;把复杂问题分成两个或者更多相同或相似的子问题，再把子问题分成更小的子问题...，直到可以直接求解，原问题的解为子问题解的合并。
&emsp;分治法应用：排序算法(快速排序、归并排序);傅里叶变换()。
#### 3.2.1 概述
&ensp;分治法思想:将一个难以直接解决的大问题,分割成一些规模小的相同问题,分而治之.

&emsp;分治法:把一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题...,直到最后子问题可以简单的直接求解,原问题的解即子问题的解的**合并**.分治法思想:排序(快速排序,归并排序),傅里叶变换(快速傅里叶变换
&emsp;1):数学归纳是使用分治思想.
&emsp;2):分治思想不一定使用递归结构.
&ensp;递归结构是循环结构的一种,也是分治思想应用最多的一种程序结构,但不一定使用它.分治法的核心是**如何分**



#### 3.2.2 策略
&ensp;分治策略:对于一个规模为n的问题,若该问题可以容易解决则直接解决,否则将其分解为k个规模较小的子问题,子问题之间相互独立且与原问题形式相同,可递归求解.分治通常用递归实现.
#### 3.2.3 应用场景
&ensp;分治法特征:
- 问题缩小到一定程度可容易解决.
- 问题可分解为若干个规模较小的相同问题,即问题具有最优子结构性质.
- 子问题的解可合并为该问题的解.
- 问题分解的子问题相互独立,子问题之间不包含公告子问题.

#### 3.2.4 步骤
&ensp;分治法一层递归步骤:
- 1) **分解**:将原问题分解为若干规模较小,相互独立,与原问题形式相同的子问题.
- 2) **解决**:若子问题可直接求解,则直接求解,否则递归解各个子问题.
- 3) **合并**:将各个子问题的解合并为原问题的解.

&ensp;

```c


```
<br>

#### 3.2.5 应用
> 分治思维方式：二分搜索;大整数乘法;合并排序;快速排序。

&ensp;求x的n次幂
&emsp;对数复杂度O(logn)
```c
int power(int x, int n)
{
    int result;
    if (n == 1) {
        return x;
    }
    if (n % 2 == 0) {
        result = power(x, n/2) * power(x, n / 2);
    } else {
        result = power(x, (n + 1) / 2) * power(x, (n - 1) / 2);
    }
    return result;
}
```

#### 3.2.6 leetcode题目
- 搜索二维矩阵II
- 求众数
- 合并k个排序链表


### 3.3 排序算法
&emsp;各种排序算法，主要包括：插入排序、快速排序、归并排序、计数排序和技术排序。二分查找，

#### 3.3.1 冒泡排序
&ensp;重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。
&ensp;**冒泡排序算法复杂度是O(n^2)**
```c
static void bubleSort(int[] arr)
{
    int size = arr.length;
    // 
    for (int out = size - 1; out > 0; out--) {
        // 
        for (int in = 0; in < out; in++) {
            if (arr[in] > arr[in + 1]) {
                swap(arr, in, in + 1);
            }
        }
    }
}
```
<br>

```c++
#include <iostream>
using namespace std;
template<typename T>
//整数或浮点数皆可使用
void bubble_sort(T arr[], int len)
{
    int i, j; T temp;
    for (i = 0; i < len - 1; i++) {
        for (j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

#### 3.3.2 选择排序
&emsp;选择排序算法时间复杂度为O(n^2)

```c
static void selectSort(int[] arr)
{
    int size = arr.lenght;
    //
    for (int out = 0; out < size; out++) {
        int mixIndex = out;
        //
        for (int in = out - 1; in < size; in++) {
            if (arr[mixIndex] > arr[in]) {
                mixIndex = in;
            }
        }

        if (mixIndex != out) {
            swap(arr, mixIndex, out);
        }
    }
}
```

#### 3.3.3 插入排序
&emsp;插入排序每次从无序数据集合中取出一个元素，插入到已经排好序的数据集中适当位置，使数据集仍然有序。插入排序不需要额外空间。时间复杂度O(n2)

```c
static void insertSort(int[] arr)
{
    int size = arr.lenght;
    // 
    for (int out = 1; out < size; out++) {
        //
        int temp = arr[out];
        int in = out;
        //
        // 
        while (in - 1 >= 0 && arr[in - 1] > temp) {
            arr[in] = arr[in - 1];
            in--;
        }
        if (in != out) {
            arr[in] = temp;
        }
    }
}
```

```c
int issort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2))
{
    char *a = data;
    void *key;
    int i, j;

    if ((key = (char *)malloc(esize)) == NULL) {
        return -1;
    }

    for (j = 1; j < size; j++) {
        i = j - 1;

        while (i >= 0 && compare(&a[i * esize], key) > 0) {
            mamcpy(&a[(i + 1) * esize], &a[i * esize], esize);
            i--;
        }
        memcpy(&a[(i + 1) * esize], key, esize);
    }

    free(key);

    return 0;
}
```
#### 3.3.4 希尔排序

&ensp;希尔排序时间复杂度O(n*(logn)^2)
```c
static void shellSort(int[] arr)
{
    int size = arr.lenght;
    int h = 1;
    while (h <= size / 3) {
        //
        h = h * 3 + 1;
    }
    while (h > 0) {
        for (int out = h; out < size; out++) {
            int temp = arr[out];
            int in = out;
            //
            while (in - h >= 0 && arr[in - h] > temp) {
                arr[in] = arr[in - h];
                in = in - h;
            }
            if (in != out) {
                arr[in] = temp;
            }
        }
        h = (h - 1) / 3;
    }
}
```
#### 3.3.5 归并排序
&emsp;归并排序是一种分支排序算法。归并排序需要额外存储空间来完成排序。
```c
int min(int x, int y)
{
    return  x < y ? x : y;
}

void merge_sort(int arr[], int len)
{
    int *a = arr;
    int *b = (int *)malloc(len * sizeof(int));
    int seg, start;
    for (seg = 1; seg < len; seg += seg) {
        for (start )
    }
}
```
#### 3.3.6 快速排序
&emsp;快速排序是一种分治排序算法。不需要额外存储空间，时间复杂度O(nlgn)

&emsp;快速排序三个步骤：
- 分：设定一个分割值并将数据分为两部分。
- 治：分别在两部分使用递归方式继续使用快速排序方法。
- 和：对分割部分排序直至完成。

```c
typedef struct _Range {
    int start;
    int end;
} Range;

Range now_Range(int s, int e)
{
    Range r;
    r.start = s;
    r.end = e;
    return r;
}

void swap(int *x, int *y)
{
    int t = *x;
    *x = *y;
    *y = t;
}

void quick_sort(int arr[], const int len)
{
    if (len <= 0) {
        return;
    }
    Range r[len];
    int p = 0;
    r[p++] = new_Range(0, len - 1);
    while (p) {
        Range range = r[--p];
        if (range.start >= range.end) {
            continue;
        }
        int mid = arr[(range.start + range.end) / 2];
        int left = range.start;
        int right = range.end;
        do {
            while (arr[left] < mid) {
                ++left;
            }
            while (arr[right] > mid) {
                --right;
            }
            if (left <= right) {
                swap(&arr[left], &arr[right]);
                left++;
                right--;
            }
        } while (left <= right);
        if (range.start < right) {
            r[p++] = new_Range(range.start, right);
        }
        if (range.end > left) {
            r[p++] = new_Range(left, range.end);
        }
    }
}
```

```c
void QuickSort(int *arr, int low, int high)
{
    if (low < high) {
        int i = low;
        int j = high;
        int k = arr[low];
        while (i < j) {
            // 从右向左找第一个小于k的数
            while (i < j && arr[j] >= k) {
                j--;
            }

            if (i < j) {
                arr[i++] = arr[j];
            }
            // 从左向右找第一个大于等于k的数
            while (i < j && arr[i] < k) {
                i++;
            }

            if (i < j) {
                arr[j--] = arr[i];
            }
        }
        arr[i] = k;

        // 递归调用
        QuickSort(arr, low, i - 1); // 排序k左边
        QuickSort(arr, i + 1, high); // 排序k右边
    }
}

void quick_sort( int *a, int n)
{
    int i, j, p, tmp;
    if (n < 2)  return;

    p = a[n / 2];   // Get the middle element as pivot ..

    for ( i = 0, j = n -1;; i++, j--) {
        while (a[i] < p)
            i++;
        while (p < a[j])
            j--;
        if ( i >= j)
            break;
        tmp = a[i]; a[i] = a[j]; a[j] = tmp;    //swap both ..
    }   

    quick_sort( a, i); 
    quick_sort( a + i, n - i); 
}
```

```c++
#include <iostream>
using namespace std;
 
void Qsort(int arr[], int low, int high){
    if (high <= low) return;
    int i = low;
    int j = high + 1;
    int key = arr[low];
    while (true) {
        /*从左向右找比key大的值*/
        while (arr[++i] < key) {
            if (i == high) {
                break;
            }
        }

        /*从右向左找比key小的值*/
        while (arr[--j] > key)
        {
            if (j == low) {
            break;
            }
        }

        if (i >= j) break;
        /*交换i,j对应的值*/
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    /*中枢值与j对应值交换*/
    int temp = arr[low];
    arr[low] = arr[j];
    arr[j] = temp;
    Qsort(arr, low, j - 1);
    Qsort(arr, j + 1, high);
}
```

**qsort/sort函数**
&ensp;在c语言库函数中已经实现了qsort函数,
&emsp;qsort函数用法:
```c
void qsort(void *base, int nelem, int width, int (*fcmp)(const void *, const void *));
// 参数:1 带排序数组首地址, nelem 数组中待排元素数量  width 各元素所在空间大小  *fcmp 指向函数的指针
```

```c
// int 数组
int cmp(const void *a, const void *b)
{
    return (*(int *)a - *(int *)b);
}
qsort(arr, n, sizeof(arr[0]), cmp);

// char 数组
int com(const void *a, const void *b)
{
    return *(char *)a - *(char *)b;
}
char word[100];
qsort(word, 100, sizeof(word[0]), cmp);

// double 类型
int cmp(const void *a, const void *b)
{
    return *(double *)a > *(double*)b ? 1 : -1;
}
double in[100];
qsort(in, 100, sizeof(in[00]), cmp);

// struct 结构体
struct Sample {
    double data;
    int num;
}st[100];

int cmp(const void *a, const void *b)
{
    return (*(Sample *)a).data > (*(Sampel *)b).data ? 1 : -1;
}
qsort(s, 100, sizeof(s[0]), cmp);
// 
int cmp(const void *a, const void *b)
{
    struct Sample *c = (Sample *)a;
    struct Sample *d = (Sample *)b;
    if(c->x != d->x) {
        return c->x - d->x;
    } else {
        return d->y - c->y;
    }
}

qsort(s,100,sizeof(s[0]),cmp);

truct Sample
{
    int data;
    char str[100];
}s[100];

//按照结构体中字符串str的字典顺序排序

int cmp (const void *a, const void *b)
{
    return strcmp((*(Sample *)a)->str , (*(Sample *)b)->str);
}

qsort(s,100,sizeof(s[0]),cmp);
```
#### 3.3.7 堆排序
&emsp;桶排序算法基本原理：把数组中的所有元素分为若干个数据块，也就是若干个桶，然后对每个桶里的数据进行排序，最后将所有桶里的数据依次排列。
&emsp;存在两个问题：
&emsp;(1)怎样划分数据块，也就是分几个桶，每个桶放哪几个数据。
&emsp;(2)对每个数据块里的数据怎样排序。
```c
#include<sdtio.h>
#include<stdlib.h>

typedef struct node {
    int key;
    struct node *next;
} KeyNode;

void bucket_sort(int keys[], int size, int bucket_size) {
    int i, j;
    KeyNode **bucket_table = (KeyNode **)mallov(bucket_size * sizeof(KeyNode*));
    for(i = 0;i < bucket_size;i++) {
        bucket_table[i] = (KeyNode*)malloc(sizeof(KeyNode));
        bucket_table[i]->key = 0;
        bucket_table[i]->next = NULL;
	}
	for(j = 0;j < size;j++) {
		KeyNode *node = (KeyNode *)malloc(sizeof(KeyNode));
		node->key = keys[j];
		node->next = NULL;
		int index = keys[j]/10;
		KeyNode *p = bucket_table[index];
		if(p->key == 0) {
			bucket_table[index]->next = node;
			(bucket_table[index]->key)++;
		}else {
			while(p->next != NULL && p->next->key <= node->key)
				p = p->next;
			node->next = p->next;
			p->next = node;
			(bucket_table[index]->key)++;
		}
	}
	//print result
	KeyNode * k = NULL;
	for(i = 0;i < bucket_size;i++)
		for(k = bucket_table[i]->next;k!=NULL;k=k->next)
			printf("%d ",k->key);
	printf("\n");
}

int main()
{
	int raw[] = {49,38,65,97,76,13,27,49};
	int size = sizeof(raw)/sizeof(int);
	bucket_sort(raw,size,10);
}
```

```c
void Heapify(int A[], int i, int size)
{
    int lef_child = 2 * i + 1;
    int right_child = 2 * i + 2;
    int max = i;
    if (lef_child < size && A[lef_child] > A[max]) {
        max = lef_child;
    }
    if (right_child < size && A[right_child] > A[max]) {
        max = right_child;
    }
    if (max != i) {
        Swap(A, i max);
        Heapify(A, max, size);
    }
}

int BuildHeap(int A[], int n)
{
    int heap_size = n;
    for (int i = heap_size / w - 1; i >= 0; i--) {
        Heapify(A, i, heap_size);
        return heap_size;
    }
}

void HeapSort(int A[], int n)
{
    int heap_size = BuildHeap(A, n);
    while (heap_size > 1) {
        Swap(A, 0, heap_size);
        Heap(A, 0, heap_size);
    }
}
```

#### 3.3.8 leetcode排序



### 3.4 贪心算法

#### 3.4.1 基本概念
&ensp;贪心算法:在对问题求解时,总是做出在当前是最好的选择,即不考虑整体最优,仅考虑局部最优解.
&ensp;贪心算法没有固定算法框架,算法关键是贪心策略的选择.他想算法不是所有问题都得到最优解,选择贪心策略必须具备无后效性,即某个状态以后的过程不会影响一起的状态,只与当前状态有关.
#### 3.4.2 描述
&ensp;贪心算法实现步骤:
&emsp;1.建立数学模型描述问题
&emsp;2.把求解的问题分成若干个子问题
&emsp;3.对每个子问题求解,得到子问题的局部最优解
&emsp;4.把子问题的解局部最优解合成原来问题的一个解.
&ensp;实现算法过程:
```c
while (能朝给定总目标前进一步)
{
    利用可行的决策,求出可行解的一个解元素;
}
由所有解元素组合成问题的一个可行解
```
#### 3.4.3 应用

**最小生成树算法**
&ensp;贪心算法经典实践:最小生成树算法
&emsp;设`G=(V, E)`是无向连通带权图,即一个网络,E中的每一条边`(v,w)` 的全为 `c[v][w]`.如果G的字体 G' 是一颗包含 G 的所有顶点的数,则称 G' 为 G 的生成树.生成树上各边权的总和称为生成树的耗费.在 G 的所有生成树中,耗费最小的生成树称为 G 的最小生成树.
&ensp;最小生成树的性质:
&emsp;&emsp;设`G=(V, E)`是连通带权图, U是V的真子集.如果(u,v)属于E,且u属于E,v属于V-U,且在所有这样的边中,(u,v)的权c[u][v]最小,那么一定存在G的一颗最小生成树,它亦是(u,v)为其中一条边,这个性质有时也称为MST性质.


**Prim算法**
&emsp;&emsp;设`G=(V, E)`是连通带权图, V={1,2,...,n}.构造G的最小生成树Prim算法的基本思想是:**首先置S={1},然后,只有S是V的真子集,就进行如下的贪心选择:选取满足添加i属于S,j属于V-S,且c[i][j]最小的边,将顶点j添加到S中.这个过程一直进行到S=V时为止.在这个过程中选取到的所有边恰好构成G的一颗最小生成树.

#### 3.4.4 leetcode题目
- 柠檬水找零
- 分发饼干

### 3.5 动态规划
&ensp;动态规划(`DP`):是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.常用于重叠子问题和最优子结构性质的问题,动态规划时间通常远小于朴素解法.
#### 3.5.1 基本概念
&ensp;动态规划:要解一个给定问题,需要解其不同部分(即子问题),再根据子问题的解以得出原问题的解.通常子问题非常相似,子问题解算出后,将其记录.
&ensp;动态规划过程是:每次决策依赖于当前状态,又随即引起状态转移.一个决策序列就是在变化的状态中产生除留的,这种多阶段最优化决策解决过程称为动态规划.
&ensp;动态规划与分治法的区别是子问题通常不是独立的.

#### 3.5.2 描述算法
&ensp;可采用动态规划的问题3个性质:
&emsp;1) **最优化原理**:如果问题的最优解所包含的子问题的解也是最优的,则称该问题具有最优子结构,即满足最优化原理.
&emsp;2) **无后效性**:即某阶段状态确定后,就不受之后的决策影响,即某状态以后过程不影响以前的状态,只与当前状态有关.
&emsp;3) **有重叠子问题**:

<br>
&ensp;动态规划所处理的问题是一个多阶段决策问题,由初始状态开始,通过中间阶段决策的选择,达到结束状态.形成一个决策序列.

&ensp;动态规划求解三要素:
> (1) 问题的节点
> (2) 每个阶段的状态
> (3) 从前一个阶段转化到后一个阶段之间的递推关系

&ensp;**最优决策表**
> f(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}

#### 3.5.3 背包问题

&ensp;问题描述:
&emsp;有N件物品和一个体积为V的背包.(每种物品只有一件)第i件物品的体积是volume[i],价值是value[i],求解哪些物品装入背包可使这些物品的体积综合不超过背包体积,且价值总和最大.
&ensp;解题思路:
&emsp;p[i][j]代表前i件物品组合在容量为j的背包的最优解.将前i件物品放入容量为v的背包中这个子问题,若只考虑第i件物品的策略(放或不放),那么可以转化为一个只牵扯前i-1物品的问题.如果不放第i件物品,那么问题就转化为"前i-1件物品放入容量为v的背包中,价值为p[i-1][v];如果放第i件物品,那么问题就转化为"前i-1物品放入剩下的容量为v-volume[i]的背包中",此时能获得的最大价值就是p[i-1][j-volume]再加上通过放入第i件物品获得的价值value[i].


&ensp;**状态转移方程:**
> p[i][j] = max{p[i-1][j-vol] + value[i], p[i-1][j]}
&ensp;伪代码描述:
```c
for i = 1...N
    for j = V...0
        p[j] = max{p[j-volume[i]] + value[i], p[j]};
```


#### 3.5.4 最长公共子序列
&ensp;问题描述:
&emsp;一个散列S,如果分别是两个或多个已知数列的子序列,且是所有匹配此条件序列中最长的,则S称为已知序列的最长公共子序列(LCS)
&ensp;给定两个序列X,Y,求两个序列的最长公共子序列.
&ensp;截图思路:
&emsp;

&ensp;伪代码:
```c
function LCSLength(X[1..m], Y[1..n])
    C = array(0..m, 0..n)
    for i := 0..m
        C[i, 0] = 0;
    for j := 0..n
        C[0, j] = 0
    for i := 1..m
        for j := 1..n
            if X[i] = Y[j]
                C[i, j] := C[i-1, j-1] + 1
            else
                C[i, j] := max(C[i, j-1], C[i-1,j])
    
    return C[m, n]
```

#### 3.5.5 leetcode题目

- 最大子序和
- 编辑距离
- 大礼包
- 最长上升子序列


### 3.6 回溯法

#### 3.6.1 基本概念

&ensp;回溯算法实际上一个类似枚举的搜索尝试过程,主要是在**搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就"回溯"返回,尝试别的路径**.
&ensp;回溯法是一种迭代搜索法,按选优条件详情搜索,以达到目标.但当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择,这种走不通就退回再走的技术为回溯法,而满足回溯条件的某个状态的点称为"回溯法".
&ensp;许多复杂度,规模较大的问题都看看而已使用回溯法,有"同意解题方法"的美称.

&ensp;在包含问题的所有解的解空间树中,按照深度优先的策略,从根节点出发深度探索解空间树.当探索到某一节点时,要先判断该节点是否包含问题的解,如果包含,就从该节点出发继续探索下去,如果该节点不包含问题的解,则逐层向其足协节点回溯.(其实回溯法就是堆隐式图的深度优先搜索算法).
&ensp;若用回溯法求问题的所有解时,要回溯的根,且根节点的所有可行的子树都要已被搜索遍才结束,而若使用回溯法求任一个解时,只要搜索到问题的一个解就可以结束.
&ensp;回溯法一般解题步骤:
&emsp;1.**针对所给问题,确定问题的解空间**;首先应明确定义问题的解空间,解空间应至少包含问题的一个(最优)解.
&emsp;2.**确定节点的扩展搜索规则**
&emsp;3.**以深度优先方式搜索解空间,并在搜索过程中用剪枝函数避免无效搜索**

&ensp;伪代码:
```c
//
void iterativeBacktrack()
{
    int t = 1;
    while (t > 0) {
        if (f(n, t) <= g(n, t)) {
            for (int i = f(n,t); i <= g(n,t); i++) {
                x[t] = h(i);
                if (constraint(t) && bound(t)) {
                    //
                    if (solution(t)) {
                        output(x);
                    } else {
                        t++;
                    }
                } else {
                    t--;
                }
            }
        }
    }
}
```

#### 3.6.2 八皇后问题
&ensp;问题描述
&emsp;八皇后问题使一个以国际象棋为背景的问题:如何能够在 8*8 的国际象棋棋盘上放着八个皇后,使得任何一个皇后都无法直接吃掉其他的皇后?为了达到此目的,任两个皇后都不能处于同一条横行,纵行或斜线上.
&ensp;转化规则:其实八皇后问题可以推广为更一般的n皇后摆放问题;这时棋盘大小变为n*n,而皇后个数也变成n.当且仅当n = 1 或 n >= 4 时间问题有解.

&ensp;伪代码描述
```c
int queens(int Queens) {

}
```

#### 3.6.3 leetcode题目
- N皇后
- 括号生成
- 单词搜索
- 解数独


## 4 参考链接

- 复杂度速查表
https://liam.page/2016/06/20/big-O-cheat-sheet/
- 线性表
https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8
    - 单链表
https://www.jianshu.com/p/73f0d8f807aa

http://cocofe.cn/

