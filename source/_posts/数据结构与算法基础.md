---
title: 数据结构与算法基础
date: 2021-10-27 00:47:53
updated: 2021-10-27 00:53:53
password: liuz0000
abstract: 这是一篇加密博文，请输入密码后查看
message: 这里需要密码才能访问。
wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.
categories: 
    - tool
tags: 
    - 实用教程
    - Another Tag
---

## 1 程序性能

<!--more-->

&ensp;程序性能是指运行程序所需要的内存大小(空间复杂度)和时间(时间复杂度),运行时间和占用空间是算法性能最关键的指标。
&ensp;软件程序性能衡量指标:
&emsp;响应时间、启动时间、执行时间、执行速度、计算资源分配、内存分配、磁盘吞吐量、网络吞吐量、负载承受能力


### 1.1 空间复杂度
&ensp;空间复杂度(Space complexity)，算法完全运行所需存储空间。表示算法的存储空间与数据规模之间的增长关系：常量空间、线性空间、二维空间。
&ensp;算法在计算机存储器上所占用的存储空间，包括**存储程序本身占用的存储空间，算法输入输出数据所占的存储空间和算法在运行过程中临时占用的存储空间**。


### 1.2 时间复杂度
&ensp;时间复杂度(Time complexity)，算法完全运行所需运算时间。时间复杂度通常用大O符合表示。

![20211027233029](https://i.loli.net/2021/10/27/UxWCvnRQLYz5eiG.png)

#### 1.2.1 常见算法大O
&emsp; 常量阶O(1); 对数阶O(logn); 线性阶O(n); 线性对数阶O(nlogn); k次方阶O(n^k)
![20211028010721](https://i.loli.net/2021/10/28/GWOFcUi3qdVIlmf.png)

#### 1.2.2 常见数据结构

### 本章参考：
- 复杂度速查表
https://liam.page/2016/06/20/big-O-cheat-sheet/

## 2 基本数据结构

### 2.1 线性表
&ensp;线性表是n个具有相同特性的数据元素的有序序列。线性表除第一个和最后一个数据元素之外，其他数据元素都是首尾相接的。
&ensp;数据在实际的物理存储中有两种形式：分散存储和集中存储,常见数据结构有栈、队列、字符串、链表等。
&ensp;两种情况下数据的存储问题：
&emsp; 数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；
&emsp; 数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”

#### 2.1.1 数组
&emsp;数组是一批相同数据的集合。数组的三部分：地址 大小 和 空间。数组的保存形式为线性表。
```c
int arr[10]; // /[]内必须是常量/常量表达式(3+8)，不能是一个变量(x...)
// 数组初始化
int arr1[3] = {1, 2, 3};
char arr6[] = "abcdef";
// 指针
int *ptr = NULL;//定义一个整型的指针变量，初始化为NULL
char *ptr = NULL;//定义一个字符的指针变量，初始化为NULL
// 二维数组
int arr[3][5] = { 0 };
// C 传递数组给函数
// 
void myFunction(int *param)
void myFunction(int param[10])
void myFunction(int param[])
// C 从函数返回数组
int * myFunction()
{
...
}
```
<br>

**二分搜索**
&emsp;基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）
&emsp;二分搜索的时间复杂度为 ***对数时间O(logn)***
```c
int binary_search(int key, int a[], int n)
{
    int low = 0;
    int high = n - 1;
    int mid, count = 0, count1 = 0;

    while(low < high) {
        count++;
        mid = (low + high) / 2;
        if (key < a[mid]) {
            high = mid - 1;
        } else if (key > a[mid]) {
            low = mid + 1;
        } else if (key == a[mid]) {
            count1++;
            break;
        }
    }

    if (count1 == 0) {
        return 1;
    }

    return 0;
}
```

#### 2.1.2 单链表
&emsp; 单链表元素之间有一个单独的指针链接。这种结构的链表可以使得从第一个元素遍历到最后一个元素
```c
typedef struct ListElmt_ {
    void *data;  // 数据成员
    struct ListElmt_ * next; // next指针
} ListElmt;

typedef struct List_ {
    int size;
    int (*match)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    ListElmt *head;
    ListElmt *tail;
} List;
```
&emsp;单链表操作：插入、删除、
#### 2.1.3 双链表
&emsp; 双向链表的元素通过两个指针链接。双向链表可以正向遍历，也可反向遍历。
```c
typedef struct DListElmt_ {
    void *data;
    struct DListElmt_ *prev;
    struct DListElmt_ *next;
} DListElmt;

typedef struct DList_ {
    int size;
    int (*match)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    DListElmt *head;
    DListElmt *tail;
} DList;
```

#### 2.1.4 跳表
&emsp;跳表对标的是平衡树(AVL Tree), 插入/删除/搜索都是 O(logn)的数据结构。

#### 2.1.5 栈
&emsp;栈按照后进先出(LIFO)的顺序存储和检索数据的数据结构，检索元素的顺序和存储元素顺序相反。
&emsp;可通过链表来实现栈stack
```c
typedef List Stack;

#define stack_init list_init;
int stack_push(Stack *stack, const void *data);
int stack_pop(Stack *stack, void **data);
#define stack_peek(stack) ((stack)->head == NULL ? NULL : (stack)->head->data);
#define stack_size list_size;
```
&emsp;c语言顺序栈
```c
// 元素elem进栈
int push(char *a, int top, char elem) {
    a[++top] = elem;
    return top;
}
// 数据元素出栈
int pop(char *a, int top)
{
    if (top == -1) {
        return -1;
    }

    top--;
    return top;
}
```
&emsp;链栈
```c
typedef struct lineStack {
    char data;
    struct lineStack *next;
}lineStack;
lineStack* push(lineStack * stack,char a){
    lineStack * line=(lineStack*)malloc(sizeof(lineStack));
    line->data=a;
    line->next=stack;
    stack=line;
    return stack;
}
lineStack * pop(lineStack * stack){
    if (stack) {
        lineStack * p=stack;
        stack=stack->next;
        printf("弹栈元素：%c ",p->data);
        if (stack) {
            printf("栈顶元素：%c\n",stack->data);
        }else{
            printf("栈已空\n");
        }
        free(p);
    }else{
        printf("栈内没有元素");
        return stack;
    }
    return stack;
}
```

#### 2.1.6 队列
&emsp;队列，在前端(front)进行删除操作，后端(rear)进行插入操作; 按照先进先出(FIFO)的顺序存储和检索数据的高效数据结构，按照元素的存储顺序检索元素。
&emsp;队列也可通过数组和链表实现。
```c
typedef List Queue;

#define queue_init list_init;
#define queue_destroy list_destroy;
int queue_enqueue(Queue *queue, const void *data);
int queue_dequeue(Queue *queue, void **data);
#define queue_peek(queue) ((queue)->head == NULL ? NULL : (queue)->head->data);
#define queue_size list_size;
```

&ensp;队列应用：进程通信
消息队列
&emsp;linux内核 <sys/msg.h> 头文件中定义了消息队列结构
```c
struct msqid_ds {
    struct ipc_perm msg_perm;
    struct msg* msg_first; // 指向队列中第一个消息
    struct msg* msg_last; // 队列中最后一个消息
    ...
}
```
&emsp;Linux消息队列函数接口
```c
// 
int msgget(key_t key, int msgflg);
//
int msgsnd(int msgid, const void *msg_ptr, size_t msg_sz, int msgflg);
//
msgrcv(int msgid, void *msg_ptr, size_t msg_st, long int msgtype, int msgflg);
//
int msgctl(int msgid, int command, struct msgid_ds *buf);
```

#### 2.1.7 leetcode题目

### 2.2 哈希表
&emsp;哈希表是一种最有效的检索方法，散列，从本质上看，一个哈希表包含一个数组，通过特殊的索引（键）来访问数组中的元素。哈希表主要思想是通过一个哈希函数，在所有可能的键和值直接建立映射表。
#### 2.2.1 哈希函数设计
- 直接地址发
- 数字分析法
- 平方取中法
- 折叠法
- 除留取余法

#### 2.2.2 哈希冲突
- 链地址法
#### 2.2.3 leetcode题目

### 2.3 树与二叉树
&emsp;树(tree)是一种用来模拟树状结构的抽象数据结构(ADT);
#### 2.3.1 概述
- 节点的度
- 树的度
- 叶节点
- 父节点
- 子节点
- 兄弟节点
- 节点的层次
- 深度
- 高度
- 森林

&emsp;树由称为结点的元素按照层次结构的方式组织而成。最顶端称为根。与根直接相连的结点称为根的子结点。子节点本身也可以有子结点。除根结点外，每个结点都有唯一的父结点。

#### 2.3.2 树的种类
- 无序树
- 有序树
   - 二叉树: 每个节点最多含有两个子树的树.
      - 完全二叉树: 对于一颗深度为d的二叉树,除第d层外,其他各层节点数目均达最大值,且第d层所有节点从左向右连续紧密排列.
         - 满二叉树:所有叶节点都最底层的完全二叉树.
      - 平衡二叉树(AVL):当且仅当任何节点的两颗子树的高度差不大于1的二叉树.
      - 排序二叉树:二叉查找树

    - 霍夫曼树:带权路径最短的二叉树(又称最优二叉树).
    - B树:一种堆读写操作进行优化的自平衡二叉查找树,能够保持数据有序,拥有多余两个子树.


&emsp;树有多种结构形式，包括二叉树、。

#### 2.3.3 二叉树

&emsp;二叉树每个结点最多只有两个与它直接相关联的子结点。直接相连下方的结点称为子结点，每个子结点直接相连的上方结点称为父结点。
&emsp;二叉树中结点包含三部分：一个数据成员两个左右指针。
```c
typedef struct BiTreeNode_ {
    void *data;
    struct BiTreeNode_ *left;
    struct BiTreeNode_ *right;
}BiTreeNode;

typedef struct BiTree_ {
    int size;
    int (*compare)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    BiTreeNode *root;
}BiTree;
```
&emsp;树的周游算法包含先序遍历、中序遍历、后序遍历和层序遍历。
- 先序遍历：先访问根结点，然后左子树，最后右子结点。深度优先思想。
- 中序遍历：先访问左子结点，然后根结点，最后右子结点。
- 后序遍历：先访问左子结点，然后右子结点，最后根结点。
- 层序遍历：先访问树的根结点，然后依次向下层处理，按照从左向右的顺序访问每层结点。广度优先的策略。


#### 2.3.4 二叉查找树
&emsp;二叉查找树是由二叉树组成的专用于查找和搜索目的的一种数据结构。二叉搜索树中查找一个结点，从根结点开始一层一层向下查找，当遇到一个比目标结点值大的结点时，顺着该结点左子树继续查找，如果遇到的结点值小于目标结点，则顺着该结点的右子树查找，直到找到目标结点为止。
&emsp;一颗二叉搜索树要插入一个结点，要从根结点开始，一层一层往下，适当地移动左或右子结点上，当到达树的分支尽头时，执行插入操作。
&emsp;二叉搜索树是一种用于查找操作的高效数据结构，在最坏情况下，只需查找一个分支上的数据即可。查找操作的复杂度是 O(lgn)，n为树中结点数。
&emsp;保持一棵树的平衡是指对于给定数量的结点，要使得树的高度尽可能短。

&emsp;**AVL树**
&emsp;在AVL树中,任一节点对于的两颗子树的最大高度差为1,因此也称为高度平衡树.查找,插入和删除的平均和最坏时间复杂度是O(logn),
&emsp;高度为h的AVL树,总节点数最多为2^h-1; 当前节点数为N时,高度h最多为:
> log(5*0.5 * (N + 1)) - 2

**红黑树**

B+树



#### 2.3.5 平衡树

#### 2.3.6 堆树和优先队列
&emsp;堆是一颗二叉树，通常其子结点存储的值比父结点的值小，所以，根结点为树中最大的结点(大顶堆)。同样，根结点也可以是树中最小的结点(小顶堆)。能够快速确定包含最大(小)值的特点。
&emsp;堆时左平衡的树，随着结点增加，树会逐级从左至右增长。一个较好地表示左平衡二叉树的方式是，将结点通过层序遍历方式连续存储到一个数组中。

```c
typedef struct Heap_ {
    int size;
    int (*compare)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    void **tree;
}
```
&emsp;堆排序，要排序的数据首先存储在一个堆中。从堆中一次取出一个结点。放置到有序数据集的尾部。当取出每个结点时，它的下一个结点就会浮现到堆的顶部。


&emsp;优先队列是从堆衍生的数据结构。在优先队列中，数据保存在一个堆中，可快速确定下一个最高优先级的结点。

&emsp;优先队列将数据按照优先级顺序排列。一个优先队列由许多有序元素构成，所以优先级最高的元素可以有效而快速的确定。

```c
typedef Heap PQueue;
```


#### 2.3.7 leetcode题目

## 2.4 图

&emsp;图是一种灵活的数据结构，用来定义对象之间关联或联系的模型。对象由顶点表示，而对象直接的关系或关联则通过顶点之间的边来表示。
&emsp;图的访问方式：广度优先和深度优先。

### 2.4.1 基础知识
&emsp;图由两种类型的元素组成：顶点和边，顶点代表对象，边则建立起对象之间的关系或关联。图的边可关联值或权重信息。
&emsp;图分为有向图和无向图。有向图，边是由两个顶点组成的有序对，具有特定的方向。边也可称为弧。无向图中，边是没有方向的。

### 2.4.2 图表示
&emsp;图的表示方法是G=(V, E)，V代表顶点的集合，而E和V之间是二元关系。
&emsp;图中由两个重要关系邻接(adjacency)和关联(incidence)。邻接是两个顶点之间的关系。关联是顶点和边之间的关系。
邻接矩阵表示
邻接链表表示

```c
typedef struct AdjList_ {
    void *vertex;
    Set adjacent;
}AdjList;

typedef struct Graph_ {
    int vcount;
    int ecount;
    int (*match)(const void *key1, const void *key2);
    List adjlists;
}
```

### 2.4.3 图遍历
&ensp;图的搜索方法：深度优先搜索和广度优先搜索。
&emsp;深度优先遍历(DFS)
&emsp;思路: 从图中某点v出发:
&emsp;&emsp;&emsp;1.访问顶点v
&emsp;&emsp;&emsp;2.从v的未被访问的邻接点中选取一个顶点w,从w出发进行深度优先遍历.
&emsp;&emsp;&emsp;3.重复上述两步,直到图中所有和v有路径相通的顶点都被访问.
&emsp;伪代码: 
```c
// 
void DFS(Vertex v) {
    vistied[v] = true;
    for (v 的每个邻接点 w) {
        if (!visited[w]) {
            DFS(w);
        }
    }
}
```

&ensp;广度优先遍历(BFS)
&emsp;思路: 
&emsp;&emsp;&emsp;1.顶点v入队列
&emsp;&emsp;&emsp;2.当队列非空时则继续执行,否则算法结束.
&emsp;&emsp;&emsp;3.出队列取得队头顶点v',访问顶点v 并标记顶点v已被访问.
&emsp;&emsp;&emsp;4.查找顶点v的第一个邻接顶点col
&emsp;&emsp;&emsp;5.若v的邻接顶点col未被访问过的,则col继续.
&emsp;&emsp;&emsp;6.查找顶点v的另一个新的邻接顶点col,转到步骤5入队列,直到顶点v的所有未被访问过的邻接点处理完,转到步骤2.


### 2.4.4 最短路径
迪杰斯特拉Dijkstra算法

弗洛伊德Floyd算法



### 2.4.5 拓扑排序


### 2.4.6 leetcode题目

## 3 常见算法

### 3.1 分治法
&emsp;把复制问题分成两个或者更多相同或相似的子问题，再把子问题分成更小的子问题...，直到可以直接求解，原问题的解为子问题解的合并。
&emsp;分治法应用：排序算法(快速排序、归并排序);傅里叶变换()。
#### 3.1.1 概述
&ensp;分治法思想:将一个难以直接解决的大问题,分割成一些规模小的相同问题,分而治之.
#### 3.1.2 策略
&ensp;分治策略:对于一个规模为n的问题,若该问题可以容易解决则直接解决,否则将其分解为k个规模较小的子问题,子问题之间相互独立且与原问题形式相同,可递归求解.分治通常用递归实现.
#### 3.1.3 应用场景
&ensp;分治法特征:
- 问题缩小到一定程度可容易解决.
- 问题可分解为若干个规模较小的相同问题,即问题具有最优子结构性质.
- 子问题的解可合并为该问题的解.
- 问题分解的子问题相互独立,子问题之间不包含公告子问题.

#### 3.1.4 步骤
&ensp;分治法一层递归步骤:
- 1) **分解**:将原问题分解为若干规模较小,相互独立,与原问题形式相同的子问题.
- 2) **解决**:若子问题可直接求解,则直接求解,否则递归解各个子问题.
- 3) **合并**:将各个子问题的解合并为原问题的解.
&ensp;
```c


```
#### 3.1.5 应用
> 分治思维方式：二分搜索;大整数乘法;合并排序;快速排序。

&ensp;求x的n次幂
&emsp;对数复杂度O(logn)
```c
int power(int x, int n)
{
    int result;
    if (n == 1) {
        return x;
    }
    if (n % 2 == 0) {
        result = power(x, n/2) * power(x, n / 2);
    } else {
        result = power(x, (n + 1) / 2) * power(x, (n - 1) / 2);
    }
    return result;
}
```

#### 3.1.6 leetcode题目

## 3.2 排序算法
&emsp;各种排序算法，主要包括：插入排序、快速排序、归并排序、计数排序和技术排序。二分查找，

### 3.2.1 冒泡排序
**冒泡排序算法复杂度是O(n^2)**
```c
static void bubleSort(int[] arr)
{
    int size = arr.length;
    // 
    for (int out = size - 1; out > 0; out--) {
        // 
        for (int in = 0; in < out; in++) {
            if (arr[in] > arr[in + 1]) {
                swap(arr, in, in + 1);
            }
        }
    }
}
```
### 3.2.2 选择排序
&emsp;选择排序算法时间复杂度为O(n^2)

```c
static void selectSort(int[] arr)
{
    int size = arr.lenght;
    //
    for (int out = 0; out < size; out++) {
        int mixIndex = out;
        //
        for (int in = out - 1; in < size; in++) {
            if (arr[mixIndex] > arr[in]) {
                mixIndex = in;
            }
        }

        if (mixIndex != out) {
            swap(arr, mixIndex, out);
        }
    }
}
```

### 3.2.3 插入排序
&emsp;插入排序每次从无序数据集合中取出一个元素，插入到已经排好序的数据集中适当位置，使数据集仍然有序。插入排序不需要额外空间。时间复杂度O(n2)

```c
static void insertSort(int[] arr)
{
    int size = arr.lenght;
    // 
    for (int out = 1; out < size; out++) {
        //
        int temp = arr[out];
        int in = out;
        //
        // 
        while (in - 1 >= 0 && arr[in - 1] > temp) {
            arr[in] = arr[in - 1];
            in--;
        }
        if (in != out) {
            arr[in] = temp;
        }
    }
}
```

```c
int issort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2))
{
    char *a = data;
    void *key;
    int i, j;

    if ((key = (char *)malloc(esize)) == NULL) {
        return -1;
    }

    for (j = 1; j < size; j++) {
        i = j - 1;

        while (i >= 0 && compare(&a[i * esize], key) > 0) {
            mamcpy(&a[(i + 1) * esize], &a[i * esize], esize);
            i--;
        }
        memcpy(&a[(i + 1) * esize], key, esize);
    }

    free(key);

    return 0;
}

```
### 3.2.4 希尔排序
&ensp;希尔排序时间复杂度O(n*(logn)^2)
```c
static void shellSort(int[] arr)
{
    int size = arr.lenght;
    int h = 1;
    while (h <= size / 3) {
        //
        h = h * 3 + 1;
    }
    while (h > 0) {
        for (int out = h; out < size; out++) {
            int temp = arr[out];
            int in = out;
            //
            while (in - h >= 0 && arr[in - h] > temp) {
                arr[in] = arr[in - h];
                in = in - h;
            }
            if (in != out) {
                arr[in] = temp;
            }
        }
        h = (h - 1) / 3;
    }
}
```
### 3.2.5 归并排序
&emsp;归并排序是一种分支排序算法。归并排序需要额外存储空间来完成排序。
```c
int min(int x, int y)
{
    return  x < y ? x : y;
}
void merge_sort(int arr[], int len)
{
    int *a = arr;
    int *b = (int *)malloc(len * sizeof(int));
    int seg, start;
    for (seg = 1; seg < len; seg += seg) {
        for (start )
    }
}

```
### 3.2.6 快速排序
&emsp;快速排序是一种分治排序算法。不需要额外存储空间，时间复杂度O(nlgn)

&emsp;快速排序三个步骤：
- 分：设定一个分割值并将数据分为两部分。
- 治：分别在两部分使用递归方式继续使用快速排序方法。
- 和：对分割部分排序直至完成。

```c
typedef struct _Range {
    int start;
    int end;
} Range;
Range now_Range(int s, int e)
{
    Range r;
    r.start = s;
    r.end = e;
    return r;
}

void swap(int *x, int *y)
{
    int t = *x;
    *x = *y;
    *y = t;
}

void quick_sort(int arr[], const int len)
{
    if (len <= 0) {
        return;
    }
    Range r[len];
    int p = 0;
    r[p++] = new_Range(0, len - 1);
    while (p) {
        Range range = r[--p];
        if (range.start >= range.end) {
            continue;
        }
        int mid = arr[(range.start + range.end) / 2];
        int left = range.start;
        int right = range.end;
        do {
            while (arr[left] < mid) {
                ++left;
            }
            while (arr[right] > mid) {
                --right;
            }
            if (left <= right) {
                swap(&arr[left], &arr[right]);
                left++;
                right--;
            }
        } while (left <= right);
        if (range.start < right) {
            r[p++] = new_Range(range.start, right);
        }
        if (range.end > left) {
            r[p++] = new_Range(left, range.end);
        }
    }
}

```


```c
void QuickSort(int *arr, int low, int high)
{
    if (low < high) {
        int i = low;
        int j = high;
        int k = arr[low];
        while (i < j) {
            // 从右向左找第一个小于k的数
            while (i < j && arr[j] >= k) {
                j--;
            }

            if (i < j) {
                arr[i++] = arr[j];
            }
            // 从左向右找第一个大于等于k的数
            while (i < j && arr[i] < k) {
                i++;
            }

            if (i < j) {
                arr[j--] = arr[i];
            }
        }
        arr[i] = k;

        // 递归调用
        QuickSort(arr, low, i - 1); // 排序k左边
        QuickSort(arr, i + 1, high); // 排序k右边
    }
}

void quick_sort( int *a, int n)
{
    int i, j, p, tmp;
    if (n < 2)  return;

    p = a[n / 2];   // Get the middle element as pivot ..

    for ( i = 0, j = n -1;; i++, j--) {
        while (a[i] < p)
            i++;
        while (p < a[j])
            j--;
        if ( i >= j)
            break;
        tmp = a[i]; a[i] = a[j]; a[j] = tmp;    //swap both ..
    }   

    quick_sort( a, i); 
    quick_sort( a + i, n - i); 
}

```
**qsort/sort函数**
&ensp;在c语言库函数中已经实现了qsort函数,
&emsp;qsort函数用法:
```c
void qsort(void *base, int nelem, int width, int (*fcmp)(const void *, const void *));
// 参数:1 带排序数组首地址, nelem 数组中待排元素数量  width 各元素所在空间大小  *fcmp 指向函数的指针
```

```c
// int 数组
int cmp(const void *a, const void *b)
{
    return (*(int *)a - *(int *)b);
}
qsort(arr, n, sizeof(arr[0]), cmp);

// char 数组
int com(const void *a, const void *b)
{
    return *(char *)a - *(char *)b;
}
char word[100];
qsort(word, 100, sizeof(word[0]), cmp);

// double 类型
int cmp(const void *a, const void *b)
{
    return *(double *)a > *(double*)b ? 1 : -1;
}
double in[100];
qsort(in, 100, sizeof(in[00]), cmp);

// struct 结构体
struct Sample {
    double data;
    int num;
}st[100];

int cmp(const void *a, const void *b)
{
    return (*(Sample *)a).data > (*(Sampel *)b).data ? 1 : -1;
}
qsort(s, 100, sizeof(s[0]), cmp);
// 
int cmp( const void *a , const void *b )
{
struct Sample *c = (Sample *)a;
struct Sample *d = (Sample *)b;
if(c->x != d->x) return c->x - d->x;
else return d->y - c->y;
}

qsort(s,100,sizeof(s[0]),cmp);

truct Sample
{
int data;
char str[100];
}s[100];

//按照结构体中字符串str的字典顺序排序

int cmp ( const void *a , const void *b )
{
return strcmp( (*(Sample *)a)->str , (*(Sample *)b)->str );
}

qsort(s,100,sizeof(s[0]),cmp);
```
### 3.2.7 堆排序
&emsp;桶排序算法基本原理：把数组中的所有元素分为若干个数据块，也就是若干个桶，然后对每个桶里的数据进行排序，最后将所有桶里的数据依次排列。
&emsp;存在两个问题：
&emsp;(1)怎样划分数据块，也就是分几个桶，每个桶放哪几个数据。
&emsp;(2)对每个数据块里的数据怎样排序。
```c
#include<sdtio.h>
#include<stdlib.h>

typedef struct node {
    int key;
    struct node *next;
} KeyNode;

void bucket_sort(int keys[], int size, int bucket_size) {
    int i, j;
    KeyNode **bucket_table = (KeyNode **)mallov(bucket_size * sizeof(KeyNode*));
    for(i = 0;i < bucket_size;i++) {
		bucket_table[i] = (KeyNode*)malloc(sizeof(KeyNode));
		bucket_table[i]->key = 0;
		bucket_table[i]->next = NULL;
	}
	for(j = 0;j < size;j++) {
		KeyNode *node = (KeyNode *)malloc(sizeof(KeyNode));
		node->key = keys[j];
		node->next = NULL;
		int index = keys[j]/10;
		KeyNode *p = bucket_table[index];
		if(p->key == 0) {
			bucket_table[index]->next = node;
			(bucket_table[index]->key)++;
		}else {
			while(p->next != NULL && p->next->key <= node->key)
				p = p->next;
			node->next = p->next;
			p->next = node;
			(bucket_table[index]->key)++;
		}
	}
	//print result
	KeyNode * k = NULL;
	for(i = 0;i < bucket_size;i++)
		for(k = bucket_table[i]->next;k!=NULL;k=k->next)
			printf("%d ",k->key);
	printf("\n");
}


int main()
{
	int raw[] = {49,38,65,97,76,13,27,49};
	int size = sizeof(raw)/sizeof(int);
	bucket_sort(raw,size,10);
}
```

```c
void Heapify(int A[] int i, int size)
{
    int lef_child = 2 * i + 1;
    int right_child = 2 * i + 2;
    int max = i;
    if (lef_child < size && A[lef_child] > A[max]) {
        max = lef_child;
    }
    if (right_child < size && A[right_child] > A[max]) {
        max = right_child;
    }
    if (max != i) {
        Swap(A, i max);
        Heapify(A, max, size);
    }
}

int BuildHeap(int A[], int n)
{
    int heap_size = n;
    for (int i = heap_size / w - 1; i >= 0; i--) {
        Heapify(A, i, heap_size);
        return heap_size;
    }
}

void HeapSort(int A[], int n)
{
    int heap_size = BuildHeap(A, n);
    while (heap_size > 1) {
        Swap(A, 0, heap_size);
        Heap(A, 0, heap_size);
    }
}
```

### 3.2.8 leetcode排序

## 3.3 贪心算法

### 3.3.1 基本概念
&ensp;贪心算法:在对问题求解时,总是做出在当前是最好的选择,即不考虑整体最优,仅考虑局部最优解.
&ensp;贪心算法没有固定算法框架,算法关键是贪心策略的选择.他想算法不是所有问题都得到最优解,选择贪心策略必须具备无后效性,即某个状态以后的过程不会影响一起的状态,只与当前状态有关.
### 3.3.2 描述
&ensp;贪心算法实现步骤:
&emsp;1.建立数学模型描述问题
&emsp;2.把求解的问题分成若干个子问题
&emsp;3.对每个子问题求解,得到子问题的局部最优解
&emsp;4.把子问题的解局部最优解合成原来问题的一个解.
&ensp;实现算法过程:
```c
while (能朝给定总目标前进一步)
{
    利用可行的决策,求出可行解的一个解元素;
}
由所有解元素组合成问题的一个可行解
```
### 3.3.3. 应用

&ensp;贪心算法经典实践:最小生成树算法

**最小生成树算法**

**Prim算法**


### 3.3.4 leetcode题目

## 3.4 动态规划
&ensp;动态规划(`DP`):是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.常用于重叠子问题和最优子结构性质的问题,动态规划时间通常远小于朴素解法.
### 3.4.1 基本概念
&ensp;动态规划:要解一个给定问题,需要解其不同部分(即子问题),再根据子问题的解以得出原问题的解.通常子问题非常相似,子问题解算出后,将其记录.
&ensp;动态规划过程是:每次决策依赖于当前状态,又随即引起状态转移.一个决策序列就是在变化的状态中产生除留的,这种多阶段最优化决策解决过程称为动态规划.
&ensp;动态规划与分治法的区别是子问题通常不是独立的.

### 3.4.2 描述算法
&ensp;可采用动态规划的问题3个性质:
&emsp;1) **最优化原理**:如果问题的最优解所包含的子问题的解也是最优的,则称该问题具有最优子结构,即满足最优化原理.
&emsp;2) **无后效性**:即某阶段状态确定后,就不受之后的决策影响,即某状态以后过程不影响以前的状态,只与当前状态有关.
&emsp;3) **有重叠子问题**:

<br>
&ensp;动态规划所处理的问题是一个多阶段决策问题,由初始状态开始,通过中间阶段决策的选择,达到结束状态.形成一个决策序列.

&ensp;动态规划求解三要素:
> (1) 问题的节点
> (2) 每个阶段的状态
> (3) 从前一个阶段转化到后一个阶段之间的递推关系

&ensp;**最优决策表**
> f(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}

### 3.4.3 背包问题


&ensp;状态转移方程:
> p[i][j] = max{p[i-1][j-vol] + value[i], p[i-1][j]}

### 3.4.4 最长公共子序列


### 3.4.5 leetcode题目

## 3.5 回溯法


### 3.5.1 基本概念

### 3.5.2 八皇后问题



### 3.5.3 leetcode题目


## 4 参考链接

- 复杂度速查表
https://liam.page/2016/06/20/big-O-cheat-sheet/
- 线性表
https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%R8%A1%A8



