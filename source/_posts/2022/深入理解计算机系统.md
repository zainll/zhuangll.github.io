---
title: 深入理解计算机系统
date: 2022-02-27 00:47:53
updated: 2022-02-27 00:53:53
categories: 
    - tool
tags: 
    - 实用教程
    - Another Tag
---


[toc]
# 深入理解计算机系统

## 第1章 计算机系统

<!--more-->

1. hello world程序分析

&emsp;&emsp;hello.c编译

![20220608231046](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608231046.png)

&emsp;&emsp;编译系统：预处理器cpp、编译器ccl、汇编器as和链接器ld

2. 计算机系统硬件组成：总线，I/O设备，主存，处理器
![20220608231607](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608231607.png)

3. CPU 在指令的要求下执行操作：加载、存储、操作和跳转

4. hello程序加载
&emsp;&emsp;从键盘上读取 hello 命令,从磁盘加载可执行文件到主存,将输出字符串从存储器写到显示器

5. 高速缓存存储器cache：L1 L2 L3(SRAM)
![20220608232141](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232141.png)


6. 存储设备层次结构
![20220608232321](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232321.png)


7. 操作系统有两个基本功能：（1)防止硬件被失控的应用程序滥用；（2 )向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备
![20220608232459](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232459.png)

&emsp;&emsp;操作系统通过几个基本的抽象概念：**进程、虚拟内存和文件**
![20220608232435](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232435.png)

&emsp;&emsp;Posix 标准：Unix 系统调用的 C 语言接口、shell 程序和工具、线程及网络编程

&emsp;&emsp;进程：操作系统对一个正在运行的程序的一种抽象，操作系统实现进程交错执行的机制称为上下文切换

&emsp;&emsp;操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括 PC 和寄存器文件的当前值，以及主存的内容

&emsp;&emsp;系统调用会将控制权传递给操作系统


&emsp;&emsp;从一个进程到另一个进程的转换是由操作系统内核（kernel )管理的。内核是操作系统代码常驻主存的部分


&emsp;&emsp;读写文件，执行一条系统调用（system call)指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序

&emsp;&emsp;内核不是一个独立的进程。是系统管理全部进程所用代码和数据结构的集合

&emsp;&emsp;线程：每个线程都运行在进程的上下文中，并共享同样的代码和全局数据

&emsp;&emsp;虚拟内存
![20220608232704](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232704.png)


&emsp;&emsp;程序代码和数据，堆，共享库，栈，内核虚拟内存，

&emsp;&emsp;文件 &emsp;&emsp;I/O 设备是文件


8. 系统之间网络通信

9. Amdahl定律

&emsp;&emsp;对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度


10. 并发和并行

&emsp;三个层次：
- 线程级并发
- 指令级并行
- 单指令、多数据并行


11. 计算机系统中抽象
![20220608232955](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232955.png)
 

<br>



# 程序结构和执行

&emsp;&emsp;处理器和存储子系统，基本数据结构，指令操作，编译器翻译

## 第2章 信息的表示和处理
### 2.1 信息表示
1. 十六进制
x是2的非负整数n次幂时，x=2”，我们可以很容易地将 x 写成十六进制形式，只要记住 X 的二进制表示就是1后面跟n个0， 2^9 = 512   0x200
2. 字节序
&emsp;&emsp;低有效字节在最前面的方式，称为小端法
&emsp;&emsp;最高有效字节在最前面的方式，称为大端法
&emsp;&emsp;x01234567 大端01 23 45 67 小端 67 45 23 01

3. 位运算与逻辑运算
&emsp;&emsp;位运算&与 |或 ~非 异或 
&emsp;&emsp;逻辑运算：&&与  ||或  !非 
无符号，补码，浮点数

4. 移位运算
&emsp;&emsp;算数右移和逻辑右移

### 2.2 整数表示
&emsp;&emsp;有符号数和无符号数
&emsp;&emsp;补码计算公式
[![20220609225345](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220609225345.png)](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220609225345.png)
&emsp;&emsp;C 库中的文件<limits.h>定义了一组常量，来限定编译器运行的这台机器的不同整型数据类型的取值范围。常量 INT_MAX、INT_MIN 和UINT_MAX,
&emsp;&emsp;stdint.h 中uintl6_t，int32_t定义指定位数类型。
```c
#define INT_MAX 2147483647
#define INT.MIN (-INT_MAX 1)
```


### 2.3 整数运算
计算机执行的 “整数” 运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出

### 2.4 浮点数
![20220609233406](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220609233406.png)

浮点表示通过将数字编码为: x*2〃的形式来近似地表示实数




<br>

## 第3章 程序的机器级表示
&emsp;计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、 读写存储设备上的数据，以及利用网络通信 

### 3.1 机器码
1. 指令集体系结构或指令集架构(Instruction Set Architecture,ISA)定义机器级程序的格式和行为，定义了处理器状态、指令的格式，已经每条指令对状态的影响。

&emsp;机器级程序使用的内存地址是虚拟地址，内存模型看做一个大字节数组。

&ensp;处理器状态：
- 程序计数器(PC x86-64中%rip)给出将要执行的下一条指令在内存中的地址
- 整数寄存器文件包含16个命名的位置,分别存储64位的值.
- 条件码寄存器保存着最近执行的算数或逻辑指令的状态信息.
- 一组向量寄存器可存放一个或多个整数或浮点数值.

```sh
# -S 产生汇编代码 生成 .s 文件
gcc -Og -S mstore.c
# -c 编译并汇编  产生 .o 文件
gcc -Og -c mstore.c
# 反汇编 
objdump -d mstore.o

```

&emsp;x86-64指令长度从1到15字节不等.
&emsp;反汇编器基于机器代码文件中的字节序列确定汇编代码
&emsp;汇编代码中以 以.开头的行都是指导汇编器和链接器工作的伪指令
&emsp;C语言中插入汇编代码:1)独立汇编文件,用汇编器和链接器把它和C语言代码合并.2)使用GCC的内联汇编特性,用asm伪指令在C程序中包含汇编代码
&emsp;数据传送指令四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)和movq(传送四字)

### 3.2 处理器访问
&emsp;x86-64的中央处理器(CPU)包含一组16个存储64位值的通用目的寄存器。%r开头，%rax-%rbp
![20220611014655](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220611014655.png)

&emsp;栈指针%rsp，用来指明运行时栈的结束位置

&emsp;复制和生成 1 字节、2 字节、4 字节和 8 字节值。当这些指令以寄存器作为目标时，对于生成小于 8 字节结果的指令，寄存器中剩下的字节会怎么样，有两条规则：生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；生成 4 字节数字的指令会把高位 4 个字节置为 0。
#### 3.2.1 指令操作和类型
&emsp;指令操作数：指令操作使用的源数据值，以及放置结果的目的位置。操作数三种类型：立即数(immediate)、寄存器(register)和内存引用。

![20220613224202](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613224202.png)



&emsp;**数据传送指令**
- MOV类：movb，movw，movl和movq
![20220613224634](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613224634.png)

&emsp;&emsp;源操作数类型：立即数，寄存器值和内存中的值，目的操作数：指定位置，寄存器，内存地址，x86-64中源操作数和目的操作数不能同为内存地址。
- MOVZ类指令把目的中剩余资金填充位0
- MOVS类指令通过符号扩展来填充，把源操作数高位进行复制。
- cltq指令：总以寄存器%eax作为源，%rax作为符号扩展结果的目的

*指针简介引用，&取址

#### 3.2.2 压入和弹出栈数据
&emsp;pushq操作把数据压入栈中，popq指令弹出数据；栈向下增长，栈顶元素在低地址，栈指针%rsp保存栈顶元素地址。
![20220613231258](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613231258.png)

### 3.3 算术和逻辑操作
&emsp;加法指令ADD类：addb、addw、addl和addq
&emsp;四组操作：加载有效地址、一元操作、二元操作和移位
![20220613231925](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613231925.png)

&emsp;leaq 将有效地址写入到目的操作数。
&emsp;一元操作：只有一个操作数，即是源又是目的。
&emsp;二元操作：第二个操作数既是源又是目的。
&emsp;移位操作：先给出移位量，然后第二项给出的是要移位的数。算术和逻辑右移。移位量是个立即数，或者但自己寄存器%c1中。左移：SAL和SHL；右移：SAR和SHR

&emsp;特殊算数操作
![20220613234132](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613234132.png)


### 3.4 控制指令
&emsp;两种基本条件行为：测试数据值，然后根据曹氏结果来改变控制流或数据流。
#### 3.4.1 条件码(condition code)寄存器
- CF：进位标志
- ZF：零标志
- SF：符号标志
- OF：溢出标志

&emsp;两类设置条件码指令：
- CMP指令：根据两个操作数之差来设置条件码
- TEST指令：与AND(&)指令一样，但仅设置条件码

&emsp;访问条件码：1)条件码的某种组合SET指令 2)条件跳转 3)条件传送数据


&emsp;跳转指令jump
- jmp无条件跳转指令：直接跳转和间接跳转
```sh
# 用寄存器%rax中的值作为跳转目标
jmp *%rax
# 以%rax中的值作为读地址，从内存中读取跳转目标
jmp *(%rax)
```
![20220614000119](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220614000119.png)

&emsp;当执行 PC 相对寻址时，程序计数器的值是跳转指令后面的那条指令
的地址，而不是跳转指令本身的地址

&emsp;为什么基于条件数据传送(条件赋值)的代码会比基于条件控制转移的代码性能要好？
- 分支预测是条件表达式50%的正确率，x86-64分支预测错误惩罚19个时钟周期。
- 无论测试数据是什么，编译出使用条件传送代码所需的时间8个时钟周期。控制流不依赖于数据，处理器更容易保持流水线是满的。

&emsp;条件传送指令
![20220614002405](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220614002405.png)



#### 3.4.2 循环

&emsp;条件测试和跳转组合实现循环

- do-while循环
```sh
loop:
    bogy-statement
    t = text-expr;
    if (t)
        goto loop

```

- while 循环
```sh
goto test;
loop: 
    body-statement
test:
    t = text-expr;
    if (t)
        goto loop;


t = text-expr
if (!t)
    got done;
do 
    body-statement
    while(test-expr);
done
```

- for循环

```sh
init-expr;
got test;
loop:
    body-statement
    update-expr;
test:
    t = test-expr;
    if (t)
        goto loop;


init-expr;
t = test-expr;
if (!t)
    goto done;
loop:
    body-statement
    update-epxr;
    t = test-expr;
    if (t)
        goto loop;
done

```


#### 3.4.2 switch语句
&emsp;switch(开关)语句可以根据一个整数索引值进行多重分支（multiway branching)。使用跳转表(jump table)数据结构使得实现更加高效,跳转表是一个数组，表项i是一个代码段的地址。和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关
&emsp; .rodata（只读数据，Read-Only Data)的目标代码文件的
段中


### 3.5 过程
&emsp;过程：函数，方法，子例程，处理函数。
&emsp;过程切换：传递控制，传递数据，分配和释放内存

- 运行时栈
![20220616003644](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616003644.png)

&emsp;栈向低地址方向增长，栈指针%rsp指向栈顶元素。pushq和popq指令将数据压栈和出栈。运行栈划分成栈帧，被调函数返回地址属于调用函数栈帧。

- 转移控制
&emsp;将程序计数器(PC)设置为转移目的代码起始位置。
&emsp;call Q调用过程
![20220616004340](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616004340.png)
&emsp;call指令，指明被调用过程起始的指令地址,直接调用的目标是标号,间接调用的目标是*后面跟一个操作数指示符.call将返回地址压入栈中,并跳转到函数的第一条指令.

- 数据传送
&emsp;大部分数据传送通过寄存器实现,返回值通过%rax寄存器.
&emsp;x86-64中通过寄存器最多传递6个整型参数,超出部分通过栈传递,栈顶数据大小都向8的倍数对齐。ARMv8通过寄存器最多可传递8个参数。
![20220616005655](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616005655.png)

&emsp;栈上局部存储：超出寄存器数量，局部变量地址&，局部变量数组或结构
&emsp;寄存器中的局部存储空间：寄存器组，寄存器%rbx、%rbp和%r12-%r15为被调用者保存寄存器。被调用这必须保存这些寄存器值，不改变值或入栈返回前恢复。其他寄存器由调用者保存。
&emsp;每次函数调用由字节私有的状态信息（保存的返回值位置和被调用这保存寄存器的值）存储空间。
&emsp;递归过程与普通调用一致

### 3.6 数组分配与访问
&emsp;数组声明：T A[N]
&emsp;x86-64内存引用指令可简化数组访问
```sh
# E[i] E地址在寄存器%rdx中，i值在寄存器%rcx中  x + 4i
movl (%rdx, %rcx, 4), %eax
```

&emsp;指针运算
&emsp;单操作符&和*可产生指针和间接引用指针
![20220616012142](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616012142.png)
&emsp;嵌套数组(多维数组)
&emsp;定长数组 #define N 1
&emsp;变长数组 malloc

### 3.7 结构struct和联合union
- struct
&emsp;指向结构的指针就是结构第一个字节的地址,结构信息每个字段（field)的字节偏移

- union
&emsp;联合能够规避c语言的类型系统，允许以多种类型引用一个对象


- 数据对齐
&emsp;x86-64数据类型对齐
![20220616013159](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616013159.png)
```sh
# 保证起始地址是8的倍数
.align 8 
```

### 3.8机器级程序中控制和数据结合
- 指针
&emsp;指针类型，指针值，指针创建&，指针间接引用*，数组与指针，指针强制类型转换，函数指针(*f)()

- GDB
```sh
gdb prog

```
![20220616013902](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616013902.png)

- 内存越界引用和缓冲区溢出
&emsp;数组越界访问
&emsp;字符串长度超过分配的数组空间

&emsp;防止缓冲区溢出：栈随机化，栈破坏检测，限制可执行代码区域，变长栈帧


### 3.9 浮点代码
&emsp;MMX-SSE-SSE2-AVX-AVX2
&emsp;AVX浮点体系16个YMM寄存器%ymm0-%ymm15,256bit(32字节)
![20220616014704](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616014704.png)

&emsp;浮点传送和转换
![20220616014723](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616014723.png)

&emsp;浮点运算
![20220616014839](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616014839.png)

<br>

x86-64 机器代码
控制结构（比如条件、循环和开关语句）生成的基本指令模式
括栈分配、寄存器使用惯例和参数传递
数据结构（如结构、联合和数组）的分配和访问方式
整数和浮点数算术运算的指令
代码安全漏洞（例如缓冲区溢出）

<br>

## 第4章 处理器体系结构

&ensp;处理器支持的指令和指令的字节级编码称为指令集体系结构(Instruction-Set Architecture ISA)
&ensp;HCL(Hardware Control Language硬件控制语言)

### 4.1 Y86-64指令集

![20220617004032](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617004032.png)

Y86-64 指令
- movq指令分成4中：irmovq,rrmovq,mrmovq和rmmovq;i立即数，r寄存器，m内存
- 整数操作指令4个：addq,subq,andq和xorq;可设置条件吗ZF(零)，SF(符号)和OF(溢出)
- 跳转指令7条：jmp、 jle、 jl、 je、 jne、 jge 和 jg
- 6个条件传送指令: cmovle、cmovl、cmove、 cmovne、
cmovge 和 cmovg。
- call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的调用中返回
- pushq 和 popq 指令实现了人栈和出栈
-  halt 指令停止指令的执行

&ensp;CISC(复杂指令集)和RISC(精简指令集)
&emsp;RISC寻址方式简单:机制和便宜了寻址，只能对寄存器操作数进行算数和逻辑运算，内存引用仅有load和store

&emsp;状态码Stat，程序执行的总体状态
![20220617005952](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617005952.png)

以.开头的词是汇编器伪指令（assembler directives)，它们告诉汇
编器调整地址，以便在那儿产生代码或插人一些数据。

push %rsp指令行为：1)压人％rsp 的原始值，2)压人减去 8 的红印的值

### 4.2 逻辑设计和硬件控制语言HCL

- 逻辑门 与 或 非

![20220617010845](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617010845.png)

逻辑门组成组合电路

存储器和时钟 
&emsp;两类存储设备：时钟寄存器(寄存器)和随记访问存储器(内存)
&ensp;处理器随机访问存储器来存储程序数据
![20220617012336](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617012336.png)

SEQ("se-quential" 顺序的）的处理器

操作阶段：
- 取值fetch:从内存读取指令字节，地址为程序计数器（PC)的值,从指令中取出指令指示符字节的两个四位部分，称为 icode(指令代码）和 ifun(指令功能）。
- 译码decode: 译码阶段从寄存器文件读人最多两个操作数
- 执行execute: 执行阶段，算术/逻辑单元（ALU)要么执行指令指明的操作（根据 ifun 的值），计算内存引用的有效地址，要么增加或减少栈指针
- 访存memory: 访存阶段可以将数据写人内存，或者从内存读出数据
- 写回: 最多可以写两个结果到寄存器文件
- 更新PC: 将 PC 设置成下一条指令的地址。


SEQ引进结构

![20220621004444](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621004444.png)

![20220621004430](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621004430.png)

控制处理器中活动的时序原则：从不回读，

取指阶段
![20220621003818](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003818.png)


译码和写回阶段
![20220621003858](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003858.png)

执行阶段
![20220621003917](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003917.png)

访存阶段
![20220621003932](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003932.png)

更新PC阶段
![20220621003949](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003949.png)



### 流水线

吞吐量：每秒千兆条指令（GIPS)

各个阶段之间放上流水线寄存器（pipeline register)
现代处理器采用了很深的(15 或更多的阶段)流水线

带反馈流水线系统
指令执行顺序相关：
- 数据相关
- 控制相关

SEQ+
![20220621004527](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621004527.png)

PIPE
![20220621225618](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621225618.png)

预测下一个 PC

猜测分支方向并根据猜测开始取指的技术称为分支预测，预测 PC 的新值为 valG

流水线冒险
相关有两种形式：1)数据相关，下一条指令会用到这一条指令计算出的结果；2)控制相关，一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时
冒险也可以分为两类：数据冒险（data hazard)和控制冒险(control hazard)

对于Y86-64 来说，程序状态包括程序寄存器、程序计数器、内存、条件码寄存器和状态寄存器

异常处理
Y86-64 包括三种不同的内部产生的异常：l)halt 指令，2)有非法指令和功能码组合的指令，3)取指或数据读写试图访问一个非法地址
导致异常的指令称为异常指令（excepting instruction)

PIPE 各阶段的实现
PC 选择和取指阶段
译码和写回阶段
执行阶段
访存阶段

CPI(Cycles Per Instruction, 每指令周期数）

<br>
第四章流水部分还需要继续阅读

基本的组合和时序逻辑元素
流水线
五阶段处理器流水线







<br>

## 第5章 优化程序性能

&ensp;高性能程序：1)数据结构与算法选择 2)编译器能够优化 3)计算分解，并行化

### 5.1 优化编译器
&ensp;GCC 编译选项 -Og -O1 -O2 -O3
&ensp;两个指针可能指向同一个内存位置的情况称为内存别 名使用（memory aliasing)
&ensp;包含函数调用的代码可以用一个称为 内联函数替换（inline substitution, 或 者简称"内联（inlining)"）的过程进行优化

&ensp;程序性能表示 CPE每元素的周期数（Cycles Per Element, CPE)


&ensp;消除循环的低效率:循环条件判断中使用数值，而不是表达式
&ensp;减少过程调用：将调用移出循环
&ensp;消除不必要的内存引用：把中间结果存在临时变量中，最后在赋给引用地址

### 5.2 现代处理器

指令并行
两种下界描述了程序的最大性能:延迟界限(latency bound)和吞吐量界限(throughpu bound)
&ensp;超标量：每个时钟周期执行多个操作
&ensp;乱序：指令的顺序不一定与机器级程序中的顺序一致
&ensp;处理器设计两个主要部分：指令控制单元(ICU)和执行单元(EU)
![20220622221549](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220622221549.png)

&ensp;分支预测(branch prediction):处理器会猜测是否选择分支，还预测分支的目的地址
&ensp;投机执行（speculative execution)冒险？ 处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码
&ensp;Intel Core i7 Haswell 有 8 个功能单元:
&emsp;0 整数运算、浮点乘、整数和浮点数除法、分支
&emsp;1 整数运算、浮点加、整数乘、浮点乘
&emsp;2 加载、地址计算
&emsp;3 加载、地址计算
&emsp;4 存储
&emsp;5 整数运算
&emsp;6 整数运算、分支
&emsp;7 存储、地址计算

任何对程序寄存器的更新都只会在指令退役时才会发生
控制操作数在执行单元间传送的最常见的机制称为寄存器重命名（register renaming)：值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来，
重命名表只包含关于有未进行写操作的寄存器条目。

&ensp;运算性能：
- 延迟：完成运算所需总时间
- 发射时间：两个联系同类型运算直接最小时间周期数
- 容量：能够执行该元素的功能单元的数量

数据流(data-flow)，关键路径(critical path)



循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。编译器GCC优化等级-O3

### 5.3 提高并行性
对于一个可结合和可交换的合并运算来说，比如说整数加法或乘法，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能
浮点乘法和加法不是可结合的

重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能力得到更好的性能。

极大化对向量元素加或者乘的函数性能

制约程序性能的一些限制因素：寄存器溢出，并行度p超过寄存器数量；分支预测和预测错误处罚


### 5.4 内存性能
加载的性能：对两个加载单元而言，其每个时钟周期只能启动一条加载操作，所以 CPE 不可能小于 0.50
存储的性能：每个周期开始一条新的存储

![20220622235348](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220622235348.png)



### 5.5 性能提高技术

1）高级设计：为问题选择适当的算法和数据结构
2）编码原则：消除连续的函数调用；消除不必要的内存引用
3）低级优化：展开循环；使用多个累积变量和重新结合等，提高指令并行；功能性的风格重写条件操作

基准数据（benchmark data}
Unix 系统提供了一个剖析程序 GPROF
Linux 系统上 VALGRIND�
循环展开、创建多个累积变量和重新结合，它们可以利用现代处理器
提供的指令级并行
<br>

减少程序需要做的工作的变换 
指令级并行度的变换
现代乱序处理器是如何工作的



<br>


## 第6章 存储器层次结构

存储器层次结构
局部性（locality)
存储技术棗 SRAM 存储器、DRAM 存储器、ROM 存储器以及旋转的和固态的硬盘

### 6.1 随机访问存储器
&ensp;随机访问存储器（Random-Access Memory, RAM)分为两类：静态的和动态的。静态AM(SRAM)比动态 RAM(DRAM)更快，SRAM 用来作为高速缓存存储器，可在CPU芯片上，也可在片下。
&ensp;SRAM每个位存储在一个双稳态的（bistable)存储器单元
&ensp;DRAM 将每个位存储为对一个电容的充电
&ensp;行地址i称为 RAS(Row Access Strobe, 行访问选通脉冲）请求。列地址j称为 CAS(Cÿlumn Access Strobe, 列访问选通脉冲）请求。注意，RAS 和 CAS 请求共享相同的 DRAM 地址引脚
&ensp;双倍数据速率同步 DRAM(Double Data-Rate Synchronous DRAM, DDR SDRAM)
&ensp;SRAM和DRAM都是易失的,ROM非易失的
&ensp;只读存储器（Read-Only Memory, ROM)
&ensp;可擦写 可编程 ROM(Erasable Programmable ROM, EPROM)
&ensp;闪存（flash memory)是一类非易失性存储器，基于 EEPROM

&ensp;总线事务(bus transaction)。读事务（read transaction)从主存传送数据到CPU写事务（write transaction)从CPU传送数据到主存。
&ensp;地址、数据和控制总线

&ensp;IO总线：PCI、PCIE、USB

&ensp;CPU 使用一种称为内存映射 I/O(memory-mapped I/O)的技术来向 I/O 设备发射命令。内存映射 I/O 的系统中，地址空间中有一块地址是为与 I/O 设备通信保留的。每个这样的地址称为一个 I/O 端口（I/O port)，当一个设备连接到总线时，它与一个或多个端口相关联(或它被映射到一个或多个端口）
&ensp;直接内存访问(Direct Memory Access DMA)

&ensp;固态硬盘
![20220629003932](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629003932.png)
&emsp;读SSD比写要快


### 6.2 局部性
&ensp;局部性原理（principle of locality)：倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身
&ensp;时间局部性（temporal locality) 和空间局部性（spatial
locality)
&ensp;时间局部性的程序中，被引用过一次的内存位置很可能在不远
的将来再被多次引用
&ensp;空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置
&ensp;数据引用的局部性，取指令的局部性
&ensp;局部性原则：重复引用相同变量；步长为々的引用模式的程序，步长越小，空间局部性越好；取指令来说，循环有好的时间和空间局部性

### 6.3 存储层次结构

存储器层次结构
![20220629005430](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629005430.png)

&ensp;高速缓存cache
存储器被划分成连续的数据对象组块（chunk), 称为块（block)。
数据总是以块大小为传送单元（transfer unit)在第k层和第;k+1 层之间来回复制的
缓存命中和缓存不命中(cache miss)
替换策略：最近最少被使用（LRU)替换策略的缓存会选择那个最后被访问的时间距现在最远的块
缓存不命中的种类
- 强制性不命中（compulsory miss)或冷不命中（cold miss)：空的缓存有时被称为冷缓存（cold cache)
- 冲突不命中（conflict miss)：限制性的放置策略会引起一种不命中
- 容量不命中（capacity miss)：工作集的大小超过缓存的大小
![20220629010259](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629010259.png)

高速缓存被组织成一个有 S=2^s个高速缓存组（cache set)的数组。每个组包含 £个高速缓存行（cache line)， 每个行是由一个 B =2^b 字节的数据块(block)组成的，一个有效位（valid bit)指明这个行是否包含有意义的信息，还有 t=m-(b+s)个标记位（tag bit)(是当前块的内存地址的位的一个子集》s 它们唯一地标识存储在
这个高速缓存行中的块。
![20220629010749](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629010749.png)
高速缓存的结构可以用元组（S,E,B,m)来描述

![20220629010927](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629010927.png)

&ensp;高速缓存请求名字，抽取被请求子过程：1)组选择 2)行匹配 3)字抽取

&ensp;组相联高速缓存： 1<E<C/B 称为E路组相联高速缓存
![20220629225753](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629225753.png)
组相连替换最不常使用(Least-Frequently-Used,LFU)策略会替换在过去某个时间窗口内引用次数最少的那一行。最近最 少使用(Least-Recently-Used LRU)策略会替换最后一次访问时间最久远的那一行。

&ensp;全相联高速缓存： 包含所有高速缓存行的组（即 E=C/B)组成
![20220629230138](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629230138.png)

![20220629230242](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629230242.png)


写的问题：直写，写回，写分配
i-cache和d-cache
高速缓存性能指标：不命中率(miss rate)，命中率(hit rate)，命中时间(hit time)，不命中出发(miss penalty)
块：固定大小，cache与主存之间传送
行：cache的一个存储单元？
组：一个或者多个含的集合
编写高速缓存友好代码：对局部变量反复引用；步长为1的引用模式


高速缓存与程序性能一个程序从存储系统中读数据的速率称为读呑吐量(read throughput) 或者有时称为读带宽(read bandwidth)
利用时间局部性，使得频繁使用的字从 L1 中取出，还要利用空.间局部性，使得尽可能多的字从一个L1 高速缓存行中访问到

存储器层次结构对程序编写指导：
- 注意力集中在内循环上
- 按照数据对象存储在内存中的顺序、以步长为 1 的来读数据，从而使得你程序中的空间局部性最大
- 从存睹器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大


<br>
基本存储技术包括随机存储器(RAM)、非易失性存储器（ROM)和磁盘。RAM 有两种基本类型。静态RAM(SRAM)快一些，用做 CPU 芯片上的髙速缓存，也可以用做芯片下的高速缓存；动态 RAM(DRAM)慢一点，用做主存和图形帧缓冲区；在关电的时候,ROM 也能保持它们的信息；


随机存取存储器（RAM)和只读存储器(ROM) 及磁盘和固态硬盘
时间局部性和空间局部性来提高应用程序的性能




<br>

# 在系统上运行程序

## 第7章 链接

&ensp;链接可以执行于编译时,也可以在源代码翻译成机器代码时；也可以执行于加载时(dynamorio中的链接在执行时)，即程序被加载器加载到内存并执行时；也可以执行与运行时。静态链接和加载时的共享库动态链接，运行时共享库动态链接

![20220701231510](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220701231510.png)

```sh
# 编译
gcc -Og -o prog main.c sum.c

# 预处理
cpp [可选] main.c main.i
# 编译
ccl main.i -Og [可选] -o main.s
# 汇编  >>可重定位目标文件
as [] -o main.o main.s
# 链接 >>可执行目标文件
ld -o prog [] main.o sum.o
# 执行
./prog
```

### 7.1 静态链接
&ensp;链接器生成可执行文件两个过程：
- 符号解析
- 重定位：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置

&ensp;目标文件三种形式：
- 可重定位目标文件：包含二进制代码和数据
- 可执行目标文件：包含二进制代码和数据，可直接复制到内存并执行
- 共享目标文件：特殊可重定位目标文件，可在加载或运行时被动态地加载进内存并链接
&ensp;Unix a.out格式，windows可移植可执行(PE)格式，linux 可执行可链接格式(ELF)

&ensp;可重定位目标文件
![20220701232932](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220701232932.png)
&ensp;ELF头(ELF header)以一个16字节的序列开始,描述生成该文件的系统的字的大小和字节顺序;帮助链接器语法分析和解释目标文件的信息，包括ELF头大小、目标文件类型(可重定位、可执行或共享的)、机器类型、节头部表的文件便宜，节头部表中条目的大小和数量。
&ensp;夹在 ELF 头和节头部表之间的都是节
&ensp;ELF可重定位目标文件包含的节：
- .text : 编译程序的机器代码
- .rodata: 只读数据，格式串和开关语句的跳转表
- .data: 已初始化的全局和静态 C 变量
- .bss : 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量
- .symtab: 符号表，存放在程序中定义和引用的函数和全局变量的信息
- .rel.text: 一个.text 节中位置的列表
- .rel.data： 被模块引用或定义的所有全局变量的重定位信息
- .debug：调试符号表，其条目是程序中定义的局部变量和类型定义
- .line： 调试符号表，其条目是程序中定义的局部变量和类型定义 __LINE__
- .strtab: 字符串表



&ensp;符号表：全局符号，外部符号和局部符号
&ensp;符号表是由汇编器构造的，使用编译器输出到汇编语言.s 文件中的符号。.symtab节中包含ELF符号表。
&ensp;有三个特殊的伪节（pseudosection), 它们在节头部表中是没有条目的：ABS 代表不该被重定位的符号；UNDEF 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号；COMMON 表示还未被分配位置的未初始化的数据目标
&ensp;符号解析：连接器解析符号

编译器向汇编器输出每个全局符号，或者是强(strong)或者是弱(weak)，Linux 链接器来处理多重定义的符号名规则
&ensp;编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库(static library)
&ensp;相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以过在命令行上指定单独的文件名字来使用这些在库中定义的函数
```sh
# 创建静态库
gcc -c addvec.c multvec.c
# AR工具
ar rcs libvector.a addvex.op multvec.o
# 使用静态库，包含头文件
gcc -c  main2.c
gcc -static -o prog2c main2.o ./libvector.a
# 等价
gcc -c main2.c
gcc --static -o prog2c main2.o -L. -lvector
```

![20220708002734](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708002734.png)



### 7.2 重定位
&ensp;重定位由两步组成：
&emsp;重定位节和符号定义：合并节为聚合节，为聚会节赋运行时内存地址，为符号赋地址
&emsp;重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址
&ensp;重定位条目
&emsp;汇编时汇编器不知道外部函数或全局变量的位置，未知目标引用即为重定位条目，代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中
![20220708003652](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708003652.png)
&ensp;ELF 定义了 32 种不同的重定位类型,两种最基本的
重定货类型：
- R_X86_64_PC32 重定位一个使用32位PC相对地址的引用
- R_X86_64_32 重定位一个使用32位绝对地址的引用

重定位PC相对引用
重定位绝对引用


### 7.3 可执行目标文件

![20220708004108](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708004108.png)
ELF 头描述文件的总体格式。它还包括程序的入口点（entry point), 也就是当程序运行时要执行的第一条指令的地址。.text、.rodata 和.data 节与可重定位目标文件中的节是相似的，init 节定义了一个小函数，叫做_init， 程序的初始化代码会调用它
可执行文件的连续的片（chunk)被映射到连续的内存段。程序头部表（program header table)描述了这种映射关系

加载可执行目标文件
```sh
./prog
```
&ensp;shell 认为 prog 是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它。linux程序可通过调用execve函数来调用加载器，加载器加可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。

&ensp;在 Linux X86-64系统中，代码段总是从地址 0x400加0 处开始，后面是数据段,运行时堆在数据段之后，通过调用 malloc 库往上增长。后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址(2^48 —1)开始，向较小内存地址增长。栈上的区域，从地址 2^48 开始，是为内核（kernel)中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分

![20220708004746](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708004746.png)

加载器运行时在程序头部表的引导下,加载器将可执行文件的片(chunk)复制到代码段和数据段。加载器跳转到程序的入口点，即_start函数的地址，这个函数是在系统目标文件 Ctrl.o 中定义的，对所有的 C 程序都是一样的。_start 函数调用系统启动函数 __libc_start_main，该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核
&ensp;父进程创建一个fork子进程，子进程通过execve系统调用启动加载器，加载器删除子进程现有的 虚拟内存段，并创建一组新的代码、数
据、堆和栈段。


### 7.4 动态链接共享库
&ensp;共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking), 是由一个叫做动态链接器(dynamic linker)的程序来执行的。共享库也称为共享目标(shared object)，在 Linux 系统中通常用 .so后缀来表示,windows中用DLL


![20220709000956](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220709000956.png)

```sh
# -fpic 编译器生成与位置无关代码
gcc -shared -fpic -o libvector.so addvec.c multvec.c
```
&ensp;动态链接器通过执行重定位完成链接任务
&ensp;Linux 系统动态链接器接口
```c
#include<dlfcn.h>

void *dlopen(const char *filename, int flag);

// dlsym 函数的输人是一个指向前面已经打开了的共享库的句柄和一个 symbol 名字,如果该符号存在，就返回符号的地址，否则返回 NULL
void *dlsym(void *handle, char *symbol);

int dlclose(void *handle);

const char *dlerror(void);
```

&ensp;可加载而无需重定位的代码称为位置无关代码(PIC)
&ensp;数据段与代码段的距离总是保持不变,数据段开始的地方创建了一个表，叫做全局偏移量表(Global Offset Table, GOT)
&ensp;延迟绑定(lazy binding), 将过程地址的绑定推迟到第一次调用该过程时。过程链接表(Procedure Linkage Table, PLT)

Linux 链接器支持库打桩(library interpositioning), 允许截获对共享库函数的调用，取而代之执行自己的代码。打桩可以发生在编译时、链接时或当程序被加载和执行的运行时

```sh
# 编译时打桩
gcc -DCOMPILETIME -c mymalloc.c
gcc -I. -o intc int.c mymalloc.o

# 链接时打桩
gcc -DLINKTIME -c mymallo.c
gcc -c int.c
gcc -Wl, --wrap, malloc -Wl, --wrap, free -o initl int.o mymalloc.o

# 运行时打桩
gcc -DRUNTIME -shared -fpic ~o mymalloc.so mymalloc.c -ldl

```

处理目标文件的工具,GNUbinutils 包
- AR 创建静态库，插人、删除、列出和提取成员
- STRINGS 列出一个目标文件中所有可打印的字符串。
- STRIP 从目标文件中删除符号表信息
- NM 列出目标文件的符号表中定义的符号
- SIZE 列出目标文件中节的名字和大小
- READELF 显示目标文件的完整结构，ELF头信息
- OBJDUMP 所有二进制工具，反汇编
- LDD 可执行文件在运行时所需要的共享库


<br>

静态和动态链接,
可重定位的、可执行的和共享的
可重定位的和可执行的目标文件、符号解析、重定位、静态库、 共享目标库、 位置无关代码，以及库打桩
链接器的两个主要任务是符号解析和重定位
链接器生成的目标文件是与一些像加载、虚拟内存和内存映射
加载器将可执行文件的内容映射到内存，并运行这个程序


<br>

## 第8章 异常控制流ECF


### 8.1 异常

&ensp;ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制
&ensp;应用程序与操作系统交换通过陷阱(trap)或系统(system call)的ECF形式
&ensp;异常处理通过非本地跳转响应错误，C通过setjmp和longjmph函数
&ensp;状态变化称为事件(event),处理器检测到事件发生，通过异常表(存储异常号)的跳转表，进行间接过程调用，跳转到操作系统子程序(异常处理程序(exception handler))。异常表的起始地地址放在叫做异常表基址寄存器(exception table base register)的特殊CPU寄存器
&ensp;异常不同于调用：调用返回地址压入栈，异常返回地址位当前指令或下一条指令；额外压入处理器状态到栈；如控制转移到内核，则压入内核栈；异常程序运行在内核模式
&ensp;异常分为四类：中断(interrupt)、陷阱(trap)、故障(fault)和终止(abort)
![20220711002750](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711002750.png)

&ensp;陷阱用在用户程序和内核之间的系统调用，用户程序向内核请求服务，如读文件(read)、创建进程(fork)、加载程序(execve)和终止进程(exit)等，syscall n 指令
&ensp;故障示例缺页异常
&ensp;linux/x85-64异常
![20220711003346](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711003346.png)
&ensp;C程序用 syscall 函数可以直接调用任何系统调用，通常通过包装函数(系统级函数)使用
&ensp;寄存 %rax 包含系统调用号,寄存器%rdi，%rsi、%rdx、%r10、%r8和%r9包含最多6个参数。
![20220711003746](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711003746.png)

### 8.2 进程
&ensp;进程一个执行中程序的实例，系统中的每个程序都运行在某个进程的上下文(context)中
&ensp;PC值的序列叫逻辑控制流，一个逻辑流在时间上与另一个流重叠，称为并发流，并发运行
&ensp;并发多个流并发执行；多任务进程轮流运行；时间片

&ensp;进程私有地址空间

![20220711004452](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711004452.png)

&ensp;代码段总是从地址 0x400000 开始,地址空间顶部保留给内核(操作系统常驻内存的部分)

&ensp;处理器通常是用某个控制寄存器中的一个模式位(mode bit)来确定用户模式和内核模式
&ensp;linux系统提供 /proc 文件系统，允许用户模式进程访问内核数据结构的内容

&ensp;上下文切换(context swtich):通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构

&ensp;内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度(scheduling), 是由内核中称为调度器(scheduler)的代码处理的


&ensp;系统调用错误处理Unix 系统级函数遇到错误时,返回-1，设置全局整数变量errno


### 8.3 进程控制

&ensp;获取进程ID
```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pit_t getppid(void);
```

&ensp;进程三种状态
- 运行：在 CPU 上执行；或等待被执行且最终会被内核调度
- 停止：进程的执行被挂起（suspended), 且不会被调度。收到SIGSTOP、SIGTSTP、SIGYTTIN或SIGTTOU信号，进程停止，直到收到SIGCONT信号，再次运行
- 终止：进程会因为三种原因终止：1)收到一个信号，该信号的默认行为是终止进程，2)从主程序返回，3)调用 exit 函数

```c
#include <stdlib.h>

// 以status退出状态终止进程
void exit(int status)
```

```c
#include <sys/types.h>
#include <unistd.h>

// 创建进程 调用一次返回两次在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0
pid_t fork(void);
```

![20220711010245](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711010245.png)

&ensp;回收子进程；内核将子进程的退出状态传递给父进程;如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父.init 进程的 PID 为 1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先

```c
#include<sys/types.h>
#include<sys/wait.h>

// waitpid 函数来等待它的子进程终止或者停止
pid_t waitpid(pid_t pid, int *statusp, int options);
```
options 设置为常量 WNOHANG、WUNTRACED 和 WCONTINUED
的各种组合来修改默认行为



```c
#include<unistd.h>
// 进程休眠secs秒
unsigned int sleep(unsigned int secs);
// 让调用函数休眠
int pause(void);
// 加载并运行一个新程序 和fork的区别 ？
int execve(const char *filename, const char *argv[], const char *envp[]);

```

![20220712001432](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220712001432.png)

&ensp;main函数有3个参数：1）argc argv[]数组中非空指针数量 2)argv 指向argv[]数组第一个条目 3) envp 指向envp[]数组中第一个条目
```c
#include <stdlib.h>

char *getenv(const char *name);
int setenv(const char *name, const char *newvalue, int overwrite);

void unsetenv(const char *name);
```

### 8.4 信号

![20220712004654](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220712004654.png)

&ensp;发送信号
每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。getpgrp函数返回当前进程的进程组 ID:

```c
#include<unistd.h>

pid_t getpgrp(void);

// 改变进程所属进程组
int setpgid(pid_t pid, pid_t pgid);

```


&ensp;/bin/kill 程序向另外i的进程发送任意信号
```sh
# 15213 进程组
/bin/kill -9 -15213
```

```c
#include<sys/typed.h>
#include<signal.h>
//调用 kill 函数发送信号给其他进程
int kill(pid_t pid, int sig);

#include<unistd.h>
// 调用 alarm 函数向它自己发送 SIGALRM 信号
unsigned int alarm(unsigned int secs);

```

接收信号

```c
#include<signale.h>

typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);

```

Linux 提供阻塞信号的隐式和显式的机制：

&ensp;隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。
&ensp;显式阻塞机制。应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。

```c
#include<signal.h>

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);

int sigismember(const sigset_t *set, int signum);

```

![20220712223916](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220712223916.png)

信号处理程序中产生输出唯一安全的方法是使用 write 函数, printf和spirintf是不安全的


### 8.5 非本地跳转
&ensp;C 语言提供了一种用户级异常控制流形式，称为非本地跳转（nonlocal jump)，将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列
```c
#include<setjmp.h>
// setjmp 函数在 env 缓冲区中保存当前调用环境
int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);
// longjmp 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化的 setjmp 调用的返回
void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);
```


操作进程工具：
- strace 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹
- ps  列出当前系统中的进程
- top 打印出关于当前进程资源使用的信息
- pmap 显示进程的内存映射
- /proc 虚拟文件系统，输出大量内核数据结构的内容 如：cat /proc/loadavg
<br>

异常控制流
系统所有层次的异常控制流
底层的硬件异常和中断
四种异常：中断、陷阱、故障和终止
在操作系统层，内核用 ECF 提供进程的基本概念。
并发进程的上下文切换
进程的基本概念
通过 Linux 系统调用来使用多个进程


<br>

## 第9章 虚拟内存

虚拟内存提供了三个重要的能力:1)主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域; 2)为每个进程提供了一致的地址空间; 3)保护了每个进程的地址空间不被其他进程破坏
虚拟内存如何工作;使用和管理虚拟内存

物理地址(PA)和虚拟地址(VA)
![20220713002341](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220713002341.png)
MMU内存管理单元：地址翻译

### 9.1 虚拟内存作为缓存工具

&ensp;虚拟页面三个状态：未分配的；缓存的；位缓存的
&ensp;DRAM缓存
&ensp;页表(page table)，页表将虚拟页映射到物理页；页表是页表条目(Page Table Entry PTE)的数组

![20220713003303](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220713003303.png)

&ensp;页命中
&ensp;缺页 DRAM缓存不命中，缺页异常

&ensp;磁盘和内存之间传送也叫做交换或页面调度；按需页面调度策略:直到不命中才换入页面

&ensp;分配页面 VP分配过程是在磁盘上创建空间并更新PTE，指向磁盘上新创建的页面
&ensp;局部性保证了程序趋于较小的活动页面上

### 9.2 虚拟内存作为内存管理工具
&ensp;进程页表独立
- 简化链接：进程内存映射采用相同的基本格式，linux64中代码段总是从虚拟地址0x400000开始
- 简化加载：.text和.data节linux加载器分配虚拟页，标记位无效的，加载不从磁盘复制数据，内存映射(memory mapping)：将一组连续虚拟也映射到任意一个文件中的任意位置表示 linux系统调用mmap，应用程序可做内存映射。
- 简化共享：
- 简化内存分配：页表方式可分配不连续物理空间
### 9.3 虚拟内存作为内存保护工具

&ensp;PTE三个许可标志位：
- SUP 进程是否必须运行在内核(超级用户)模式下才能访问该页
- READ 位和 WRITE 位控制对页面的读和写访问 



### 9.4 地址翻译

![20220713005924](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220713005924.png)

![20220713010059](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220713010059.png)

TLB加速地址翻译：
MMU 中包括了一个关于 PTE 的小的缓存，称为翻译后备缓冲器(Translation Lookaside Buffer, TLB) TLB 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE 组成的块
![20220713010234](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220713010234.png)


多级页表
![20220713213131](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220713213131.png)

Core i7内存系统

![20220713213739](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220713213739.png)

![20220713213848](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220713213848.png)

Linux 虚拟内存系统
![20220713214143](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220713214143.png)

内核为系统中的每个进程维护一个单独的任务结构(源代码中的 task_StrUCt),任务结构中的元素包含或者指向内核运行该进程所需要的所有信息(例如，PID、指向用户栈的指针、可执行目标文件的
名字，以及程序计数器)
![20220713214605](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220713214605.png)


Linux 缺页异常处理
MMU 在试图翻译某个虚拟地址 A 时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序


### 9.5 内存映射


Linux 通过将一个虚拟内存区域与一个磁盘上的对象（object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)


fork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID, 给这个新进程创建虚拟内存，它创建了当前进程的 mm_struct、区域结构和页表的副本

删除已存在的用户区域、映射私有区域、映射共享区域、设置程序计数器(PC)

![20220713215322](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220713215322.png)

mmap 函数的用户级内存映射
```c
#include<unistd.h>
#include<sys/mman.h>
// Linux 进程使用 mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);

// munmap 函数删除虚拟内存的区域
// munmap 函数删除从虚拟地址 start 开始的，由接下来 length 字节组成的区域
int munmap(void *start, size_t length);
```

### 9.6 动态内存分配
&ensp;mmap 和 munmap 函数来创建和删除虚拟内存的区域，C语言使用动态内存分配器，动态内存分配器维护着一个进程的虚拟内存区
域，称为堆(heap),每个进程，内核维护着一个变量 brk(读break) 它指向堆的顶部。
- 显示分配器：c语言malloc free；C++中new和delete
- 隐式分配器：垃圾收集器GC，Java

```c
#include<stdio.h>
// malloc 函数从堆中分配块
void *malloc(size_t size);
void free(void *ptr);
// malloc 可通过使用 mmap 和 munmap 函数，显式地分配和释放堆内存，或者还可以使用 sbrk 函数
#include<unistd.h>

void *sbrk(intptr_t incr);
```

&ensp;动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小

<br>

管理和操纵虚拟内存
存储分配操作，标准库的 malloc 和 free 操作
存储泄漏和非法指针引用等内存引用错误


<br>

# 程序间的交互和通信

## 第10章 系统级 1/()

### 10.1

&ensp;输入/输出(I/O)是在主存和外部设备(例如磁盘驱动器、终端和网络)之间复制数据的过程
&ensp;Unix I/O和标准I/O
Unix I/O：打开文件、改变单位文件位置、读写文件和关闭文件。
Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入(描述符为 0)、标准输出(描述符为 1)和标准错误(描述符为 2)
&ensp;Linux 文件: 普通文件、目录、套接字

```c
#include<sys/types.h>
#include<sys/sttat.h>
#include<fcntl.h>
// flags O_RDONYL 只读   O_WRONLY 只写   O_RDWR 可读可写
int open(char *filename, int flags, mode_t mode);

#include <unistd.h>
// 关闭文件
int close(int fd)

#include<unistd.h>
// 读写文件
ssize_t read(int  fd, void *buf, size_t n);
ssize_t write(int fd, const void *buf, size_t n);

```

RIO健壮读写包
https://blog.csdn.net/df12138/article/details/122272107


读取文件元数据
```c
#include<unistd.h>
#include<sys/stat.h>

int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
```

读取目录内容
```c
#include<sys/types.h>
#include<dirent.h>

DIR *opendir(const char *name);

struct dirent *readdir(DIR *dirp);

int closedir(DIR *dirp);

```

共享文件
- 描述符表：每个进程有独立描述符表
- 文件表：所有进程共享
- v-node表：所有进程共享
![20220714004001](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220714004001.png)

![20220714004036](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220714004036.png)


### 10.2 I/O 重定向
```sh
linux> ls > foo.txt
```
```c
#include<unistd.h>

int dup2(int oldfd, int newfd);
```

### 10.3 标准I/O
&ensp;C语言`libc`库提供了打开和关闭文件的函数(fopen 和 fclose)、读和写字节的函数(fread 和 fwrite)、读和写字符串的函数(fgets 和 fputs)以及复杂的格式化的 I/O 函数(scanf 和 printf)
&ensp;标准 I/O 库将一个打开的文件模型化为一个流,一个流就是一个指向 FILE 类型的结构的指针,有三个打开的流 stdin、stdout和 stderr分别对应于标准输人、标准输出和标准错误

![20220714004733](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220714004733.png)




<br>
<br>
Unix VO 的基本概念
文件和描述符
共享文件，1/O重定向
访问文件的元数据
C 的标准 I/O 库
Linux 内核使用三个相关的数据结构来表示打开的文件
描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向 v-node 表中的表项，每个进程都有它自己单独的描述符表，而所有的进程共享同一个打开文件表和 v-node 表



<br>


## 第11章 网络编程

### 11.1 客户端-服务器
&ensp;客户端-服务器(CS)模型中的基本操作是事务(transaction)
&ensp;网络是一种I/O设备，
![20220714231031](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220714231031.png)
&ensp;局域网(LAN)、以太网
![20220714231314](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220714231314.png)

![20220714231337](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220714231337.png)

&ensp;IP地址是32位无符号整数
```c
// IP address struct 
struc in_addr {
    uint32_t s_addr;
}

// 网络字节序是大端字节序
#include<arpa/int.h>

uint32_t htonl(unit32_t hostlong);
uint16_t htons(uint16_t hostshort);

uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint_16_t netshort);
```

### 11.2 因特网

&ensp;域名 DNS域名集合和 IP 地址集合之间的映射
```sh
nslookup localhost
hostname
nslookup cs.mit.edu

```



&ensp;因特网客户端和服务器通过在连接上发送和接收字节流来通信,客户端套接字地址中的端口是由内核自动分配的
&ensp;文件/etc/services 包含机器提供的知名名字和知名端口之间的映射
&ensp;套接字对(socket pair) :—个连接是由它两端的套接字地址唯一确定
```sh
(cliaddr:cliport, servaddr:servport)
```

### 11.3 套接字接口

套接字接口(socket interface)是一组函数，和 Unix I/O 函数结合起来，用以创建网络应用
![20220714232835](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220714232835.png)

套接字地址结构
```c
struct sockaddr_int {
    uint16_t sin_family; // Protocol family (always AF_INET)
    uint16_t sin_port; // Port number in network byte order
    struct in_addr sin_addr; // IP address in network byte order
    unsigned char sin_zero[8]；// Pad to sizeof(struct sockaddr) 
}

struct sockaddr {
    uint16_t sa_famliy; // Protocol family
    char sa_data[14]; // Address data
}

```


```c
#include<sys/types.h>
#include<sys/socket.h>

int socket(int domain, int type, int protocol);
int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);
int bind(int sockfd const struct sockaddr *addr, socklen_t addrlen);
int listen(int sockfd, int backlog);
int accept(int listenfd, struct sockaddr *addr, int *addrlen);


```
&ensp;getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构
&ensp;getnameinfo 函数和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串


### 11.3 Web服务器
&ensp;HTTP、HTML

![20220714234155](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220714234155.png)

&ensp;TINY Web 服务器

<br>
网络是 I/O 设备
客户端-服务器模型



<br>

## 第12章 并发编程

&ensp;逻辑控制流在时间上重叠称为并发。使用应用级并发的应用程序称为并发程序(concurrent program)。现代操作系统提供
了三种基本的构造并发程序：
- 进程：每个逻辑控制流都是一个进程，由内核来调度和维护。进
程有独立的虚拟地址空间。进程间通信(interprocess communication IPC)
- I/O 多路复用:逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态
- 线程：线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度


### 12.1 基于进程的并发编程

&ensp;创建进程fork、exec和waitpid。并发服务器的法，在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。
&ensp;进程模型：共享文件表，不共享用户地址空间。独立的地址空间使得显式的 IPC(进程间通信)机制。Unix IPC同一台主机上其他进程进行通信的技术，包括管道、先进先出(FIFO)、系统 V 共享内存，以及系统 V 信号量(semaphore)

### 12.2 基于I/O多路复用的并发编程
&ensp;I/O 多路复用(I/O multiplexing)技术,基本的思路就是使用 select 函数，要求内核挂起进程，只有在一个或多个 I/O 事件发生后，才将控制返回给应用程序
```c
#include <sys/select,h>

int select(int n, fd_set *fdset, NULL, NULL, NULL);

FD_ZERO(fd_set *fdset);   /* Clear all bits in fdset */
FD_CLR(int fd, fd.set *fdset);  /* Clear bit fd in fdset */
FD_SET(int fd, fd_set *fdset);  /* Turn on bit fd in fdset */
FD_ISSET(int fd, fd_set *fdset);  /* Is bit fd in fdset on? */
```

I/O 多路复用可以用做并发事件驱动(event-driven)程序的基础，在事件驱动程序中，某些事件会导致流向前推进。将逻辑流模型化为状态机。一个状态机(state machine)就是一组状态(state)、输入事件(input event)和转移(transition)，其中转移是将状态和输人事件映射到状态。每个转移是将一个（输人状态，输人事件）对映
射到一个输出状态。


### 12.3 基于线程的并发编程

第一种方法中，为每个流使用单独的进程。内核会自动调度每个进程，而每个进程有它自己的私有地址空间，使得流共享数据很困难。第二种方法中，创建自己的逻辑流，并利用 I/O 多路复用来显式地调度流。因为只有一个进程，所有的流共享整个地址空间
第三种方法：线程(thread)就是运行在进程上下文中的逻辑流.一个进程里同时运行多个线程的程序。线程由内核自动调度。每个线程都有它自己的线程上下文(thread context), 包括一个唯一的整数线程ID(Thread ID, TID)、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。

![20220715221630](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220715221630.png)
&ensp;每个进程开始生命周期时都是单一线程，这个线程称为主线程(main thread)在某一时刻，主线程创建一个对等线程(peer thread)。线程的上下文要比一个进程的上下文小得多，线程的上下文切换要比进程的上下文切换快得多。对等(线程)池概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止

&ensp;Posix 线程(Pthreads)是在 C 程序中处理线程的一个标准接口。
```c
#include<pthread.h>
// 创建线程
typedef void *(func)(void*)
int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg);
// 获线程 ID
pthread_t pthread_self(void);
// 终止线程
void pthread_exit(void *thread_return);
// 终止当前线程
int pthread_cancel(pthread_t tid);
// 回收终止线程资源
int pthread_join(pthread_t tid, void **thread_return);
// 分离线程
int pthread_detach(pthread_t tid);
// 初始化线程
pthread_once_t once_control = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));

```


### 12.4 多线程程序中的共享变量
&ensp;线程共享相同的程序变量。一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括线程ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。**寄存器是从不共享的**，而虚拟内存总是共享的。
&ensp;多线程的 C 程序中变量根据它们的存储类型被映射到虚拟内存：全局变量、本地自动变量、本地静态变量。
&ensp;用信号量同步线程:信号量 s 是具有非负整数值的全局变量，只能由两种特殊的操作来处理，这两种操作称为 P 和 V:








### 12.5 并发问题

线程安全：函数被称为线程安全的(thread-safe), 当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果



<br>

三种编写并发程序的基本机制（进程、 1/()多路复用和线程）
用 P、 V 信号量操作来实现同步、线程安全和可重人、竞争条件以及死锁等的基本原则

<br>

