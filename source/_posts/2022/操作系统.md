---
title: 操作系统
date: 2022-06-28 00:47:53
updated: 2022-06-28 00:53:53
categories: 
    - tool
tags: 
    - Computer Science
    - Another Tag
---

[toc]

操作系统

<!--more-->

## 3 OS Organization and System Calls

1.操作系统有两个基本功能：
- 防止硬件被失控的应用程序滥用  隔离
- 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备

![20220710174724](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220710174724.png)

&ensp;隔离：隔离硬件;内存空间隔离(虚拟内存)->进程管理;防御安全
&ensp;隔离实现分时复用硬件资源

&ensp;操作系统通过几个基本的抽象概念：进程、虚拟内存和文件
![20220710175044](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220710175044.png)

进程：操作系统对一个正在运行的程序的一种抽象，操作系统实现进程交错执行的机制称为上下文切换

  操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括 PC 和寄存器文件的当前值，以及主存的内容

  系统调用会将控制权传递给操作系统

  从一个进程到另一个进程的转换是由操作系统内核（kernel )管理的。内核是操作系统代码常驻主存的部分

  读写文件，执行一条系统调用（system call)指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序

  内核不是一个独立的进程。是系统管理全部进程所用代码和数据结构的集合


&ensp;kernel和User mode。这两种模式用来隔离操作系统内核和用户应用程序，用户态和内核态通过标志位区分。
&ensp;用户态普通指令，内核态执行特权指令

RISC-V还有第三种模式称为machine mode，三级权限(user/kernel/machine)

&ensp;操作系统和应用程序之前的接口被称为系统调用接口(System call interface)


用户态与内核态切换
RISC-V中ECALL，ARM64中SVC，HVC？


宏内核与微内核
linux，unix宏内核，是微内核
怎么区分宏内核和微内核？将大部分的操作系统运行在内核之外，大部分硬件驱动不在内核是微内核。微内核跳转变多

XV6编译
XV6代码三部分：kernel、user和mkfs
QEMU
https://blog.csdn.net/fangye945a/article/details/121962409

```sh
sudo apt-get install ninja-build
```
https://blog.csdn.net/Leo_h1104/article/details/115580753

https://zhuanlan.zhihu.com/p/351865040

https://zhuanlan.zhihu.com/p/466423677

```sh
# gdb
make qemu
echo set auto-load safe-path / > ~/.gdbinit
gdb-multiarch

layout split

```



## Page Table

&ensp;虚拟内存-页表
1. 映射：虚拟地址<-->物理地址  

2. 地址空间(Address Spaces)
虚拟地址空间->内存隔离

3. 物理内存如何比虚拟内存大？实际程序运行时并不全部加载指令和数据，而是用时加载或者局部加载，所以并不需要加载全部虚拟地址空间，也不需要使用全部物理地址。但是虚拟地址需要有对应的物理地址，是一一对应的吗？如果虚拟地址更大，对应的物理地址数据会刷回到硬盘吗？即内存是硬盘的缓存

4. kalloc保存了空余page的列表，列表为空或者耗尽，kalloc会返回一个空指针，内核会妥善处理并将结果返回给用户应用程序。并告诉用户应用程序，要么是对这个应用程序没有额外的内存了，要么是整个机器都没有内存

5. 实现地址空间->页表
页表是在硬件中通过处理器和内存管理单元(Memory Management Unit)实现
6. 任何带有地址的指令，其中的地址应该认为是虚拟内存地址而不是物理地址
7. CPU角度，一旦MMU打开，它执行的每条指令中的地址都是虚拟内存地址
8. MMU会有一个表单，表单中，一边是虚拟内存地址，另一边是物理内存地址。RISC-V上一个叫做SATP的寄存器保存表单地址
9. MMU并不会保存page table，它只会从内存中读取page table，然后完成翻译
10. 操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。进程对应的SATP值是由内核保存，只有运行在kernel mode的代码可以更新这个寄存器。SATP呢？它存的是物理地址还是虚拟地址？物理地址
11. RISC-V中，一个page是4KB，也就是4096Bytes，为每个page创建一条表单条目
12. 对于虚拟内存地址，划分为两个部分，index和offset，index用来查找page，offset对应的是一个page中的哪个字节。
MMU在做地址翻译，通过读取虚拟内存地址中的index可以知道物理内存中的page号，这个page号对应了物理内存中的4096个字节。之后虚拟内存地址中的offset指向了page中的4096个字节中的某一个，假设offset是12，那么page中的第12个字节被使用了。将offset加上page的起始地址，就可以得到物理内存地址
13. RISC-V的寄存器是64bit，虚拟内存地址的数量现在只有2^39个，大概是512GB，39bit中，有27bit被用来当做index，12bit被用来当做offset。offset必须是12bit，因为对应了一个page的4096个字节。
14. RISC-V中，物理内存地址是56bit，ARM v8也是？44bit是物理page号(PPN，Physical Page Number)，剩下12bit是offset完全继承自虚拟内存地址
16. 增大页表？16k 64k？
17. 多级页表，虚拟内存地址中的27bit的index，实际上是由3个9bit的数字组成(L2，L1，L0)。前9个bit被用来索引最高级的page directory
18. 一个directory是4096Bytes，就跟page的大小是一样的。Directory中的一个条目被称为PTE（Page Table Entry）是64bits，就像寄存器的大小一样，也就是8Bytes。所以一个Directory page有512个条目。
19. SATP寄存器会指向最高一级的page directory的物理内存地址，虚拟内存中index的高9bit用来索引最高一级的page directory，这样我们就能得到一个PPN，也就是物理page号。这个PPN指向了中间级的page directory
最高级的page directory中的PPN，包含了下一级page directory的物理内存地址，依次类推。在最低级page directory，我们还是可以得到44bit的PPN，这里包含了我们实际上想要翻译的物理page地址，然后再加上虚拟内存地址的12bit offset，就得到了56bit物理内存地址
20. PTE中的Flag，因为它也很重要。每个PTE的低10bit是一堆标志位
- 第一个标志位是Valid。如果Valid bit位为1，那么表明这是一条合法的PTE
- 下两个标志位分别是Readable和Writable。表明你是否可以读/写这个page
- Executable表明你可以从这个page执行指令
- user表明这个page可以被运行在用户空间的进程访问。

21. 页表缓存(Translation Lookaside Buffer)
TLB会保存虚拟地址到物理地址的映射关系。
Q切换了page table，操作系统需要告诉处理器当前正在切换page table，处理器会清空TLB。在RISC-V中，清空TLB的指令是sfence_vma。
虚拟地址索引的cache位于MMU之前，由物理地址索引的cache位于MMU之后
在XV6中，内核有它自己的page table，用户进程也有自己的page table，用户进程指向sys_info结构体的指针存在于用户空间的page table，但是内核需要将这个指针翻译成一个自己可以读写的物理地址。copy_in，copy_out，你可以发现内核会通过用户进程的page table，将用户的虚拟地址翻译得到物理地址，这样内核可以读写相应的物理内存地址
page table提供了一层抽象(level of indirection)。抽象就是指从虚拟地址到物理地址的映射
22. 当操作系统启动时，会从地址0x80000000开始运行，这个地址其实也是由硬件设计者决定的。地址0是保留的，地址0x10090000对应以太网，地址0x80000000对应DDR内存，处理器外的易失存储（Off-Chip Volatile Memory），也就是主板上的DRAM芯片
23. 地址0x1000是boot ROM的物理地址，当你对主板上电，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址0x80000000，操作系统需要确保那个地址有一些数据能够接着启动操作系统。
24. I/O设备
- PLIC是中断控制器(Platform-Level Interrupt Controller)
- CLINT(Core Local Interruptor)也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适的处理函数
- UART0（Universal Asynchronous Receiver/Transmitter）负责与Console和显示器交互
- VIRTIO disk，与磁盘进行交互。
25. 同一个物理地址映射两个虚拟地址，你可以不将一个虚拟地址映射到物理地址。可以是一对一的映射，一对多映射，多对一映射
26. 用户进程的虚拟地址空间分布
![20220717173502](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220717173502.png)

Kvminit函数
kvminithart函数
walk函数


### Armv8-A Address Translation

1. 支持4K、16K和64K页表。TCR_EL1寄存存储支持页表大小。
2. AArch64 4级页表，4K页表，48bit地址，9bit索引，512个表项，12bit的offset。
![20220724171523](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220724171523.png)

16K页表，11bit索引，2048表项，14bit的offset
64K页表，3级索引，
3. MMU 使用转换表和转换寄存器来控制哪些内存位置是可缓存。缓存策略MAIR_ELn寄存器标识，TLB缓存是否有效。

### DDI0487H_a_a-profile_architecture_reference_manual.pdf

#### D5.2.6

单一阶段转换：虚拟地址->物理地址
两阶段转换：虚拟地址->中间物理地址->物理地址


阶段1 

![20220724173718](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220724173718.png)



### ARM64体系结构编程实践
#### 第14章 内存管理

##### 1 
1. 进程地址空间使用内存3部分：进程本身、栈空间、堆空间
2. 地址转换(address translation):进程请求虚拟地址(VA)转换为物理地址(PA)，通过MMU实现。
3. 操作系统3元素：进程地址空间、进程的CPU虚拟化和文件对存储空间的抽象。
4. 分页机制引入虚拟存储，核心思想让程序不使用的内存交换到磁盘中，程序正在使用内存保留在物理内存。
5. 4K页帧虚拟地址组成VA[31:0]，偏移量offset VA[11:0]; 虚拟页帧号(VPN)。物理地址组成，偏移量offset PA[11:0];物理页帧号(PFN)。MMU把虚拟页帧号转换成物理页帧号。
6. 页表：存储VPN到PFN的映射关系，表项称为页表项PTE。多级页表用来减少页表占用内存空间，ARM64v8支持4级页表。
7. TLB未命中从，处理器MMU中页表查询
- 处理器根据虚拟地址判断使用TTBR0还是TTBR1，虚拟地址第63位为1时，选择TTBR1，为0时，选择TTBR0。TTBR中存储一级页表(L0)基地址。
- 处理器以虚拟地址一级索引在一级页表中查找表项。
8. ARM64 处理器的MMU包括TLB和页表遍历单元。TLB是高速缓存，用于缓存页表转换的结果。
9. 进程地址空间分为：内核空间(kernel space)和用户空间(user space)
10. SMP多核处理器系统中，每个处理器内置MMU和TLB，如何保证CPU访问正前有效的TLB。
11. AArach64体系结构页表特性：
- 最多支持4级页表
- 输入地址最多有效位宽为48bit
- 输出地址最大有效位款为48bit
- 页帧大小支持4KB、16KB和64KB

12. AArach64采用两套页表设计，虚拟地址空间分为三部分：下面是用户空间，中间是非规范区，上面是内核空间。当CPU访问用户空间是，MMU选择TTBR0指向的页表，CPU访问内核空间时，MMU选择TTBR1寄存器指向的页表。

13. 页表属性
- 共享性与缓存性：共享性决定高速缓存可被哪些观察者观察到; 缓存性值页面是否使能高速缓存以及高速缓存的范围。
- 访问权限：AP字段控制CPU对页面的访问，可读可写属性。
- 执行权限：PXN字段以及XN/UXN字段设置CPU是否可执行页面
- 访问标志位：访问字段AF用来标识页面是否被访问过。
- 全局和进程特有TLB：nG字段，0全局，1进程特有
14. 硬件管理访问位和脏位(TTHM特性)，页表转换控制器TCR，HA字段自动设置AF标志。
脏位TCR_EL1的HD字段，

15. 转换控制寄存器(TCR)、系统控制寄存器(SCTLR)和转换页表基址寄存器(TTBR)。
TTBR中ASID字段用来存储硬件ASID，AADDR字段存储页表基地址。
16. 内存属性：Armv8两种内存属性：普通类型内存和设备内存。普通内存可优化。设备内存不可预测访问。



## Calling conventions and stack frames RISC-V

- syscanll  lab
- C -> Asm / Processor
- RISC-V & x86 & Arm64
- Registers
- stack + calling conventions
- struct layout in memory

### 编译，RISV-V调用规范
&ensp;ISA就是处理器能够理解的指令集。每一条指令都有一个对应的二进制编码或者一个Opcode。
&ensp;预处理-编译-汇编-链接
&ensp;RISC精简指令集与CISC复杂指令集，RISC统一的加载与存储指令。
&ensp;RISC-V指令包含Base Integer Instruction Set和Standard Extension Instruction Set
&ensp;汇编代码：global全局变量函数，text代码段
进程地址空间
![20220731191036](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220731191036.png)
&ensp;gdb layout split会同时展现C代码和汇编，而layout source只会展示C代码。

### RISC-V寄存器
![20220731191509](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220731191509.png)
- Caller Saved寄存器在函数调用的时候不会保存
- Callee Saved寄存器在函数调用的时候会保存
&ensp;汇编代码并不是在内存上执行，而是在寄存器上执行，load到寄存器，store到其他地方。除了Compressed Instruction，寄存器都是通过它们的ABI名字来引用。
&ensp;a0到a7寄存器是用来作为函数的参数。如果一个函数有超过8个参数，需要用内存

### Stack 
Stack Frame
![20220731192550](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220731192550.png)
函数通过移动Stack Pointer来完成Stack Frame的空间分配。
- Return address总是会出现在Stack Frame的第一位
- 指向前一个Stack Frame的指针也会出现在栈中的固定位置
第一个是SP（Stack Pointer），指向Stack的底部并代表了当前Stack Frame的位置。第二个是FP（Frame Pointer），它指向当前Stack Frame的顶部。因为Return address和指向前一个Stack Frame的的指针都在当前Stack Frame的固定位置，所以可以通过当前的FP寄存器寻址到这两个数据。?  前一个Frame Pointer存储到FP寄存器
&ensp;leaf函数是指不调用别的函数的函数,不用担心保存自己的Return address或者任何其他的Caller Saved寄存器
&ensp;删除掉Prologue和Epllogue? sum_then_double将不知道它应该返回的Return address。所以调用sum_to的时候，Return address被覆盖了，最终sum_to函数不能返回到它原本的调用位置。

&ensp;info frame
- Stack level 0，表明这是调用栈的最底层
- pc，当前的程序计数器
- saved pc，demo4的位置，表明当前函数要返回的位置
- source language c，表明这是C代码
- Arglist at，表明参数的起始地址。当前的参数都在寄存器中，可以看到argc=3，argv是一个地址

### Struct


## Isolation & system call entry/exit(Rebort)

### Trap
&ensp;用户空间与内核空间切换trap：
- 程序执行系统调用
- 出现如page fault、运算时除以0的错误
- 设备触发中断使得当前程序运行需要响应内核设备驱动
&ensp;32个寄存器：SP堆栈指针寄存器、PC程序计算器
&ensp;mode标志位：标志当前是supervisor还是user mode
&ensp;RSIC-V SATP（Supervisor Address Translation and Protection）寄存器，它包含了指向page table的物理内存地址
&ensp;STVEC（Supervisor Trap Vector Base Address Register）寄存器，它指向了内核中处理trap的指令的起始地址
&ensp;SEPC（Supervisor Exception Program Counter）寄存器，在trap的过程中保存程序计数器的值。
&ensp;在trap处理的过程中的操作：
- 保存32个寄存器
- 保存程序计数器PC
- 将mode改为supervisor mode，内核中执行特权指令
- SATP寄存器由指向user page table变为指向 kernelpage table
- 将堆栈寄存器指向内核中的地址
- 跳入到内核的C代码
&ensp;supervisor mode可：读写SATP寄存器，也就是page table的指针；STVEC，也就是处理trap的内核指令地址；SEPC，保存当发生trap时的程序计数器；SSCRATCH；使用PTE_U标志位为0的PTE。当PTE_U标志位为1的时候，表明用户代码可以使用这个页表；如果这个标志位为0，则只有supervisor mode可以使用这个页表。
supervisor mode中的代码并不能读写任意物理地址 ？

&ensp;trap执行流程，系统调用通过执行ECALL指令来执行系。ECALL指令会切换到具有supervisor mode的内核中。在这个过程中，内核中执行的第一个指令是一个由汇编语言写的函数，叫做uservec。这个函数是内核代码trampoline.s文件的一部分。所以执行的第一个代码就是这个uservec汇编函数。在这个汇编函数中，代码执行跳转到了由C语言实现的函数usertrap中，这个函数在trap.c中，在usertrap这个C函数中，我们执行了一个叫做syscall的函数。这个函数会在一个表单中，根据传入的代表系统调用的数字进行查找，并在内核中执行具体实现了系统调用功能的函数

## Page faults(Frans)

1. page fault相关功能：1)lazy allocation 2)copy-on-write fork 3)demand paging 4)memroy mapped files

2. 虚拟内存两个主要的优点：隔离Isoation; 虚拟地址空间level of indirection
3. page fault触发trap机制，将程序运行切换到内核，出错地址保存在STVAL寄存器；引起page fault的内存地址
page fault原因load 13、store 15或jump 12指令，SCAUSE寄存器；引起page fault的原因类型
触发page fault的指令的地址存放在SEPC寄存器；引起page fault时的程序计数器值

4. Lazy page allocation
sbrk的实现默认是eager allocation,内核会立即分配应用程序所需要的物理内存。而实际上内核在这个时间点并不会分配任何物理内存。之后在某个时间点，应用程序使用到了新申请的那部分内存，这时会触发page fault，因为我们还没有将新的内存映射到page table
用lazy allocation，应用程序怎么才能知道当前已经没有物理内存可用了？替换页？
如何判断一个地址是新分配的内存还是一个无效的地址？
如果使用的地址低于p->sz，那么这是一个用户空间的有效地址。如果大于p->sz，对应的就是一个程序错误

5. Zero Fill On Demand
BSS段未被初始化或者初始化为0的全局变量，多个page为全0，map到一个物理page，物理page为只读，当写BSS中的一个page时触发page fault，创建一个新的page，将其内容设置为0，并重新执行指令

6. Copy On Write Fork(COW fork)
直接共享父进程的物理内存page，设置子进程的PTE指向父进程对应的物理内存page，将父进程和子进程的PTE的标志位都设置成只读的，改内存的内容时，会得到page fault，拷贝相应的物理page，分配一个新的物理内存page，然后将page fault相关的物理内存page拷贝到新分配的物理内存page中，并将新分配的物理内存page映射到子进程

如何发现父进程写了这部分内存地址？是与子进程相同的方法吗？相同的处理方式

7. Demand Paging
延迟加载text和data段
dirty page，因为它在某个时间点会被重新写回到内存中。

8.  Memory Mapped Files
mmap的系统调用，系统调用会接收一个虚拟内存地址（VA），长度（len），protection，一些标志位，一个打开文件的文件描述符，和偏移量（offset）
多个进程将同一个文件映射到内存，然后会有同步的问题？
mmap的参数中，len和flag是什么意思？  len是文件中你想映射到内存中的字节数。prot是read/write。flags会在mmap lab中出现，我认为它表示了这个区域是私有的还是共享的



## Interrupts

1. 中断触发处理流程
![20220821155615](https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220821155615.png)
RISC-V中断控制器PLIC？ARM64 GIC
2. UART设备的驱动uart.c文件
bottom/top，bottom部分通常是Interrupt handler；top部分，是用户进程，或者内核的其他部分调用的接口；top部分的代码会从队列中读写数据，而Interrupt handler（bottom部分）同时也会向队列中读写数据
RISC-V通过memory mapped I/O完成设备地址映射，设备地址出现在物理地址的特定区间内
对设备load/store指令读写设备的控制寄存器
3. RISC-V与中断相关的寄存器：
- SIE（Supervisor Interrupt Enable）寄存器，bit E外部设备的中断、S软件中断、T定时器中断
- SSTATUS（Supervisor Status）寄存器 打开或者关闭中断 ARM64 SPSR_ELx  D、A、I、F位置1
- SIP（Supervisor Interrupt Pending）寄存器  中断类型  ELx
- SCAUSE寄存器 中断原因 ARM64 ESR
- STVEC寄存器 保存trap，page fault或者中断发生时，CPU运行的用户程序的程序计数器， ARM64 ELR_ELx
 bottom/top和 ARM64中上半部分和下半部分反的？
polling轮询处理快速中断

ARM 64体系结构
### 11 异常处理

1. 异常种类：中断、种植、复位和系统调用
2. 异常等级EL0-EL3  EL0用户模式，EL1系统内核特权模式、EL2虚拟化管理hypervisor，EL3安全管理
3. 同步异常：指令异常和数据异常page fault；异常异常：中断，物理中断IRQ和FRQ，虚拟中断vIRQ和vFRQ
4. 异常处理：
- PSTATE寄存器保存到SPSR_ELx中，PSTATE寄存器D、A、I和F位置位1，关闭异常
- 返回地址保存到ELR_ELx中
- ESR_ELx保存异常原因
- SP切换到目标异常等级SP_ELx
- 切换到对应异常等级，跳转到异常向量表
异常返回：
- 从ELR_ELx中恢复PC
- 从SPSR_ELx中恢复PSTATE，开中断
异常返回地址：X30(LR)保存子函数返回地址，用ret返回；ELR_ELx保存异常返回地址，用eret返回
5. 异常处理路由，当异常发生时应该在那个等级处理
6. 异常向量表 arch/arm64/kernel/entry.S kerenl_ventry
ARM64 v8中VBAR_ELx寄存器设置异常向量表的地址
7. 异常现场栈空间内容：PSTATE寄存器值、PC值、SP值、X0-X30寄存器值。此栈空间为发生异常时进程的内核态的栈空间
8. 同步异常  寄存器ESR




### 12 中断处理

1. ARM64 中断nIRQ和nFRQ，PSTATE中对应I和F两位
2. 中断处理过程
1)把当前PC值保存到ELR_ELx中，把PSTATE保存到SPSR中，跳转到异常向量表
2)异常向量表中，CPU跳转到对应的汇编处理函数elx_irq
3)在汇编函数里保存中断现场
4)跳转到中断号所对应的中断处理函数
5)在中断处理程序中处理中断
6)返回elx_irq汇编函数，恢复中断上下文
7)调用ERET指令完成中断返回
8)CPU继续执行中断现场下一条指令
3. 中断现场数据结构pt_regs保存中断现场
中断发生时，把中断现场保存到当前进程的内核栈里：
- PSTATE保存到SPSR_ELx
- PC保存到ELR_ELx
- SP保存到栈顶
- regs保存LR的值
- regs[0]-regs[29]对应保存X0-X30寄存器值


<br>

## Lec10 Multiprocessors and locking
1. 锁来控制并确保共享的数据是正确的
RSIC-V kalloc.c文件中的kfree函数会将释放的page保存于freelist中
2. 锁lock API：
- acquire，接收指向lock的指针作为参数。acquire确保了在任何时间，只会有一个进程能够成功的获取锁。
- release，也接收指向lock的指针作为参数。在同一时间尝试获取锁的其他进程需要等待，直到持有锁的进程对锁调用release。
3. 什么时候才必须要加锁呢？
如果两个进程访问了一个共享的数据结构，并且其中一个进程会更新共享的数据结构，那么就需要对于这个共享的数据结构加锁。
有没有可能两个进程同时acquire锁，然后同时修改数据？不会
可不可以在访问某个数据结构的时候，就获取所有相关联的数据结构的锁？但是这种方式最后会很快演进成big kernel lock
4. 锁有三种作用
- 锁可以避免丢失更新
- 锁可以打包多个操作，使它们具有原子性。
- 锁可以维护共享数据结构的不变性。
5. 一个死锁的最简单的场景就是：首先acquire一个锁，然后进入到critical section；在critical section中，再acquire同一个锁；第二个acquire必须要等到第一个acquire状态被release了才能继续执行，但是不继续执行的话又走不到第一个release，所以程序就一直卡在这了。这就是一个死锁。
同一个进程多次acquire同一个锁，就会触发一个panic。
相互acquuire对方锁，多个锁，你需要对锁进行排序，所有的操作都必须以相同的顺序获取锁。
6. 自旋锁
硬件指令。这个特殊的硬件指令会保证一次test-and-set操作的原子性。在RISC-V上，这个特殊的指令就是amoswap（atomic memory swap）
内存屏障指令

<br>

## 11. Thread switching



### Q
1. 为什么计算机需要运行多线程？
计算机在同一时间不是只执行一个任务。需要执行分时复用的任务
线程可以让程序的结构变得简单
在多核CPU的计算机上多线程可以通过并行运算获得更快的处理速度

2. 线程的状态包含了三个部分?
- 程序计数器（Program Counter），它表示当前线程执行指令的位置。
- 保存变量的寄存器。
- 程序的Stack,Stack记录了函数调用的记录，并反映了当前线程的执行点。

3. 多线程的并行运行主要有两个策略：
- 多核处理器上使用多个CPU，每个CPU都可以运行一个线程
- 一个CPU在多个线程之间来回切换

4. 所有的内核线程都共享了内核内存,每一个用户进程都有独立的内存地址空间。XV6中的用户线程之间没有共享内存，一个进程只有一个线程。Linux，允许在一个用户进程中包含多个线程

5. XV6线程调度
如何实现线程间的切换？
线程调度(Scheduling)? 停止一个线程的运行并启动另一个线程的过程。线程调度器（Scheduler）
线程切换时，需要保存并恢复线程的状态？
如何处理运算密集型线程（compute bound thread）？ 利用定时器中断
定时器中断会强制的将CPU控制权从用户进程给到内核，这里是pre-emptive scheduling，之后内核会代表用户进程（注，实际是内核中用户进程对应的内核线程会代表用户进程出让CPU），使用voluntary scheduling。
5. 线程状态
- RUNNING，线程当前正在某个CPU上运行
- RUNABLE，线程还没有在某个CPU上运行，但是一旦有空闲的CPU就可以运行
- SLEEPING，这节课我们不会介绍，下节课会重点介绍，这个状态意味着线程在等待一些I/O事件，它只会在I/O事件发生了之后运行

6. 线程切换过程：
从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存用户进程的状态并运行第一个用户进程的内核线程。  --- 定时器中断
再从第一个用户进程的内核线程切换到第二个用户进程的内核线程。 --- 让出CPU   swtch函数
之后，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器。
最后返回到第二个用户进程继续执行。

swtch函数会保存用户进程P1对应内核线程的寄存器至context对象
schedulder函数
任何运行在CPU1上的进程，当它决定出让CPU，它都会切换到CPU1对应的调度器线程，并由调度器线程切换到下一个进程。
context保存在哪？
每一个内核线程都有一个context对象。但是内核线程实际上有两类。每一个用户进程有一个对应的内核线程，它的context对象保存在用户进程对应的proc结构体中。
出让CPU是由用户发起的还是由内核发起的？



<br>
<br>

b站课程：
https://www.bilibili.com/video/BV19k4y1C7kA?p=2&spm_id_from=pageDriver&vd_source=6768732acbd0f78ac59230d2faa59a86

课程翻译
https://github.com/huihongxiao/MIT6.S081
https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/

https://pdos.csail.mit.edu/6.828/2020/schedule.html

https://pdos.csail.mit.edu/6.828/2020/schedule.html

