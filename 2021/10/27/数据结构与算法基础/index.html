<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true,"b2t":false,"scrollpercent":true},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1 程序性能">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法基础">
<meta property="og:url" content="http://example.com/2021/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="liuz">
<meta property="og:description" content="1 程序性能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/10/27/UxWCvnRQLYz5eiG.png">
<meta property="og:image" content="https://i.loli.net/2021/10/28/GWOFcUi3qdVIlmf.png">
<meta property="article:published_time" content="2021-10-26T16:47:53.000Z">
<meta property="article:modified_time" content="2021-10-26T16:53:53.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="实用教程">
<meta property="article:tag" content="Another Tag">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/10/27/UxWCvnRQLYz5eiG.png">

<link rel="canonical" href="http://example.com/2021/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构与算法基础 | liuz</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="liuz" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liuz</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuz">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-27 00:47:53 / 修改时间：00:53:53" itemprop="dateCreated datePublished" datetime="2021-10-27T00:47:53+08:00">2021-10-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>126k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:55</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-程序性能"><a href="#1-程序性能" class="headerlink" title="1 程序性能"></a>1 程序性能</h2><span id="more"></span>

<p> 程序性能是指运行程序所需要的<strong>内存大小(空间复杂度)和时间(时间复杂度)</strong>,运行时间和占用空间是算法性能最关键的指标。<br> 软件程序性能衡量指标:<br> 响应时间、启动时间、执行时间、执行速度、计算资源分配、内存分配、磁盘吞吐量、网络吞吐量、负载承受能力</p>
<h3 id="1-1-空间复杂度"><a href="#1-1-空间复杂度" class="headerlink" title="1.1 空间复杂度"></a>1.1 空间复杂度</h3><p> 空间复杂度(Space complexity)，算法完全运行所需存储空间。表示算法的存储空间与数据规模之间的增长关系：常量空间、线性空间、二维空间。<br> 算法在计算机存储器上所占用的存储空间，包括<strong>存储程序本身占用的存储空间，算法输入输出数据所占的存储空间和算法在运行过程中临时占用的存储空间</strong>。</p>
<h3 id="1-2-时间复杂度"><a href="#1-2-时间复杂度" class="headerlink" title="1.2 时间复杂度"></a>1.2 时间复杂度</h3><p> 时间复杂度(Time complexity)，算法完全运行所需运算时间。时间复杂度通常用大O符合表示。</p>
<p><img src="https://i.loli.net/2021/10/27/UxWCvnRQLYz5eiG.png" alt="20211027233029"></p>
<h4 id="1-2-1-常见算法大O"><a href="#1-2-1-常见算法大O" class="headerlink" title="1.2.1 常见算法大O"></a>1.2.1 常见算法大O</h4><p>  常量阶O(1); 对数阶O(logn); 线性阶O(n); 线性对数阶O(nlogn); k次方阶O(n^k)<br><img src="https://i.loli.net/2021/10/28/GWOFcUi3qdVIlmf.png" alt="20211028010721"></p>
<h4 id="1-2-2-常见数据结构"><a href="#1-2-2-常见数据结构" class="headerlink" title="1.2.2 常见数据结构"></a>1.2.2 常见数据结构</h4><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>数据结构与算法<ul>
<li>线性表<ul>
<li>数组</li>
<li>链表<ul>
<li>单链表</li>
<li>双链表</li>
<li>循环链表</li>
<li>双向循环链表</li>
<li>静态链表</li>
</ul>
</li>
<li>栈<ul>
<li>顺序栈</li>
<li>链式栈</li>
</ul>
</li>
<li>队列<ul>
<li>普通队列</li>
<li>双端队列</li>
<li>阻塞队列</li>
<li>并发队列</li>
<li>阻塞并发队列</li>
</ul>
</li>
</ul>
</li>
<li>散列表<ul>
<li>散列函数</li>
<li>冲突解决<ul>
<li>链表法</li>
<li>开放地址</li>
<li>其他</li>
</ul>
</li>
<li>动态扩容</li>
<li>位置</li>
</ul>
</li>
<li>树<ul>
<li>二叉树<ul>
<li>二叉查找树</li>
<li>平衡二叉树</li>
<li>平衡二叉查找树<ul>
<li>AVL树</li>
<li>红黑树</li>
</ul>
</li>
<li>完全二叉树</li>
<li>满二叉树</li>
</ul>
</li>
<li>多路查找树<ul>
<li>B树</li>
<li>B+树</li>
<li>2-3树</li>
<li>2-3-4树</li>
</ul>
</li>
<li>堆<ul>
<li>小顶堆</li>
<li>大顶堆</li>
<li>优先级队列</li>
<li>斐波那契堆</li>
<li>二项堆</li>
</ul>
</li>
<li>其他<ul>
<li>树状数组</li>
<li>线段树</li>
</ul>
</li>
</ul>
</li>
<li>图<ul>
<li>图的存储<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
</ul>
</li>
<li>拓扑排序</li>
<li>最短路径</li>
<li>关键路径</li>
<li>最小生成树</li>
<li>二分图</li>
<li>最大流</li>
</ul>
</li>
<li>复杂度分析<ul>
<li>空间复杂度</li>
<li>时间复杂度</li>
</ul>
</li>
<li>基本算法思想<ul>
<li>分治法</li>
<li>递归算法</li>
<li>贪心算法</li>
<li>动态规划</li>
<li>回溯法</li>
<li>枚举法</li>
</ul>
</li>
<li>排序<ul>
<li>O(n^2)<ul>
<li>冒泡排序</li>
<li>插入排序</li>
<li>选择排序</li>
<li>希尔排序</li>
</ul>
</li>
<li>O(nlogn)<ul>
<li>归并排序</li>
<li>快速排序</li>
<li>堆排序</li>
</ul>
</li>
<li>O(n)<ul>
<li>计数排序</li>
<li>基数排序</li>
<li>桶排序</li>
</ul>
</li>
</ul>
</li>
<li>搜索<ul>
<li>深度优先搜索</li>
<li>广度优先搜索</li>
<li>A*启发式搜索</li>
</ul>
</li>
<li>查找<ul>
<li>线性表查找</li>
<li>树结构查找</li>
<li>散列表查找</li>
</ul>
</li>
<li>字符串匹配<ul>
<li>朴素</li>
<li>KMP</li>
<li>Robin-Karp</li>
<li>Boyer-Moore</li>
<li>AC自动机</li>
<li>Trie</li>
<li>后缀数组</li>
</ul>
</li>
<li>其他<ul>
<li>数论</li>
<li>计算几何</li>
<li>概率分析</li>
<li>并查集</li>
<li>拓扑网络</li>
<li>矩阵运算</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h3 id="本章参考："><a href="#本章参考：" class="headerlink" title="本章参考："></a>本章参考：</h3><ul>
<li>复杂度速查表<br><a target="_blank" rel="noopener" href="https://liam.page/2016/06/20/big-O-cheat-sheet/">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></li>
</ul>
<h2 id="2-基本数据结构"><a href="#2-基本数据结构" class="headerlink" title="2 基本数据结构"></a>2 基本数据结构</h2><h3 id="2-1-线性表"><a href="#2-1-线性表" class="headerlink" title="2.1 线性表"></a>2.1 线性表</h3><p> 线性表是n个具有相同特性的数据元素的有序序列。线性表除第一个和最后一个数据元素之外，其他数据元素都是首尾相接的。<br> 数据在实际的物理存储中有两种形式：分散存储和集中存储,常见数据结构有栈、队列、字符串、链表等。<br> 两种情况下数据的存储问题：<br>  数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；<br>  数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”</p>
<h4 id="2-1-1-数组"><a href="#2-1-1-数组" class="headerlink" title="2.1.1 数组"></a>2.1.1 数组</h4><p> 数组是一批相同数据的集合。数组的三部分：<code>地址 大小 和 空间</code>。数组的保存形式为线性表。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>]; <span class="comment">// /[]内必须是常量/常量表达式(3+8)，不能是一个变量(x...)</span></span><br><span class="line"><span class="comment">// 数组初始化</span></span><br><span class="line"><span class="keyword">int</span> arr1[<span class="number">3</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="keyword">char</span> arr6[] = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">int</span> *ptr = <span class="literal">NULL</span>;<span class="comment">//定义一个整型的指针变量，初始化为NULL</span></span><br><span class="line"><span class="keyword">char</span> *ptr = <span class="literal">NULL</span>;<span class="comment">//定义一个字符的指针变量，初始化为NULL</span></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">// C 传递数组给函数</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> *param)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> param[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> param[])</span></span></span><br><span class="line"><span class="function"><span class="comment">// C 从函数返回数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>array</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> used;</span><br><span class="line">    <span class="keyword">int</span> *arr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(struct <span class="built_in">array</span> *<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="built_in">array</span>-&gt;used; idx++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%02d]: %08d\n"</span>, idx, <span class="built_in">array</span>-&gt;arr[idx]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(struct <span class="built_in">array</span> *<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">array</span>-&gt;arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">array</span>-&gt;size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(struct <span class="built_in">array</span> *<span class="built_in">array</span>, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;used &gt;= <span class="built_in">array</span>-&gt;size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; <span class="built_in">array</span>-&gt;used; idx++) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;arr[idx] &gt; elem)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="built_in">array</span>-&gt;used)</span><br><span class="line">        memmove(&amp;<span class="built_in">array</span>-&gt;arr[idx+<span class="number">1</span>], &amp;<span class="built_in">array</span>-&gt;arr[idx],</span><br><span class="line">            (<span class="built_in">array</span>-&gt;used - idx) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span>-&gt;arr[idx] = elem;</span><br><span class="line">    <span class="built_in">array</span>-&gt;used++;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(struct <span class="built_in">array</span> *<span class="built_in">array</span>, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt;= <span class="built_in">array</span>-&gt;used)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    memmove(&amp;<span class="built_in">array</span>-&gt;arr[idx], &amp;<span class="built_in">array</span>-&gt;arr[idx+<span class="number">1</span>],</span><br><span class="line">        (<span class="built_in">array</span>-&gt;used - idx - <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">array</span>-&gt;used--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(struct <span class="built_in">array</span> *<span class="built_in">array</span>, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="built_in">array</span>-&gt;used; idx++) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;arr[idx] == elem)</span><br><span class="line">            <span class="keyword">return</span> idx;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;arr[idx] &gt; elem)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array</span> <span class="title">ten_int</span> =</span> {<span class="number">10</span>, <span class="number">0</span>, <span class="literal">NULL</span>};</span><br><span class="line"></span><br><span class="line">    alloc(&amp;ten_int);</span><br><span class="line">    <span class="keyword">if</span> (!ten_int.arr) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    insert(&amp;ten_int, <span class="number">1</span>);</span><br><span class="line">    insert(&amp;ten_int, <span class="number">3</span>);</span><br><span class="line">    insert(&amp;ten_int, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== insert 1, 3, 2\n"</span>);</span><br><span class="line">    dump(&amp;ten_int);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = search(&amp;ten_int, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2 is at position %d\n"</span>, idx);</span><br><span class="line">    idx = search(&amp;ten_int, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"9 is at position %d\n"</span>, idx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== delete [6] element \n"</span>);</span><br><span class="line">    <span class="keyword">delete</span>(&amp;ten_int, <span class="number">6</span>);</span><br><span class="line">    dump(&amp;ten_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== delete [0] element \n"</span>);</span><br><span class="line">    <span class="keyword">delete</span>(&amp;ten_int, <span class="number">0</span>);</span><br><span class="line">    dump(&amp;ten_int);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<br>

<p><strong>二分搜索</strong><br> 基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字 key 进行比较，若相等，则査找成功；若 key 值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找：若 key 值比该关键宇值小，则要找的元素一定在左子表中，继续对左子表进行折半査找。如此递推，直到査找成功或査找失败（或査找范围为 0）<br> 左闭右闭[left, right]：high = mid - 1;<br> 左闭右开[left, right)：high = mid;<br> 二分搜索的时间复杂度为 <em><strong>对数时间O(logn)</strong></em></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭 右闭区间  [left, right] </span></span><br><span class="line"><span class="comment">// low = mid + 1  high = mid - 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid, count = <span class="number">0</span>, count1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) {</span><br><span class="line">        count++;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) {</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid]) {</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key == a[mid]) {</span><br><span class="line">            count1++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count1 == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-1-2-单链表"><a href="#2-1-2-单链表" class="headerlink" title="2.1.2 单链表"></a>2.1.2 单链表</h4><p>  单链表元素之间有一个单独的指针链接。这种结构的链表可以使得从第一个元素遍历到最后一个元素</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListElmt_</span> {</span></span><br><span class="line">    <span class="keyword">void</span> *data;  <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListElmt_</span> * <span class="title">next</span>;</span> <span class="comment">// next指针</span></span><br><span class="line">} ListElmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List_</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">void</span> *data);</span><br><span class="line">    ListElmt *head;</span><br><span class="line">    ListElmt *tail;</span><br><span class="line">} List;</span><br></pre></td></tr></tbody></table></figure>
<p> 单链表操作：插入、删除、<br> 如何判断单链表存在回环？<br>  设有两个指针p1，p2。在美学循环的时候，p1先走一步，p2走两步，直到p2碰到空指针或者两者相等时循环结束，如果两个指针相等则说明存在回环。</p>
<p> 翻转链表</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">reverse</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">res</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre_node</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        pre_node-&gt;next = res;</span><br><span class="line">        res = pre_node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>singleList</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SINGLELIST_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SINGLELIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">}listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkedList</span> {</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">size_t</span> typesize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>(*dup)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line">    <span class="keyword">int</span>(*match)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line">    <span class="keyword">void</span>(*<span class="built_in">free</span>)(<span class="keyword">void</span>*);</span><br><span class="line">}linkedList;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br><span class="line"></span><br><span class="line"><span class="function">linkedList *<span class="title">listCreate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function">linkedList *<span class="title">listAddNodeHead</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function">linkedList *<span class="title">listAddNodeTail</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function">linkedList *<span class="title">listInsertNode</span><span class="params">(linkedList *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">bool</span> after)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(linkedList *<span class="built_in">list</span>, listNode *node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span>;</span><br><span class="line"><span class="function">linkedList* <span class="title">listRewind</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">listLength</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !__SINGLELIST_H__</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"singleList.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">linkedList * <span class="title">listCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linkedList *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listEmpty(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != <span class="built_in">list</span>-&gt;head) {</span><br><span class="line">        listNode *pNode = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = pNode-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">list</span>-&gt;<span class="built_in">free</span>) {</span><br><span class="line">            <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(pNode-&gt;value);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">free</span>(pNode-&gt;value);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(pNode);</span><br><span class="line">        pNode = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">linkedList * <span class="title">listAddNodeHead</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> * value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span> || <span class="literal">NULL</span> == value) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *node = <span class="literal">NULL</span>;</span><br><span class="line">    node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*node));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == node) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line"></span><br><span class="line">    ++<span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">linkedList * <span class="title">listAddNodeTail</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span> || <span class="literal">NULL</span> == value) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *node = <span class="literal">NULL</span>;</span><br><span class="line">    node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*node));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == node) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>-&gt;head &amp;&amp; <span class="built_in">list</span>-&gt;len == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        listNode *tail = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        listNode *pre = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> != tail) {</span><br><span class="line">            pre = tail;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ++<span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">linkedList * <span class="title">listInsertNode</span><span class="params">(linkedList *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">bool</span> after)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span> || <span class="literal">NULL</span> == old_node) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *pNode = <span class="literal">NULL</span>;</span><br><span class="line">    pNode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*pNode));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pNode) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNode-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (after) {</span><br><span class="line">        pNode-&gt;next = old_node-&gt;next;</span><br><span class="line">        old_node-&gt;next = pNode;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        listNode *pre = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next != old_node) {</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pre) {</span><br><span class="line">            pre-&gt;next = pNode;</span><br><span class="line">            pNode-&gt;next = old_node;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ++<span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(linkedList *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span> || <span class="literal">NULL</span> == node) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *pre = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    listNode *cur = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != cur &amp;&amp; cur != node) {</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pre) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pre-&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    --<span class="built_in">list</span>-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">list</span>-&gt;<span class="built_in">free</span>) {</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        node = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">listNode * <span class="title">listSearchKey</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *node = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != node) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">list</span>-&gt;match) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(key, node-&gt;value) == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) {</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">listNode * <span class="title">listIndex</span><span class="params">(linkedList *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; <span class="built_in">list</span>-&gt;len) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *pNode = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; index; ++i) {</span><br><span class="line">        pNode = pNode-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">linkedList* <span class="title">listRewind</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    listNode *head = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    listNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    listNode *next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != head) {</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = pre;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">listLength</span><span class="params">(linkedList *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<details>
<summary>single_list</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">single_list_head</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">head</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(struct single_list_head *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> head-&gt;head == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(struct single_list_head *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">tmp</span> =</span> head-&gt;head;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tmp) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%02d]: %08d\n"</span>, idx++, tmp-&gt;val);</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(struct single_list **prev, struct single_list *elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!prev)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    elem-&gt;next = *prev;</span><br><span class="line">    *prev = elem;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_head</span><span class="params">(struct single_list_head *head, struct single_list *elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    insert(&amp;head-&gt;head, elem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct single_list* <span class="title">del</span><span class="params">(struct single_list **prev)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (*prev == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    tmp = *prev;</span><br><span class="line">    *prev = (*prev)-&gt;next;</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">struct single_list* <span class="title">delete_head</span><span class="params">(struct single_list_head* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> del(&amp;head-&gt;head);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">struct single_list** <span class="title">search</span><span class="params">(struct single_list_head* head, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> **<span class="title">prev</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (prev = &amp;head-&gt;head, tmp = *prev; tmp &amp;&amp; (tmp-&gt;val &lt; target);</span><br><span class="line">    prev = &amp;tmp-&gt;next, tmp = *prev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(struct single_list_head* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list_head</span> <span class="title">tmp</span> =</span> {<span class="literal">NULL</span>};</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">elem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_empty(head)) {</span><br><span class="line">        elem = delete_head(head);</span><br><span class="line">        insert_head(&amp;tmp, elem);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    head-&gt;head = tmp.head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_cyclic</span><span class="params">(struct single_list_head* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">s1</span>, *<span class="title">s2</span>;</span></span><br><span class="line"></span><br><span class="line">    s1 = s2 = head-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(s1 &amp;&amp; s2) {</span><br><span class="line">        s1 = s1-&gt;next;</span><br><span class="line">        s2 = s2-&gt;next ? s2-&gt;next-&gt;next:s2-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s1 == s2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct single_list* <span class="title">middle</span><span class="params">(struct single_list_head* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> *<span class="title">s1</span>, *<span class="title">s2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> <span class="title">pseudo_head</span>;</span></span><br><span class="line"></span><br><span class="line">    pseudo_head.next = head-&gt;head;</span><br><span class="line">    s1 = s2 = &amp;pseudo_head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (!s2 || !s2-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> s1;</span><br><span class="line">        s1 = s1-&gt;next;</span><br><span class="line">        s2 = s2-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list_head</span> <span class="title">head</span> =</span> {<span class="literal">NULL</span>};</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> <span class="title">lists</span>[10];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">single_list</span> **<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; <span class="number">10</span>; idx++) {</span><br><span class="line">        lists[idx].val = idx;</span><br><span class="line">        lists[idx].next = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    insert_head(&amp;head, &amp;lists[<span class="number">6</span>]);</span><br><span class="line">    insert_head(&amp;head, &amp;lists[<span class="number">5</span>]);</span><br><span class="line">    insert_head(&amp;head, &amp;lists[<span class="number">4</span>]);</span><br><span class="line">    insert_head(&amp;head, &amp;lists[<span class="number">1</span>]);</span><br><span class="line">    insert_head(&amp;head, &amp;lists[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== insert 0, 1, 4, 5, 6\n"</span>);</span><br><span class="line">    dump(&amp;head);</span><br><span class="line"></span><br><span class="line">    prev = search(&amp;head, <span class="number">2</span>);</span><br><span class="line">    insert(prev, &amp;lists[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== insert 2\n"</span>);</span><br><span class="line">    dump(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"middle elem is %d\n"</span>, middle(&amp;head)-&gt;val);</span><br><span class="line"></span><br><span class="line">    prev = search(&amp;head, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> ((*prev) &amp;&amp; ((*prev)-&gt;val == <span class="number">2</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The list contains 2\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The list not contains 2\n"</span>);</span><br><span class="line"></span><br><span class="line">    del(prev);</span><br><span class="line">    prev = search(&amp;head, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After remove 2\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((*prev) &amp;&amp; ((*prev)-&gt;val == <span class="number">2</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The list contains 2\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The list not contains 2\n"</span>);</span><br><span class="line">    dump(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After reverse \n"</span>);</span><br><span class="line">    reverse(&amp;head);</span><br><span class="line">    dump(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"middle elem is %d\n"</span>, middle(&amp;head)-&gt;val);</span><br><span class="line"></span><br><span class="line">    lists[<span class="number">0</span>].next = &amp;lists[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"list is%s cyclic\n"</span>, is_cyclic(&amp;head)?<span class="string">""</span>:<span class="string">" not"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<details>
<summary>LinkedListAlgo</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1) 单链表反转</span></span><br><span class="line"><span class="comment"> * 2) 链表中环的检测</span></span><br><span class="line"><span class="comment"> * 3) 两个有序的链表合并</span></span><br><span class="line"><span class="comment"> * 4) 删除链表倒数第 n 个结点</span></span><br><span class="line"><span class="comment"> * 5) 求链表的中间结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Author: Smallfly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SinglyLinkedNode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SinglyLinkedNode</span>* <span class="title">next</span>;</span></span><br><span class="line">} SinglyLinkedNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(SinglyLinkedNode** head_ref, <span class="keyword">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(SinglyLinkedNode* head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 反转单链表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(SinglyLinkedNode** head_ref)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">    SinglyLinkedNode *current = *head_ref;</span><br><span class="line">    <span class="keyword">while</span> (current) {</span><br><span class="line">        SinglyLinkedNode *next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!next) {</span><br><span class="line">            <span class="comment">// 到达尾结点时，将地址存入 head_ref</span></span><br><span class="line">            *head_ref = current;</span><br><span class="line">        }</span><br><span class="line">        current-&gt;next = prev;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = next;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_reverse</span><span class="params">()</span> </span>{</span><br><span class="line">    SinglyLinkedNode* head = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;head, <span class="number">3</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">2</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    reverse(&amp;head);</span><br><span class="line">    printLinkedList(head);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 检测单链表是否有环 */</span></span><br><span class="line"><span class="comment">// 这里使用一级指针也可以</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkCircle</span><span class="params">(SinglyLinkedNode** head_ref)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    SinglyLinkedNode *slow = *head_ref, *fast = *head_ref;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_checkCircle</span><span class="params">()</span> </span>{</span><br><span class="line">    SinglyLinkedNode* head = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;head, <span class="number">3</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">2</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result1 = checkCircle(&amp;head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"has circle: %d\n"</span>, result1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// make circle linklist</span></span><br><span class="line">    SinglyLinkedNode* current = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SinglyLinkedNode));</span><br><span class="line">    current-&gt;data = <span class="number">0</span>;</span><br><span class="line">    SinglyLinkedNode* h = current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">        SinglyLinkedNode* node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SinglyLinkedNode));</span><br><span class="line">        node-&gt;data = i;</span><br><span class="line">        current-&gt;next = node;</span><br><span class="line">        <span class="comment">//reset current node</span></span><br><span class="line">        current = node;</span><br><span class="line">    }</span><br><span class="line">    current-&gt;next = h;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result2 = checkCircle(&amp;h);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"has circle: %d\n"</span>, result2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 有序链表合并 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveNode</span><span class="params">(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SinglyLinkedNode* <span class="title">mergeSortedLinkedList</span><span class="params">(SinglyLinkedNode* la, SinglyLinkedNode* lb)</span> </span>{</span><br><span class="line">    <span class="comment">// 辅助结点，next 指针持有合并后的有序链表</span></span><br><span class="line">    SinglyLinkedNode dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有序链表的尾结点</span></span><br><span class="line">    SinglyLinkedNode* tail = &amp;dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 如果有一个链表为空，直接与另一个链表接起来</span></span><br><span class="line">        <span class="keyword">if</span> (!la) {</span><br><span class="line">            tail-&gt;next = lb;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!lb) {</span><br><span class="line">            tail-&gt;next = la;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将头结点较小的优先添加到 tail</span></span><br><span class="line">        <span class="keyword">if</span> (la-&gt;data &lt;= lb-&gt;data) {</span><br><span class="line">            moveNode(&amp;(tail-&gt;next), &amp;la);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            moveNode(&amp;(tail-&gt;next), &amp;lb);</span><br><span class="line">        }</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 src_ref 的头结点，添加到 dest_ref 的头部。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveNode</span><span class="params">(SinglyLinkedNode** dest_ref, SinglyLinkedNode** src_ref)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*src_ref == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    SinglyLinkedNode* new_node = *src_ref;</span><br><span class="line">    </span><br><span class="line">    *src_ref = new_node-&gt;next;</span><br><span class="line">    </span><br><span class="line">    new_node-&gt;next = *dest_ref;</span><br><span class="line">    *dest_ref = new_node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_mergeSortedLinkedList</span><span class="params">()</span> </span>{</span><br><span class="line">    SinglyLinkedNode* a = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;a, <span class="number">10</span>);</span><br><span class="line">    insertNode(&amp;a, <span class="number">5</span>);</span><br><span class="line">    insertNode(&amp;a, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode* b = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;b, <span class="number">8</span>);</span><br><span class="line">    insertNode(&amp;b, <span class="number">6</span>);</span><br><span class="line">    insertNode(&amp;b, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode* result = mergeSortedLinkedList(a, b);</span><br><span class="line">    printLinkedList(result);</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode* result2 = mergeSortedLinkedList(a, <span class="literal">NULL</span>);</span><br><span class="line">    printLinkedList(result2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 删除倒数第 K 个结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteLastKth</span><span class="params">(SinglyLinkedNode** head_ref, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*head_ref == <span class="literal">NULL</span> || k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快指针向前移动 k-1</span></span><br><span class="line">    SinglyLinkedNode* fast = *head_ref;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; k &amp;&amp; fast != <span class="literal">NULL</span>) {</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        ++i;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果快指针为空，说明结点个数小于 k</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode* slow = *head_ref;</span><br><span class="line">    SinglyLinkedNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        prev = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 prev 为空，头结点刚好是第 k 个结点</span></span><br><span class="line">    <span class="keyword">if</span> (!prev) {</span><br><span class="line">        (*head_ref) = (*head_ref)-&gt;next;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        prev-&gt;next = slow-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(slow);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_deleteLastKth</span><span class="params">()</span> </span>{</span><br><span class="line">    SinglyLinkedNode* head = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;head, <span class="number">1</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">2</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">3</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">4</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 删除头结点</span></span><br><span class="line">    deleteLastKth(&amp;head, <span class="number">5</span>);</span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 删除中间结点</span></span><br><span class="line">    deleteLastKth(&amp;head, <span class="number">2</span>);</span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 求中间结点  */</span></span><br><span class="line"><span class="function">SinglyLinkedNode* <span class="title">findMiddleNode</span><span class="params">(SinglyLinkedNode* head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    SinglyLinkedNode* slow = head;</span><br><span class="line">    SinglyLinkedNode* fast = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 慢指针走一步，快指针两步</span></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_findMiddleNode</span><span class="params">()</span> </span>{</span><br><span class="line">    SinglyLinkedNode* head = <span class="literal">NULL</span>;</span><br><span class="line">    insertNode(&amp;head, <span class="number">1</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">2</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">3</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">4</span>);</span><br><span class="line">    insertNode(&amp;head, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    SinglyLinkedNode* middleNode = findMiddleNode(head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, middleNode-&gt;data);</span><br><span class="line">    printLinkedList(head);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 工具方法 */</span></span><br><span class="line"><span class="comment">// 插入新结点到链表头部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(SinglyLinkedNode** head_ref, <span class="keyword">int</span> data)</span> </span>{</span><br><span class="line">    SinglyLinkedNode* new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SinglyLinkedNode));</span><br><span class="line">    new_node-&gt;data = data;</span><br><span class="line">    new_node-&gt;next = *head_ref;</span><br><span class="line">    *head_ref = new_node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(SinglyLinkedNode* node)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--- start ---\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (node) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"data: %d\n"</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--- end ---\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跑测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">    </span><br><span class="line">    test_reverse();  </span><br><span class="line"><span class="comment">//    test_checkCircle();</span></span><br><span class="line"><span class="comment">//    test_mergeSortedLinkedList();</span></span><br><span class="line"><span class="comment">//    test_deleteLastKth();  </span></span><br><span class="line"><span class="comment">//    test_findMiddleNode();</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<details>
<summary>linklist_jinshaohui</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: lisklist.c</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-10-07  </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stlistNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">}listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*反转链表*/</span></span><br><span class="line"><span class="function">listNode <span class="title">reverseList</span><span class="params">(listNode *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    listNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">    listNode *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">NULL</span>) {</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        head-&gt;next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断链表是否有环*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hasCycle</span><span class="params">(listNode *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    listNode * fast = head;</span><br><span class="line">    listNode * low = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        low = low-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (low == fast) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*合并有序链表*/</span></span><br><span class="line"><span class="function">listNode *<span class="title">mergeTwoLists</span><span class="params">(listNode *l1,listNode *l2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    listNode head = {<span class="number">0</span>};</span><br><span class="line">    listNode *pRes = &amp;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>) {</span><br><span class="line">            pRes-&gt;next = l2;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) {</span><br><span class="line">            pRes-&gt;next = l1;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) {</span><br><span class="line">            pRes-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            pRes-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        pRes = pRes-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *删除链表倒数第n个节点，并返回链表头节点 */</span></span><br><span class="line"><span class="function">listNode * <span class="title">removeNthFromEnd</span><span class="params">(listNode*headi,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    listNode *fast = head;</span><br><span class="line">    listNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">    listNpde *next = head;</span><br><span class="line">    <span class="keyword">int</span> k = n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*快指针往后移动k-1*/</span></span><br><span class="line">    <span class="keyword">while</span>((k &gt; <span class="number">1</span>) &amp;&amp; (fast != <span class="literal">NULL</span>)) {</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        k--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*说明链表数目不足n个*/</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        prev = next;</span><br><span class="line">        next = next-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prev == <span class="literal">NULL</span>) {</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*求链表的中间节点*/</span></span><br><span class="line"><span class="function">listNode *<span class="title">middleNode</span><span class="params">(listNode *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    listNode * fast = head;</span><br><span class="line">    listNode * low = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        low = low-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<h4 id="2-1-3-双链表"><a href="#2-1-3-双链表" class="headerlink" title="2.1.3 双链表"></a>2.1.3 双链表</h4><p>  双向链表的元素通过两个指针链接，一个指向直接后继，一个指向直接前驱。双向链表可以正向遍历，也可反向遍历。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DListElmt_</span> {</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DListElmt_</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DListElmt_</span> *<span class="title">next</span>;</span></span><br><span class="line">} DListElmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DList_</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">void</span> *data);</span><br><span class="line">    DListElmt *head;</span><br><span class="line">    DListElmt *tail;</span><br><span class="line">} DList;</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>Dlist</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dlist.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DlistNode</span> {</span>    <span class="comment">//双向链表中每一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DlistNode</span> *<span class="title">prev</span>;</span>   <span class="comment">//节点前项指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DlistNode</span> *<span class="title">next</span>;</span>   <span class="comment">//节点后项指针</span></span><br><span class="line">    <span class="keyword">int</span>    data;              <span class="comment">//数据</span></span><br><span class="line">}stDlistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dlisthead</span> {</span>    <span class="comment">//定义链表总体</span></span><br><span class="line">    <span class="keyword">int</span> size;                 <span class="comment">//链表长度</span></span><br><span class="line">    stDlistNode *head;        <span class="comment">//头指针</span></span><br><span class="line">    stDlistNode *tail;        <span class="comment">//尾部指针</span></span><br><span class="line">}stDlistHead;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dlist.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./Dlist.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlist_init</span><span class="params">(stDlistHead *dlist)</span>    <span class="comment">//链表初始化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dlist-&gt;size = <span class="number">0</span>;</span><br><span class="line">    dlist-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    dlist-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlist_destory</span><span class="params">(stDlistHead *dlist)</span>    <span class="comment">//删除链表</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stDlistNode *pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dlist-&gt;size &gt; <span class="number">0</span>) {</span><br><span class="line">        pNode = dlist-&gt;head;</span><br><span class="line">        dlist-&gt;head = dlist-&gt;head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pNode);</span><br><span class="line">        dlist-&gt;size--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dlist,<span class="number">0</span>,<span class="keyword">sizeof</span>(stDlistHead));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlist_insert_head</span><span class="params">(stDlistHead *dlist,stDlistNode *pNode,<span class="keyword">int</span> data)</span>    <span class="comment">//插入头结点，操作的链表，操作的节点，数据</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>) {   <span class="comment">//当只传递一个数据时</span></span><br><span class="line">        pNode = (stDlistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stDlistNode));    <span class="comment">//新建节点，为节点分配空间（malloc（）可能需要#include&lt;malloc.h&gt;）</span></span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNode-&gt;data = data;    </span><br><span class="line">    pNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    pNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dlist-&gt;size == <span class="number">0</span>) {  <span class="comment">//如果链表长度为0，即链表当前无节点，</span></span><br><span class="line">        dlist-&gt;head = pNode;</span><br><span class="line">        dlist-&gt;tail = pNode;</span><br><span class="line">    } <span class="keyword">else</span> {                 <span class="comment">//如果链表已有节点，则令新插入节点为头节点</span></span><br><span class="line">        pNode-&gt;next = dlist-&gt;head;</span><br><span class="line">        dlist-&gt;head-&gt;prev = pNode;</span><br><span class="line">        dlist-&gt;head = pNode;    </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dlist-&gt;size++;    <span class="comment">//每成功调用一次，链表长度+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">stDlistNode * <span class="title">dlist_remove_tail</span><span class="params">(stDlistHead *dlist)</span>    <span class="comment">//删除尾部节点,并返回删除节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stDlistNode *pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dlist-&gt;size == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNode = dlist-&gt;tail;</span><br><span class="line">    <span class="keyword">if</span>(dlist-&gt;size &gt; <span class="number">1</span>) {</span><br><span class="line">        dlist-&gt;tail = dlist-&gt;tail-&gt;prev;</span><br><span class="line">        dlist-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        dlist-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">        dlist-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    dlist-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlist_remove_node</span><span class="params">(stDlistHead * dlist,stDlistNode *pNode)</span>     <span class="comment">//删除指定节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> ((dlist == <span class="literal">NULL</span>)||(pNode == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dlist-&gt;head == pNode) {</span><br><span class="line">        dlist-&gt;head = dlist-&gt;head-&gt;next;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (dlist-&gt;tail == pNode) {</span><br><span class="line">        dlist-&gt;tail = pNode-&gt;prev;</span><br><span class="line">        dlist-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        pNode-&gt;prev-&gt;next = pNode-&gt;next;</span><br><span class="line">        pNode-&gt;next-&gt;prev = pNode-&gt;prev;</span><br><span class="line">    }</span><br><span class="line">    dlist-&gt;size--;</span><br><span class="line">    pNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    pNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dlist-&gt;size == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">memset</span>(dlist,<span class="number">0</span>,<span class="keyword">sizeof</span>(stDlistHead));     <span class="comment">//将dlist占用内存块的所有值置为0，也就是清空head,tail指针内容</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function">stDlistNode * <span class="title">dlist_search</span><span class="params">(stDlistHead * dlist,<span class="keyword">int</span> data)</span>     <span class="comment">//根据值搜索节点，并返回</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stDlistNode *pNode = dlist-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;data == data) {</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        }</span><br><span class="line">        pNode = pNode-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlist_dump</span><span class="params">(stDlistHead *dlist)</span>    <span class="comment">//显示链表中的数据</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> no = <span class="number">0</span>;</span><br><span class="line">    stDlistNode *pNode = dlist-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n [%d] = %d"</span>,no++,pNode-&gt;data);</span><br><span class="line">        pNode = pNode-&gt;next;    <span class="comment">//将pNode的下一个节点赋值给pNode，推进循环</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lru_dlist</span><span class="params">(stDlistHead *dlist,<span class="keyword">int</span> data)</span>     <span class="comment">//LRU（最近最少使用）缓存淘汰算法</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stDlistNode *pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pNode = dlist_search(dlist,data);    </span><br><span class="line">    <span class="keyword">if</span> (pNode != <span class="literal">NULL</span>) {    <span class="comment">//如果在链表中找到这个值，则删除储存这个值的节点，之后吧这个节点放在头部</span></span><br><span class="line">        dlist_remove_node(dlist,pNode);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(dlist-&gt;size &gt;= <span class="number">4</span>)    {    <span class="comment">//没在链表中找到，且链表长度大于4，则从链表中删除尾部节点，将新数据放在头部</span></span><br><span class="line">        pNode = dlist_remove_tail(dlist);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dlist_insert_head(dlist ,pNode,data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stDlistHead dlist = {<span class="number">0</span>};</span><br><span class="line">    stDlistNode * pNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    dlist_init(&amp;dlist);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n inset 1,2,3"</span>);</span><br><span class="line">    dlist_insert_head(&amp;dlist,<span class="literal">NULL</span>,<span class="number">1</span>);</span><br><span class="line">    dlist_insert_head(&amp;dlist,<span class="literal">NULL</span>,<span class="number">2</span>);</span><br><span class="line">    dlist_insert_head(&amp;dlist,<span class="literal">NULL</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line"></span><br><span class="line">    pNode = dlist_remove_tail(&amp;dlist);</span><br><span class="line">    <span class="keyword">if</span>(pNode != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n remove %d"</span>,pNode-&gt;data);</span><br><span class="line">    }</span><br><span class="line">    dlist_insert_head(&amp;dlist,pNode,<span class="number">4</span>);</span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line"></span><br><span class="line">    Lru_dlist(&amp;dlist,<span class="number">5</span>);</span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line">    Lru_dlist(&amp;dlist,<span class="number">6</span>);</span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line">    Lru_dlist(&amp;dlist,<span class="number">7</span>);</span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line">    Lru_dlist(&amp;dlist,<span class="number">5</span>);</span><br><span class="line">    dlist_dump(&amp;dlist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dlist.size &gt; <span class="number">0</span>) {</span><br><span class="line">        pNode = dlist_remove_tail(&amp;dlist);</span><br><span class="line">        <span class="keyword">if</span>(pNode != <span class="literal">NULL</span>) { </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n remove %d"</span>,pNode-&gt;data);</span><br><span class="line">            <span class="built_in">free</span> (pNode);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<details>
<summary>linux/list</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux内核源码双向链表实现include/linux/list.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIST_HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LIST_HEAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化节点：设置name节点的前继节点和后继节点都是指向name本身。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义表头(节点)：新建双向链表表头name，并设置name的前继节点和后继节点都是指向name本身。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line"><span class="meta">    struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化节点：将list节点的前继节点和后继节点都是指向list本身。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加节点：将new插入到prev和next之间。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">                  struct list_head *prev,</span><br><span class="line">                  struct list_head *next)</span><br><span class="line">{</span><br><span class="line">    next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加new节点：将new添加到head之后，是new称为head的后继节点。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(struct list_head *<span class="keyword">new</span>, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head, head-&gt;next);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加new节点：将new添加到head之前，即将new添加到双链表的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *<span class="keyword">new</span>, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head-&gt;prev, head);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双链表中删除entry节点。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(struct list_head * prev, struct list_head * next)</span><br><span class="line">{</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双链表中删除entry节点。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双链表中删除entry节点。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del_entry(struct list_head *entry)</span><br><span class="line">{</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双链表中删除entry节点，并将entry节点的前继节点和后继节点都指向entry本身。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del_init</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __list_del_entry(entry);</span><br><span class="line">    INIT_LIST_HEAD(entry);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用new节点取代old节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_replace</span><span class="params">(struct list_head *old,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = old-&gt;next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = old-&gt;prev;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_empty</span><span class="params">(<span class="keyword">const</span> struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取"MEMBER成员"在"结构体TYPE"中的位置偏移</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据"结构体(type)变量"中的"域成员变量(member)的指针(ptr)"来获取指向整个结构体变量的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) ({          \</span></span><br><span class="line"><span class="meta">    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \</span></span><br><span class="line"><span class="meta">    (type *)( (char *)__mptr - offsetof(type,member) );})</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历双向链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \</span></span><br><span class="line"><span class="meta">        pos = n, n = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
</details>

<h4 id="2-1-4-跳表"><a href="#2-1-4-跳表" class="headerlink" title="2.1.4 跳表"></a>2.1.4 跳表</h4><p> 跳表对标的是平衡树(AVL Tree), 插入/删除/搜索都是 O(logn)的数据结构。</p>
<details>
<summary>skiplist</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: skiplist.h</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-10-31</span></span><br><span class="line"><span class="comment"> &gt; Desc:    </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SKIP_LIST_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SKIP_LIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> key;    <span class="comment">/*key是唯一的*/</span></span><br><span class="line">    <span class="keyword">int</span> value;  <span class="comment">/*存储的内容*/</span></span><br><span class="line">    <span class="keyword">int</span> max_level; <span class="comment">/*当前节点最大层数*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>[0];</span><span class="comment">/*level层链表结构*/</span></span><br><span class="line">}node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">skiplist</span> {</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    node *head;</span><br><span class="line">}skiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据当前结构体元素的地址，获取到结构体首地址*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container(ptr,type,member) ({\</span></span><br><span class="line"><span class="meta">  const typeof( ((type *)0)-&gt;member) *__mptr = (ptr);\</span></span><br><span class="line"><span class="meta">  (type *) ( (char *)__mptr - offsetof(type,member));})</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./skiplist.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建node节点*/</span></span><br><span class="line"><span class="function">node* <span class="title">skip_list_create_node</span><span class="params">(<span class="keyword">int</span> level,<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    node * tmp = <span class="literal">NULL</span>;</span><br><span class="line">    tmp =(node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node) + level*<span class="keyword">sizeof</span>(node *));</span><br><span class="line">    assert(tmp != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(node) + level*<span class="keyword">sizeof</span>(node*));</span><br><span class="line">    tmp-&gt;key = key;</span><br><span class="line">    tmp-&gt;value = value;</span><br><span class="line">    tmp-&gt;max_level = level;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建跳表的表头，max_level层数*/</span></span><br><span class="line"><span class="function">skiplist * <span class="title">skip_list_create</span><span class="params">(<span class="keyword">int</span> max_level)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    skiplist * <span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span> = (skiplist *)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(skiplist));</span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;level = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = skip_list_create_node(max_level,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*skiplist 销毁*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">skip_list_destory</span><span class="params">(skiplist * <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    node * tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">list</span> == <span class="literal">NULL</span>) || (<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">list</span>-&gt;head-&gt;next[<span class="number">0</span>] != <span class="literal">NULL</span>) {</span><br><span class="line">        tmp = <span class="built_in">list</span>-&gt;head-&gt;next[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;next[<span class="number">0</span>] = tmp-&gt;next[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>-&gt;head);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入元素获得层数，是随机产生的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">skip_list_level</span><span class="params">(skiplist * <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;head-&gt;max_level; i++) {</span><br><span class="line">        <span class="keyword">if</span> ((rand()%<span class="number">2</span>) == <span class="number">1</span>) {</span><br><span class="line">            level++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">skip_list_insert</span><span class="params">(skiplist *<span class="built_in">list</span>,<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    node **update = <span class="literal">NULL</span>;<span class="comment">/*用来更新每层的指针*/</span></span><br><span class="line">    node *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    node *prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*申请update空间用于保存每层的指针*/</span></span><br><span class="line">    update = (node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node *)*<span class="built_in">list</span>-&gt;head-&gt;max_level);</span><br><span class="line">    <span class="keyword">if</span> (update == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*逐层查询节点的*/</span></span><br><span class="line">    prev = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (i = (<span class="built_in">list</span>-&gt;level <span class="number">-1</span>); i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="comment">/*初始化每level层的头指针*/</span></span><br><span class="line">        <span class="keyword">while</span>(((tmp = prev-&gt;next[i]) != <span class="literal">NULL</span>) &amp;&amp; (tmp-&gt;key &lt; key)) {</span><br><span class="line">            prev  = tmp;</span><br><span class="line">        }</span><br><span class="line">        update[i] = prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*当前key已经存在，返回错误*/</span></span><br><span class="line">    <span class="keyword">if</span> ((tmp!= <span class="literal">NULL</span>) &amp;&amp; (tmp-&gt;key == key)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*获取插入元素的随机层数，并更新跳表的最大层数*/</span></span><br><span class="line">    level = skip_list_level(<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">/*创建当前数据节点*/</span></span><br><span class="line">    tmp = skip_list_create_node(level,key,value);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*更新最大层数*/</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="built_in">list</span>-&gt;level) {</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="built_in">list</span>-&gt;level;i &lt; level; i ++) {</span><br><span class="line">            update[i] = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">list</span>-&gt;level = level;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*逐层更新节点的指针*/</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; level; i++) {</span><br><span class="line">        tmp-&gt;next[i] = update[i]-&gt;next[i];</span><br><span class="line">        update[i]-&gt;next[i] = tmp; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">skip_list_delete</span><span class="params">(skiplist * <span class="built_in">list</span>, <span class="keyword">int</span> key ,<span class="keyword">int</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    node **update = <span class="literal">NULL</span>;<span class="comment">/*用来更新每层的指针*/</span></span><br><span class="line">    node *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    node *prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> == <span class="literal">NULL</span>) &amp;&amp; (value == <span class="literal">NULL</span>)&amp;&amp; (<span class="built_in">list</span>-&gt;count == <span class="number">0</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*申请update空间用于保存每层的指针*/</span></span><br><span class="line">    update = (node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node *)*<span class="built_in">list</span>-&gt;level);</span><br><span class="line">    <span class="keyword">if</span> (update == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*逐层查询节点的*/</span></span><br><span class="line">    prev = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">for</span> (i = (<span class="built_in">list</span>-&gt;level <span class="number">-1</span>); i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="comment">/*初始化每level层的头指针*/</span></span><br><span class="line">        <span class="keyword">while</span>(((tmp = prev-&gt;next[i]) != <span class="literal">NULL</span>) &amp;&amp; (tmp-&gt;key &lt; key)) {</span><br><span class="line">            prev = tmp;</span><br><span class="line">        }</span><br><span class="line">        update[i] = prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((tmp != <span class="literal">NULL</span>) &amp;&amp; (tmp-&gt;key == key)) {</span><br><span class="line">        *value = tmp-&gt;value;</span><br><span class="line">        <span class="comment">/*逐层删除*/</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;level; i++) {</span><br><span class="line">            <span class="keyword">if</span>(update[i]-&gt;next[i] == tmp) {</span><br><span class="line">                update[i]-&gt;next[i] = tmp-&gt;next[i];       </span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        tmp = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*更新level的层数*/</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head-&gt;next[i] == <span class="literal">NULL</span> ) {</span><br><span class="line">                <span class="built_in">list</span>-&gt;level--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span>-&gt;count--;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;<span class="comment">/*未找到节点*/</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询当前key是否在跳表中，如果存在返回查询的value数值，不存在返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">skip_list_search</span><span class="params">(skiplist *<span class="built_in">list</span>,<span class="keyword">int</span> key,<span class="keyword">int</span> *value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    node *prev = <span class="literal">NULL</span>;</span><br><span class="line">    node *tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">list</span> == <span class="literal">NULL</span>) || (<span class="built_in">list</span>-&gt;count == <span class="number">0</span>) || (value == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    prev = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">while</span>(((tmp = prev-&gt;next[i]) != <span class="literal">NULL</span>) &amp;&amp; (tmp-&gt;key &lt;= key)) {</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;key == key) {</span><br><span class="line">                    *value = tmp-&gt;value;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            prev = tmp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">skip_list_dump</span><span class="params">(skiplist *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    node *ptmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n----------------------------------------------"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n skip list level[%d],count[%d]"</span>,<span class="built_in">list</span>-&gt;level,<span class="built_in">list</span>-&gt;count);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) {</span><br><span class="line">        ptmp = <span class="built_in">list</span>-&gt;head-&gt;next[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n level[%d]:"</span>,i);</span><br><span class="line">        <span class="keyword">while</span>(ptmp != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d-%d "</span>,ptmp-&gt;key,ptmp-&gt;value);</span><br><span class="line">            ptmp = ptmp-&gt;next[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n----------------------------------------------"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    skiplist *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span> = skip_list_create(<span class="number">5</span>);</span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 请输入key 和 value，当key = 1000时，退出输入："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;key,&amp;value);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="number">1000</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        res = skip_list_insert(<span class="built_in">list</span>,key,value);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n skip list insert %d,failed,res=%d."</span>,key,res);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    skip_list_dump(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 通过key 查询value的数值，当key = 1000时，退出查询"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;key);</span><br><span class="line">        <span class="keyword">if</span>(key == <span class="number">1000</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        res = skip_list_search(<span class="built_in">list</span>,key,&amp;value);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n skip list search %d,failed,res=%d."</span>,key,res);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n skip list search %d,sucessful,value=%d."</span>,key,value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    skip_list_dump(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 通过key 删除节点，当key = 1000时，退出删除"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;key);</span><br><span class="line">        <span class="keyword">if</span>(key == <span class="number">1000</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        res = skip_list_delete(<span class="built_in">list</span>,key,&amp;value);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n skip list search %d,failed,res=%d."</span>,key,res);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n skip list search %d,sucessful,value=%d."</span>,key,value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    skip_list_dump(<span class="built_in">list</span>);</span><br><span class="line">    skip_list_destory(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<h4 id="2-1-5-栈"><a href="#2-1-5-栈" class="headerlink" title="2.1.5 栈"></a>2.1.5 栈</h4><p> 栈按照后进先出(LIFO)的顺序存储和检索数据的数据结构，检索元素的顺序和存储元素顺序相反。<br> 可通过链表来实现栈stack,允许插入和删除的为栈顶(<code>top</code>),另一端为栈底(<code>bottom</code>),栈中每个元素为<code>frame</code>,栈只支持三个操作:<code>pop</code>,<code>top</code>,<code>push</code>.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> List Stack;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_init list_init;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="keyword">void</span> **data)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_peek(stack) ((stack)-&gt;head == NULL ? NULL : (stack)-&gt;head-&gt;data);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_size list_size;</span></span><br></pre></td></tr></tbody></table></figure>
<p> c语言顺序栈</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素elem进栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">int</span> top, <span class="keyword">char</span> elem)</span> </span>{</span><br><span class="line">    a[++top] = elem;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 数据元素出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">int</span> top)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<details>
<summary>arrayStack</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: arrayStack</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-10-12</span></span><br><span class="line"><span class="comment"> &gt; Desc:   数组实现顺序栈 </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAY_STACJ_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_STACJ_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">array_stack</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">/*栈的大小*/</span></span><br><span class="line">    <span class="keyword">int</span> pos;<span class="comment">/*当前存储元素的个数，即栈顶元素下表*/</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>;<span class="comment">/*数据存储区*/</span></span><br><span class="line">}stArrayStack;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arrayStack_size(arrayStack) (arrayStack-&gt;size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arrayStack_is_empty(arrayStack) (arrayStack-&gt;pos == -1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arrayStack_is_full(arrayStack)  (arrayStack-&gt;pos == (arrayStack-&gt;size-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./arrayStack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建并初始化顺序栈*/</span></span><br><span class="line"><span class="function">stArrayStack * <span class="title">arrayStack_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stArrayStack *parrStack = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    parrStack = (stArrayStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stArrayStack));</span><br><span class="line">    <span class="keyword">if</span> (parrStack == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    parrStack-&gt;size = size;</span><br><span class="line">    parrStack-&gt;pos = <span class="number">-1</span>;</span><br><span class="line">    parrStack-&gt;<span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*size);</span><br><span class="line">    <span class="keyword">if</span>(parrStack-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(parrStack);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parrStack;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*销毁顺序栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrayStack_destory</span><span class="params">(stArrayStack * parrStack)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(parrStack == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parrStack-&gt;<span class="built_in">array</span> != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(parrStack-&gt;<span class="built_in">array</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(parrStack);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*出栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayStack_pop</span><span class="params">(stArrayStack *parrStack)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(arrayStack_is_empty(parrStack)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    data = parrStack-&gt;<span class="built_in">array</span>[parrStack-&gt;pos];</span><br><span class="line">    parrStack-&gt;pos--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*入栈*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayStack_push</span><span class="params">(stArrayStack *parrStack,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(arrayStack_is_full(parrStack)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    parrStack-&gt;pos++;</span><br><span class="line">    parrStack-&gt;<span class="built_in">array</span>[parrStack-&gt;pos] = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayStack_push_new</span><span class="params">(stArrayStack*parrStack,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> *ptmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果栈不满，直接插入*/</span></span><br><span class="line">    <span class="keyword">if</span>(!arrayStack_is_full(parrStack)) {</span><br><span class="line">        <span class="keyword">return</span> arrayStack_push(parrStack,data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果栈已经满，申请内存*/</span></span><br><span class="line">    ptmp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span>*parrStack-&gt;size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (ptmp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(ptmp,parrStack-&gt;<span class="built_in">array</span>,parrStack-&gt;size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(parrStack-&gt;<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    parrStack-&gt;<span class="built_in">array</span> = ptmp;</span><br><span class="line">    parrStack-&gt;size = <span class="number">2</span>*parrStack-&gt;size;</span><br><span class="line">    parrStack-&gt;pos++;</span><br><span class="line">    parrStack-&gt;<span class="built_in">array</span>[parrStack-&gt;pos] = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrayStack_dump</span><span class="params">(stArrayStack *parrStack)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arrayStack_is_empty(parrStack)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n arrayStack is empty."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\narrayStack size = %d,pos= %d,"</span>,</span><br><span class="line">    parrStack-&gt;size,parrStack-&gt;pos);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= parrStack-&gt;pos; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\narry[%d] = %d"</span>,i,parrStack-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    stArrayStack * parrStack = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n create size = 4 arrayStack."</span>);</span><br><span class="line"></span><br><span class="line">    parrStack = arrayStack_create(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (parrStack == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n create size = 4 arrayStack faided."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        ret = arrayStack_push(parrStack,i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n push size = %d arrayStack faided."</span>,i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    arrayStack_dump(parrStack);</span><br><span class="line">    </span><br><span class="line">    ret = arrayStack_push_new(parrStack,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n push size = %d arrayStack faided."</span>,<span class="number">4</span>);</span><br><span class="line">    }</span><br><span class="line">    arrayStack_dump(parrStack);</span><br><span class="line">    arrayStack_destory(parrStack);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<p> 链栈</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> {</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> *<span class="title">next</span>;</span></span><br><span class="line">}lineStack;</span><br><span class="line"></span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>, <span class="keyword">char</span> a)</span></span>{</span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) {</span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"弹栈元素：%c "</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈顶元素：%c\n"</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈已空\n"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈内没有元素"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>linklist_stack</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: linklist_stack</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-10-12</span></span><br><span class="line"><span class="comment"> &gt; Desc:    </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_LINK_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_LINK_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">linkliststack</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">linkliststack</span> *<span class="title">next</span>;</span></span><br><span class="line">}linklist_stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_is_empty(liststack) (liststack-&gt;next == NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./linklist_stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">linklist_stack * <span class="title">stack_create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linklist_stack * <span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span> = (linklist_stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist_stack));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_destory</span><span class="params">(linklist_stack* <span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linklist_stack * ptmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack_is_empty(<span class="built_in">stack</span>)) {</span><br><span class="line">        ptmp = <span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;next = <span class="built_in">stack</span>-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(ptmp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_push</span><span class="params">(linklist_stack *<span class="built_in">stack</span>,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linklist_stack * ptmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ptmp = (linklist_stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist_stack));</span><br><span class="line">    <span class="keyword">if</span> (ptmp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ptmp-&gt;data = data;</span><br><span class="line">    ptmp-&gt;next = <span class="built_in">stack</span>-&gt;next;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = ptmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_pop</span><span class="params">(linklist_stack*<span class="built_in">stack</span>,<span class="keyword">int</span> *data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linklist_stack *ptmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(stack_is_empty(<span class="built_in">stack</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    }</span><br><span class="line">    *data = <span class="built_in">stack</span>-&gt;next-&gt;data;</span><br><span class="line">    ptmp = <span class="built_in">stack</span>-&gt;next;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = ptmp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(ptmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_dump</span><span class="params">(linklist_stack *<span class="built_in">stack</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    linklist_stack * ptmp = <span class="built_in">stack</span>-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(ptmp != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n data = %d"</span>,ptmp-&gt;data);</span><br><span class="line">        ptmp = ptmp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    linklist_stack * <span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = stack_create();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n stack create falied."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">        ret = stack_push(<span class="built_in">stack</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n stack push %d falied."</span>,i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stack_dump(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        ret = stack_pop(<span class="built_in">stack</span>,&amp;data);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n stack pop%d falied."</span>, i);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n data = %d,"</span>,data);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    stack_destory(<span class="built_in">stack</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<h4 id="2-1-6-队列"><a href="#2-1-6-队列" class="headerlink" title="2.1.6 队列"></a>2.1.6 队列</h4><p> 队列，在前端(<code>front</code>)进行删除操作，后端(<code>rear</code>)进行插入操作; 按照先进先出(<code>FIFO</code>)的顺序存储和检索数据的高效数据结构，按照元素的存储顺序检索元素。<br> 队列也可通过数组和链表实现。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> List Queue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> queue_init list_init;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> queue_destroy list_destroy;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_enqueue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_dequeue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="keyword">void</span> **data)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> queue_peek(queue) ((queue)-&gt;head == NULL ? NULL : (queue)-&gt;head-&gt;data);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> queue_size list_size;</span></span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>array_queue</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: array_queue</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-10-12</span></span><br><span class="line"><span class="comment"> &gt; Desc:    </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAY_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">array_queue</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">/*队列的大小*/</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">/*当前存储数据的大小*/</span></span><br><span class="line">    <span class="keyword">int</span> head;<span class="comment">/*队列的头*/</span></span><br><span class="line">    <span class="keyword">int</span> tail;<span class="comment">/*队列的尾*/</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>;<span class="comment">/*数据存储区*/</span></span><br><span class="line">}array_queue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> array_queue_is_empty(array_queue) (array_queue-&gt;num == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> array_queue_is_full(array_queue)  ((array_queue-&gt;num) == (array_queue-&gt;size))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./array_queue.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">array_queue * <span class="title">array_queue_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    array_queue * <span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> = (array_queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(array_queue));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*size);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size  = size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;num   = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head  = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_queue_destory</span><span class="params">(array_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;<span class="built_in">array</span> != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;<span class="built_in">array</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*入队列 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">array_queue_enqueue</span><span class="params">(array_queue *<span class="built_in">queue</span>,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/*队列为空，或者队列满时，返回-1*/</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">queue</span> == <span class="literal">NULL</span>) || (array_queue_is_full(<span class="built_in">queue</span>))) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;num++;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[<span class="built_in">queue</span>-&gt;tail] = data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = (<span class="built_in">queue</span>-&gt;tail + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">array_queue_dequeue</span><span class="params">(array_queue * <span class="built_in">queue</span>,<span class="keyword">int</span> *data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/*队列为空，数据存储为空，队列为空时返回-1*/</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">queue</span> == <span class="literal">NULL</span>) || (data == <span class="literal">NULL</span>) || (array_queue_is_empty(<span class="built_in">queue</span>))) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    *data = <span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[<span class="built_in">queue</span>-&gt;head];</span><br><span class="line">    <span class="built_in">queue</span>-&gt;num--;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = (<span class="built_in">queue</span>-&gt;head + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">array_queue_dump</span><span class="params">(array_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">queue</span> == <span class="literal">NULL</span>) || (array_queue_is_empty(<span class="built_in">queue</span>))) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n queue is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n size:%d,num:%d,head:%d,tali:%d"</span>,</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size,<span class="built_in">queue</span>-&gt;num,<span class="built_in">queue</span>-&gt;head,<span class="built_in">queue</span>-&gt;tail);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>-&gt;num; i ++) {</span><br><span class="line">        pos = (<span class="built_in">queue</span>-&gt;head + i) %<span class="built_in">queue</span>-&gt;size;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n array[%d] = %d"</span>,pos,<span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[pos]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    array_queue * <span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> = array_queue_create(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n queue is create failed."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*队列时空时，出队返回错误*/</span></span><br><span class="line">    ret = array_queue_dequeue(<span class="built_in">queue</span>, &amp;data);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n queue %d dequeue failed."</span>,ret);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*队列大小是4，入队5个，最后一个报错*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        ret = array_queue_enqueue(<span class="built_in">queue</span>,i);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n queue %d enqueue failed."</span>,i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    array_queue_dump(<span class="built_in">queue</span>);</span><br><span class="line">    </span><br><span class="line">    ret = array_queue_dequeue(<span class="built_in">queue</span>, &amp;data);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n queue %d dequeue failed."</span>,i);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n queue %d dequue."</span>,data);</span><br><span class="line">    array_queue_dump(<span class="built_in">queue</span>);</span><br><span class="line">    data = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n queue %d enqueue."</span>,data);</span><br><span class="line">    ret = array_queue_enqueue(<span class="built_in">queue</span>,data);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n queue %d enqueue failed."</span>,data);</span><br><span class="line">    }</span><br><span class="line">    array_queue_dump(<span class="built_in">queue</span>);</span><br><span class="line">    </span><br><span class="line">    array_queue_destory(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<details>
<summary>list_queue</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINK_LIST_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK_LIST_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_queue_node</span> {</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">list_queue_node</span> *<span class="title">next</span>;</span></span><br><span class="line">}queue_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">list_queue</span> {</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    queue_node *head;</span><br><span class="line">    queue_node *tail;</span><br><span class="line">}list_queue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_queue_is_empty(queue) ((queue-&gt;num) == 0)</span></span><br><span class="line"><span class="function">list_queue *<span class="title">list_queue_create</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list_queue_enqueue</span><span class="params">(list_queue *<span class="built_in">queue</span>,<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list_queue_dequeue</span><span class="params">(list_queue *<span class="built_in">queue</span>,<span class="keyword">void</span> **data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"./list_queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建队列头*/</span></span><br><span class="line"><span class="function">list_queue *<span class="title">list_queue_create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    list_queue * <span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> = (list_queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(list_queue));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;num  = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*入队*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list_queue_enqueue</span><span class="params">(list_queue *<span class="built_in">queue</span>,<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    queue_node *ptmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    ptmp = (queue_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(queue_node));</span><br><span class="line">    <span class="keyword">if</span> (ptmp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ptmp-&gt;data = data;</span><br><span class="line">    ptmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;head = ptmp;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;tail-&gt;next = ptmp;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = ptmp;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;num++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*出队*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list_queue_dequeue</span><span class="params">(list_queue *<span class="built_in">queue</span>,<span class="keyword">void</span> **data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    queue_node * ptmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">queue</span> == <span class="literal">NULL</span>) || (data == <span class="literal">NULL</span>) || list_queue_is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    *data = <span class="built_in">queue</span>-&gt;head-&gt;data;</span><br><span class="line">    ptmp = <span class="built_in">queue</span>-&gt;head;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="built_in">queue</span>-&gt;head-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;num--;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">queue</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<details>
<summary>ring_queue</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ring_queue</span> {</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> head, tail;</span><br><span class="line">    <span class="keyword">int</span> *_q;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_queue</span><span class="params">(struct ring_queue* <span class="built_in">queue</span>, <span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span> || cap &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;_q)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;_q = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(cap * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">queue</span>-&gt;_q)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="built_in">queue</span>-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;cap = cap;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_queue</span><span class="params">(struct ring_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">queue</span>-&gt;cap = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="built_in">queue</span>-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;_q);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _valid_index(<span class="keyword">int</span> curr, <span class="keyword">int</span> step, <span class="keyword">int</span> cap)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> (curr + step) % cap;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _next(<span class="keyword">int</span> curr, <span class="keyword">int</span> cap)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> _valid_index(curr, <span class="number">1</span>, cap);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(struct ring_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">queue</span>-&gt;head == <span class="built_in">queue</span>-&gt;tail);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_full</span><span class="params">(struct ring_queue *<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> next_tail = _next(<span class="built_in">queue</span>-&gt;tail, <span class="built_in">queue</span>-&gt;cap);</span><br><span class="line">    <span class="keyword">return</span> (next_tail == <span class="built_in">queue</span>-&gt;head);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enqueue</span><span class="params">(struct ring_queue* <span class="built_in">queue</span>, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (is_full(<span class="built_in">queue</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;_q[<span class="built_in">queue</span>-&gt;tail] = elem;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = _next(<span class="built_in">queue</span>-&gt;tail, <span class="built_in">queue</span>-&gt;cap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">(struct ring_queue* <span class="built_in">queue</span>, <span class="keyword">int</span> *elem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">queue</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elem)</span><br><span class="line">    *elem = <span class="built_in">queue</span>-&gt;_q[<span class="built_in">queue</span>-&gt;head];</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = _next(<span class="built_in">queue</span>-&gt;head, <span class="built_in">queue</span>-&gt;cap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(struct ring_queue* <span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">queue</span>-&gt;tail - <span class="built_in">queue</span>-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">    size += <span class="built_in">queue</span>-&gt;cap;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(struct ring_queue* <span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i, idx;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Queue has %d elements with %d capacity\n"</span>,</span><br><span class="line">    size(<span class="built_in">queue</span>), <span class="built_in">queue</span>-&gt;cap);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size(<span class="built_in">queue</span>); i++) {</span><br><span class="line">        idx = _valid_index(<span class="built_in">queue</span>-&gt;head, i, <span class="built_in">queue</span>-&gt;cap);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%02d]: %08d\n"</span>, idx, <span class="built_in">queue</span>-&gt;_q[idx]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ring_queue</span> <span class="title">queue</span> =</span> {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>};</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc_queue(&amp;<span class="built_in">queue</span>, <span class="number">8</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to allocate a queue\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"A new queue is %s\n"</span>, is_empty(&amp;<span class="built_in">queue</span>)?<span class="string">"empty"</span>:<span class="string">"not empty"</span>);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;<span class="built_in">queue</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After enqueue 1 element, queue is %s\n"</span>, is_empty(&amp;<span class="built_in">queue</span>)?<span class="string">"empty"</span>:<span class="string">"not empty"</span>);</span><br><span class="line">    dequeue(&amp;<span class="built_in">queue</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After dequeue 1 element, queue is %s\n"</span>, is_empty(&amp;<span class="built_in">queue</span>)?<span class="string">"empty"</span>:<span class="string">"not empty"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    enqueue(&amp;<span class="built_in">queue</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After enqueue 7 element, queue is %s\n"</span>, is_full(&amp;<span class="built_in">queue</span>)?<span class="string">"full"</span>:<span class="string">"not full"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">        dequeue(&amp;<span class="built_in">queue</span>, <span class="literal">NULL</span>);</span><br><span class="line">        enqueue(&amp;<span class="built_in">queue</span>, i);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After enqueue/dequeue 4 element, queue is %s\n"</span>,</span><br><span class="line">    is_full(&amp;<span class="built_in">queue</span>)?<span class="string">"full"</span>:<span class="string">"not full"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Head is %d, Tail is %d\n"</span>, <span class="built_in">queue</span>.head, <span class="built_in">queue</span>.tail);</span><br><span class="line"></span><br><span class="line">    dump(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    free_queue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<p> 队列应用：进程通信<br> 消息队列提供了从一个进程向另一个进程发送一个数据块的方法.每个数据库都认为含有一个类型,接收进程可以独立地接收含有不同类型的数据结构.</p>
<p> linux内核 &lt;sys/msg.h&gt; 头文件中定义了消息队列结构</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">msg_first</span>;</span> <span class="comment">// 指向队列中第一个消息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">msg_last</span>;</span> <span class="comment">// 队列中最后一个消息</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> Linux消息队列函数接口</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建和访问一个消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 把消息添加到消息队列中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">const</span> <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_sz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 从一个消息对立获取消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_st, <span class="keyword">long</span> <span class="keyword">int</span> msgtype, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 控制消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msgid, <span class="keyword">int</span> command, struct msgid_ds *buf)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-1-7-leetcode题目"><a href="#2-1-7-leetcode题目" class="headerlink" title="2.1.7 leetcode题目"></a>2.1.7 leetcode题目</h4><ul>
<li><p>重复N次的元素&lt;数组&gt;</p>
</li>
<li><p>两数相加&lt;链表&gt;</p>
</li>
<li><p>基本计算器&lt;栈&gt;</p>
</li>
<li><p>设计循环队列&lt;队列&gt;</p>
</li>
</ul>
<h3 id="2-2-哈希表"><a href="#2-2-哈希表" class="headerlink" title="2.2 哈希表"></a>2.2 哈希表</h3><p> 哈希表是一种最有效的检索方法，散列，从本质上看，一个哈希表包含一个数组，通过特殊的索引（键）来访问数组中的元素。哈希表主要思想是通过一个哈希函数，在所有可能的键和值直接建立映射表。<br> 每个记录的关键字k通过一种函数H(k)计算出函数值.此函数为哈希函数或散列函数.</p>
<h4 id="2-2-1-哈希函数设计"><a href="#2-2-1-哈希函数设计" class="headerlink" title="2.2.1 哈希函数设计"></a>2.2.1 哈希函数设计</h4><ul>
<li><p>直接地址法<br>关键字是整数类型的数据,直接地址的哈希函数H直接利用关键字求得哈希地址.<br>H(k) = aK*i + b</p>
</li>
<li><p>数字分析法<br>取关键字数中分布均匀的若干作为哈希地址</p>
</li>
<li><p>平方取中法<br>取关键字平方中间几位作为散列地址</p>
</li>
<li><p>折叠法<br>把关键字分割成位数相同的几段，段的位数取决于哈希地址的位数，然后将它们叠加和作为哈希地址</p>
</li>
<li><p>除留取余法<br>关键字K除以一个合适的不大于哈希表长度的正整数P,所得余数作为哈希地址.<br>H(K) = K MOD P</p>
</li>
</ul>
<details>
<summary>uthash用法</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> &gt; File Name: listhash.h</span></span><br><span class="line"><span class="comment"> &gt; Author:  jinshaohui</span></span><br><span class="line"><span class="comment"> &gt; Mail:    jinshaohui789@163.com</span></span><br><span class="line"><span class="comment"> &gt; Time:    18-11-06</span></span><br><span class="line"><span class="comment"> &gt; Desc: 根据linux内核模块hashtab编写用户层hashtab接口</span></span><br><span class="line"><span class="comment">         linux-4.19.1\security\selinux\ss\hashtab.c</span></span><br><span class="line"><span class="comment">     linux-4.19.1\security\selinux\ss\hashtab.h</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __HASHTAB_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HASHTAB_H__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hashtab_node</span> {</span></span><br><span class="line">    <span class="keyword">void</span> * key;</span><br><span class="line">    <span class="keyword">void</span> * data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">hashtab_node</span> *<span class="title">next</span>;</span></span><br><span class="line">}hashtab_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hashtab</span> {</span></span><br><span class="line">    hashtab_node **htables; <span class="comment">/*哈希桶*/</span></span><br><span class="line">    <span class="keyword">int</span> size;              <span class="comment">/*哈希桶的最大数量*/</span></span><br><span class="line">    <span class="keyword">int</span> nel;               <span class="comment">/*哈希桶中元素的个数*/</span></span><br><span class="line">    <span class="keyword">int</span> (*hash_value)(struct _hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">/*哈希函数*/</span></span><br><span class="line">    <span class="keyword">int</span> (*keycmp)(struct _hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key1,<span class="keyword">const</span> <span class="keyword">void</span> *key2);<span class="comment">/*哈希key比较函数，当哈希数值一致时使用*/</span></span><br><span class="line">    <span class="keyword">void</span> (*hash_node_free)(hashtab_node *node);</span><br><span class="line">}hashtab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHTAB_MAX_NODES  (0xffffffff)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*hash_key_func)</span><span class="params">(struct _hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">/*哈希函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*keycmp_func)</span><span class="params">(struct _hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key1,<span class="keyword">const</span> <span class="keyword">void</span> *key2)</span></span>;<span class="comment">/*哈希key比较函数，当哈希数值一致时使用*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*hash_node_free_func)</span><span class="params">(hashtab_node *node)</span></span>;</span><br><span class="line"><span class="comment">/*根据当前结构体元素的地址，获取到结构体首地址*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE,MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container(ptr,type,member) ({\</span></span><br><span class="line"><span class="meta">  const typeof( ((type *)0)-&gt;member) *__mptr = (ptr);\</span></span><br><span class="line"><span class="meta">  (type *) ( (char *)__mptr - offsetof(type,member));})</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">hashtab * <span class="title">hashtab_create</span><span class="params">(<span class="keyword">int</span> size,hash_key_func hash_value,</span></span></span><br><span class="line"><span class="params"><span class="function">        keycmp_func keycmp,hash_node_free_func hash_node_free)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashtab_destory</span><span class="params">(hashtab *h)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashtab_insert</span><span class="params">(hashtab * h,<span class="keyword">void</span> *key,<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function">hashtab_node *<span class="title">hashtab_delete</span><span class="params">(hashtab *h, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">hashtab_search</span><span class="params">(hashtab*h,<span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"listhash.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MEMORY_TEST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mcheck.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">hashtab * <span class="title">hashtab_create</span><span class="params">(<span class="keyword">int</span> size,hash_key_func hash_value,</span></span></span><br><span class="line"><span class="params"><span class="function">    keycmp_func keycmp,hash_node_free_func hash_node_free)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    hashtab * h = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((size &lt; <span class="number">0</span>) || (hash_value == <span class="literal">NULL</span>) || (keycmp == <span class="literal">NULL</span>)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    h = (hashtab *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(hashtab));</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    h-&gt;htables = (hashtab_node **)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(hashtab_node*));</span><br><span class="line">    <span class="keyword">if</span> (h-&gt;htables == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    h-&gt;size = size;</span><br><span class="line">    h-&gt;nel = <span class="number">0</span>;</span><br><span class="line">    h-&gt;hash_value = hash_value;</span><br><span class="line">    h-&gt;keycmp = keycmp;</span><br><span class="line">    h-&gt;hash_node_free = hash_node_free;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        h-&gt;htables[i] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashtab_destory</span><span class="params">(hashtab *h)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    hashtab_node * cur = <span class="literal">NULL</span>;</span><br><span class="line">    hashtab_node * tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;h-&gt;size; i++) {</span><br><span class="line">        cur = h-&gt;htables[i];</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) {</span><br><span class="line">            tmp = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            h-&gt;hash_node_free(tmp);</span><br><span class="line">        }</span><br><span class="line">        h-&gt;htables[i] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(h-&gt;htables);</span><br><span class="line">    <span class="built_in">free</span>(h);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashtab_insert</span><span class="params">(hashtab * h,<span class="keyword">void</span> *key,<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hvalue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    hashtab_node *cur = <span class="literal">NULL</span>; </span><br><span class="line">    hashtab_node *prev = <span class="literal">NULL</span>; </span><br><span class="line">    hashtab_node *newnode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((h == <span class="literal">NULL</span>) || (key == <span class="literal">NULL</span>) || (data == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取hash 数值*/</span></span><br><span class="line">    hvalue = h-&gt;hash_value(h,key);</span><br><span class="line">    cur = h-&gt;htables[hvalue];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class="line">    <span class="keyword">while</span>((cur != <span class="literal">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt; <span class="number">0</span>)) {</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果key和当前key比对一致，直接返回，数据已经存在*/</span></span><br><span class="line">    <span class="keyword">if</span> ((cur != <span class="literal">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) == <span class="number">0</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    newnode = (hashtab_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(hashtab_node));</span><br><span class="line">    <span class="keyword">if</span> (newnode == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    newnode-&gt;key = key;</span><br><span class="line">    newnode-&gt;data = data;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) {</span><br><span class="line">        newnode-&gt;next = h-&gt;htables[hvalue];</span><br><span class="line">        h-&gt;htables[hvalue] = newnode;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        newnode-&gt;next = prev-&gt;next;</span><br><span class="line">        prev-&gt;next = newnode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    h-&gt;nel++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">hashtab_node *<span class="title">hashtab_delete</span><span class="params">(hashtab *h, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> hvalue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    hashtab_node *cur = <span class="literal">NULL</span>; </span><br><span class="line">    hashtab_node *prev = <span class="literal">NULL</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((h == <span class="literal">NULL</span>) || (key == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取hash 数值*/</span></span><br><span class="line">    hvalue = h-&gt;hash_value(h,key);</span><br><span class="line">    cur = h-&gt;htables[hvalue];</span><br><span class="line">    <span class="comment">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class="line">    <span class="keyword">while</span>((cur != <span class="literal">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt;= <span class="number">0</span>)) {</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;keycmp(h,key,cur-&gt;key) == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) {</span><br><span class="line">                        h-&gt;htables[hvalue] = cur-&gt;next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                        prev-&gt;next = cur-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        }</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">hashtab_search</span><span class="params">(hashtab*h,<span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> hvalue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    hashtab_node *cur = <span class="literal">NULL</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((h == <span class="literal">NULL</span>) || (key == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取hash 数值*/</span></span><br><span class="line">    hvalue = h-&gt;hash_value(h,key);</span><br><span class="line">    cur = h-&gt;htables[hvalue];</span><br><span class="line">    <span class="comment">/*hash桶中元素是从小到大排列的，找到要插入的位置*/</span></span><br><span class="line">    <span class="keyword">while</span>((cur != <span class="literal">NULL</span>) &amp;&amp; (h-&gt;keycmp(h,key,cur-&gt;key) &gt;= <span class="number">0</span>)) {</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;keycmp(h,key,cur-&gt;key) == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> cur-&gt;data;</span><br><span class="line">        }</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashtab_dump</span><span class="params">(hashtab *h)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    hashtab_node * cur = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n----开始--size[%d],nel[%d]------------"</span>,h-&gt;size,h-&gt;nel);</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; h-&gt;size; i ++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n htables[%d]:"</span>,i);</span><br><span class="line">        cur = h-&gt;htables[i];</span><br><span class="line">        <span class="keyword">while</span>((cur != <span class="literal">NULL</span>)) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"key[%s],data[%s] "</span>,cur-&gt;key,cur-&gt;data);    </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n----结束--size[%d],nel[%d]------------"</span>,h-&gt;size,h-&gt;nel);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> key[<span class="number">80</span>];</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">80</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">siample_hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*str) {</span><br><span class="line">        hash = hash*seed + *str++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash &amp; (<span class="number">0x7FFFFFFF</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashtab_hvalue</span><span class="params">(hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (siample_hash(key) % h-&gt;size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashtab_keycmp</span><span class="params">(hashtab *h,<span class="keyword">const</span> <span class="keyword">void</span> *key1,<span class="keyword">const</span> <span class="keyword">void</span> *key2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(key1,key2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashtab_node_free</span><span class="params">(hashtab_node*node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_node</span> * <span class="title">ptmp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    ptmp = container(node-&gt;key,struct test_node,key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptmp);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *pres = <span class="literal">NULL</span>;</span><br><span class="line">    hashtab_node * node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_node</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    hashtab *h = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> MEMORY_TEST</span></span><br><span class="line">    setenv(<span class="string">"MALLOC_TRACE"</span>,<span class="string">"1.txt"</span>,<span class="number">1</span>);</span><br><span class="line">    mtrace();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    h = hashtab_create(<span class="number">5</span>,hashtab_hvalue,hashtab_keycmp,hashtab_node_free);</span><br><span class="line">    assert(h!= <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        p = (struct test_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct test_node));</span><br><span class="line">        assert(p != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 请输入key 和value，当可以等于\"quit\"时退出"</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;key);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p-&gt;key,<span class="string">"quit"</span>) == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        res = hashtab_insert(h,p-&gt;key,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s],data[%s] insert failed %d"</span>,p-&gt;key,p-&gt;data,res);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s],data[%s] insert success %d"</span>,p-&gt;key,p-&gt;data,res);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hashtab_dump(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        p = (struct test_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct test_node));</span><br><span class="line">        assert(p != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 请输入key 查询value的数值，当可以等于\"quit\"时退出"</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p-&gt;key,<span class="string">"quit"</span>) == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        pres = hashtab_search(h,p-&gt;key);</span><br><span class="line">        <span class="keyword">if</span> (pres == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s] search data failed"</span>,p-&gt;key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s],search data[%s] success"</span>,p-&gt;key,pres);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    }</span><br><span class="line">    hashtab_dump(h);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        p = (struct test_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct test_node));</span><br><span class="line">        assert(p != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n 请输入key 删除节点的数值，当可以等于\"quit\"时退出"</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p-&gt;key,<span class="string">"quit"</span>) == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        node = hashtab_delete(h,p-&gt;key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s] delete node failed "</span>,p-&gt;key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n key[%s],delete data[%s] success"</span>,node-&gt;key,node-&gt;data);</span><br><span class="line">            h-&gt;hash_node_free(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        hashtab_dump(h);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    hashtab_destory(h);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> MEMORY_TEST</span></span><br><span class="line">        muntrace();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<details>
<summary>hash_table</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* One implementation of hash table with linear probing. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_SHIFT 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_SIZE (1 &lt;&lt; HASH_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_MASK (HASH_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  used;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> entry[HASH_SIZE];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_reset</span><span class="params">(struct hash_table *table)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    table-&gt;used = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_SIZE; i++)</span><br><span class="line">    table-&gt;entry[i] = ~<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hash_function</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> value &amp; HASH_MASK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_hash_table</span><span class="params">(struct hash_table *table)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_SIZE; i++) {</span><br><span class="line">        <span class="keyword">if</span> (table-&gt;entry[i] == ~<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2u:       nil \n"</span>, i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2u:%10lu -&gt; %2u\n"</span>,</span><br><span class="line">        i, table-&gt;entry[i],</span><br><span class="line">        hash_function(table-&gt;entry[i]));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_function_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    srandom(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> val = random();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%10lu -&gt; %2u\n"</span>, val, hash_function(val));;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">next_probe</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> prev_key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (prev_key + <span class="number">1</span>) &amp; HASH_MASK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next_probe_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key1, key2;</span><br><span class="line"></span><br><span class="line">    key1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_SIZE; i++) {</span><br><span class="line">        key2 = next_probe(key1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2u -&gt; %2u\n"</span>, key1, key2);</span><br><span class="line">        key1 = key2;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_add</span><span class="params">(struct hash_table *table, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key = hash_function(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (table-&gt;used &gt;= HASH_SIZE)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (table-&gt;entry[key] != ~<span class="number">0</span>)</span><br><span class="line">        key = next_probe(key);</span><br><span class="line"></span><br><span class="line">    table-&gt;entry[key] = value;</span><br><span class="line">    table-&gt;used++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hash_table_slot</span><span class="params">(struct hash_table *table, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key = hash_function(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_SIZE; i++) {</span><br><span class="line">        <span class="keyword">if</span> (table-&gt;entry[key] == value || table-&gt;entry[key] == ~<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        key = next_probe(key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hash_table_find</span><span class="params">(struct hash_table *table, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> table-&gt;entry[hash_table_slot(table, value)] == value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_del</span><span class="params">(struct hash_table *table, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hash_table_find(table, value))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    i = j = hash_table_slot(table, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        table-&gt;entry[i] = ~<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            j = next_probe(j);</span><br><span class="line">            <span class="keyword">if</span> (table-&gt;entry[j] == ~<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            k = hash_function(table-&gt;entry[j]);</span><br><span class="line">        } <span class="keyword">while</span> ((i &lt;= j) ? (i &lt; k &amp;&amp; k &lt;= j) : (i &lt; k || k &lt;= j));</span><br><span class="line"></span><br><span class="line">        table-&gt;entry[i] = table-&gt;entry[j];</span><br><span class="line">        i = j;</span><br><span class="line">    }</span><br><span class="line">    table-&gt;used++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_add_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> <span class="title">table</span>;</span></span><br><span class="line"></span><br><span class="line">    hash_table_reset(&amp;table);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">87645</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Table has%s 87645\n"</span>,</span><br><span class="line">    hash_table_find(&amp;table, <span class="number">87645</span>) ? <span class="string">""</span>:<span class="string">"n't"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Table has%s 87647\n"</span>,</span><br><span class="line">    hash_table_find(&amp;table, <span class="number">87647</span>) ? <span class="string">""</span>:<span class="string">"n't"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_del_test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> <span class="title">table</span>;</span></span><br><span class="line"></span><br><span class="line">    hash_table_reset(&amp;table);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x1ff0</span>);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x2ff0</span>);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x3ff0</span>);</span><br><span class="line">    dump_hash_table(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== Remove 0x1ff0\n"</span>);</span><br><span class="line">    hash_table_del(&amp;table, <span class="number">0x1ff0</span>);</span><br><span class="line">    dump_hash_table(&amp;table);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_table_del_test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> <span class="title">table</span>;</span></span><br><span class="line"></span><br><span class="line">    hash_table_reset(&amp;table);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x1ff0</span>);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x1ff1</span>);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x1ff2</span>);</span><br><span class="line">    hash_table_add(&amp;table, <span class="number">0x2ff0</span>);</span><br><span class="line">    dump_hash_table(&amp;table);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=== Remove 0x1ff0\n"</span>);</span><br><span class="line">    hash_table_del(&amp;table, <span class="number">0x1ff0</span>);</span><br><span class="line">    dump_hash_table(&amp;table);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//hash_function_test();</span></span><br><span class="line">    <span class="comment">//next_probe_test();</span></span><br><span class="line">    <span class="comment">//hash_table_add_test();</span></span><br><span class="line">    hash_table_del_test2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<h4 id="2-2-2-哈希冲突"><a href="#2-2-2-哈希冲突" class="headerlink" title="2.2.2 哈希冲突"></a>2.2.2 哈希冲突</h4><p> 理想情况下,哈希函数在关键字和地址之间建立一对一关系.但H(k1) = H(k2),即为冲突.</p>
<p> 解决哈希冲突常用方法:</p>
<ul>
<li>链地址法<br>将哈希值相同的元素构成一个同义词的单链表,并将单链表头指针存放在哈希表的地i个单元中,查找,插入和删除主要在同义词链表中.</li>
<li>线性探测</li>
<li>二次探测</li>
</ul>
<h4 id="2-2-3-uthash"><a href="#2-2-3-uthash" class="headerlink" title="2.2.3 uthash"></a>2.2.3 uthash</h4><p> uthash的插入、查找、删除的操作时间都是常量</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uthash.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span> id;            <span class="comment">/* we'll use this field as the key */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh; <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">users</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_user</span><span class="params">(struct my_struct *s)</span> </span>{</span><br><span class="line">    HASH_ADD_INT(users, id, s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>uthash用法</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>   <span class="comment">/* gets */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  <span class="comment">/* atoi, malloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  <span class="comment">/* strcpy */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uthash.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span> id;                    <span class="comment">/* key */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh;         <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">users</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_user</span><span class="params">(<span class="keyword">int</span> user_id, <span class="keyword">char</span> *name)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* id already in the hash? */</span></span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">NULL</span>) {</span><br><span class="line">        s = (struct my_struct *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *s);</span><br><span class="line">        s-&gt;id = user_id;</span><br><span class="line">        HASH_ADD_INT( users, id, s );  <span class="comment">/* id: name of key field */</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;name, name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct my_struct *<span class="title">find_user</span><span class="params">(<span class="keyword">int</span> user_id)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* s: output pointer */</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_user</span><span class="params">(struct my_struct *user)</span> </span>{</span><br><span class="line">    HASH_DEL(users, user);  <span class="comment">/* user: pointer to deletee */</span></span><br><span class="line">    <span class="built_in">free</span>(user);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_all</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">current_user</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_ITER(hh, users, current_user, tmp) {</span><br><span class="line">        HASH_DEL(users, current_user);  <span class="comment">/* delete it (users advances to next) */</span></span><br><span class="line">        <span class="built_in">free</span>(current_user);             <span class="comment">/* free it */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_users</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(s=users; s != <span class="literal">NULL</span>; s=(struct my_struct*)(s-&gt;hh.next)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"user id %d: name %s\n"</span>, s-&gt;id, s-&gt;name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">name_sort</span><span class="params">(struct my_struct *a, struct my_struct *b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a-&gt;name,b-&gt;name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id_sort</span><span class="params">(struct my_struct *a, struct my_struct *b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (a-&gt;id - b-&gt;id);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_by_name</span><span class="params">()</span> </span>{</span><br><span class="line">    HASH_SORT(users, name_sort);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_by_id</span><span class="params">()</span> </span>{</span><br><span class="line">    HASH_SORT(users, id_sort);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> in[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> id=<span class="number">1</span>, running=<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> num_users;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (running) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 1. add user\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 2. add/rename user by id\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 3. find user\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 4. delete user\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 5. delete all users\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 6. sort items by name\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 7. sort items by id\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 8. print users\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 9. count users\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"10. quit\n"</span>);</span><br><span class="line">        gets(in);</span><br><span class="line">        <span class="keyword">switch</span>(atoi(in)) {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"name?\n"</span>);</span><br><span class="line">                add_user(id++, gets(in));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"id?\n"</span>);</span><br><span class="line">                gets(in); id = atoi(in);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"name?\n"</span>);</span><br><span class="line">                add_user(id, gets(in));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"id?\n"</span>);</span><br><span class="line">                s = find_user(atoi(gets(in)));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"user: %s\n"</span>, s ? s-&gt;name : <span class="string">"unknown"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"id?\n"</span>);</span><br><span class="line">                s = find_user(atoi(gets(in)));</span><br><span class="line">                <span class="keyword">if</span> (s) delete_user(s);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"id unknown\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                delete_all();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                sort_by_name();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                sort_by_id();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                print_users();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                num_users=HASH_COUNT(users);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"there are %u users\n"</span>, num_users);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                running=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    delete_all();  <span class="comment">/* free any structures */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<ul>
<li>参考链接<br>官网:<a target="_blank" rel="noopener" href="https://troydhanson.github.io/uthash/">https://troydhanson.github.io/uthash/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fan_h_l/article/details/107241520">https://blog.csdn.net/fan_h_l/article/details/107241520</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/whatday/article/details/95926766">https://blog.csdn.net/whatday/article/details/95926766</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pam-sh/p/12827658.html">https://www.cnblogs.com/pam-sh/p/12827658.html</a></li>
</ul>
<h4 id="2-2-4-leetcode题目"><a href="#2-2-4-leetcode题目" class="headerlink" title="2.2.4 leetcode题目"></a>2.2.4 leetcode题目</h4><ul>
<li><p>设计哈希集合 </p>
</li>
<li><p>设计哈希映射</p>
</li>
<li><p>根据字符出现频率排序</p>
</li>
</ul>
<h3 id="2-3-树与二叉树"><a href="#2-3-树与二叉树" class="headerlink" title="2.3 树与二叉树"></a>2.3 树与二叉树</h3><p> 树(tree)是一种用来模拟树状结构的抽象数据结构(ADT);</p>
<p> 树的特点:</p>
<ul>
<li>没有父节点的节点称为根节点</li>
<li>每个非根节点有且只有一个父节点</li>
<li>除了根结点外,每个子节点可分为多个不相交的子树</li>
<li>树中没有环路</li>
</ul>
<h4 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h4><ul>
<li>节点的度: 一个节点含有子树的个数</li>
<li>树的度: 树中最大的节点度</li>
<li>叶节点: 度为零的节点</li>
<li>父节点</li>
<li>子节点</li>
<li>兄弟节点</li>
<li>节点的层次</li>
<li>深度: 任意节点n,n的深度为从n到一片树叶的最长路径长,根的深度为0</li>
<li>高度: 对任意节点n,n的高度为从n到一片树叶的最长路径长,所有树叶的高度为0.</li>
<li>森林</li>
</ul>
<p> 树由称为结点的元素按照层次结构的方式组织而成。最顶端称为根。与根直接相连的结点称为根的子结点。子节点本身也可以有子结点。除根结点外，每个结点都有唯一的父结点。</p>
<h4 id="2-3-2-树的种类"><a href="#2-3-2-树的种类" class="headerlink" title="2.3.2 树的种类"></a>2.3.2 树的种类</h4><ul>
<li><p>无序树</p>
</li>
<li><p>有序树</p>
<ul>
<li><p>二叉树: 每个节点最多含有两个子树的树.</p>
<ul>
<li>完全二叉树: 对于一颗深度为d的二叉树,除第d层外,其他各层节点数目均达最大值,且第d层所有节点从左向右连续紧密排列.<ul>
<li>满二叉树:所有叶节点都最底层的完全二叉树.</li>
</ul>
</li>
<li>平衡二叉树(AVL):当且仅当任何节点的两颗子树的高度差不大于1的二叉树.</li>
<li>排序二叉树:二叉查找树</li>
</ul>
</li>
<li><p>霍夫曼树:带权路径最短的二叉树(又称最优二叉树).</p>
</li>
<li><p>B树:一种堆读写操作进行优化的自平衡二叉查找树,能够保持数据有序,拥有多余两个子树.</p>
</li>
</ul>
</li>
</ul>
<br>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>二叉树</td>
<td>二叉查找树(BST) 笛卡尔树 MVP树 Top tree T树</td>
</tr>
<tr>
<td>自平衡二叉查找树</td>
<td>AVL树 红黑树 加权平衡树 AA树</td>
</tr>
<tr>
<td>B树</td>
<td>B树 B+树</td>
</tr>
<tr>
<td>堆</td>
<td>二项堆 斐波那契堆</td>
</tr>
<tr>
<td>Trie</td>
<td>后缀树 基数树 三叉查找树</td>
</tr>
</tbody></table>
<p> 树有多种结构形式，包括二叉树、。</p>
<h4 id="2-3-3-二叉树"><a href="#2-3-3-二叉树" class="headerlink" title="2.3.3 二叉树"></a>2.3.3 二叉树</h4><p> 二叉树两个条件:</p>
<ul>
<li>本身是有序树</li>
<li>树中包含的各个节点的度不能超过2,即只能是0,1或者2</li>
</ul>
<p> 二叉树中结点包含三部分：一个数据成员两个左右指针。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode_</span> {</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode_</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode_</span> *<span class="title">right</span>;</span></span><br><span class="line">}BiTreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTree_</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> (*compare)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">void</span> *data);</span><br><span class="line">    BiTreeNode *root;</span><br><span class="line">}BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*树根*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span>{</span></span><br><span class="line">    Node * root;</span><br><span class="line">}Tree;</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>二叉树</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"list_queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">treenode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">treenode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">treenode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">}Tnode,Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_create</span><span class="params">(Tree **Root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n输入节点数值((当输入为100时，当前节点创建完成))):"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">100</span>) {</span><br><span class="line">        *Root = <span class="literal">NULL</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        *Root = (Tnode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tnode));</span><br><span class="line">        <span class="keyword">if</span> (*Root == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        (*Root)-&gt;data = a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n create %d 的左孩子:"</span>,a);</span><br><span class="line">        binarytree_create(&amp;((*Root)-&gt;lchild));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\r\n create %d 的右孩子:"</span>,a);</span><br><span class="line">        binarytree_create(&amp;((*Root)-&gt;rchild));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_destory</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    binarytree_destory(root-&gt;lchild);</span><br><span class="line">    binarytree_destory(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*先序遍历:根结点--》左子树---》右子树*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_preorder</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d "</span>,root-&gt;data);</span><br><span class="line">    binarytree_preorder(root-&gt;lchild);</span><br><span class="line">    binarytree_preorder(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*中序遍历:左子树--》跟节点---》右子树*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_inorder</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    binarytree_inorder(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d "</span>,root-&gt;data);</span><br><span class="line">    binarytree_inorder(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*后序遍历:左子树---》右子树-》根节点*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_postorder</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    binarytree_postorder(root-&gt;lchild);</span><br><span class="line">    binarytree_postorder(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d "</span>,root-&gt;data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_levelorder</span><span class="params">(Tree * root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    list_queue *<span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line">    Tnode * node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> = list_queue_create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*根节点先入队*/</span></span><br><span class="line">    list_queue_enqueue(<span class="built_in">queue</span>,(<span class="keyword">void</span> *)root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!list_queue_is_empty(<span class="built_in">queue</span>)) {</span><br><span class="line">        list_queue_dequeue(<span class="built_in">queue</span>,(<span class="keyword">void</span> *)&amp;node);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d "</span>,node-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;lchild != <span class="literal">NULL</span>) {</span><br><span class="line">            list_queue_enqueue(<span class="built_in">queue</span>,(<span class="keyword">void</span> *)node-&gt;lchild);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;rchild != <span class="literal">NULL</span>) {</span><br><span class="line">            list_queue_enqueue(<span class="built_in">queue</span>,(<span class="keyword">void</span> *)node-&gt;rchild);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*打印叶子节点*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree_printfleaf</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((root-&gt;lchild == <span class="literal">NULL</span>) &amp;&amp; (root-&gt;rchild == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d "</span>,root-&gt;data);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        binarytree_printfleaf(root-&gt;lchild);</span><br><span class="line">        binarytree_printfleaf(root-&gt;rchild);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*打印叶子的个数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarytree_getleafnum</span><span class="params">(Tree*root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((root-&gt;lchild == <span class="literal">NULL</span>) &amp;&amp; (root-&gt;rchild == <span class="literal">NULL</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> binarytree_getleafnum(root-&gt;lchild) + binarytree_getleafnum(root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">/*打印数的高度*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarytree_gethigh</span><span class="params">(Tree *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> lhigh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rhigh = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    lhigh = binarytree_gethigh(root-&gt;lchild);</span><br><span class="line">    rhigh = binarytree_gethigh(root-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((lhigh &gt; rhigh)?(lhigh + <span class="number">1</span>):(rhigh + <span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree *root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    setenv(<span class="string">"MALLOC_TRACE"</span>,<span class="string">"1.txt"</span>,<span class="number">1</span>);</span><br><span class="line">    mtrace();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n创建二叉树:"</span>);</span><br><span class="line">    binarytree_create(&amp;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n先序遍历二叉树:"</span>);</span><br><span class="line">    binarytree_preorder(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n中序遍历二叉树:"</span>);</span><br><span class="line">    binarytree_inorder(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n后序遍历二叉树:"</span>);</span><br><span class="line">    binarytree_postorder(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n层次遍历二叉树:"</span>);</span><br><span class="line">    binarytree_levelorder(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n打印二叉树叶子节点:"</span>);</span><br><span class="line">    binarytree_printfleaf(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n打印二叉树叶子节点个数:%d"</span>,binarytree_getleafnum(root));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n打印二叉树高度:%d"</span>,binarytree_gethigh(root));</span><br><span class="line"></span><br><span class="line">    binarytree_destory(root);</span><br><span class="line"></span><br><span class="line">    muntrace();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<details>
<summary>binarytree</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Implement binary tree in array */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_NODES (1 &lt;&lt; 8)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_tree</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nodes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">n</span>[<span class="title">MAX_TREE_NODES</span>];</span></span><br><span class="line">    };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_binary_tree</span><span class="params">(struct binary_tree *tree)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_TREE_NODES; i++) {</span><br><span class="line">        tree-&gt;n[i] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct node* <span class="title">create_node</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n)</span><br><span class="line">        n-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fake_a_tree</span><span class="params">(struct binary_tree* tree)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* data is in ordered */</span></span><br><span class="line">    <span class="keyword">int</span> i, data[<span class="number">10</span>] = {<span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>};</span><br><span class="line"></span><br><span class="line">    init_binary_tree(tree);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* root start at 1 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        tree-&gt;n[i+<span class="number">1</span>] = create_node(data[i]);</span><br><span class="line"></span><br><span class="line">    tree-&gt;nodes = <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _in_order(struct binary_tree* tree, <span class="keyword">int</span> index)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!tree-&gt;n[index])</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* left child at (index &lt;&lt; 1) */</span></span><br><span class="line">    _in_order(tree, index &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%2d]: %4d\n"</span>, index, tree-&gt;n[index]-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* right child at (index &lt;&lt; 1) + 1 */</span></span><br><span class="line">    _in_order(tree, (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(struct binary_tree* tree)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    _in_order(tree, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binary_tree</span> <span class="title">tree</span>;</span></span><br><span class="line"></span><br><span class="line">    fake_a_tree(&amp;tree);</span><br><span class="line">    in_order(&amp;tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<p> 二叉树性质:</p>
<ul>
<li>二叉树中,第i层最多有 2^(i-1)个节点</li>
<li>如果二叉树的深度为K,则二叉树最多有<code>2^K - 1</code>个节点</li>
<li>二叉树中，终端结点树(叶子节点树)为n0，度为2的节点树为n1，则 n0=n1+1</li>
</ul>
<p><strong>满二叉树</strong><br> 如果二叉树中除了叶子节点，每个节点的度都为2，则此二叉树为满二叉树。</p>
<p><strong>完全二叉树</strong><br> 如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p>
<p> 树的周游算法包含先序遍历、中序遍历、后序遍历和层序遍历。</p>
<ul>
<li>先序遍历：先访问根结点，然后左子树，最后右子结点。深度优先思想。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cur-&gt;val = %d\n"</span>, cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">    traversal(root);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 迭戈</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> <span class="title">st</span>[<span class="title">MAXSIZE</span>];</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">    st[top] = root;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top &gt;= <span class="number">0</span>) {</span><br><span class="line">        TreeNode* node = st[top];                       <span class="comment">// 中</span></span><br><span class="line">        top--;</span><br><span class="line">        result[i++] = node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) {</span><br><span class="line">             <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            st[++top] = node-&gt;right</span><br><span class="line">        }       </span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) {</span><br><span class="line">            <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">            st[++top] = node-&gt;left; </span><br><span class="line">        }        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>中序遍历：先访问左子结点，然后根结点，最后右子结点。</li>
<li>后序遍历：先访问左子结点，然后右子结点，最后根结点。</li>
<li>层序遍历：先访问树的根结点，然后依次向下层处理，按照从左向右的顺序访问每层结点。广度优先的策略。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>{</span><br><span class="line">      <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"cur-&gt;val = %d\n"</span>, cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">      traversal(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">      traversal(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">      traversal(root, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-3-4-二叉查找树-BST"><a href="#2-3-4-二叉查找树-BST" class="headerlink" title="2.3.4 二叉查找树(BST)"></a>2.3.4 二叉查找树(BST)</h4><p> 二叉查找树也称二叉搜索树,有序二叉树或排序二叉树,具有性质:</p>
<ul>
<li>若任意节点左子树不为空,则左子树上所有节点的值均小于它的根节点的值</li>
<li>若任意节点的右子树不为空,则右子树所有节点的值均大于根节点的值</li>
<li>任意节点的左,右子树也分别为二叉查找树</li>
<li>没有键值相等的节点</li>
</ul>
<p> 一颗二叉搜索树要插入一个结点，要从根结点开始，一层一层往下，适当地移动左或右子结点上，当到达树的分支尽头时，执行插入操作。<br> 二叉搜索树是一种用于查找操作的高效数据结构，在最坏情况下，只需查找一个分支上的数据即可。<strong>查找,插入</strong>操作的复杂度是 <code>O(logn)</code>，<strong>搜索,插入,删除</strong>复杂度等于树高,期望<code>O(logn)</code>,最坏为<code>O(n)</code>,(树退化为线性表)n为树中结点数。<br> 保持一棵树的平衡是指对于给定数量的结点，要使得树的高度尽可能短。</p>
<p> 二叉查找树是由二叉树组成的专用于查找和搜索目的的一种数据结构。二叉搜索树中查找一个结点，从根结点开始一层一层向下查找，当遇到一个比目标结点值大的结点时，顺着该结点左子树继续查找，如果遇到的结点值小于目标结点，则顺着该结点的右子树查找，直到找到目标结点为止。</p>
<p> <strong>查找算法</strong><br>  1.若b是空树,则搜索失败,否则;<br>  2.若x等于b的根节点的数据域之值,则查找成功;<br>  3.若x小于b的根节点的数据域之值,则搜索左子树<br>  4.查找右子树</p>
<p> <strong>插入算法</strong><br>  1.若b是空树,则将s所指节点作为根节点插入;否则<br>  2.若<code>s-&gt;data</code>等于b的根节点的数据域值,则返回,否则;<br>  3.若<code>s-&gt;data</code>小于b的根节点的数据域之值,则把s所值节点插入到左子树中,否则<br>  4.把s所指节点插入到右子树中,(新插入节点总是叶子节点)</p>
<p> <strong>删除算法</strong><br>  1.若*p节点为叶子节点,即PL(左子树)和PR(右子树)均为空树.由于删去叶子节点不破坏整棵树的结构,则只需修改其双亲节点的指针即可.</p>
<details>
<summary>binarysearch</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">} BTree, *BTreePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** 插入 **********************/</span></span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(BTreePtr *T, ElemType e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    BTreePtr p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*T == <span class="literal">NULL</span>) {</span><br><span class="line">        *T = (BTreePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTree));</span><br><span class="line">        (*T)-&gt;data = e;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        p = *T;</span><br><span class="line">        <span class="keyword">while</span> ( p != <span class="literal">NULL</span>) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e &gt; p-&gt;data) {</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;rchild == <span class="literal">NULL</span>) {</span><br><span class="line">                    p-&gt;rchild = (BTreePtr) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BTree));</span><br><span class="line">                    p-&gt;rchild-&gt;data = e;</span><br><span class="line">                    <span class="keyword">return</span> TRUE;</span><br><span class="line">                }</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) {</span><br><span class="line">                    p-&gt;lchild = (BTreePtr) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BTree));</span><br><span class="line">                    p-&gt;lchild-&gt;data = e;</span><br><span class="line">                    <span class="keyword">return</span> TRUE;</span><br><span class="line">                }</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**************** 删除 **********************/</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BTreePtr T, ElemType e)</span> </span>{</span><br><span class="line">    BTreePtr p, pp, minP, minPP, child;</span><br><span class="line">    child = <span class="literal">NULL</span>;</span><br><span class="line">    p = T;</span><br><span class="line">    pp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( (p != <span class="literal">NULL</span>) &amp;&amp; (p-&gt;data != e) ) {</span><br><span class="line">        pp = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e &gt; p-&gt;data) {</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;lchild != <span class="literal">NULL</span>) &amp;&amp; (p-&gt;rchild != <span class="literal">NULL</span>) {</span><br><span class="line">        minPP = p;</span><br><span class="line">        minP = p-&gt;rchild;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (minP-&gt;lchild != <span class="literal">NULL</span>) {</span><br><span class="line">            minPP = minP;</span><br><span class="line">            minP = minP-&gt;lchild;</span><br><span class="line">        }</span><br><span class="line">        p-&gt;data = minP-&gt;data;</span><br><span class="line">        minPP-&gt;lchild = minP-&gt;rchild;</span><br><span class="line">        <span class="built_in">free</span>(minP);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有一个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;lchild != <span class="literal">NULL</span>) || (p-&gt;rchild != <span class="literal">NULL</span>)) { <span class="comment">//应该将原有的pp同child连接在一起</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild) {</span><br><span class="line">            child = p-&gt;lchild;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">           child = p-&gt;rchild;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pp-&gt;data&gt;p-&gt;data) {</span><br><span class="line">            pp-&gt;lchild=child;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            pp-&gt;rchild=child;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有节点</span></span><br><span class="line">    <span class="keyword">if</span> (pp-&gt;lchild == p) {<span class="comment">//这里面临pp除p以外的节点为null的情况</span></span><br><span class="line">        pp-&gt;lchild = child;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        pp-&gt;rchild = child;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**************** 查找 **********************/</span></span><br><span class="line">Status Find(BTreePtr T, ElemType e) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((T != <span class="literal">NULL</span>) &amp;&amp; (T-&gt;data != e)) {</span><br><span class="line">        <span class="keyword">if</span> (e &gt; T-&gt;data) {</span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (T) {</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** 最大值 **********************/</span></span><br><span class="line">ElemType FindMax(BTreePtr T) {</span><br><span class="line">    ElemType max;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span>) {</span><br><span class="line">        max = T-&gt;data;</span><br><span class="line">        T = T-&gt;rchild;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** 最小值 **********************/</span></span><br><span class="line">ElemType FindMin(BTreePtr T) {</span><br><span class="line">    ElemType min;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span>) {</span><br><span class="line">        min = T-&gt;data;</span><br><span class="line">        T = T-&gt;lchild;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PreOrderTraverse(BTreePtr T)<span class="comment">//前序遍历二叉树</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(T) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,T-&gt;data);</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DestroyTree(BTreePtr T) {</span><br><span class="line">    <span class="keyword">if</span> (T) {</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;lchild) {</span><br><span class="line">            DestroyTree(T-&gt;lchild);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rchild) {</span><br><span class="line">            DestroyTree(T-&gt;rchild);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************** 执行测试 *************************/</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span><br><span class="line">{</span><br><span class="line">    BTreePtr T;</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> a[] = {<span class="number">33</span>, <span class="number">16</span>, <span class="number">50</span>, <span class="number">13</span>, <span class="number">18</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">25</span>, <span class="number">51</span>, <span class="number">66</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">55</span>};</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) {</span><br><span class="line">        Insert(&amp;T, a[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Max is %d\n"</span>, FindMax(T));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Min is %d\n"</span>, FindMin(T));</span><br><span class="line">    Delete(T, <span class="number">18</span>);</span><br><span class="line">    Delete(T, <span class="number">13</span>);</span><br><span class="line">    PreOrderTraverse(T);</span><br><span class="line">    DestroyTree(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<details>
<summary>bst</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">child_dir</span> {</span></span><br><span class="line">    left_child,</span><br><span class="line">    right_child,</span><br><span class="line">    root,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">root</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">r</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(struct node *node, <span class="keyword">int</span> level, <span class="keyword">enum</span> child_dir dir)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    dump(node-&gt;right, level + <span class="number">1</span>, right_child);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == left_child)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%*s\n"</span>, level*<span class="number">3</span>, <span class="string">"|"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%*s - %05lu\n"</span>, level*<span class="number">3</span>, <span class="string">" "</span>, node-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == right_child)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%*s\n"</span>, level*<span class="number">3</span>, <span class="string">"|"</span>);</span><br><span class="line"></span><br><span class="line">    dump(node-&gt;left, level + <span class="number">1</span>, left_child);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct node* <span class="title">find</span><span class="params">(struct root *root, <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">n</span> =</span> root-&gt;r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n) {</span><br><span class="line">        <span class="keyword">if</span> (n-&gt;data == data)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; n-&gt;data)</span><br><span class="line">            n = n-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            n = n-&gt;right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct node* <span class="title">new_node</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line"></span><br><span class="line">    n-&gt;data = data;</span><br><span class="line">    n-&gt;left = n-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(struct root *root, struct node *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;r) {</span><br><span class="line">        root-&gt;r = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    parent = root-&gt;r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="comment">/* Don't support duplicate data */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;data == parent-&gt;data)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>-&gt;data &lt; parent-&gt;data) {</span><br><span class="line">        <span class="keyword">if</span> (!parent-&gt;left) {</span><br><span class="line">            parent-&gt;left = <span class="keyword">new</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        parent = parent-&gt;left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (!parent-&gt;right) {</span><br><span class="line">                parent-&gt;right = <span class="keyword">new</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            parent = parent-&gt;right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct node* <span class="title">delete</span><span class="params">(struct root *root, <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">n</span> =</span> root-&gt;r, **p = &amp;root-&gt;r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">child</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &amp;&amp; n-&gt;data != data) {</span><br><span class="line">        <span class="keyword">if</span> (data &lt; n-&gt;data) {</span><br><span class="line">            p = &amp;n-&gt;left;</span><br><span class="line">            n = n-&gt;left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p = &amp;n-&gt;right;</span><br><span class="line">            n = n-&gt;right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n-&gt;left &amp;&amp; n-&gt;right) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">rn</span> =</span> n-&gt;right, **rp = &amp;n-&gt;right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rn-&gt;left) {</span><br><span class="line">            rp = &amp;rn-&gt;left;</span><br><span class="line">            rn = rn-&gt;left;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        n-&gt;data = rn-&gt;data;</span><br><span class="line">        n = rn;</span><br><span class="line">        p = rp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    child = n-&gt;left ? n-&gt;left : n-&gt;right;</span><br><span class="line">    *p = child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">root</span> <span class="title">tree</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    tree.r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">5</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">2</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">18</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">13</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">21</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    dump(tree.r, <span class="number">0</span>, root);</span><br><span class="line"></span><br><span class="line">    n = find(&amp;tree, <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &amp;&amp; n-&gt;data == <span class="number">18</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Get 18\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">root</span> <span class="title">tree</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">    tree.r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">5</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">2</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">18</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">13</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">21</span>));</span><br><span class="line">    insert(&amp;tree, new_node(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    dump(tree.r, <span class="number">0</span>, root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>(&amp;tree, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Delete 20\n"</span>);</span><br><span class="line">    dump(tree.r, <span class="number">0</span>, root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>(&amp;tree, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Delete 9\n"</span>);</span><br><span class="line">    dump(tree.r, <span class="number">0</span>, root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//insert_test();</span></span><br><span class="line">    delete_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<h4 id="2-3-5-平衡树"><a href="#2-3-5-平衡树" class="headerlink" title="2.3.5 平衡树"></a>2.3.5 平衡树</h4><p> 平衡树是一类改进的二叉查找树,一般二叉查找树的查询复杂度与目标节点到树根的距离(深度)有关,因此当深度较大时,查询均摊复杂度会上升.<br> <strong>平衡指所有叶子的深度趋于平衡</strong>,更广义指树上所有可能查找的均摊复杂度偏低.<strong>平衡树的操作时基于树旋转操作,通过旋转可使树趋于平衡</strong>.<br> 对一颗查找树进行查询,新增,删除等操作,所花的时间与树的高度h成比例,并不与树的容量n成比例.</p>
<ul>
<li><strong>AVL树</strong></li>
</ul>
<p> 在<strong>AVL树中,任一节点对于的两颗子树的最大高度差为1,因此也称为高度平衡树</strong>.查找,插入和删除的平均和最坏时间复杂度是O(logn),增加和删除元素的操作则可能需要借由一层或多次旋转,以实现树的重新平衡.<br> <strong>高度为h的AVL树,总节点数最多为2^h-1</strong>; 当前节点数为N时,高度h最多为:</p>
<blockquote>
<p>log(5*0.5 * (N + 1)) - 2</p>
</blockquote>
<br>

<ul>
<li><strong>红黑树</strong></li>
</ul>
<p> 红黑树是一种自平衡二叉查找树,典型的用途是实现关联数组.红黑树实现复制,查找,插入和删除时间复杂度为O(logn)<br> 红黑树相对于AVL树,牺牲了部分平衡性以换取插入\删除操作时少量的旋转操作,整体性能优于AVL树.</p>
<p> 红黑树与AVL树的相比:<br>  AVL树在插入,删除节点时要把树调整到完全平衡,红黑树只要调整到大致平衡,因此通常红黑树的插入,删除节点性能稍好.<br>  AVL的查找性能通常比红黑树好<br>  如果节点的增删操作远小于查找操作,则应选择AVL;反之,红黑树可能更好.</p>
<p> 红黑树是每个节点都带有颜色属性的二叉树,颜色为红色或黑色.在二叉查找树强制一般要求以外,对于任何有效的红黑树我们怎讲了弱小额外要求:<br>  1.节点是红或黑色<br>  2.根是黑色<br>  3.所有叶子都是黑色(叶子是NIL节点)<br>  4.每个红色节点必须右两个黑色的子节点.(从每个叶子到根的所有路径上不能右两个连续的红色节点.)<br>  5.从任一节点到其每个叶子的所有简单路径都包含相同苏后面的黑色节点.<br> 红黑树关键特性:<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>.红黑树是大致平衡的.插入,删除和查找某个值最坏情况下与树的高度成比例.</p>
<ul>
<li><strong>B+树</strong></li>
</ul>
<p> B+树通常用于数据库和操作系统的文件系统中.<strong>B+树的特点是能够保持数据稳定有序,其插入与修改拥有较文档的对数时间复杂度</strong>.B+树元素自底向上插入,与二叉树相反.<br> B+树是内部节点可右在预定范围内的可变量目的子节点.因此,B+树不需要像其他自平衡二叉查找树那样重新平衡.</p>
<ul>
<li><strong>字典树</strong></li>
</ul>
<details>
<summary>Trie</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">children</span>[26];</span></span><br><span class="line">    Status end;</span><br><span class="line">} Trie, *TriePtr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(TriePtr *T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    (*T) = (TriePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">    (*T)-&gt;data = <span class="string">'/'</span>;</span><br><span class="line">    (*T)-&gt;end = FALSE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(TriePtr T, <span class="keyword">char</span> *str)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c = *str++) {</span><br><span class="line">        index = c - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;children[index] == <span class="literal">NULL</span>) {</span><br><span class="line">            TriePtr Node;</span><br><span class="line">            Node = (TriePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">            Node-&gt;data = c;</span><br><span class="line">            Node-&gt;end = FALSE;</span><br><span class="line">            T-&gt;children[index] = Node;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        T = T-&gt;children[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T-&gt;end = TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Search</span><span class="params">(TriePtr T, <span class="keyword">char</span> *str)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c = *str++) {</span><br><span class="line">        index = c - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;children[index] == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        T = T-&gt;children[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;end) {</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    TriePtr T;</span><br><span class="line">    Init(&amp;T);</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">"hi"</span>;</span><br><span class="line"></span><br><span class="line">    Insert(T, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str is search %d\n"</span>, Search(T, str));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2 is search %d\n"</span>, Search(T, str2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<h4 id="2-3-6-堆树和优先队列"><a href="#2-3-6-堆树和优先队列" class="headerlink" title="2.3.6 堆树和优先队列"></a>2.3.6 堆树和优先队列</h4><p> 堆(heap)也称为优先队列,堆遵守队列操作模式,在堆底插入元素,在堆顶取出元素,但堆中元素的排列不是按照到来的先后顺序,而是按照一定的有序顺序排列的.<br> 堆的本质是一个完全二叉树,可使用二叉树表示堆,也可使用数组来表示.<br> 堆的特性:<br>  必须是完全二叉树<br>  用数组实现<br>  任一节点的值是其子树所有节点的最大值或最小值<br>   最大值时,称为最大堆,也称大顶堆<br>   最小时,称为最小堆,也称小顶堆.<br> <strong>堆不能保证整棵树都是有序的,堆中的插入和删除操作时时间复杂度为O(log2n)</strong></p>
<p> 堆是一颗二叉树，通常其子结点存储的值比父结点的值小，所以，根结点为树中最大的结点(大顶堆)。同样，根结点也可以是树中最小的结点(小顶堆)。能够快速确定包含最大(小)值的特点。<br> 堆时左平衡的树，随着结点增加，树会逐级从左至右增长。一个较好地表示左平衡二叉树的方式是，将结点通过层序遍历方式连续存储到一个数组中。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Heap_</span> {</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> (*compare)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> **tree;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>heap</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Implement heap */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_HEAP_SIZE (1 &lt;&lt; 8)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> elements;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">elem</span>[<span class="title">MAX_HEAP_SIZE</span>];</span></span><br><span class="line">    };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_heap</span><span class="params">(struct heap *heap)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_HEAP_SIZE; i++) {</span><br><span class="line">        heap-&gt;elem[i] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_heap</span><span class="params">(struct heap *heap, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">elem</span>;</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt; heap-&gt;elements)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    elem = heap-&gt;elem[index];</span><br><span class="line">    level = fls(index);</span><br><span class="line"></span><br><span class="line">    dump_heap(heap, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(index % <span class="number">2</span>) &amp;&amp; index != <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%*s\n"</span>, level*<span class="number">3</span>, <span class="string">"|"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%*s - %05d\n"</span>, level*<span class="number">3</span>, <span class="string">" "</span>, elem-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index % <span class="number">2</span> &amp;&amp; index != <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%*s\n"</span>, level*<span class="number">3</span>, <span class="string">"|"</span>);</span><br><span class="line"></span><br><span class="line">    dump_heap(heap, index * <span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(struct heap *heap, <span class="keyword">int</span> elements)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= elements; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%02d]: %4d\n"</span>, i, heap-&gt;elem[i]-&gt;data);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct element* <span class="title">create_element</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">elem</span>;</span></span><br><span class="line"></span><br><span class="line">    elem = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct element));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elem)</span><br><span class="line">        elem-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fake_a_heap</span><span class="params">(struct heap *heap)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* data is in ordered */</span></span><br><span class="line">    <span class="keyword">int</span> i, data[<span class="number">10</span>] = {<span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>};</span><br><span class="line"></span><br><span class="line">    init_heap(heap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* root start at 1 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        heap-&gt;elem[i+<span class="number">1</span>] = create_element(data[i]);</span><br><span class="line"></span><br><span class="line">    heap-&gt;elements = <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(struct heap *heap, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    tmp = heap-&gt;elem[j];</span><br><span class="line">    heap-&gt;elem[j] = heap-&gt;elem[i];</span><br><span class="line">    heap-&gt;elem[i] = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(struct heap *heap, <span class="keyword">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> **<span class="title">elem</span> =</span> heap-&gt;elem;</span><br><span class="line">    <span class="keyword">int</span> elements = heap-&gt;elements;</span><br><span class="line">    <span class="keyword">int</span> left, right, max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        left = parent * <span class="number">2</span>;</span><br><span class="line">        right = left + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        max = parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= elements &amp;&amp; elem[max]-&gt;data &lt; elem[left]-&gt;data)</span><br><span class="line">            max = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= elements &amp;&amp; elem[max]-&gt;data &lt; elem[right]-&gt;data)</span><br><span class="line">            max = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (max == parent)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap(heap, max, parent);</span><br><span class="line">        parent = max;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(struct heap *heap)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = heap-&gt;elements / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        heapify(heap, i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heap_sort</span><span class="params">(struct heap *heap)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> elements = heap-&gt;elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap-&gt;elements) {</span><br><span class="line">        swap(heap, <span class="number">1</span>, heap-&gt;elements);</span><br><span class="line">        heap-&gt;elements--;</span><br><span class="line">        heapify(heap, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> elements;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">heap</span> <span class="title">heap</span>;</span></span><br><span class="line">    <span class="keyword">int</span> elements;</span><br><span class="line"></span><br><span class="line">    fake_a_heap(&amp;heap);</span><br><span class="line">    dump_heap(&amp;heap, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After Heapify:\n"</span>);</span><br><span class="line">    build_heap(&amp;heap);</span><br><span class="line">    dump_heap(&amp;heap, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After Heap sort:\n"</span>);</span><br><span class="line">    elements = heap_sort(&amp;heap);</span><br><span class="line">    dump(&amp;heap, elements);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<p> 堆排序，要排序的数据首先存储在一个堆中。从堆中一次取出一个结点。放置到有序数据集的尾部。当取出每个结点时，它的下一个结点就会浮现到堆的顶部。</p>
<p> 优先队列是从堆衍生的数据结构。在优先队列中，数据保存在一个堆中，可快速确定下一个最高优先级的结点。</p>
<p> 优先队列将数据按照优先级顺序排列。一个优先队列由许多有序元素构成，所以优先级最高的元素可以有效而快速的确定。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Heap PQueue;</span><br></pre></td></tr></tbody></table></figure>


<h4 id="2-3-7-leetcode题目"><a href="#2-3-7-leetcode题目" class="headerlink" title="2.3.7 leetcode题目"></a>2.3.7 leetcode题目</h4><ul>
<li>先序遍历构造二叉树</li>
<li>从中序与后序遍历构造二叉树</li>
<li>二叉树的层次遍历</li>
<li>从二叉搜索树到更大和树</li>
<li>二叉搜索树的最近公共祖先</li>
<li>前K个高频单词&lt;堆&gt;</li>
</ul>
<h3 id="2-4-图"><a href="#2-4-图" class="headerlink" title="2.4 图"></a>2.4 图</h3><p> 图(Graph)是由顶点的有穷非空集合和顶点之间的边的集合组成,通常表示为:<code>G(V,E)</code>.其中,G表示一个图,V是入G中顶点的集合,E是图G中的集合.</p>
<p> 图是一种灵活的数据结构，用来定义对象之间关联或联系的模型。对象由顶点表示，而对象直接的关系或关联则通过顶点之间的边来表示。<br> 图的访问方式：广度优先和深度优先。</p>
<h4 id="2-4-1-基础知识"><a href="#2-4-1-基础知识" class="headerlink" title="2.4.1 基础知识"></a>2.4.1 基础知识</h4><p> 图由两种类型的元素组成：顶点和边，顶点代表对象，边则建立起对象之间的关系或关联。图的边可关联值或权重信息。</p>
<ul>
<li>一组顶点：用V(vertex)表示顶点集合</li>
<li>一组边：用E(edge)表示边的集合<br> 图分为有向图和无向图。有向图，边是由两个顶点组成的有序对，具有特定的方向。边也可称为弧。无向图中，边是没有方向的。</li>
<li>(v, w)表示无向边，即v和w是互通的</li>
<li>&lt; v, w &gt;表示有向边，该边始于v，终于w<br> 图可分为连通图和非连通图</li>
<li>连通图：所有的点都右路径相连</li>
<li>非连通图：存在某两个点没有路径相连</li>
<li>强连通图： </li>
</ul>
<p> 图中的顶点度</p>
<ul>
<li>度</li>
<li>入度</li>
<li>出度</li>
</ul>
<h4 id="2-4-2-图表示"><a href="#2-4-2-图表示" class="headerlink" title="2.4.2 图表示"></a>2.4.2 图表示</h4><p> 图的表示方法是G=(V, E)，V代表顶点的集合，而E和V之间是二元关系。<br> 图中由两个重要关系邻接(adjacency)和关联(incidence)。邻接是两个顶点之间的关系。关联是顶点和边之间的关系。<br>邻接矩阵表示</p>
<p>邻接链表表示</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjList_</span> {</span></span><br><span class="line">    <span class="keyword">void</span> *vertex;</span><br><span class="line">    Set adjacent;</span><br><span class="line">}AdjList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Graph_</span> {</span></span><br><span class="line">    <span class="keyword">int</span> vcount;</span><br><span class="line">    <span class="keyword">int</span> ecount;</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    List adjlists;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>graph</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vertex</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex</span> *<span class="title">v</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> *<span class="title">next</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vertex</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> *<span class="title">adj</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_GRAPH_VERTEX (1 &lt;&lt; 8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex</span> *<span class="title">vxs</span>[<span class="title">MAX_GRAPH_VERTEX</span>];</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_graph</span><span class="params">(struct graph *graph)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_GRAPH_VERTEX; i++)</span><br><span class="line">        graph-&gt;vxs[i] = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct vertex *<span class="title">create_vertex</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex</span> *<span class="title">v</span>;</span></span><br><span class="line"></span><br><span class="line">    v = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct vertex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v) {</span><br><span class="line">        v-&gt;data = data;</span><br><span class="line">        v-&gt;adj = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct vertex_adjs *<span class="title">create_vertex_adj</span><span class="params">(struct vertex *v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> *<span class="title">v_adj</span>;</span></span><br><span class="line"></span><br><span class="line">    v_adj = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct vertex_adjs));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v_adj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    v_adj-&gt;v = v;</span><br><span class="line">    v_adj-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> v_adj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_adj</span><span class="params">(struct vertex *v, struct vertex *adj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> **<span class="title">v_adj</span>;</span></span><br><span class="line"></span><br><span class="line">    v_adj = &amp;v-&gt;adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*v_adj)</span><br><span class="line">    v_adj = &amp;(*v_adj)-&gt;next;</span><br><span class="line"></span><br><span class="line">    *v_adj = create_vertex_adj(adj);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_raw</span><span class="params">(struct graph *graph)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_GRAPH_VERTEX; i++) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vertex</span> *<span class="title">v</span> =</span> graph-&gt;vxs[i];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vertex_adjs</span> *<span class="title">adj</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Vertex[%02d]: %8d -&gt;"</span>, i, v-&gt;data);</span><br><span class="line"></span><br><span class="line">        adj = v-&gt;adj;</span><br><span class="line">        <span class="keyword">while</span> (adj) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %8d,"</span>, adj-&gt;v-&gt;data);</span><br><span class="line">            adj = adj-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  1 ----- 2 ----- 3</span></span><br><span class="line"><span class="comment">  |     / |     /</span></span><br><span class="line"><span class="comment">  |    /  |    / </span></span><br><span class="line"><span class="comment">  |   /   |   /  </span></span><br><span class="line"><span class="comment">  |  /    |  /   </span></span><br><span class="line"><span class="comment">  | /     | /    </span></span><br><span class="line"><span class="comment">  4 ----- 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fake_a_graph</span><span class="params">(struct graph *graph)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    init_graph(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    graph-&gt;vxs[i] = create_vertex(i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* connect 1 -&gt; 2, 1 -&gt; 4 */</span></span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">0</span>], graph-&gt;vxs[<span class="number">1</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">0</span>], graph-&gt;vxs[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">/* connect 2 -&gt; 1, 2 -&gt; 3, 2 -&gt; 5, 2 -&gt; 4 */</span></span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">1</span>], graph-&gt;vxs[<span class="number">0</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">1</span>], graph-&gt;vxs[<span class="number">2</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">1</span>], graph-&gt;vxs[<span class="number">4</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">1</span>], graph-&gt;vxs[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">/* connect 3 -&gt; 2, 3 -&gt; 5 */</span></span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">2</span>], graph-&gt;vxs[<span class="number">1</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">2</span>], graph-&gt;vxs[<span class="number">4</span>]);</span><br><span class="line">    <span class="comment">/* connect 4 -&gt; 1, 4 -&gt; 2, 4 -&gt; 5 */</span></span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">3</span>], graph-&gt;vxs[<span class="number">0</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">3</span>], graph-&gt;vxs[<span class="number">1</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">3</span>], graph-&gt;vxs[<span class="number">4</span>]);</span><br><span class="line">    <span class="comment">/* connect 5 -&gt; 4, 5 -&gt; 2, 5 -&gt; 3 */</span></span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">4</span>], graph-&gt;vxs[<span class="number">3</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">4</span>], graph-&gt;vxs[<span class="number">1</span>]);</span><br><span class="line">    insert_adj(graph-&gt;vxs[<span class="number">4</span>], graph-&gt;vxs[<span class="number">3</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">graph</span> <span class="title">g</span>;</span></span><br><span class="line"></span><br><span class="line">    fake_a_graph(&amp;g);</span><br><span class="line">    dump_raw(&amp;g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<h4 id="2-4-3-图遍历"><a href="#2-4-3-图遍历" class="headerlink" title="2.4.3 图遍历"></a>2.4.3 图遍历</h4><p> 图的搜索方法：深度优先搜索和广度优先搜索。<br> 深度优先遍历(DFS)<br> 思路: 从图中某点v出发:<br>   1.访问顶点v<br>   2.从v的未被访问的邻接点中选取一个顶点w,从w出发进行深度优先遍历.<br>   3.重复上述两步,直到图中所有和v有路径相通的顶点都被访问.<br> 伪代码: </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Vertex v)</span> </span>{</span><br><span class="line">    vistied[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (v 的每个邻接点 w) {</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) {</span><br><span class="line">            DFS(w);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<details>
<summary>dfs</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Graph.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NODES 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[MAX_NODES];  <span class="comment">// array to store visiting order</span></span><br><span class="line">                         <span class="comment">// indexed by vertex 0..nV-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfsPathCheck</span><span class="params">(Graph g, <span class="keyword">int</span> nV, Vertex v, Vertex dest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Vertex w;</span><br><span class="line">    <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; nV; w++)</span><br><span class="line">        <span class="keyword">if</span> (adjacent(g, v, w) &amp;&amp; visited[w] == <span class="number">-1</span>)</span><br><span class="line">        {</span><br><span class="line">            visited[w] = v;</span><br><span class="line">            <span class="keyword">if</span> (w == dest)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dfsPathCheck(g, nV, w, dest))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findPathDFS</span><span class="params">(Graph g, <span class="keyword">int</span> nV, Vertex src, Vertex dest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Vertex v;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; nV; v++) visited[v] = <span class="number">-1</span>;</span><br><span class="line">    visited[src] = src;</span><br><span class="line">    <span class="keyword">return</span> dfsPathCheck(g, nV, src, dest);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> V = <span class="number">6</span>;</span><br><span class="line">    Graph g = newGraph(V);</span><br><span class="line"></span><br><span class="line">    Edge e;</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">1</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">4</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">5</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">5</span>;</span><br><span class="line">    e.w = <span class="number">4</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">4</span>;</span><br><span class="line">    e.w = <span class="number">2</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">4</span>;</span><br><span class="line">    e.w = <span class="number">3</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">5</span>;</span><br><span class="line">    e.w = <span class="number">3</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">1</span>;</span><br><span class="line">    e.w = <span class="number">2</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">3</span>;</span><br><span class="line">    e.w = <span class="number">2</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> src = <span class="number">0</span>, dest = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (findPathDFS(g, V, src, dest)) {</span><br><span class="line">        Vertex v = dest;</span><br><span class="line">        <span class="keyword">while</span> (v != src) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d - "</span>, v);</span><br><span class="line">            v = visited[v];</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, src);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<p> 广度优先遍历(BFS)<br> 思路:<br>   1.顶点v入队列<br>   2.当队列非空时则继续执行,否则算法结束.<br>   3.出队列取得队头顶点v’,访问顶点v 并标记顶点v已被访问.<br>   4.查找顶点v的第一个邻接顶点col<br>   5.若v的邻接顶点col未被访问过的,则col继续.<br>   6.查找顶点v的另一个新的邻接顶点col,转到步骤5入队列,直到顶点v的所有未被访问过的邻接点处理完,转到步骤2.</p>
<details>
<summary>bfs_queue</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Graph.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NODES 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[MAX_NODES];  <span class="comment">// array to store visiting order</span></span><br><span class="line">                         <span class="comment">// indexed by vertex 0..nV-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findPathBFS</span><span class="params">(Graph g, <span class="keyword">int</span> nV, Vertex src, Vertex dest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Vertex v;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; nV; v++) visited[v] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    visited[src] = src;</span><br><span class="line">    <span class="built_in">queue</span> Q = newQueue();</span><br><span class="line">    QueueEnqueue(Q, src);</span><br><span class="line">    <span class="keyword">while</span> (!QueueIsEmpty(Q)) {</span><br><span class="line">        v = QueueDequeue(Q);</span><br><span class="line">        Vertex w;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; nV; w++) (</span><br><span class="line">            <span class="keyword">if</span> (adjacent(g, v, w) &amp;&amp; visited[w] == <span class="number">-1</span>) {</span><br><span class="line">                visited[w] = v;</span><br><span class="line">                <span class="keyword">if</span> (w == dest)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    QueueEnqueue(Q, w);</span><br><span class="line">            }</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> V = <span class="number">10</span>;</span><br><span class="line">    Graph g = newGraph(V);</span><br><span class="line"></span><br><span class="line">    Edge e;</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">1</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">2</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">0</span>;</span><br><span class="line">    e.w = <span class="number">5</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">1</span>;</span><br><span class="line">    e.w = <span class="number">5</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">2</span>;</span><br><span class="line">    e.w = <span class="number">3</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">3</span>;</span><br><span class="line">    e.w = <span class="number">4</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">3</span>;</span><br><span class="line">    e.w = <span class="number">5</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">3</span>;</span><br><span class="line">    e.w = <span class="number">8</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">4</span>;</span><br><span class="line">    e.w = <span class="number">5</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">4</span>;</span><br><span class="line">    e.w = <span class="number">7</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">4</span>;</span><br><span class="line">    e.w = <span class="number">8</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">5</span>;</span><br><span class="line">    e.w = <span class="number">6</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">7</span>;</span><br><span class="line">    e.w = <span class="number">8</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">7</span>;</span><br><span class="line">    e.w = <span class="number">9</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line">    e.v = <span class="number">8</span>;</span><br><span class="line">    e.w = <span class="number">9</span>;</span><br><span class="line">    insertEdge(g, e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> src = <span class="number">0</span>, dest = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (findPathBFS(g, V, src, dest)) {</span><br><span class="line">        Vertex v = dest;</span><br><span class="line">        <span class="keyword">while</span> (v != src) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d - "</span>, v);</span><br><span class="line">            v = visited[v];</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, src);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<p> 深度优先搜索和广度优先搜索,时间复杂度都为O(n^2)</p>
<p>深度优先:从初始点出发,不断向前走,如果碰到死路,就往回走一步,尝试另一条路,直到发现目标位置.<br>广度优先:从初始点出发,把所有可能的路径都走一遍,如果里面没有目标位置,则尝试把所有两步能够到的位置都走一遍,看有没有目标位置.</p>
<h4 id="2-4-4-最短路径"><a href="#2-4-4-最短路径" class="headerlink" title="2.4.4 最短路径"></a>2.4.4 最短路径</h4><p><strong>迪杰斯特拉Dijkstra算法</strong><br> Dijkstra算法适用于权值为正的图.<br> Dijkstra算法属于单源算法,即只能求出某点到其它点最短距离,并不能得出任意两点之间的最短距离.<br> 在源点可达的情况下,Dijkstra算法的时间复杂度时 <code>O(ElogV)</code><br> 算法步骤:<br>  1.将所有边初始化为无穷大<br>  2.旋转一个开始的顶点,添加到优先队列中.<br>  3.对于该点的所有邻接顶点进行判断,如果到该点的距离小于原先的值,则该值进行更新.<br>  4.将该点所有邻接顶点添加到优先队列中.<br>  5.从优先队列中挑选除一个路径值最小的顶点,将其弹出,作为新的顶点,重复步骤3,4,5<br>  6.直到所有点都被处理过一次.</p>
<detials>
<summary>迪杰斯特拉</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 999</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mat[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[MAX];</span><br><span class="line"><span class="keyword">int</span> qp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> v)</span> </span>{ q[qp++] = v; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cf</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> *x = (<span class="keyword">int</span> *)a;</span><br><span class="line">    <span class="keyword">int</span> *y = (<span class="keyword">int</span> *)b;</span><br><span class="line">    <span class="keyword">return</span> *y - *x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    qsort(q, qp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cf);</span><br><span class="line">    <span class="keyword">return</span> q[--qp];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_has_something</span><span class="params">()</span> </span>{ <span class="keyword">return</span> (qp &gt; <span class="number">0</span>); }</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[MAX];</span><br><span class="line"><span class="keyword">int</span> vp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (i != s) {</span><br><span class="line">            dist[i] = INF;</span><br><span class="line">        }</span><br><span class="line">        enqueue(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (queue_has_something()) {</span><br><span class="line">        <span class="keyword">int</span> u = dequeue();</span><br><span class="line">        visited[vp++] = u;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V; ++i) {</span><br><span class="line">            <span class="keyword">if</span> (mat[u][i]) {</span><br><span class="line">                <span class="keyword">if</span> (dist[i] &gt; dist[u] + mat[u][i]) {</span><br><span class="line">                    dist[i] = dist[u] + mat[u][i];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter the number of vertices: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">" %d"</span>, &amp;V);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter the adj matrix: "</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V; ++i) {</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; V; ++j) {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %d"</span>, &amp;mat[i][j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dijkstra(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nNode\tDist\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t%d\n"</span>, i, dist[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</detials>

<p><strong>弗洛伊德Floyd算法</strong><br> Floyd算法是一个经典的动态规划算法.首先目标是寻找从点<code>i</code>到<code>j</code>的最短路径.<br> <strong>Floyd算法可以求出任意两点的最短距离.时间复杂度:</strong><code>O(你^3)</code><br> 从任意节点i到任意节点j的最短路径不外乎2种可能:<br>  1.是之间从i到j<br>  2是从i到经过若干个节点k到j<br> 设Dist(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，则设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] &gt; (A[i][k] + A[k][j])) {</span><br><span class="line">                A[i][j] = A[i][k] + A[k][j];</span><br><span class="line">                path[i][j] = k;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h4 id="2-4-5-拓扑排序"><a href="#2-4-5-拓扑排序" class="headerlink" title="2.4.5 拓扑排序"></a>2.4.5 拓扑排序</h4><p> 拓扑排序是一个有向无环图(DAG)的所有顶点的线性序列.且该序列必须满足下面两个条件:</p>
<ul>
<li>每个顶点出现且只出现一次</li>
<li>若存在一条顶点A到顶点B的路径,那么在序列中顶点A出现在顶点B的前面.<br> 有向无环图(DAG)才有拓扑排序，非DAG图没有拓扑排序。<br> 拓扑排序步骤：</li>
<li>从DAG图中选择一个 没有前缀(即入度为0)的顶点并输出</li>
<li>从图中删除该顶点和所有以它为起点的有向边</li>
<li>重复1和2直到当前的DAG图为空或当前图中不存在无前缀的顶点为止。后一种情况说明有向图中必然存在环。</li>
</ul>
<h4 id="2-4-6-leetcode题目"><a href="#2-4-6-leetcode题目" class="headerlink" title="2.4.6 leetcode题目"></a>2.4.6 leetcode题目</h4><ul>
<li>判断二分图</li>
<li>克隆图</li>
<li>找到小镇的法官</li>
<li>钥匙和房间</li>
<li>最短路径访问所有节点</li>
</ul>
<br>

<h2 id="3-常见算法"><a href="#3-常见算法" class="headerlink" title="3 常见算法"></a>3 常见算法</h2><h3 id="3-1-递归思想"><a href="#3-1-递归思想" class="headerlink" title="3.1 递归思想"></a>3.1 递归思想</h3><h4 id="3-1-1-递归思想"><a href="#3-1-1-递归思想" class="headerlink" title="3.1.1 递归思想"></a>3.1.1 递归思想</h4><p> 递归思想是:将大问题分解为小问题来求解,然后再将小问题分解为更小的问题.逐层分解,直到问题规模被分解到可以直接计算结果.<br> 如果把一层一层分解过程画成图,它其实就是一棵树,称为递归树.</p>
<!--more-->

<p> 斐波那契数列</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (N &lt; = <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fib(N<span class="number">-1</span>) + fib(N<span class="number">-2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> 递归的过程中,符合<strong>后进先出</strong>规则,所以用一个堆栈的数据结构.函数递归过程中会自动产生栈帧,当函数栈帧的深度越来越大,栈也也越来越大,如果递归没有终止条件,则会爆栈.递归算法第一步要思考的就是<strong>递归终止条件</strong>.<br> 递归思想的两个延申算法:分治算法和动态规划.<br> 递归的一般结构:</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (符合边界条件) {</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ..;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 某种形式的调用</span></span><br><span class="line">    func();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> 阶乘函数:</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>参考链接:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b2d2edb4ba5b">https://www.jianshu.com/p/b2d2edb4ba5b</a></li>
</ul>
<h4 id="3-1-2-递归基本步骤"><a href="#3-1-2-递归基本步骤" class="headerlink" title="3.1.2 递归基本步骤:"></a>3.1.2 递归基本步骤:</h4><p>  1.定义一个函数,明确函数功能<br>  2.寻找问题与子问题之间的关系(递推公式)<br>  3.将递推公式在定义的函数中实现<br>  4.推导时间复杂度,判定是否可以接受,无法接受更换算法.</p>
<h4 id="3-1-3-代表题目"><a href="#3-1-3-代表题目" class="headerlink" title="3.1.3 代表题目"></a>3.1.3 代表题目</h4><ul>
<li>爬楼梯 70</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> *mem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> mem[n] = {};</span><br><span class="line">    <span class="keyword">return</span> climb(n, mem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climb</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *mem)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mem[n] &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> mem[n];</span><br><span class="line">    }</span><br><span class="line">    mem[<span class="number">0</span>] = climb(n<span class="number">-1</span>, mem) + climb(n<span class="number">-2</span>, mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>青蛙跳台阶 10-II</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> num[n+<span class="number">1</span>] = {<span class="number">-1</span>};</span><br><span class="line">    <span class="keyword">return</span> jump(n, num);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (num[n] != <span class="number">-1</span>) {</span><br><span class="line">        <span class="keyword">return</span> num[n];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    num[n] = (jump(n<span class="number">-1</span>, num) + jump(n<span class="number">-2</span>, num) % <span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> num[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-1-4-触类旁通"><a href="#3-1-4-触类旁通" class="headerlink" title="3.1.4 触类旁通"></a>3.1.4 触类旁通</h4><ul>
<li>反转二叉树 226<br> 1).对于根节点<code>1</code>来说,假设<code>2,3</code>节点下的节点都已经翻转,那么只要翻转<code>2,2</code>节点即满足需求.<br> 2).对于<code>2,3</code>节点来说,也是翻转其左右节点即可.<br> 依此类推,对每一个节点,依次翻转其左右节点,所以我们可知问题与子问题的关系是翻转(根节点) = 翻转(根节点的左节点) + 翻转(根节点的右节点),即<blockquote>
<p>invert(root) = invert(root-&gt;left) + invert(root-&gt;right)<br> 加号是追加到root上的意思</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">invertTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TreeNode *left = (struct TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    TreeNode *right = (struct TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    left = invertTree(root.left);</span><br><span class="line">    rgith = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>路径总和 112<br> 给定一个二叉树和一个目标和,判断该树中是否存在根节点到叶子节点的路径,这条路径上所有节点值相加等于目标和.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">NULL</span> &amp;&amp; root.right == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> root.data == sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> remain = sum - root.data;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, remain) || hashPashSum(root.right, remain);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>细胞分裂</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b2d2edb4ba5b">https://www.jianshu.com/p/b2d2edb4ba5b</a></p>
<h3 id="3-2-分治法"><a href="#3-2-分治法" class="headerlink" title="3.2 分治法"></a>3.2 分治法</h3><p> 把复杂问题分成两个或者更多相同或相似的子问题，再把子问题分成更小的子问题…，直到可以直接求解，原问题的解为子问题解的合并。<br> 分治法应用：排序算法(快速排序、归并排序);傅里叶变换()。</p>
<h4 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h4><p> 分治法思想:将一个难以直接解决的大问题,分割成一些规模小的相同问题,分而治之.</p>
<p> 分治法:把一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题…,直到最后子问题可以简单的直接求解,原问题的解即子问题的解的<strong>合并</strong>.分治法思想:排序(快速排序,归并排序),傅里叶变换(快速傅里叶变换<br> 1):数学归纳是使用分治思想.<br> 2):分治思想不一定使用递归结构.<br> 递归结构是循环结构的一种,也是分治思想应用最多的一种程序结构,但不一定使用它.分治法的核心是<strong>如何分</strong></p>
<h4 id="3-2-2-策略"><a href="#3-2-2-策略" class="headerlink" title="3.2.2 策略"></a>3.2.2 策略</h4><p> 分治策略:对于一个规模为n的问题,若该问题可以容易解决则直接解决,否则将其分解为k个规模较小的子问题,子问题之间相互独立且与原问题形式相同,可递归求解.分治通常用递归实现.</p>
<h4 id="3-2-3-应用场景"><a href="#3-2-3-应用场景" class="headerlink" title="3.2.3 应用场景"></a>3.2.3 应用场景</h4><p> 分治法特征:</p>
<ul>
<li>问题缩小到一定程度可容易解决.</li>
<li>问题可分解为若干个规模较小的相同问题,即问题具有最优子结构性质.</li>
<li>子问题的解可合并为该问题的解.</li>
<li>问题分解的子问题相互独立,子问题之间不包含公告子问题.</li>
</ul>
<h4 id="3-2-4-步骤"><a href="#3-2-4-步骤" class="headerlink" title="3.2.4 步骤"></a>3.2.4 步骤</h4><p> 分治法一层递归步骤:</p>
<ul>
<li><ol>
<li><strong>分解</strong>:将原问题分解为若干规模较小,相互独立,与原问题形式相同的子问题.</li>
</ol>
</li>
<li><ol start="2">
<li><strong>解决</strong>:若子问题可直接求解,则直接求解,否则递归解各个子问题.</li>
</ol>
</li>
<li><ol start="3">
<li><strong>合并</strong>:将各个子问题的解合并为原问题的解.</li>
</ol>
</li>
</ul>
<p> </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<br>

<h4 id="3-2-5-应用"><a href="#3-2-5-应用" class="headerlink" title="3.2.5 应用"></a>3.2.5 应用</h4><blockquote>
<p>分治思维方式：二分搜索;大整数乘法;合并排序;快速排序。</p>
</blockquote>
<p> 求x的n次幂<br> 对数复杂度O(logn)</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">        result = power(x, n/<span class="number">2</span>) * power(x, n / <span class="number">2</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        result = power(x, (n + <span class="number">1</span>) / <span class="number">2</span>) * power(x, (n - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-2-6-leetcode题目"><a href="#3-2-6-leetcode题目" class="headerlink" title="3.2.6 leetcode题目"></a>3.2.6 leetcode题目</h4><ul>
<li>搜索二维矩阵II</li>
<li>求众数</li>
<li>合并k个排序链表</li>
</ul>
<h3 id="3-3-排序算法"><a href="#3-3-排序算法" class="headerlink" title="3.3 排序算法"></a>3.3 排序算法</h3><p> 各种排序算法，主要包括：插入排序、快速排序、归并排序、计数排序和技术排序。二分查找，</p>
<h4 id="3-3-1-冒泡排序"><a href="#3-3-1-冒泡排序" class="headerlink" title="3.3.1 冒泡排序"></a>3.3.1 冒泡排序</h4><p> 重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。<br> <strong>冒泡排序算法复杂度是O(n^2)</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> out = size - <span class="number">1</span>; out &gt; <span class="number">0</span>; out--) {</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> in = <span class="number">0</span>; in &lt; out; in++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[in] &gt; arr[in + <span class="number">1</span>]) {</span><br><span class="line">                swap(arr, in, in + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a,b) \</span></span><br><span class="line"><span class="meta">do{\</span></span><br><span class="line"><span class="meta">    (a) ^= (b);\</span></span><br><span class="line"><span class="meta">    (b) ^= (a);\</span></span><br><span class="line"><span class="meta">    (a) ^= (b);\</span></span><br><span class="line"><span class="meta">}while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*冒泡排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> swap_flg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {<span class="comment">/*排序的趟数*/</span> </span><br><span class="line">        swap_flg = <span class="number">0</span>;<span class="comment">/*每次设置交换标识为0*/</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) {          <span class="comment">/*本趟排序的遍历元素个数*/</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) {</span><br><span class="line">                SWAP(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">                swap_flg = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/*本趟数，无数据交换的话，说明已经有序，直接退出*/</span></span><br><span class="line">        <span class="keyword">if</span> (swap_flg == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<br>

<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">//整数或浮点数皆可使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i, j; T temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) {</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-2-选择排序"><a href="#3-3-2-选择排序" class="headerlink" title="3.3.2 选择排序"></a>3.3.2 选择排序</h4><p> 选择排序算法时间复杂度为O(n^2)</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> size = arr.lenght;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> out = <span class="number">0</span>; out &lt; size; out++) {</span><br><span class="line">        <span class="keyword">int</span> mixIndex = out;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> in = out - <span class="number">1</span>; in &lt; size; in++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[mixIndex] &gt; arr[in]) {</span><br><span class="line">                mixIndex = in;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mixIndex != out) {</span><br><span class="line">            swap(arr, mixIndex, out);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选择排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)  {</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; size; j++) {</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min]) {</span><br><span class="line">                min = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min != i) {</span><br><span class="line">            SWAP(a[i],a[min]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-3-插入排序"><a href="#3-3-3-插入排序" class="headerlink" title="3.3.3 插入排序"></a>3.3.3 插入排序</h4><p> 插入排序每次从无序数据集合中取出一个元素，插入到已经排好序的数据集中适当位置，使数据集仍然有序。插入排序不需要额外空间。时间复杂度O(n2)</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> size = arr.lenght;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> out = <span class="number">1</span>; out &lt; size; out++) {</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[out];</span><br><span class="line">        <span class="keyword">int</span> in = out;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">while</span> (in - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[in - <span class="number">1</span>] &gt; temp) {</span><br><span class="line">            arr[in] = arr[in - <span class="number">1</span>];</span><br><span class="line">            in--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (in != out) {</span><br><span class="line">            arr[in] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i ++)<span class="comment">/*需要插入的元素个数*/</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> key = a[i];<span class="comment">/*保存插入的元素数据*/</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/* i 之前的元素都是有序的，找到比key小的插入到他后面，</span></span><br><span class="line"><span class="comment">        * 比key大的，需要往后挪一个位置*/</span></span><br><span class="line">        <span class="keyword">while</span>((j &gt;= <span class="number">0</span>) &amp;&amp; (a[j] &gt; key)) {</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        a[j + <span class="number">1</span>] = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">issort</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">int</span> size, <span class="keyword">int</span> esize, <span class="keyword">int</span> (*compare)(<span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> *a = data;</span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((key = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(esize)) == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; size; j++) {</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; compare(&amp;a[i * esize], key) &gt; <span class="number">0</span>) {</span><br><span class="line">            mamcpy(&amp;a[(i + <span class="number">1</span>) * esize], &amp;a[i * esize], esize);</span><br><span class="line">            i--;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;a[(i + <span class="number">1</span>) * esize], key, esize);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-3-4-希尔排序"><a href="#3-3-4-希尔排序" class="headerlink" title="3.3.4 希尔排序"></a>3.3.4 希尔排序</h4><p> 希尔排序时间复杂度O(n*(logn)^2)</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> size = arr.lenght;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt;= size / <span class="number">3</span>) {</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (h &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> out = h; out &lt; size; out++) {</span><br><span class="line">            <span class="keyword">int</span> temp = arr[out];</span><br><span class="line">            <span class="keyword">int</span> in = out;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">while</span> (in - h &gt;= <span class="number">0</span> &amp;&amp; arr[in - h] &gt; temp) {</span><br><span class="line">                arr[in] = arr[in - h];</span><br><span class="line">                in = in - h;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (in != out) {</span><br><span class="line">                arr[in] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        h = (h - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-3-5-归并排序"><a href="#3-3-5-归并排序" class="headerlink" title="3.3.5 归并排序"></a>3.3.5 归并排序</h4><p> 归并排序是一种分支排序算法。归并排序需要额外存储空间来完成排序。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span>  x &lt; y ? x : y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> *a = arr;</span><br><span class="line">    <span class="keyword">int</span> *b = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> seg, start;</span><br><span class="line">    <span class="keyword">for</span> (seg = <span class="number">1</span>; seg &lt; len; seg += seg) {</span><br><span class="line">        <span class="keyword">for</span> (start )</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; size; idx++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%08d\n"</span>, arr[idx]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __merge(<span class="keyword">int</span> *arr, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> *tmp;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((r - p + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tmp)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = p, j = q + <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= q &amp;&amp; j &lt;= r;) {</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j])</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == q + <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= r;)</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= q;)</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(arr + p, tmp, (r - p + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __merge_sort(<span class="keyword">int</span> *arr, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    q = (p + r) / <span class="number">2</span>;</span><br><span class="line">    __merge_sort(arr, p, q);</span><br><span class="line">    __merge_sort(arr, q + <span class="number">1</span>, r);</span><br><span class="line">    __merge(arr, p, q, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __merge_sort(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_verify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> test[<span class="number">10</span>] = {<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">67</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>};</span><br><span class="line"></span><br><span class="line">    __merge(test, <span class="number">0</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    dump(test, <span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> test[<span class="number">10</span>] = {<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">67</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>};</span><br><span class="line"></span><br><span class="line">    merge_sort(test, <span class="number">10</span>);</span><br><span class="line">    dump(test, <span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//merge_verify();</span></span><br><span class="line">    merge_sort_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-3-6-快速排序"><a href="#3-3-6-快速排序" class="headerlink" title="3.3.6 快速排序"></a>3.3.6 快速排序</h4><p> 快速排序是一种分治排序算法。不需要额外存储空间，时间复杂度O(nlgn)</p>
<p> 快速排序三个步骤：</p>
<ul>
<li>分：设定一个分割值并将数据分为两部分。</li>
<li>治：分别在两部分使用递归方式继续使用快速排序方法。</li>
<li>和：对分割部分排序直至完成。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Range</span> {</span></span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">} Range;</span><br><span class="line"></span><br><span class="line"><span class="function">Range <span class="title">now_Range</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Range r;</span><br><span class="line">    r.start = s;</span><br><span class="line">    r.end = e;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = new_Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid = arr[(range.start + range.end) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = range.start;</span><br><span class="line">        <span class="keyword">int</span> right = range.end;</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid) {</span><br><span class="line">                ++left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; mid) {</span><br><span class="line">                --right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) {</span><br><span class="line">                swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; right) {</span><br><span class="line">            r[p++] = new_Range(range.start, right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (range.end &gt; left) {</span><br><span class="line">            r[p++] = new_Range(left, range.end);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) {</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high;</span><br><span class="line">        <span class="keyword">int</span> k = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="comment">// 从右向左找第一个小于k的数</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= k) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) {</span><br><span class="line">                arr[i++] = arr[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 从左向右找第一个大于等于k的数</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; k) {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) {</span><br><span class="line">                arr[j--] = arr[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        arr[i] = k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        QuickSort(arr, low, i - <span class="number">1</span>); <span class="comment">// 排序k左边</span></span><br><span class="line">        QuickSort(arr, i + <span class="number">1</span>, high); <span class="comment">// 排序k右边</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">( <span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, p, tmp;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    p = a[n / <span class="number">2</span>];   <span class="comment">// Get the middle element as pivot ..</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>, j = n <span class="number">-1</span>;; i++, j--) {</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt; p)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (p &lt; a[j])</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> ( i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        tmp = a[i]; a[i] = a[j]; a[j] = tmp;    <span class="comment">//swap both ..</span></span><br><span class="line">    }   </span><br><span class="line"></span><br><span class="line">    quick_sort( a, i); </span><br><span class="line">    quick_sort( a + i, n - i); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; size; idx++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%08d\n"</span>, arr[idx]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//int pivot = arr[r];</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    i = j = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; j &lt; r; j++) {</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[r]) {</span><br><span class="line">            <span class="keyword">if</span>(i != j) {</span><br><span class="line">                swap(arr + i, arr + j);</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    swap(arr + i, arr + r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __quick_sort(<span class="keyword">int</span> *arr, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    q = partition(arr, p, r);</span><br><span class="line">    __quick_sort(arr, p, q<span class="number">-1</span>);</span><br><span class="line">    __quick_sort(arr, q+<span class="number">1</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    __quick_sort(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> test[<span class="number">10</span>] = {<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">67</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">31</span>, <span class="number">56</span>};</span><br><span class="line"></span><br><span class="line">    quick_sort(test, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    dump(test, <span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    quick_sort_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (high &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> key = arr[low];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">/*从左向右找比key大的值*/</span></span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; key) {</span><br><span class="line">            <span class="keyword">if</span> (i == high) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*从右向左找比key小的值*/</span></span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; key)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (j == low) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/*交换i,j对应的值*/</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*中枢值与j对应值交换*/</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[low];</span><br><span class="line">    arr[low] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">    <span class="built_in">Qsort</span>(arr, low, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Qsort</span>(arr, j + <span class="number">1</span>, high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>qsort/sort函数</strong><br> 在c语言库函数中已经实现了qsort函数,<br> qsort函数用法:</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">int</span> nelem, <span class="keyword">int</span> width, <span class="keyword">int</span> (*fcmp)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="comment">// 参数:1 带排序数组首地址, nelem 数组中待排元素数量  width 各元素所在空间大小  *fcmp 指向函数的指针</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">}</span><br><span class="line">qsort(arr, n, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// char 数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">com</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">char</span> *)a - *(<span class="keyword">char</span> *)b;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">char</span> word[<span class="number">100</span>];</span><br><span class="line">qsort(word, <span class="number">100</span>, <span class="keyword">sizeof</span>(word[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// double 类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">double</span> *)a &gt; *(<span class="keyword">double</span>*)b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">double</span> in[<span class="number">100</span>];</span><br><span class="line">qsort(in, <span class="number">100</span>, <span class="keyword">sizeof</span>(in[<span class="number">00</span>]), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sample</span> {</span></span><br><span class="line">    <span class="keyword">double</span> data;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">}st[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (*(Sample *)a).data &gt; (*(Sampel *)b).data ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line">qsort(s, <span class="number">100</span>, <span class="keyword">sizeof</span>(s[<span class="number">0</span>]), cmp);</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Sample</span> *<span class="title">c</span> =</span> (Sample *)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Sample</span> *<span class="title">d</span> =</span> (Sample *)b;</span><br><span class="line">    <span class="keyword">if</span>(c-&gt;x != d-&gt;x) {</span><br><span class="line">        <span class="keyword">return</span> c-&gt;x - d-&gt;x;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> d-&gt;y - c-&gt;y;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">qsort(s,<span class="number">100</span>,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),cmp);</span><br><span class="line"></span><br><span class="line">truct Sample</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">}s[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照结构体中字符串str的字典顺序排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>((*(Sample *)a)-&gt;str , (*(Sample *)b)-&gt;str);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">qsort(s,<span class="number">100</span>,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),cmp);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-3-7-堆排序"><a href="#3-3-7-堆排序" class="headerlink" title="3.3.7 堆排序"></a>3.3.7 堆排序</h4><p> 桶排序算法基本原理：把数组中的所有元素分为若干个数据块，也就是若干个桶，然后对每个桶里的数据进行排序，最后将所有桶里的数据依次排列。<br> 存在两个问题：<br> (1)怎样划分数据块，也就是分几个桶，每个桶放哪几个数据。<br> (2)对每个数据块里的数据怎样排序。<br> 堆排序使利用堆这种数据结构设计的一种选择排序算法。堆是一种近似完全二叉树的结构(通常堆用一维数组实现),并满足性质；最大堆(大顶堆)为例，其父节点的值总是大于它的孩子节点。<br> 堆排序的过程：<br> 1.由输入的无序数组构造一个最大堆，作为初始的无序区<br> 2.把堆顶元素(最大值)和堆尾元素互换<br> 3.把堆(无序区)的尺寸缩小1，并调用heapify(A,0)从新的堆顶元素开始进行堆调整。<br> 4.重复步骤2，直到堆的尺寸为1<br> 因为每次插入数据效率是O(logN)，而我们需要进行n次循环，将数组中每个值插入到堆中，所以它的执行时间是O(N*logN)级。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sdtio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">} KeyNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span> keys[], <span class="keyword">int</span> size, <span class="keyword">int</span> bucket_size)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    KeyNode **bucket_table = (KeyNode **)mallov(bucket_size * <span class="keyword">sizeof</span>(KeyNode*));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; bucket_size;i++) {</span><br><span class="line">        bucket_table[i] = (KeyNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(KeyNode));</span><br><span class="line">        bucket_table[i]-&gt;key = <span class="number">0</span>;</span><br><span class="line">        bucket_table[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; size;j++) {</span><br><span class="line">        KeyNode *node = (KeyNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(KeyNode));</span><br><span class="line">        node-&gt;key = keys[j];</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> index = keys[j]/<span class="number">10</span>;</span><br><span class="line">        KeyNode *p = bucket_table[index];</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;key == <span class="number">0</span>) {</span><br><span class="line">            bucket_table[index]-&gt;next = node;</span><br><span class="line">            (bucket_table[index]-&gt;key)++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;key &lt;= node-&gt;key)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            node-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = node;</span><br><span class="line">            (bucket_table[index]-&gt;key)++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//print result</span></span><br><span class="line">    KeyNode * k = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; bucket_size;i++)</span><br><span class="line">    <span class="keyword">for</span>(k = bucket_table[i]-&gt;next;k!=<span class="literal">NULL</span>;k=k-&gt;next)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,k-&gt;key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> raw[] = {<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>};</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(raw)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    bucket_sort(raw,size,<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapify</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> lef_child = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right_child = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> max = i;</span><br><span class="line">    <span class="keyword">if</span> (lef_child &lt; size &amp;&amp; A[lef_child] &gt; A[max]) {</span><br><span class="line">        max = lef_child;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (right_child &lt; size &amp;&amp; A[right_child] &gt; A[max]) {</span><br><span class="line">        max = right_child;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (max != i) {</span><br><span class="line">        Swap(A, i max);</span><br><span class="line">        Heapify(A, max, size);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> heap_size = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heap_size / w - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        Heapify(A, i, heap_size);</span><br><span class="line">        <span class="keyword">return</span> heap_size;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> heap_size = BuildHeap(A, n);</span><br><span class="line">    <span class="keyword">while</span> (heap_size &gt; <span class="number">1</span>) {</span><br><span class="line">        Swap(A, <span class="number">0</span>, heap_size);</span><br><span class="line">        Heap(A, <span class="number">0</span>, heap_size);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-8-leetcode排序"><a href="#3-3-8-leetcode排序" class="headerlink" title="3.3.8 leetcode排序"></a>3.3.8 leetcode排序</h4><ul>
<li>按奇偶排序数组</li>
<li>对链表进行插入排序</li>
<li>合并区间</li>
<li>最大数</li>
<li>最接近原点的K个点</li>
</ul>
<h3 id="3-4-贪心算法"><a href="#3-4-贪心算法" class="headerlink" title="3.4 贪心算法"></a>3.4 贪心算法</h3><h4 id="3-4-1-基本概念"><a href="#3-4-1-基本概念" class="headerlink" title="3.4.1 基本概念"></a>3.4.1 基本概念</h4><p> 贪心算法:在对问题求解时,总是做出在当前是最好的选择,即不考虑整体最优,仅考虑局部最优解.<br> 贪心算法没有固定算法框架,算法关键是贪心策略的选择.他想算法不是所有问题都得到最优解,选择贪心策略必须具备无后效性,即某个状态以后的过程不会影响一起的状态,只与当前状态有关.</p>
<h4 id="3-4-2-描述"><a href="#3-4-2-描述" class="headerlink" title="3.4.2 描述"></a>3.4.2 描述</h4><p> 贪心算法实现步骤:<br> 1.建立数学模型描述问题<br> 2.把求解的问题分成若干个子问题<br> 3.对每个子问题求解,得到子问题的局部最优解<br> 4.把子问题的解局部最优解合成原来问题的一个解.<br> 实现算法过程:</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (能朝给定总目标前进一步)</span><br><span class="line">{</span><br><span class="line">    利用可行的决策,求出可行解的一个解元素;</span><br><span class="line">}</span><br><span class="line">由所有解元素组合成问题的一个可行解</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-4-3-应用"><a href="#3-4-3-应用" class="headerlink" title="3.4.3 应用"></a>3.4.3 应用</h4><p><strong>最小生成树算法</strong><br> 贪心算法经典实践:最小生成树算法<br> 设<code>G=(V, E)</code>是无向连通带权图,即一个网络,E中的每一条边<code>(v,w)</code> 的全为 <code>c[v][w]</code>.如果G的字体 G’ 是一颗包含 G 的所有顶点的数,则称 G’ 为 G 的生成树.生成树上各边权的总和称为生成树的耗费.在 G 的所有生成树中,耗费最小的生成树称为 G 的最小生成树.<br> 最小生成树的性质:<br>  设<code>G=(V, E)</code>是连通带权图, U是V的真子集.如果(u,v)属于E,且u属于E,v属于V-U,且在所有这样的边中,(u,v)的权c[u][v]最小,那么一定存在G的一颗最小生成树,它亦是(u,v)为其中一条边,这个性质有时也称为MST性质.</p>
<p><strong>Prim算法</strong><br>  设<code>G=(V, E)</code>是连通带权图, V={1,2,…,n}.构造G的最小生成树Prim算法的基本思想是:**首先置S={1},然后,只有S是V的真子集,就进行如下的贪心选择:选取满足添加i属于S,j属于V-S,且c[i][j]最小的边,将顶点j添加到S中.这个过程一直进行到S=V时为止.在这个过程中选取到的所有边恰好构成G的一颗最小生成树.</p>
<details>
<summary>Prim</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file</span></span><br><span class="line"><span class="comment"> * @author [Timothy Maloney](https://github.com/sl1mb0)</span></span><br><span class="line"><span class="comment"> * @brief [Prim's algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)</span></span><br><span class="line"><span class="comment"> * implementation in C to find the MST of a weighted, connected graph.</span></span><br><span class="line"><span class="comment"> * @details Prim's algorithm uses a greedy approach to generate the MST of a</span></span><br><span class="line"><span class="comment"> *weighted connected graph. The algorithm begins at an arbitrary vertex v, and</span></span><br><span class="line"><span class="comment"> *selects a next vertex u, where v and u are connected by a weighted edge whose</span></span><br><span class="line"><span class="comment"> *weight is the minimum of all edges connected to v.</span></span><br><span class="line"><span class="comment"> * @references Page 319 "Introduction to the Design and Analysis of Algorithms"</span></span><br><span class="line"><span class="comment"> *- Anany Levitin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To test - run './prim -test'</span></span><br><span class="line"><span class="comment"> * prim() will find the MST of the following adj. matrix:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	  0  1  2  3</span></span><br><span class="line"><span class="comment"> *        1  0  4  6</span></span><br><span class="line"><span class="comment"> *        2  4  0  5</span></span><br><span class="line"><span class="comment"> *        3  6  5  0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The minimum spanning tree for the above weighted connected graph is given by</span></span><br><span class="line"><span class="comment"> *the following adj matrix:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	  0  1  2  3</span></span><br><span class="line"><span class="comment"> *	  1  0  0  0</span></span><br><span class="line"><span class="comment"> *	  2  0  0  0</span></span><br><span class="line"><span class="comment"> *	  3  0  0  0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following [link](https://visualgo.net/en/mst) provides a visual</span></span><br><span class="line"><span class="comment"> *representation of graphs that can be used to test/verify the algorithm for</span></span><br><span class="line"><span class="comment"> *different adj matrices and their weighted, connected graphs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>    <span class="comment">/// for assert()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span>  <span class="comment">/// for uint16_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>     <span class="comment">/// for IO operations</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>    <span class="comment">/// for string comparison</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Finds index of minimum element in edge list for an arbitrary vertex</span></span><br><span class="line"><span class="comment"> * @param arr graph row</span></span><br><span class="line"><span class="comment"> * @param N number of elements in arr</span></span><br><span class="line"><span class="comment"> * @returns index of minimum element in arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">minimum</span><span class="params">(<span class="keyword">uint16_t</span> arr[], <span class="keyword">uint16_t</span> N)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint16_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> min = INF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) {</span><br><span class="line">            min = arr[i];</span><br><span class="line">            index = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Used to find MST of user-generated adj matrix G</span></span><br><span class="line"><span class="comment"> * @returns void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">(<span class="keyword">uint16_t</span> G[][MAX], <span class="keyword">uint16_t</span> MST[][MAX], <span class="keyword">uint16_t</span> V)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint16_t</span> u, v;</span><br><span class="line">    <span class="keyword">uint16_t</span> E_t[MAX], path[MAX];</span><br><span class="line">    <span class="keyword">uint16_t</span> V_t[MAX], no_of_edges;</span><br><span class="line"></span><br><span class="line">    E_t[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// edges for current vertex</span></span><br><span class="line">    V_t[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// list of visited vertices</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i = <span class="number">1</span>; i &lt; V; i++) {</span><br><span class="line">        E_t[i] = G[i][<span class="number">0</span>];</span><br><span class="line">        path[i] = <span class="number">0</span>;</span><br><span class="line">        V_t[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    no_of_edges = V - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (no_of_edges &gt; <span class="number">0</span>) {</span><br><span class="line">        u = minimum(E_t, V);</span><br><span class="line">        <span class="keyword">while</span> (V_t[u] == <span class="number">1</span>) {</span><br><span class="line">            E_t[u] = INF;</span><br><span class="line">            u = minimum(E_t, V);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        v = path[u];</span><br><span class="line">        MST[v][u] = E_t[u];</span><br><span class="line">        MST[u][v] = E_t[u];</span><br><span class="line">        no_of_edges--;</span><br><span class="line">        V_t[u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i = <span class="number">1</span>; i &lt; V; i++) {</span><br><span class="line">            <span class="keyword">if</span> (V_t[i] == <span class="number">0</span> &amp;&amp; G[u][i] &lt; E_t[i]) {</span><br><span class="line">                E_t[i] = G[u][i];</span><br><span class="line">                path[i] = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Self-test implementations</span></span><br><span class="line"><span class="comment"> * @returns void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">uint16_t</span> G[][MAX], <span class="keyword">uint16_t</span> MST[][MAX], <span class="keyword">uint16_t</span> V)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint16_t</span> test[<span class="number">4</span>][<span class="number">4</span>] = {</span><br><span class="line">        {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}, {<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>}, {<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>}, {<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">0</span>}};</span><br><span class="line">    <span class="keyword">uint16_t</span> solution[<span class="number">4</span>][<span class="number">4</span>] = {</span><br><span class="line">        {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}, {<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>}, {<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>}, {<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line">    V = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i = <span class="number">0</span>; i &lt; V; ++i) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint16_t</span> j = <span class="number">0</span>; j &lt; V; ++j) {</span><br><span class="line">            G[i][j] = test[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    prim(&amp;(*G), &amp;(*MST), V);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i = <span class="number">0</span>; i &lt; V; ++i) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint16_t</span> j = <span class="number">0</span>; j &lt; V; ++j) {</span><br><span class="line">            assert(MST[i][j] == solution[i][j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Function user_graph();</span></span><br><span class="line"><span class="comment"> * gets user input adj. matrix and finds MST of that graph</span></span><br><span class="line"><span class="comment"> * @returns void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">user_graph</span><span class="params">(<span class="keyword">uint16_t</span> G[][MAX], <span class="keyword">uint16_t</span> MST[][MAX], <span class="keyword">uint16_t</span> V)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter the number of vertices: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">" %hd"</span>, &amp;V);</span><br><span class="line"></span><br><span class="line">    assert(V &lt;= MAX);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter the adj matrix\n"</span>);</span><br><span class="line">    <span class="keyword">uint16_t</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V; ++i) {</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; V; ++j) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"G[%d][%d]: "</span>, i, j);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %hd"</span>, &amp;G[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (G[i][j] == <span class="number">0</span>)</span><br><span class="line">                G[i][j] = INF;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    prim(&amp;(*G), &amp;(*MST), V);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"minimum spanning tree:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; V; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; V; ++j) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, MST[i][j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Main function</span></span><br><span class="line"><span class="comment"> * @param argc commandline argument count (ignored)</span></span><br><span class="line"><span class="comment"> * @param argv commandline array of arguments (ignored)</span></span><br><span class="line"><span class="comment"> * @returns 0 on exit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint16_t</span> G[MAX][MAX];    <span class="comment">///&lt; weighted, connected graph G</span></span><br><span class="line">    <span class="keyword">uint16_t</span> MST[MAX][MAX];  <span class="comment">///&lt; adj matrix to hold minimum spanning tree of G</span></span><br><span class="line">    <span class="keyword">uint16_t</span> V;              <span class="comment">///&lt; number of vertices in V in G</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-test"</span>) == <span class="number">0</span>) {</span><br><span class="line">        test(&amp;(*G), &amp;(*MST), V);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        user_graph(&amp;(*G), &amp;(*MST), V);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<h4 id="3-4-4-leetcode题目"><a href="#3-4-4-leetcode题目" class="headerlink" title="3.4.4 leetcode题目"></a>3.4.4 leetcode题目</h4><ul>
<li>柠檬水找零</li>
<li>分发饼干</li>
</ul>
<h3 id="3-5-动态规划"><a href="#3-5-动态规划" class="headerlink" title="3.5 动态规划"></a>3.5 动态规划</h3><p> 动态规划(<code>DP</code>):是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.常用于重叠子问题和最优子结构性质的问题,动态规划时间通常远小于朴素解法.</p>
<h4 id="3-5-1-基本概念"><a href="#3-5-1-基本概念" class="headerlink" title="3.5.1 基本概念"></a>3.5.1 基本概念</h4><p> 动态规划:要解一个给定问题,需要解其不同部分(即子问题),再根据子问题的解以得出原问题的解.通常子问题非常相似,子问题解算出后,将其记录.<br> 动态规划过程是:每次决策依赖于当前状态,又随即引起状态转移.一个决策序列就是在变化的状态中产生除留的,这种多阶段最优化决策解决过程称为动态规划.<br> 动态规划与分治法的区别是子问题通常不是独立的.</p>
<h4 id="3-5-2-描述算法"><a href="#3-5-2-描述算法" class="headerlink" title="3.5.2 描述算法"></a>3.5.2 描述算法</h4><p> 可采用动态规划的问题3个性质:<br> 1) <strong>最优化原理</strong>:如果问题的最优解所包含的子问题的解也是最优的,则称该问题具有最优子结构,即满足最优化原理.<br> 2) <strong>无后效性</strong>:即某阶段状态确定后,就不受之后的决策影响,即某状态以后过程不影响以前的状态,只与当前状态有关.<br> 3) <strong>有重叠子问题</strong>:</p>
<br>
 动态规划所处理的问题是一个多阶段决策问题,由初始状态开始,通过中间阶段决策的选择,达到结束状态.形成一个决策序列.

<p> 动态规划求解三要素:</p>
<blockquote>
<p>(1) 问题的节点<br>(2) 每个阶段的状态<br>(3) 从前一个阶段转化到后一个阶段之间的递推关系</p>
</blockquote>
<p> <strong>最优决策表</strong></p>
<blockquote>
<p>f(n, m) = max{f(n-1, m), f(n-1, m-w[n]) + P(n, m)}</p>
</blockquote>
<h4 id="3-5-3-背包问题"><a href="#3-5-3-背包问题" class="headerlink" title="3.5.3 背包问题"></a>3.5.3 背包问题</h4><p> 问题描述:<br> 有N件物品和一个体积为V的背包.(每种物品只有一件)第i件物品的体积是volume[i],价值是value[i],求解哪些物品装入背包可使这些物品的体积综合不超过背包体积,且价值总和最大.<br> 解题思路:<br> p[i][j]代表前i件物品组合在容量为j的背包的最优解.将前i件物品放入容量为v的背包中这个子问题,若只考虑第i件物品的策略(放或不放),那么可以转化为一个只牵扯前i-1物品的问题.如果不放第i件物品,那么问题就转化为”前i-1件物品放入容量为v的背包中,价值为p[i-1][v];如果放第i件物品,那么问题就转化为”前i-1物品放入剩下的容量为v-volume[i]的背包中”,此时能获得的最大价值就是p[i-1][j-volume]再加上通过放入第i件物品获得的价值value[i].</p>
<p> <strong>状态转移方程:</strong></p>
<blockquote>
<p>p[i][j] = max{p[i-1][j-vol] + value[i], p[i-1][j]}<br> 伪代码描述:</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1.</span>..N</span><br><span class="line">    <span class="keyword">for</span> j = V..<span class="number">.0</span></span><br><span class="line">        p[j] = max{p[j-volume[i]] + value[i], p[j]};</span><br></pre></td></tr></tbody></table></figure>


<details>
<summary>dp</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> v[]={<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>};</span><br><span class="line"><span class="keyword">int</span> w[]={<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>};</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(a&gt;=b){</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAns</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> wi)</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=i;x++) {</span><br><span class="line">		dp[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= wi; x++) {</span><br><span class="line">		dp[<span class="number">0</span>][x]=<span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= i; x++) {</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=wi;y++) {</span><br><span class="line">			<span class="keyword">if</span>(y&gt;=w[x<span class="number">-1</span>]) {</span><br><span class="line">				dp[x][y]=Max(dp[x<span class="number">-1</span>][y],v[x<span class="number">-1</span>]+dp[x<span class="number">-1</span>][y-w[x<span class="number">-1</span>]]);</span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				dp[x][y]=dp[x<span class="number">-1</span>][y];</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%4d"</span>,dp[x][y]);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> dp[i][wi];</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> max=getAns(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
</details>

<h4 id="3-5-4-最长公共子序列"><a href="#3-5-4-最长公共子序列" class="headerlink" title="3.5.4 最长公共子序列"></a>3.5.4 最长公共子序列</h4><p> 问题描述:<br> 一个散列S,如果分别是两个或多个已知数列的子序列,且是所有匹配此条件序列中最长的,则S称为已知序列的最长公共子序列(LCS)<br> 给定两个序列X,Y,求两个序列的最长公共子序列.<br> 解题思路:<br> 最长公共子序列问题存在最优子结构；这个问题可分解成更小，更简单的“子问题”，这个子问题可以分成更多的子问题，因此整个问题就变得简单了。<br> 最长公共子序列问题的子问题的解是可以重复使用的，即，更高级别的子问题通常会重用低级子问题的解。拥有这个两个属性的问题可以使用动态规划算法来解决，这样子问题的解就可以存储起来，而不用重复计算。这个过程需要在一个表中存储同一级别的子问题的解，因此这个解可被更高级的子问题使用。设有二维数组f[i][j]表示X的i位和Y的j位之前的最长公共子序列的长度，则有：</p>
<blockquote>
<p>f[1][1] = same(1,1)<br>f[i][j] = max{f[i-1][j-1] + same(i, j), f[i-1][j], f[i][j-1]}<br> 其中，<code>same(a,b)</code>当X的第a位与Y的第b位完全相同是”1”，否则位”1”。<br> 此时，f[i][j]中最大的数便是X和Y的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。<br> 该算法的空间、时间复杂度位O(n^2)，经过优化后，空间复杂度位O(n)。</p>
</blockquote>
<p> 伪代码:</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">LCSLength</span><span class="params">(X[<span class="number">1.</span>.m], Y[<span class="number">1.</span>.n])</span></span></span><br><span class="line"><span class="function">    C </span>= <span class="built_in">array</span>(<span class="number">0.</span>.m, <span class="number">0.</span>.n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0.</span>.m</span><br><span class="line">        C[i, <span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0.</span>.n</span><br><span class="line">        C[<span class="number">0</span>, j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1.</span>.m</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1.</span>.n</span><br><span class="line">            <span class="keyword">if</span> X[i] = Y[j]</span><br><span class="line">                C[i, j] := C[i<span class="number">-1</span>, j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i, j] := max(C[i, j<span class="number">-1</span>], C[i<span class="number">-1</span>,j])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C[m, n]</span><br></pre></td></tr></tbody></table></figure>

<details>
<summary>最长公共序列数</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> max=a;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;max){</span><br><span class="line">		max=b;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(c&gt;max){</span><br><span class="line">		max=c;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">char</span> s1[],<span class="keyword">char</span> s2[],<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++){       <span class="comment">//当 s2取 1个的时候 ,s1为可变长度 </span></span><br><span class="line">		<span class="keyword">if</span>(s1[i]==s2[<span class="number">0</span>]){</span><br><span class="line">			dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;m;j++){</span><br><span class="line">				dp[j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		} </span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){      <span class="comment">//当 s1取 1个的时候 ,s2为可变长度 </span></span><br><span class="line">		<span class="keyword">if</span>(s2[i]==s1[<span class="number">0</span>]){</span><br><span class="line">			dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++){</span><br><span class="line">				dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		} </span><br><span class="line">	} </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++){</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;n;j++){</span><br><span class="line">			<span class="keyword">if</span>(s1[i]==s2[j]){</span><br><span class="line">				dp[i][j]=Max(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>,dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				dp[i][j]=dp[i<span class="number">-1</span>][j]&gt;=dp[i][j<span class="number">-1</span>]?dp[i<span class="number">-1</span>][j]:dp[i][j<span class="number">-1</span>];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	} </span><br><span class="line">	<span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> m,n;</span><br><span class="line">	<span class="keyword">char</span> s1[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">char</span> s2[<span class="number">100</span>];</span><br><span class="line">	gets(s1);</span><br><span class="line">	gets(s2);</span><br><span class="line">	m=<span class="built_in">strlen</span>(s1);</span><br><span class="line">	n=<span class="built_in">strlen</span>(s2);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,getMax(s1,s2,m,n));</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>


<details>
<summary>Fibonacci_dp</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fibonacci Series using Dynamic Programming</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Author: Moinak Banerjee(moinak878)</span></span><br><span class="line"><span class="comment">   Date : 1 October ,2019</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Out of Range checking</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nNo Such term !\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// declaring array to store fibonacci numbers -- memoization</span></span><br><span class="line">    <span class="keyword">int</span> *f = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n + <span class="number">2</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  <span class="comment">//  one extra to handle edge case, n = 0</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let 0th and 1st number of the series be 0 and 1*/</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="comment">// Adding the previous 2 terms to make the 3rd term</span></span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> out = f[n];</span><br><span class="line">    <span class="built_in">free</span>(f);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Asks for the number/position of term in Fibonnacci sequence</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>) {</span><br><span class="line">        number = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter the value of n(n starts from 0 ): "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The nth term is : %d \n"</span>, fib(number));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<h4 id="3-5-5-leetcode题目"><a href="#3-5-5-leetcode题目" class="headerlink" title="3.5.5 leetcode题目"></a>3.5.5 leetcode题目</h4><ul>
<li>最大子序和</li>
<li>编辑距离</li>
<li>大礼包</li>
<li>最长上升子序列</li>
</ul>
<h3 id="3-6-回溯法"><a href="#3-6-回溯法" class="headerlink" title="3.6 回溯法"></a>3.6 回溯法</h3><h4 id="3-6-1-基本概念"><a href="#3-6-1-基本概念" class="headerlink" title="3.6.1 基本概念"></a>3.6.1 基本概念</h4><p> 回溯算法实际上一个类似枚举的搜索尝试过程,主要是在<strong>搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就”回溯”返回,尝试别的路径</strong>.<br> 回溯法是一种迭代搜索法,按选优条件详情搜索,以达到目标.但当探索到某一步时,发现原先选择并不优或达不到目标,就退回一步重新选择,这种走不通就退回再走的技术为回溯法,而满足回溯条件的某个状态的点称为”回溯法”.<br> 许多复杂度,规模较大的问题都看看而已使用回溯法,有”通用解题方法”的美称.</p>
<p> 在包含问题的所有解的解空间树中,按照深度优先的策略,从根节点出发深度探索解空间树.当探索到某一节点时,要先判断该节点是否包含问题的解,如果包含,就从该节点出发继续探索下去,如果该节点不包含问题的解,则逐层向其足协节点回溯.(其实回溯法就是堆隐式图的深度优先搜索算法).<br> 若用回溯法求问题的所有解时,要回溯的根,且根节点的所有可行的子树都要已被搜索遍才结束,而若使用回溯法求任一个解时,只要搜索到问题的一个解就可以结束.<br> 回溯法一般解题步骤:<br> 1.<strong>针对所给问题,确定问题的解空间</strong>;首先应明确定义问题的解空间,解空间应至少包含问题的一个(最优)解.<br> 2.<strong>确定节点的扩展搜索规则</strong><br> 3.<strong>以深度优先方式搜索解空间,并在搜索过程中用剪枝函数避免无效搜索</strong></p>
<p> 伪代码:</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iterativeBacktrack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (f(n, t) &lt;= g(n, t)) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = f(n,t); i &lt;= g(n,t); i++) {</span><br><span class="line">                x[t] = h(i);</span><br><span class="line">                <span class="keyword">if</span> (constraint(t) &amp;&amp; bound(t)) {</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span> (solution(t)) {</span><br><span class="line">                        output(x);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        t++;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    t--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-6-2-八皇后问题"><a href="#3-6-2-八皇后问题" class="headerlink" title="3.6.2 八皇后问题"></a>3.6.2 八皇后问题</h4><p> 问题描述<br> 八皇后问题使一个以国际象棋为背景的问题:如何能够在 8x8 的国际象棋棋盘上放着八个皇后,使得任何一个皇后都无法直接吃掉其他的皇后?为了达到此目的,任两个皇后都不能处于同一条横行,纵行或斜线上.<br> 转化规则:其实八皇后问题可以推广为更一般的n皇后摆放问题;这时棋盘大小变为nxn,而皇后个数也变成n.当且仅当n = 1 或 n &gt;= 4 时间问题有解。令一个一维数组a[n]保存所得解，其中a[i]表示把第i个皇后放在第i行的列数(注意i的值都是从0开始计算的),下面就八皇后问题的约束条件。<br>（1）因为所有的皇后都不能放在同一列，因为任意两个a[0]…a[7]的值不能存在相同的两个值<br>（2）所有的皇后都不能在堆角线上，那么该如何检测两个皇后是否在同一个对角线上？我们将棋盘的方格成一个二维数组，如下：<br> 假设有两个皇后被放置在(i,j)和(k,l)的位置上，明显，当且仅当|i-k|=|j-l|时，两个皇后才在同一条对角线上。</p>
<p> 伪代码描述</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queens</span><span class="params">(<span class="keyword">int</span> Queens)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, k, flag, not_finish = <span class="number">1</span>, count = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 正在处理的元素下标，表示前i-1个元素已符合要求，在处理第i个元素</span></span><br><span class="line">    <span class="keyword">int</span> a[Queeens+<span class="number">1</span>]; <span class="comment">// 八皇后问题的皇后所在的行列位置，从1开始算起，所以加1</span></span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 为数组的第一个元素赋初值</span></span><br><span class="line">    <span class="keyword">while</span> (not_finish) { <span class="comment">// not_finish=1 处理尚未结束</span></span><br><span class="line">        <span class="keyword">while</span>(not_finish &amp;&amp; i &lt;= Queens) { <span class="comment">// 处理尚未结束且还没处理到第Queeens个元素</span></span><br><span class="line">        <span class="keyword">for</span> (flag=<span class="number">1</span>, k=<span class="number">1</span>; flag &amp;&amp; k &lt; i; k++) {</span><br><span class="line">            <span class="comment">// 判断是否有多个皇后在同一行</span></span><br><span class="line">            <span class="keyword">if</span> (a[k] == a[i]) {</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 判断是否有多个皇后在同一个对角线</span></span><br><span class="line">        <span class="keyword">for</span> (k=<span class="number">1</span>; flag &amp;&amp; k &lt; i; k++) {</span><br><span class="line">            <span class="keyword">if</span> ((a[i] == a[k] - (k-i)) || (a]i] == a[k] + [k-i])) {</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-6-3-leetcode题目"><a href="#3-6-3-leetcode题目" class="headerlink" title="3.6.3 leetcode题目"></a>3.6.3 leetcode题目</h4><ul>
<li>N皇后</li>
<li>括号生成</li>
<li>单词搜索</li>
<li>解数独</li>
</ul>
<h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4 参考链接"></a>4 参考链接</h2><ul>
<li>复杂度速查表<br><a target="_blank" rel="noopener" href="https://liam.page/2016/06/20/big-O-cheat-sheet/">https://liam.page/2016/06/20/big-O-cheat-sheet/</a></li>
<li>线性表<br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8</a><ul>
<li>单链表<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/73f0d8f807aa">https://www.jianshu.com/p/73f0d8f807aa</a></li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://cocofe.cn/">http://cocofe.cn/</a></p>
<ul>
<li>数据结构<br><a target="_blank" rel="noopener" href="https://github.com/wangzheng0822/algo/">https://github.com/wangzheng0822/algo/</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/" rel="tag"># 实用教程</a>
              <a href="/tags/Another-Tag/" rel="tag"># Another Tag</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/27/2021/11/leetcode%E9%A2%98%E8%A7%A3%E7%AE%97%E6%B3%95/" rel="prev" title="leetcode题解算法分析">
      <i class="fa fa-chevron-left"></i> leetcode题解算法分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/27/%E4%B9%A6%E5%8D%95/" rel="next" title="书单&电影">
      书单&电影 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD"><span class="nav-text">1 程序性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">1.1 空间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">1.2 时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%A4%A7O"><span class="nav-text">1.2.1 常见算法大O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">1.2.2 常见数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%8F%82%E8%80%83%EF%BC%9A"><span class="nav-text">本章参考：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">2 基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">2.1 线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E6%95%B0%E7%BB%84"><span class="nav-text">2.1.1 数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">2.1.2 单链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-text">2.1.3 双链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-%E8%B7%B3%E8%A1%A8"><span class="nav-text">2.1.4 跳表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-5-%E6%A0%88"><span class="nav-text">2.1.5 栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-6-%E9%98%9F%E5%88%97"><span class="nav-text">2.1.6 队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-7-leetcode%E9%A2%98%E7%9B%AE"><span class="nav-text">2.1.7 leetcode题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">2.2 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1"><span class="nav-text">2.2.1 哈希函数设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="nav-text">2.2.2 哈希冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-uthash"><span class="nav-text">2.2.3 uthash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-leetcode%E9%A2%98%E7%9B%AE"><span class="nav-text">2.2.4 leetcode题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">2.3 树与二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">2.3.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-text">2.3.2 树的种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">2.3.3 二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91-BST"><span class="nav-text">2.3.4 二叉查找树(BST)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-text">2.3.5 平衡树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-6-%E5%A0%86%E6%A0%91%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-text">2.3.6 堆树和优先队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-7-leetcode%E9%A2%98%E7%9B%AE"><span class="nav-text">2.3.7 leetcode题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%9B%BE"><span class="nav-text">2.4 图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">2.4.1 基础知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E5%9B%BE%E8%A1%A8%E7%A4%BA"><span class="nav-text">2.4.2 图表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E5%9B%BE%E9%81%8D%E5%8E%86"><span class="nav-text">2.4.3 图遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">2.4.4 最短路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-5-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">2.4.5 拓扑排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-6-leetcode%E9%A2%98%E7%9B%AE"><span class="nav-text">2.4.6 leetcode题目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="nav-text">3 常见算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3"><span class="nav-text">3.1 递归思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3"><span class="nav-text">3.1.1 递归思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E9%80%92%E5%BD%92%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-text">3.1.2 递归基本步骤:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E4%BB%A3%E8%A1%A8%E9%A2%98%E7%9B%AE"><span class="nav-text">3.1.3 代表题目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-%E8%A7%A6%E7%B1%BB%E6%97%81%E9%80%9A"><span class="nav-text">3.1.4 触类旁通</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%88%86%E6%B2%BB%E6%B3%95"><span class="nav-text">3.2 分治法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">3.2.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E7%AD%96%E7%95%A5"><span class="nav-text">3.2.2 策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.2.3 应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E6%AD%A5%E9%AA%A4"><span class="nav-text">3.2.4 步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-%E5%BA%94%E7%94%A8"><span class="nav-text">3.2.5 应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-leetcode%E9%A2%98%E7%9B%AE"><span class="nav-text">3.2.6 leetcode题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">3.3 排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">3.3.1 冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">3.3.2 选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">3.3.3 插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">3.3.4 希尔排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">3.3.5 归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-6-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">3.3.6 快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-7-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">3.3.7 堆排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-8-leetcode%E6%8E%92%E5%BA%8F"><span class="nav-text">3.3.8 leetcode排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-text">3.4 贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">3.4.1 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E6%8F%8F%E8%BF%B0"><span class="nav-text">3.4.2 描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E5%BA%94%E7%94%A8"><span class="nav-text">3.4.3 应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-leetcode%E9%A2%98%E7%9B%AE"><span class="nav-text">3.4.4 leetcode题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">3.5 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">3.5.1 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-%E6%8F%8F%E8%BF%B0%E7%AE%97%E6%B3%95"><span class="nav-text">3.5.2 描述算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">3.5.3 背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">3.5.4 最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-5-leetcode%E9%A2%98%E7%9B%AE"><span class="nav-text">3.5.5 leetcode题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="nav-text">3.6 回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">3.6.1 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-text">3.6.2 八皇后问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-leetcode%E9%A2%98%E7%9B%AE"><span class="nav-text">3.6.3 leetcode题目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-text">4 参考链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">271k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:07</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
