<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true,"b2t":false,"scrollpercent":true},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="[toc] 深入理解计算机系统第1章 计算机系统">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解计算机系统">
<meta property="og:url" content="http://example.com/2022/02/27/2022/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="liuz">
<meta property="og:description" content="[toc] 深入理解计算机系统第1章 计算机系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608231046.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608231607.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232141.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232321.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232459.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232435.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232704.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232955.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220609225345.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220609233406.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220611014655.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613224202.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613224634.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613231258.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613231925.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613234132.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220614000119.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220614002405.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616003644.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616004340.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616005655.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616012142.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616013159.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616013902.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616014704.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616014723.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616014839.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617004032.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617005952.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617010845.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617012336.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621004444.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621004430.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003818.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003858.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003917.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003949.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621004527.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621225618.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220622221549.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220622235348.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629003932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629005430.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629010259.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629010749.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629010927.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629225753.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629230138.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629230242.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220701231510.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220701232932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708002734.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708003652.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708004108.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708004746.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220709000956.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711002750.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711003346.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711003746.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711004452.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711010245.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220712001432.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220712004654.png">
<meta property="article:published_time" content="2022-02-26T16:47:53.000Z">
<meta property="article:modified_time" content="2022-02-26T16:53:53.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="实用教程">
<meta property="article:tag" content="Another Tag">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608231046.png">

<link rel="canonical" href="http://example.com/2022/02/27/2022/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入理解计算机系统 | liuz</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="liuz" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liuz</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/27/2022/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuz">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解计算机系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 00:47:53 / 修改时间：00:53:53" itemprop="dateCreated datePublished" datetime="2022-02-27T00:47:53+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/2022/" itemprop="url" rel="index"><span itemprop="name">2022</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[toc]</p>
<h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="第1章-计算机系统"><a href="#第1章-计算机系统" class="headerlink" title="第1章 计算机系统"></a>第1章 计算机系统</h2><span id="more"></span>

<ol>
<li>hello world程序分析</li>
</ol>
<p>  hello.c编译</p>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608231046.png" alt="20220608231046"></p>
<p>  编译系统：预处理器cpp、编译器ccl、汇编器as和链接器ld</p>
<ol start="2">
<li><p>计算机系统硬件组成：总线，I/O设备，主存，处理器<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608231607.png" alt="20220608231607"></p>
</li>
<li><p>CPU 在指令的要求下执行操作：加载、存储、操作和跳转</p>
</li>
<li><p>hello程序加载<br>  从键盘上读取 hello 命令,从磁盘加载可执行文件到主存,将输出字符串从存储器写到显示器</p>
</li>
<li><p>高速缓存存储器cache：L1 L2 L3(SRAM)<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232141.png" alt="20220608232141"></p>
</li>
</ol>
<ol start="6">
<li>存储设备层次结构<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232321.png" alt="20220608232321"></li>
</ol>
<ol start="7">
<li>操作系统有两个基本功能：（1)防止硬件被失控的应用程序滥用；（2 )向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232459.png" alt="20220608232459"></li>
</ol>
<p>  操作系统通过几个基本的抽象概念：<strong>进程、虚拟内存和文件</strong><br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232435.png" alt="20220608232435"></p>
<p>  Posix 标准：Unix 系统调用的 C 语言接口、shell 程序和工具、线程及网络编程</p>
<p>  进程：操作系统对一个正在运行的程序的一种抽象，操作系统实现进程交错执行的机制称为上下文切换</p>
<p>  操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括 PC 和寄存器文件的当前值，以及主存的内容</p>
<p>  系统调用会将控制权传递给操作系统</p>
<p>  从一个进程到另一个进程的转换是由操作系统内核（kernel )管理的。内核是操作系统代码常驻主存的部分</p>
<p>  读写文件，执行一条系统调用（system call)指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序</p>
<p>  内核不是一个独立的进程。是系统管理全部进程所用代码和数据结构的集合</p>
<p>  线程：每个线程都运行在进程的上下文中，并共享同样的代码和全局数据</p>
<p>  虚拟内存<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232704.png" alt="20220608232704"></p>
<p>  程序代码和数据，堆，共享库，栈，内核虚拟内存，</p>
<p>  文件   I/O 设备是文件</p>
<ol start="8">
<li><p>系统之间网络通信</p>
</li>
<li><p>Amdahl定律</p>
</li>
</ol>
<p>  对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度</p>
<ol start="10">
<li>并发和并行</li>
</ol>
<p> 三个层次：</p>
<ul>
<li>线程级并发</li>
<li>指令级并行</li>
<li>单指令、多数据并行</li>
</ul>
<ol start="11">
<li>计算机系统中抽象<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220608232955.png" alt="20220608232955"></li>
</ol>
<br>



<h1 id="程序结构和执行"><a href="#程序结构和执行" class="headerlink" title="程序结构和执行"></a>程序结构和执行</h1><p>  处理器和存储子系统，基本数据结构，指令操作，编译器翻译</p>
<h2 id="第2章-信息的表示和处理"><a href="#第2章-信息的表示和处理" class="headerlink" title="第2章 信息的表示和处理"></a>第2章 信息的表示和处理</h2><h3 id="2-1-信息表示"><a href="#2-1-信息表示" class="headerlink" title="2.1 信息表示"></a>2.1 信息表示</h3><ol>
<li><p>十六进制<br>x是2的非负整数n次幂时，x=2”，我们可以很容易地将 x 写成十六进制形式，只要记住 X 的二进制表示就是1后面跟n个0， 2^9 = 512   0x200</p>
</li>
<li><p>字节序<br>  低有效字节在最前面的方式，称为小端法<br>  最高有效字节在最前面的方式，称为大端法<br>  x01234567 大端01 23 45 67 小端 67 45 23 01</p>
</li>
<li><p>位运算与逻辑运算<br>  位运算&amp;与 |或 ~非 异或<br>  逻辑运算：&amp;&amp;与  ||或  !非<br>无符号，补码，浮点数</p>
</li>
<li><p>移位运算<br>  算数右移和逻辑右移</p>
</li>
</ol>
<h3 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h3><p>  有符号数和无符号数<br>  补码计算公式<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220609225345.png"><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220609225345.png" alt="20220609225345"></a><br>  C 库中的文件&lt;limits.h&gt;定义了一组常量，来限定编译器运行的这台机器的不同整型数据类型的取值范围。常量 INT_MAX、INT_MIN 和UINT_MAX,<br>  stdint.h 中uintl6_t，int32_t定义指定位数类型。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT.MIN (-INT_MAX 1)</span></span><br></pre></td></tr></tbody></table></figure>


<h3 id="2-3-整数运算"><a href="#2-3-整数运算" class="headerlink" title="2.3 整数运算"></a>2.3 整数运算</h3><p>计算机执行的 “整数” 运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出</p>
<h3 id="2-4-浮点数"><a href="#2-4-浮点数" class="headerlink" title="2.4 浮点数"></a>2.4 浮点数</h3><p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220609233406.png" alt="20220609233406"></p>
<p>浮点表示通过将数字编码为: x*2〃的形式来近似地表示实数</p>
<br>

<h2 id="第3章-程序的机器级表示"><a href="#第3章-程序的机器级表示" class="headerlink" title="第3章 程序的机器级表示"></a>第3章 程序的机器级表示</h2><p> 计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、 读写存储设备上的数据，以及利用网络通信 </p>
<h3 id="3-1-机器码"><a href="#3-1-机器码" class="headerlink" title="3.1 机器码"></a>3.1 机器码</h3><ol>
<li>指令集体系结构或指令集架构(Instruction Set Architecture,ISA)定义机器级程序的格式和行为，定义了处理器状态、指令的格式，已经每条指令对状态的影响。</li>
</ol>
<p> 机器级程序使用的内存地址是虚拟地址，内存模型看做一个大字节数组。</p>
<p> 处理器状态：</p>
<ul>
<li>程序计数器(PC x86-64中%rip)给出将要执行的下一条指令在内存中的地址</li>
<li>整数寄存器文件包含16个命名的位置,分别存储64位的值.</li>
<li>条件码寄存器保存着最近执行的算数或逻辑指令的状态信息.</li>
<li>一组向量寄存器可存放一个或多个整数或浮点数值.</li>
</ul>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -S 产生汇编代码 生成 .s 文件</span></span><br><span class="line">gcc -Og -S mstore.c</span><br><span class="line"><span class="comment"># -c 编译并汇编  产生 .o 文件</span></span><br><span class="line">gcc -Og -c mstore.c</span><br><span class="line"><span class="comment"># 反汇编 </span></span><br><span class="line">objdump -d mstore.o</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p> x86-64指令长度从1到15字节不等.<br> 反汇编器基于机器代码文件中的字节序列确定汇编代码<br> 汇编代码中以 以.开头的行都是指导汇编器和链接器工作的伪指令<br> C语言中插入汇编代码:1)独立汇编文件,用汇编器和链接器把它和C语言代码合并.2)使用GCC的内联汇编特性,用asm伪指令在C程序中包含汇编代码<br> 数据传送指令四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)和movq(传送四字)</p>
<h3 id="3-2-处理器访问"><a href="#3-2-处理器访问" class="headerlink" title="3.2 处理器访问"></a>3.2 处理器访问</h3><p> x86-64的中央处理器(CPU)包含一组16个存储64位值的通用目的寄存器。%r开头，%rax-%rbp<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220611014655.png" alt="20220611014655"></p>
<p> 栈指针%rsp，用来指明运行时栈的结束位置</p>
<p> 复制和生成 1 字节、2 字节、4 字节和 8 字节值。当这些指令以寄存器作为目标时，对于生成小于 8 字节结果的指令，寄存器中剩下的字节会怎么样，有两条规则：生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；生成 4 字节数字的指令会把高位 4 个字节置为 0。</p>
<h4 id="3-2-1-指令操作和类型"><a href="#3-2-1-指令操作和类型" class="headerlink" title="3.2.1 指令操作和类型"></a>3.2.1 指令操作和类型</h4><p> 指令操作数：指令操作使用的源数据值，以及放置结果的目的位置。操作数三种类型：立即数(immediate)、寄存器(register)和内存引用。</p>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613224202.png" alt="20220613224202"></p>
<p> <strong>数据传送指令</strong></p>
<ul>
<li>MOV类：movb，movw，movl和movq<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613224634.png" alt="20220613224634"></li>
</ul>
<p>  源操作数类型：立即数，寄存器值和内存中的值，目的操作数：指定位置，寄存器，内存地址，x86-64中源操作数和目的操作数不能同为内存地址。</p>
<ul>
<li>MOVZ类指令把目的中剩余资金填充位0</li>
<li>MOVS类指令通过符号扩展来填充，把源操作数高位进行复制。</li>
<li>cltq指令：总以寄存器%eax作为源，%rax作为符号扩展结果的目的</li>
</ul>
<p>*指针简介引用，&amp;取址</p>
<h4 id="3-2-2-压入和弹出栈数据"><a href="#3-2-2-压入和弹出栈数据" class="headerlink" title="3.2.2 压入和弹出栈数据"></a>3.2.2 压入和弹出栈数据</h4><p> pushq操作把数据压入栈中，popq指令弹出数据；栈向下增长，栈顶元素在低地址，栈指针%rsp保存栈顶元素地址。<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613231258.png" alt="20220613231258"></p>
<h3 id="3-3-算术和逻辑操作"><a href="#3-3-算术和逻辑操作" class="headerlink" title="3.3 算术和逻辑操作"></a>3.3 算术和逻辑操作</h3><p> 加法指令ADD类：addb、addw、addl和addq<br> 四组操作：加载有效地址、一元操作、二元操作和移位<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613231925.png" alt="20220613231925"></p>
<p> leaq 将有效地址写入到目的操作数。<br> 一元操作：只有一个操作数，即是源又是目的。<br> 二元操作：第二个操作数既是源又是目的。<br> 移位操作：先给出移位量，然后第二项给出的是要移位的数。算术和逻辑右移。移位量是个立即数，或者但自己寄存器%c1中。左移：SAL和SHL；右移：SAR和SHR</p>
<p> 特殊算数操作<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220613234132.png" alt="20220613234132"></p>
<h3 id="3-4-控制指令"><a href="#3-4-控制指令" class="headerlink" title="3.4 控制指令"></a>3.4 控制指令</h3><p> 两种基本条件行为：测试数据值，然后根据曹氏结果来改变控制流或数据流。</p>
<h4 id="3-4-1-条件码-condition-code-寄存器"><a href="#3-4-1-条件码-condition-code-寄存器" class="headerlink" title="3.4.1 条件码(condition code)寄存器"></a>3.4.1 条件码(condition code)寄存器</h4><ul>
<li>CF：进位标志</li>
<li>ZF：零标志</li>
<li>SF：符号标志</li>
<li>OF：溢出标志</li>
</ul>
<p> 两类设置条件码指令：</p>
<ul>
<li>CMP指令：根据两个操作数之差来设置条件码</li>
<li>TEST指令：与AND(&amp;)指令一样，但仅设置条件码</li>
</ul>
<p> 访问条件码：1)条件码的某种组合SET指令 2)条件跳转 3)条件传送数据</p>
<p> 跳转指令jump</p>
<ul>
<li>jmp无条件跳转指令：直接跳转和间接跳转<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用寄存器%rax中的值作为跳转目标</span></span><br><span class="line">jmp *%rax</span><br><span class="line"><span class="comment"># 以%rax中的值作为读地址，从内存中读取跳转目标</span></span><br><span class="line">jmp *(%rax)</span><br></pre></td></tr></tbody></table></figure>
<img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220614000119.png" alt="20220614000119"></li>
</ul>
<p> 当执行 PC 相对寻址时，程序计数器的值是跳转指令后面的那条指令<br>的地址，而不是跳转指令本身的地址</p>
<p> 为什么基于条件数据传送(条件赋值)的代码会比基于条件控制转移的代码性能要好？</p>
<ul>
<li>分支预测是条件表达式50%的正确率，x86-64分支预测错误惩罚19个时钟周期。</li>
<li>无论测试数据是什么，编译出使用条件传送代码所需的时间8个时钟周期。控制流不依赖于数据，处理器更容易保持流水线是满的。</li>
</ul>
<p> 条件传送指令<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220614002405.png" alt="20220614002405"></p>
<h4 id="3-4-2-循环"><a href="#3-4-2-循环" class="headerlink" title="3.4.2 循环"></a>3.4.2 循环</h4><p> 条件测试和跳转组合实现循环</p>
<ul>
<li><p>do-while循环</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">    bogy-statement</span><br><span class="line">    t = text-expr;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        goto loop</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>while 循环</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">goto <span class="built_in">test</span>;</span><br><span class="line">loop: </span><br><span class="line">    body-statement</span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    t = text-expr;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        goto loop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = text-expr</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">    got <span class="keyword">done</span>;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    body-statement</span><br><span class="line">    <span class="keyword">while</span>(test-expr);</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>for循环</p>
</li>
</ul>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">got <span class="built_in">test</span>;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    update-expr;</span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    t = test-expr;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        goto loop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init-expr;</span><br><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">    goto <span class="keyword">done</span>;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    update-epxr;</span><br><span class="line">    t = test-expr;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        goto loop;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<h4 id="3-4-2-switch语句"><a href="#3-4-2-switch语句" class="headerlink" title="3.4.2 switch语句"></a>3.4.2 switch语句</h4><p> switch(开关)语句可以根据一个整数索引值进行多重分支（multiway branching)。使用跳转表(jump table)数据结构使得实现更加高效,跳转表是一个数组，表项i是一个代码段的地址。和使用一组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关<br>  .rodata（只读数据，Read-Only Data)的目标代码文件的<br>段中</p>
<h3 id="3-5-过程"><a href="#3-5-过程" class="headerlink" title="3.5 过程"></a>3.5 过程</h3><p> 过程：函数，方法，子例程，处理函数。<br> 过程切换：传递控制，传递数据，分配和释放内存</p>
<ul>
<li>运行时栈<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616003644.png" alt="20220616003644"></li>
</ul>
<p> 栈向低地址方向增长，栈指针%rsp指向栈顶元素。pushq和popq指令将数据压栈和出栈。运行栈划分成栈帧，被调函数返回地址属于调用函数栈帧。</p>
<ul>
<li><p>转移控制<br> 将程序计数器(PC)设置为转移目的代码起始位置。<br> call Q调用过程<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616004340.png" alt="20220616004340"><br> call指令，指明被调用过程起始的指令地址,直接调用的目标是标号,间接调用的目标是*后面跟一个操作数指示符.call将返回地址压入栈中,并跳转到函数的第一条指令.</p>
</li>
<li><p>数据传送<br> 大部分数据传送通过寄存器实现,返回值通过%rax寄存器.<br> x86-64中通过寄存器最多传递6个整型参数,超出部分通过栈传递,栈顶数据大小都向8的倍数对齐。ARMv8通过寄存器最多可传递8个参数。<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616005655.png" alt="20220616005655"></p>
</li>
</ul>
<p> 栈上局部存储：超出寄存器数量，局部变量地址&amp;，局部变量数组或结构<br> 寄存器中的局部存储空间：寄存器组，寄存器%rbx、%rbp和%r12-%r15为被调用者保存寄存器。被调用这必须保存这些寄存器值，不改变值或入栈返回前恢复。其他寄存器由调用者保存。<br> 每次函数调用由字节私有的状态信息（保存的返回值位置和被调用这保存寄存器的值）存储空间。<br> 递归过程与普通调用一致</p>
<h3 id="3-6-数组分配与访问"><a href="#3-6-数组分配与访问" class="headerlink" title="3.6 数组分配与访问"></a>3.6 数组分配与访问</h3><p> 数组声明：T A[N]<br> x86-64内存引用指令可简化数组访问</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># E[i] E地址在寄存器%rdx中，i值在寄存器%rcx中  x + 4i</span></span><br><span class="line">movl (%rdx, %rcx, 4), %eax</span><br></pre></td></tr></tbody></table></figure>

<p> 指针运算<br> 单操作符&amp;和*可产生指针和间接引用指针<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616012142.png" alt="20220616012142"><br> 嵌套数组(多维数组)<br> 定长数组 #define N 1<br> 变长数组 malloc</p>
<h3 id="3-7-结构struct和联合union"><a href="#3-7-结构struct和联合union" class="headerlink" title="3.7 结构struct和联合union"></a>3.7 结构struct和联合union</h3><ul>
<li><p>struct<br> 指向结构的指针就是结构第一个字节的地址,结构信息每个字段（field)的字节偏移</p>
</li>
<li><p>union<br> 联合能够规避c语言的类型系统，允许以多种类型引用一个对象</p>
</li>
</ul>
<ul>
<li>数据对齐<br> x86-64数据类型对齐<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616013159.png" alt="20220616013159"><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保证起始地址是8的倍数</span></span><br><span class="line">.align 8 </span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="3-8机器级程序中控制和数据结合"><a href="#3-8机器级程序中控制和数据结合" class="headerlink" title="3.8机器级程序中控制和数据结合"></a>3.8机器级程序中控制和数据结合</h3><ul>
<li><p>指针<br> 指针类型，指针值，指针创建&amp;，指针间接引用*，数组与指针，指针强制类型转换，函数指针(*f)()</p>
</li>
<li><p>GDB</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb prog</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616013902.png" alt="20220616013902"></p>
</li>
<li><p>内存越界引用和缓冲区溢出<br> 数组越界访问<br> 字符串长度超过分配的数组空间</p>
</li>
</ul>
<p> 防止缓冲区溢出：栈随机化，栈破坏检测，限制可执行代码区域，变长栈帧</p>
<h3 id="3-9-浮点代码"><a href="#3-9-浮点代码" class="headerlink" title="3.9 浮点代码"></a>3.9 浮点代码</h3><p> MMX-SSE-SSE2-AVX-AVX2<br> AVX浮点体系16个YMM寄存器%ymm0-%ymm15,256bit(32字节)<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616014704.png" alt="20220616014704"></p>
<p> 浮点传送和转换<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616014723.png" alt="20220616014723"></p>
<p> 浮点运算<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220616014839.png" alt="20220616014839"></p>
<br>

<p>x86-64 机器代码<br>控制结构（比如条件、循环和开关语句）生成的基本指令模式<br>括栈分配、寄存器使用惯例和参数传递<br>数据结构（如结构、联合和数组）的分配和访问方式<br>整数和浮点数算术运算的指令<br>代码安全漏洞（例如缓冲区溢出）</p>
<br>

<h2 id="第4章-处理器体系结构"><a href="#第4章-处理器体系结构" class="headerlink" title="第4章 处理器体系结构"></a>第4章 处理器体系结构</h2><p> 处理器支持的指令和指令的字节级编码称为指令集体系结构(Instruction-Set Architecture ISA)<br> HCL(Hardware Control Language硬件控制语言)</p>
<h3 id="4-1-Y86-64指令集"><a href="#4-1-Y86-64指令集" class="headerlink" title="4.1 Y86-64指令集"></a>4.1 Y86-64指令集</h3><p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617004032.png" alt="20220617004032"></p>
<p>Y86-64 指令</p>
<ul>
<li>movq指令分成4中：irmovq,rrmovq,mrmovq和rmmovq;i立即数，r寄存器，m内存</li>
<li>整数操作指令4个：addq,subq,andq和xorq;可设置条件吗ZF(零)，SF(符号)和OF(溢出)</li>
<li>跳转指令7条：jmp、 jle、 jl、 je、 jne、 jge 和 jg</li>
<li>6个条件传送指令: cmovle、cmovl、cmove、 cmovne、<br>cmovge 和 cmovg。</li>
<li>call 指令将返回地址入栈，然后跳到目的地址。ret 指令从这样的调用中返回</li>
<li>pushq 和 popq 指令实现了人栈和出栈</li>
<li> halt 指令停止指令的执行</li>
</ul>
<p> CISC(复杂指令集)和RISC(精简指令集)<br> RISC寻址方式简单:机制和便宜了寻址，只能对寄存器操作数进行算数和逻辑运算，内存引用仅有load和store</p>
<p> 状态码Stat，程序执行的总体状态<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617005952.png" alt="20220617005952"></p>
<p>以.开头的词是汇编器伪指令（assembler directives)，它们告诉汇<br>编器调整地址，以便在那儿产生代码或插人一些数据。</p>
<p>push %rsp指令行为：1)压人％rsp 的原始值，2)压人减去 8 的红印的值</p>
<h3 id="4-2-逻辑设计和硬件控制语言HCL"><a href="#4-2-逻辑设计和硬件控制语言HCL" class="headerlink" title="4.2 逻辑设计和硬件控制语言HCL"></a>4.2 逻辑设计和硬件控制语言HCL</h3><ul>
<li>逻辑门 与 或 非</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617010845.png" alt="20220617010845"></p>
<p>逻辑门组成组合电路</p>
<p>存储器和时钟<br> 两类存储设备：时钟寄存器(寄存器)和随记访问存储器(内存)<br> 处理器随机访问存储器来存储程序数据<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220617012336.png" alt="20220617012336"></p>
<p>SEQ(“se-quential” 顺序的）的处理器</p>
<p>操作阶段：</p>
<ul>
<li>取值fetch:从内存读取指令字节，地址为程序计数器（PC)的值,从指令中取出指令指示符字节的两个四位部分，称为 icode(指令代码）和 ifun(指令功能）。</li>
<li>译码decode: 译码阶段从寄存器文件读人最多两个操作数</li>
<li>执行execute: 执行阶段，算术/逻辑单元（ALU)要么执行指令指明的操作（根据 ifun 的值），计算内存引用的有效地址，要么增加或减少栈指针</li>
<li>访存memory: 访存阶段可以将数据写人内存，或者从内存读出数据</li>
<li>写回: 最多可以写两个结果到寄存器文件</li>
<li>更新PC: 将 PC 设置成下一条指令的地址。</li>
</ul>
<p>SEQ引进结构</p>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621004444.png" alt="20220621004444"></p>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621004430.png" alt="20220621004430"></p>
<p>控制处理器中活动的时序原则：从不回读，</p>
<p>取指阶段<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003818.png" alt="20220621003818"></p>
<p>译码和写回阶段<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003858.png" alt="20220621003858"></p>
<p>执行阶段<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003917.png" alt="20220621003917"></p>
<p>访存阶段<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003932.png" alt="20220621003932"></p>
<p>更新PC阶段<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621003949.png" alt="20220621003949"></p>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>吞吐量：每秒千兆条指令（GIPS)</p>
<p>各个阶段之间放上流水线寄存器（pipeline register)<br>现代处理器采用了很深的(15 或更多的阶段)流水线</p>
<p>带反馈流水线系统<br>指令执行顺序相关：</p>
<ul>
<li>数据相关</li>
<li>控制相关</li>
</ul>
<p>SEQ+<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621004527.png" alt="20220621004527"></p>
<p>PIPE<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220621225618.png" alt="20220621225618"></p>
<p>预测下一个 PC</p>
<p>猜测分支方向并根据猜测开始取指的技术称为分支预测，预测 PC 的新值为 valG</p>
<p>流水线冒险<br>相关有两种形式：1)数据相关，下一条指令会用到这一条指令计算出的结果；2)控制相关，一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时<br>冒险也可以分为两类：数据冒险（data hazard)和控制冒险(control hazard)</p>
<p>对于Y86-64 来说，程序状态包括程序寄存器、程序计数器、内存、条件码寄存器和状态寄存器</p>
<p>异常处理<br>Y86-64 包括三种不同的内部产生的异常：l)halt 指令，2)有非法指令和功能码组合的指令，3)取指或数据读写试图访问一个非法地址<br>导致异常的指令称为异常指令（excepting instruction)</p>
<p>PIPE 各阶段的实现<br>PC 选择和取指阶段<br>译码和写回阶段<br>执行阶段<br>访存阶段</p>
<p>CPI(Cycles Per Instruction, 每指令周期数）</p>
<br>
第四章流水部分还需要继续阅读

<p>基本的组合和时序逻辑元素<br>流水线<br>五阶段处理器流水线</p>
<br>

<h2 id="第5章-优化程序性能"><a href="#第5章-优化程序性能" class="headerlink" title="第5章 优化程序性能"></a>第5章 优化程序性能</h2><p> 高性能程序：1)数据结构与算法选择 2)编译器能够优化 3)计算分解，并行化</p>
<h3 id="5-1-优化编译器"><a href="#5-1-优化编译器" class="headerlink" title="5.1 优化编译器"></a>5.1 优化编译器</h3><p> GCC 编译选项 -Og -O1 -O2 -O3<br> 两个指针可能指向同一个内存位置的情况称为内存别 名使用（memory aliasing)<br> 包含函数调用的代码可以用一个称为 内联函数替换（inline substitution, 或 者简称”内联（inlining)”）的过程进行优化</p>
<p> 程序性能表示 CPE每元素的周期数（Cycles Per Element, CPE)</p>
<p> 消除循环的低效率:循环条件判断中使用数值，而不是表达式<br> 减少过程调用：将调用移出循环<br> 消除不必要的内存引用：把中间结果存在临时变量中，最后在赋给引用地址</p>
<h3 id="5-2-现代处理器"><a href="#5-2-现代处理器" class="headerlink" title="5.2 现代处理器"></a>5.2 现代处理器</h3><p>指令并行<br>两种下界描述了程序的最大性能:延迟界限(latency bound)和吞吐量界限(throughpu bound)<br> 超标量：每个时钟周期执行多个操作<br> 乱序：指令的顺序不一定与机器级程序中的顺序一致<br> 处理器设计两个主要部分：指令控制单元(ICU)和执行单元(EU)<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220622221549.png" alt="20220622221549"></p>
<p> 分支预测(branch prediction):处理器会猜测是否选择分支，还预测分支的目的地址<br> 投机执行（speculative execution)冒险？ 处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码<br> Intel Core i7 Haswell 有 8 个功能单元:<br> 0 整数运算、浮点乘、整数和浮点数除法、分支<br> 1 整数运算、浮点加、整数乘、浮点乘<br> 2 加载、地址计算<br> 3 加载、地址计算<br> 4 存储<br> 5 整数运算<br> 6 整数运算、分支<br> 7 存储、地址计算</p>
<p>任何对程序寄存器的更新都只会在指令退役时才会发生<br>控制操作数在执行单元间传送的最常见的机制称为寄存器重命名（register renaming)：值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来，<br>重命名表只包含关于有未进行写操作的寄存器条目。</p>
<p> 运算性能：</p>
<ul>
<li>延迟：完成运算所需总时间</li>
<li>发射时间：两个联系同类型运算直接最小时间周期数</li>
<li>容量：能够执行该元素的功能单元的数量</li>
</ul>
<p>数据流(data-flow)，关键路径(critical path)</p>
<p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。编译器GCC优化等级-O3</p>
<h3 id="5-3-提高并行性"><a href="#5-3-提高并行性" class="headerlink" title="5.3 提高并行性"></a>5.3 提高并行性</h3><p>对于一个可结合和可交换的合并运算来说，比如说整数加法或乘法，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能<br>浮点乘法和加法不是可结合的</p>
<p>重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能力得到更好的性能。</p>
<p>极大化对向量元素加或者乘的函数性能</p>
<p>制约程序性能的一些限制因素：寄存器溢出，并行度p超过寄存器数量；分支预测和预测错误处罚</p>
<h3 id="5-4-内存性能"><a href="#5-4-内存性能" class="headerlink" title="5.4 内存性能"></a>5.4 内存性能</h3><p>加载的性能：对两个加载单元而言，其每个时钟周期只能启动一条加载操作，所以 CPE 不可能小于 0.50<br>存储的性能：每个周期开始一条新的存储</p>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220622235348.png" alt="20220622235348"></p>
<h3 id="5-5-性能提高技术"><a href="#5-5-性能提高技术" class="headerlink" title="5.5 性能提高技术"></a>5.5 性能提高技术</h3><p>1）高级设计：为问题选择适当的算法和数据结构<br>2）编码原则：消除连续的函数调用；消除不必要的内存引用<br>3）低级优化：展开循环；使用多个累积变量和重新结合等，提高指令并行；功能性的风格重写条件操作</p>
<p>基准数据（benchmark data}<br>Unix 系统提供了一个剖析程序 GPROF<br>Linux 系统上 VALGRIND�<br>循环展开、创建多个累积变量和重新结合，它们可以利用现代处理器<br>提供的指令级并行<br><br></p>
<p>减少程序需要做的工作的变换<br>指令级并行度的变换<br>现代乱序处理器是如何工作的</p>
<br>


<h2 id="第6章-存储器层次结构"><a href="#第6章-存储器层次结构" class="headerlink" title="第6章 存储器层次结构"></a>第6章 存储器层次结构</h2><p>存储器层次结构<br>局部性（locality)<br>存储技术棗 SRAM 存储器、DRAM 存储器、ROM 存储器以及旋转的和固态的硬盘</p>
<h3 id="6-1-随机访问存储器"><a href="#6-1-随机访问存储器" class="headerlink" title="6.1 随机访问存储器"></a>6.1 随机访问存储器</h3><p> 随机访问存储器（Random-Access Memory, RAM)分为两类：静态的和动态的。静态AM(SRAM)比动态 RAM(DRAM)更快，SRAM 用来作为高速缓存存储器，可在CPU芯片上，也可在片下。<br> SRAM每个位存储在一个双稳态的（bistable)存储器单元<br> DRAM 将每个位存储为对一个电容的充电<br> 行地址i称为 RAS(Row Access Strobe, 行访问选通脉冲）请求。列地址j称为 CAS(Cÿlumn Access Strobe, 列访问选通脉冲）请求。注意，RAS 和 CAS 请求共享相同的 DRAM 地址引脚<br> 双倍数据速率同步 DRAM(Double Data-Rate Synchronous DRAM, DDR SDRAM)<br> SRAM和DRAM都是易失的,ROM非易失的<br> 只读存储器（Read-Only Memory, ROM)<br> 可擦写 可编程 ROM(Erasable Programmable ROM, EPROM)<br> 闪存（flash memory)是一类非易失性存储器，基于 EEPROM</p>
<p> 总线事务(bus transaction)。读事务（read transaction)从主存传送数据到CPU写事务（write transaction)从CPU传送数据到主存。<br> 地址、数据和控制总线</p>
<p> IO总线：PCI、PCIE、USB</p>
<p> CPU 使用一种称为内存映射 I/O(memory-mapped I/O)的技术来向 I/O 设备发射命令。内存映射 I/O 的系统中，地址空间中有一块地址是为与 I/O 设备通信保留的。每个这样的地址称为一个 I/O 端口（I/O port)，当一个设备连接到总线时，它与一个或多个端口相关联(或它被映射到一个或多个端口）<br> 直接内存访问(Direct Memory Access DMA)</p>
<p> 固态硬盘<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629003932.png" alt="20220629003932"><br> 读SSD比写要快</p>
<h3 id="6-2-局部性"><a href="#6-2-局部性" class="headerlink" title="6.2 局部性"></a>6.2 局部性</h3><p> 局部性原理（principle of locality)：倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身<br> 时间局部性（temporal locality) 和空间局部性（spatial<br>locality)<br> 时间局部性的程序中，被引用过一次的内存位置很可能在不远<br>的将来再被多次引用<br> 空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置<br> 数据引用的局部性，取指令的局部性<br> 局部性原则：重复引用相同变量；步长为々的引用模式的程序，步长越小，空间局部性越好；取指令来说，循环有好的时间和空间局部性</p>
<h3 id="6-3-存储层次结构"><a href="#6-3-存储层次结构" class="headerlink" title="6.3 存储层次结构"></a>6.3 存储层次结构</h3><p>存储器层次结构<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629005430.png" alt="20220629005430"></p>
<p> 高速缓存cache<br>存储器被划分成连续的数据对象组块（chunk), 称为块（block)。<br>数据总是以块大小为传送单元（transfer unit)在第k层和第;k+1 层之间来回复制的<br>缓存命中和缓存不命中(cache miss)<br>替换策略：最近最少被使用（LRU)替换策略的缓存会选择那个最后被访问的时间距现在最远的块<br>缓存不命中的种类</p>
<ul>
<li>强制性不命中（compulsory miss)或冷不命中（cold miss)：空的缓存有时被称为冷缓存（cold cache)</li>
<li>冲突不命中（conflict miss)：限制性的放置策略会引起一种不命中</li>
<li>容量不命中（capacity miss)：工作集的大小超过缓存的大小<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629010259.png" alt="20220629010259"></li>
</ul>
<p>高速缓存被组织成一个有 S=2^s个高速缓存组（cache set)的数组。每个组包含 £个高速缓存行（cache line)， 每个行是由一个 B =2^b 字节的数据块(block)组成的，一个有效位（valid bit)指明这个行是否包含有意义的信息，还有 t=m-(b+s)个标记位（tag bit)(是当前块的内存地址的位的一个子集》s 它们唯一地标识存储在<br>这个高速缓存行中的块。<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629010749.png" alt="20220629010749"><br>高速缓存的结构可以用元组（S,E,B,m)来描述</p>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629010927.png" alt="20220629010927"></p>
<p> 高速缓存请求名字，抽取被请求子过程：1)组选择 2)行匹配 3)字抽取</p>
<p> 组相联高速缓存： 1&lt;E&lt;C/B 称为E路组相联高速缓存<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629225753.png" alt="20220629225753"><br>组相连替换最不常使用(Least-Frequently-Used,LFU)策略会替换在过去某个时间窗口内引用次数最少的那一行。最近最 少使用(Least-Recently-Used LRU)策略会替换最后一次访问时间最久远的那一行。</p>
<p> 全相联高速缓存： 包含所有高速缓存行的组（即 E=C/B)组成<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629230138.png" alt="20220629230138"></p>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220629230242.png" alt="20220629230242"></p>
<p>写的问题：直写，写回，写分配<br>i-cache和d-cache<br>高速缓存性能指标：不命中率(miss rate)，命中率(hit rate)，命中时间(hit time)，不命中出发(miss penalty)<br>块：固定大小，cache与主存之间传送<br>行：cache的一个存储单元？<br>组：一个或者多个含的集合<br>编写高速缓存友好代码：对局部变量反复引用；步长为1的引用模式</p>
<p>高速缓存与程序性能一个程序从存储系统中读数据的速率称为读呑吐量(read throughput) 或者有时称为读带宽(read bandwidth)<br>利用时间局部性，使得频繁使用的字从 L1 中取出，还要利用空.间局部性，使得尽可能多的字从一个L1 高速缓存行中访问到</p>
<p>存储器层次结构对程序编写指导：</p>
<ul>
<li>注意力集中在内循环上</li>
<li>按照数据对象存储在内存中的顺序、以步长为 1 的来读数据，从而使得你程序中的空间局部性最大</li>
<li>从存睹器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大</li>
</ul>
<br>
基本存储技术包括随机存储器(RAM)、非易失性存储器（ROM)和磁盘。RAM 有两种基本类型。静态RAM(SRAM)快一些，用做 CPU 芯片上的髙速缓存，也可以用做芯片下的高速缓存；动态 RAM(DRAM)慢一点，用做主存和图形帧缓冲区；在关电的时候,ROM 也能保持它们的信息；


<p>随机存取存储器（RAM)和只读存储器(ROM) 及磁盘和固态硬盘<br>时间局部性和空间局部性来提高应用程序的性能</p>
<br>

<h1 id="在系统上运行程序"><a href="#在系统上运行程序" class="headerlink" title="在系统上运行程序"></a>在系统上运行程序</h1><h2 id="第7章-链接"><a href="#第7章-链接" class="headerlink" title="第7章 链接"></a>第7章 链接</h2><p> 链接可以执行于编译时,也可以在源代码翻译成机器代码时；也可以执行于加载时(dynamorio中的链接在执行时)，即程序被加载器加载到内存并执行时；也可以执行与运行时。静态链接和加载时的共享库动态链接，运行时共享库动态链接</p>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220701231510.png" alt="20220701231510"></p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">gcc -Og -o prog main.c sum.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理</span></span><br><span class="line">cpp [可选] main.c main.i</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">ccl main.i -Og [可选] -o main.s</span><br><span class="line"><span class="comment"># 汇编  &gt;&gt;可重定位目标文件</span></span><br><span class="line">as [] -o main.o main.s</span><br><span class="line"><span class="comment"># 链接 &gt;&gt;可执行目标文件</span></span><br><span class="line">ld -o prog [] main.o sum.o</span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">./prog</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-1-静态链接"><a href="#7-1-静态链接" class="headerlink" title="7.1 静态链接"></a>7.1 静态链接</h3><p> 链接器生成可执行文件两个过程：</p>
<ul>
<li>符号解析</li>
<li>重定位：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置</li>
</ul>
<p> 目标文件三种形式：</p>
<ul>
<li>可重定位目标文件：包含二进制代码和数据</li>
<li>可执行目标文件：包含二进制代码和数据，可直接复制到内存并执行</li>
<li>共享目标文件：特殊可重定位目标文件，可在加载或运行时被动态地加载进内存并链接<br> Unix a.out格式，windows可移植可执行(PE)格式，linux 可执行可链接格式(ELF)</li>
</ul>
<p> 可重定位目标文件<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220701232932.png" alt="20220701232932"><br> ELF头(ELF header)以一个16字节的序列开始,描述生成该文件的系统的字的大小和字节顺序;帮助链接器语法分析和解释目标文件的信息，包括ELF头大小、目标文件类型(可重定位、可执行或共享的)、机器类型、节头部表的文件便宜，节头部表中条目的大小和数量。<br> 夹在 ELF 头和节头部表之间的都是节<br> ELF可重定位目标文件包含的节：</p>
<ul>
<li>.text : 编译程序的机器代码</li>
<li>.rodata: 只读数据，格式串和开关语句的跳转表</li>
<li>.data: 已初始化的全局和静态 C 变量</li>
<li>.bss : 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量</li>
<li>.symtab: 符号表，存放在程序中定义和引用的函数和全局变量的信息</li>
<li>.rel.text: 一个.text 节中位置的列表</li>
<li>.rel.data： 被模块引用或定义的所有全局变量的重定位信息</li>
<li>.debug：调试符号表，其条目是程序中定义的局部变量和类型定义</li>
<li>.line： 调试符号表，其条目是程序中定义的局部变量和类型定义 <strong>LINE</strong></li>
<li>.strtab: 字符串表</li>
</ul>
<p> 符号表：全局符号，外部符号和局部符号<br> 符号表是由汇编器构造的，使用编译器输出到汇编语言.s 文件中的符号。.symtab节中包含ELF符号表。<br> 有三个特殊的伪节（pseudosection), 它们在节头部表中是没有条目的：ABS 代表不该被重定位的符号；UNDEF 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号；COMMON 表示还未被分配位置的未初始化的数据目标<br> 符号解析：连接器解析符号</p>
<p>编译器向汇编器输出每个全局符号，或者是强(strong)或者是弱(weak)，Linux 链接器来处理多重定义的符号名规则<br> 编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库(static library)<br> 相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以过在命令行上指定单独的文件名字来使用这些在库中定义的函数</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建静态库</span></span><br><span class="line">gcc -c addvec.c multvec.c</span><br><span class="line"><span class="comment"># AR工具</span></span><br><span class="line">ar rcs libvector.a addvex.op multvec.o</span><br><span class="line"><span class="comment"># 使用静态库，包含头文件</span></span><br><span class="line">gcc -c  main2.c</span><br><span class="line">gcc -static -o prog2c main2.o ./libvector.a</span><br><span class="line"><span class="comment"># 等价</span></span><br><span class="line">gcc -c main2.c</span><br><span class="line">gcc --static -o prog2c main2.o -L. -lvector</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708002734.png" alt="20220708002734"></p>
<h3 id="7-2-重定位"><a href="#7-2-重定位" class="headerlink" title="7.2 重定位"></a>7.2 重定位</h3><p> 重定位由两步组成：<br> 重定位节和符号定义：合并节为聚合节，为聚会节赋运行时内存地址，为符号赋地址<br> 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址<br> 重定位条目<br> 汇编时汇编器不知道外部函数或全局变量的位置，未知目标引用即为重定位条目，代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708003652.png" alt="20220708003652"><br> ELF 定义了 32 种不同的重定位类型,两种最基本的<br>重定货类型：</p>
<ul>
<li>R_X86_64_PC32 重定位一个使用32位PC相对地址的引用</li>
<li>R_X86_64_32 重定位一个使用32位绝对地址的引用</li>
</ul>
<p>重定位PC相对引用<br>重定位绝对引用</p>
<h3 id="7-3-可执行目标文件"><a href="#7-3-可执行目标文件" class="headerlink" title="7.3 可执行目标文件"></a>7.3 可执行目标文件</h3><p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708004108.png" alt="20220708004108"><br>ELF 头描述文件的总体格式。它还包括程序的入口点（entry point), 也就是当程序运行时要执行的第一条指令的地址。.text、.rodata 和.data 节与可重定位目标文件中的节是相似的，init 节定义了一个小函数，叫做_init， 程序的初始化代码会调用它<br>可执行文件的连续的片（chunk)被映射到连续的内存段。程序头部表（program header table)描述了这种映射关系</p>
<p>加载可执行目标文件</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prog</span><br></pre></td></tr></tbody></table></figure>
<p> shell 认为 prog 是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它。linux程序可通过调用execve函数来调用加载器，加载器加可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。</p>
<p> 在 Linux X86-64系统中，代码段总是从地址 0x400加0 处开始，后面是数据段,运行时堆在数据段之后，通过调用 malloc 库往上增长。后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址(2^48 —1)开始，向较小内存地址增长。栈上的区域，从地址 2^48 开始，是为内核（kernel)中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分</p>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220708004746.png" alt="20220708004746"></p>
<p>加载器运行时在程序头部表的引导下,加载器将可执行文件的片(chunk)复制到代码段和数据段。加载器跳转到程序的入口点，即_start函数的地址，这个函数是在系统目标文件 Ctrl.o 中定义的，对所有的 C 程序都是一样的。_start 函数调用系统启动函数 __libc_start_main，该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核<br> 父进程创建一个fork子进程，子进程通过execve系统调用启动加载器，加载器删除子进程现有的 虚拟内存段，并创建一组新的代码、数<br>据、堆和栈段。</p>
<h3 id="7-4-动态链接共享库"><a href="#7-4-动态链接共享库" class="headerlink" title="7.4 动态链接共享库"></a>7.4 动态链接共享库</h3><p> 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking), 是由一个叫做动态链接器(dynamic linker)的程序来执行的。共享库也称为共享目标(shared object)，在 Linux 系统中通常用 .so后缀来表示,windows中用DLL</p>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220709000956.png" alt="20220709000956"></p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -fpic 编译器生成与位置无关代码</span></span><br><span class="line">gcc -shared -fpic -o libvector.so addvec.c multvec.c</span><br></pre></td></tr></tbody></table></figure>
<p> 动态链接器通过执行重定位完成链接任务<br> Linux 系统动态链接器接口</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dlsym 函数的输人是一个指向前面已经打开了的共享库的句柄和一个 symbol 名字,如果该符号存在，就返回符号的地址，否则返回 NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">char</span> *symbol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p> 可加载而无需重定位的代码称为位置无关代码(PIC)<br> 数据段与代码段的距离总是保持不变,数据段开始的地方创建了一个表，叫做全局偏移量表(Global Offset Table, GOT)<br> 延迟绑定(lazy binding), 将过程地址的绑定推迟到第一次调用该过程时。过程链接表(Procedure Linkage Table, PLT)</p>
<p>Linux 链接器支持库打桩(library interpositioning), 允许截获对共享库函数的调用，取而代之执行自己的代码。打桩可以发生在编译时、链接时或当程序被加载和执行的运行时</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译时打桩</span></span><br><span class="line">gcc -DCOMPILETIME -c mymalloc.c</span><br><span class="line">gcc -I. -o intc int.c mymalloc.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接时打桩</span></span><br><span class="line">gcc -DLINKTIME -c mymallo.c</span><br><span class="line">gcc -c int.c</span><br><span class="line">gcc -Wl, --wrap, malloc -Wl, --wrap, free -o initl int.o mymalloc.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行时打桩</span></span><br><span class="line">gcc -DRUNTIME -shared -fpic ~o mymalloc.so mymalloc.c -ldl</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>处理目标文件的工具,GNUbinutils 包</p>
<ul>
<li>AR 创建静态库，插人、删除、列出和提取成员</li>
<li>STRINGS 列出一个目标文件中所有可打印的字符串。</li>
<li>STRIP 从目标文件中删除符号表信息</li>
<li>NM 列出目标文件的符号表中定义的符号</li>
<li>SIZE 列出目标文件中节的名字和大小</li>
<li>READELF 显示目标文件的完整结构，ELF头信息</li>
<li>OBJDUMP 所有二进制工具，反汇编</li>
<li>LDD 可执行文件在运行时所需要的共享库</li>
</ul>
<br>

<p>静态和动态链接,<br>可重定位的、可执行的和共享的<br>可重定位的和可执行的目标文件、符号解析、重定位、静态库、 共享目标库、 位置无关代码，以及库打桩<br>链接器的两个主要任务是符号解析和重定位<br>链接器生成的目标文件是与一些像加载、虚拟内存和内存映射<br>加载器将可执行文件的内容映射到内存，并运行这个程序</p>
<br>

<h2 id="第8章-异常控制流ECF"><a href="#第8章-异常控制流ECF" class="headerlink" title="第8章 异常控制流ECF"></a>第8章 异常控制流ECF</h2><h3 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h3><p> ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制<br> 应用程序与操作系统交换通过陷阱(trap)或系统(system call)的ECF形式<br> 异常处理通过非本地跳转响应错误，C通过setjmp和longjmph函数<br> 状态变化称为事件(event),处理器检测到事件发生，通过异常表(存储异常号)的跳转表，进行间接过程调用，跳转到操作系统子程序(异常处理程序(exception handler))。异常表的起始地地址放在叫做异常表基址寄存器(exception table base register)的特殊CPU寄存器<br> 异常不同于调用：调用返回地址压入栈，异常返回地址位当前指令或下一条指令；额外压入处理器状态到栈；如控制转移到内核，则压入内核栈；异常程序运行在内核模式<br> 异常分为四类：中断(interrupt)、陷阱(trap)、故障(fault)和终止(abort)<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711002750.png" alt="20220711002750"></p>
<p> 陷阱用在用户程序和内核之间的系统调用，用户程序向内核请求服务，如读文件(read)、创建进程(fork)、加载程序(execve)和终止进程(exit)等，syscall n 指令<br> 故障示例缺页异常<br> linux/x85-64异常<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711003346.png" alt="20220711003346"><br> C程序用 syscall 函数可以直接调用任何系统调用，通常通过包装函数(系统级函数)使用<br> 寄存 %rax 包含系统调用号,寄存器%rdi，%rsi、%rdx、%r10、%r8和%r9包含最多6个参数。<br><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711003746.png" alt="20220711003746"></p>
<h3 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h3><p> 进程一个执行中程序的实例，系统中的每个程序都运行在某个进程的上下文(context)中<br> PC值的序列叫逻辑控制流，一个逻辑流在时间上与另一个流重叠，称为并发流，并发运行<br> 并发多个流并发执行；多任务进程轮流运行；时间片</p>
<p> 进程私有地址空间</p>
<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711004452.png" alt="20220711004452"></p>
<p> 代码段总是从地址 0x400000 开始,地址空间顶部保留给内核(操作系统常驻内存的部分)</p>
<p> 处理器通常是用某个控制寄存器中的一个模式位(mode bit)来确定用户模式和内核模式<br> linux系统提供 /proc 文件系统，允许用户模式进程访问内核数据结构的内容</p>
<p> 上下文切换(context swtich):通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构</p>
<p> 内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度(scheduling), 是由内核中称为调度器(scheduler)的代码处理的</p>
<p> 系统调用错误处理Unix 系统级函数遇到错误时,返回-1，设置全局整数变量errno</p>
<h3 id="8-3-进程控制"><a href="#8-3-进程控制" class="headerlink" title="8.3 进程控制"></a>8.3 进程控制</h3><p> 获取进程ID</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pit_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p> 进程三种状态</p>
<ul>
<li>运行：在 CPU 上执行；或等待被执行且最终会被内核调度</li>
<li>停止：进程的执行被挂起（suspended), 且不会被调度。收到SIGSTOP、SIGTSTP、SIGYTTIN或SIGTTOU信号，进程停止，直到收到SIGCONT信号，再次运行</li>
<li>终止：进程会因为三种原因终止：1)收到一个信号，该信号的默认行为是终止进程，2)从主程序返回，3)调用 exit 函数</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以status退出状态终止进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建进程 调用一次返回两次在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220711010245.png" alt="20220711010245"></p>
<p> 回收子进程；内核将子进程的退出状态传递给父进程;如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父.init 进程的 PID 为 1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// waitpid 函数来等待它的子进程终止或者停止</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statusp, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>options 设置为常量 WNOHANG、WUNTRACED 和 WCONTINUED<br>的各种组合来修改默认行为</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 进程休眠secs秒</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br><span class="line"><span class="comment">// 让调用函数休眠</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 加载并运行一个新程序 和fork的区别 ？</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[], <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220712001432.png" alt="20220712001432"></p>
<p> main函数有3个参数：1）argc argv[]数组中非空指针数量 2)argv 指向argv[]数组第一个条目 3) envp 指向envp[]数组中第一个条目</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *newvalue, <span class="keyword">int</span> overwrite)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-4-信号"><a href="#8-4-信号" class="headerlink" title="8.4 信号"></a>8.4 信号</h3><p><img src="https://raw.githubusercontent.com/zhuangll/PictureBed/main/blogs/pictures/20220712004654.png" alt="20220712004654"></p>
<p> 发送信号<br>每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。getpgrp函数返回当前进程的进程组 ID:</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变进程所属进程组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p> /bin/kill 程序向另外i的进程发送任意信号</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 15213 进程组</span></span><br><span class="line">/bin/<span class="built_in">kill</span> -9 -15213</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/typed.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//调用 kill 函数发送信号给其他进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 调用 alarm 函数向它自己发送 SIGALRM 信号</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>接收信号</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signale</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>Linux 提供阻塞信号的隐式和显式的机制：</p>
<br>

<p>异常控制流<br>系统所有层次的异常控制流<br>底层的硬件异常和中断<br>并发进程的上下文切换<br>进程的基本概念<br>通过 Linux 系统调用来使用多个进程</p>
<br>

<h2 id="第9章-虚拟内存"><a href="#第9章-虚拟内存" class="headerlink" title="第9章 虚拟内存"></a>第9章 虚拟内存</h2><p>管理和操纵虚拟内存<br>存储分配操作，标准库的 malloc 和 free 操作<br>存储泄漏和非法指针引用等内存引用错误</p>
<br>

<h1 id="程序间的交互和通信"><a href="#程序间的交互和通信" class="headerlink" title="程序间的交互和通信"></a>程序间的交互和通信</h1><h2 id="第10章-系统级-1"><a href="#第10章-系统级-1" class="headerlink" title="第10章 系统级 1/()"></a>第10章 系统级 1/()</h2><p>Unix VO 的基本概念<br>文件和描述符<br>共享文件，1/O重定向<br>访问文件的元数据<br>C 的标准 I/O 库</p>
<br>


<h2 id="第11章-网络编程"><a href="#第11章-网络编程" class="headerlink" title="第11章 网络编程"></a>第11章 网络编程</h2><p>网络是 I/O 设备<br>客户端-服务器模型</p>
<br>

<h2 id="第12章-并发编程"><a href="#第12章-并发编程" class="headerlink" title="第12章 并发编程"></a>第12章 并发编程</h2><p>三种编写并发程序的基本机制（进程、 1/()多路复用和线程）<br>用 P、 V 信号量操作来实现同步、线程安全和可重人、竞争条件以及死锁等的基本原则</p>
<br>

<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/" rel="tag"># 实用教程</a>
              <a href="/tags/Another-Tag/" rel="tag"># Another Tag</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/01/2022/leetcode%E6%9C%AA%E5%88%86%E7%B1%BB%E9%A2%98%E7%9B%AE/" rel="prev" title="leetcode基础">
      <i class="fa fa-chevron-left"></i> leetcode基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/20/2022/Dynamorio/" rel="next" title="Dynamorio">
      Dynamorio <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="nav-text">深入理解计算机系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="nav-text">第1章 计算机系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C"><span class="nav-text">程序结构和执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86"><span class="nav-text">第2章 信息的表示和处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA"><span class="nav-text">2.1 信息表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="nav-text">2.2 整数表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="nav-text">2.3 整数运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-text">2.4 浮点数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="nav-text">第3章 程序的机器级表示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="nav-text">3.1 机器码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BF%E9%97%AE"><span class="nav-text">3.2 处理器访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.2.1 指令操作和类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A0%88%E6%95%B0%E6%8D%AE"><span class="nav-text">3.2.2 压入和弹出栈数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="nav-text">3.3 算术和逻辑操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="nav-text">3.4 控制指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E6%9D%A1%E4%BB%B6%E7%A0%81-condition-code-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">3.4.1 条件码(condition code)寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E5%BE%AA%E7%8E%AF"><span class="nav-text">3.4.2 循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-switch%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.4.2 switch语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E8%BF%87%E7%A8%8B"><span class="nav-text">3.5 过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E6%95%B0%E7%BB%84%E5%88%86%E9%85%8D%E4%B8%8E%E8%AE%BF%E9%97%AE"><span class="nav-text">3.6 数组分配与访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E7%BB%93%E6%9E%84struct%E5%92%8C%E8%81%94%E5%90%88union"><span class="nav-text">3.7 结构struct和联合union</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%8E%A7%E5%88%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E5%90%88"><span class="nav-text">3.8机器级程序中控制和数据结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-%E6%B5%AE%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="nav-text">3.9 浮点代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">第4章 处理器体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Y86-64%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="nav-text">4.1 Y86-64指令集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80HCL"><span class="nav-text">4.2 逻辑设计和硬件控制语言HCL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-text">流水线</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD"><span class="nav-text">第5章 优化程序性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E4%BC%98%E5%8C%96%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-text">5.1 优化编译器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">5.2 现代处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E6%8F%90%E9%AB%98%E5%B9%B6%E8%A1%8C%E6%80%A7"><span class="nav-text">5.3 提高并行性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD"><span class="nav-text">5.4 内存性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E6%80%A7%E8%83%BD%E6%8F%90%E9%AB%98%E6%8A%80%E6%9C%AF"><span class="nav-text">5.5 性能提高技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">第6章 存储器层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">6.1 随机访问存储器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-text">6.2 局部性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">6.3 存储层次结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-text">在系统上运行程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E9%93%BE%E6%8E%A5"><span class="nav-text">第7章 链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-text">7.1 静态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="nav-text">7.2 重定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-text">7.3 可执行目标文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-text">7.4 动态链接共享库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81ECF"><span class="nav-text">第8章 异常控制流ECF</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E5%BC%82%E5%B8%B8"><span class="nav-text">8.1 异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E8%BF%9B%E7%A8%8B"><span class="nav-text">8.2 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">8.3 进程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E4%BF%A1%E5%8F%B7"><span class="nav-text">8.4 信号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-text">第9章 虚拟内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1"><span class="nav-text">程序间的交互和通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC10%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7-1"><span class="nav-text">第10章 系统级 1&#x2F;()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC11%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">第11章 网络编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-text">第12章 并发编程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">257k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:53</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
