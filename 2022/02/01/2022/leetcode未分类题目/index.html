<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true,"b2t":false,"scrollpercent":true},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1207, 876, 701, 674, 367， 231  206 201  189  160 125   121">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode基础">
<meta property="og:url" content="http://example.com/2022/02/01/2022/leetcode%E6%9C%AA%E5%88%86%E7%B1%BB%E9%A2%98%E7%9B%AE/index.html">
<meta property="og:site_name" content="liuz">
<meta property="og:description" content="1207, 876, 701, 674, 367， 231  206 201  189  160 125   121">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-31T16:47:53.000Z">
<meta property="article:modified_time" content="2022-01-31T16:53:53.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="实用教程">
<meta property="article:tag" content="Another Tag">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/02/01/2022/leetcode%E6%9C%AA%E5%88%86%E7%B1%BB%E9%A2%98%E7%9B%AE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode基础 | liuz</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="liuz" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">liuz</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/01/2022/leetcode%E6%9C%AA%E5%88%86%E7%B1%BB%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuz">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-01 00:47:53 / 修改时间：00:53:53" itemprop="dateCreated datePublished" datetime="2022-02-01T00:47:53+08:00">2022-02-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/2022/" itemprop="url" rel="index"><span itemprop="name">2022</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>1207, 876, 701, 674, 367， 231  206 201  189  160 125   121</p>
<span id="more"></span>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/submissions/"> 路径总和</a></h2><blockquote>
<p>思路：递归：递归出口； 注意书判空</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> targetSum)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span> &amp;&amp; root-&gt;val == targetSum) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h2><blockquote>
<p>思路：股票是连续收益的 maxcmp(0, maxCur + prices[i] - prices[i - 1])</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxcmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">return</span> (a &gt;= b) ? a : b; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> maxCur = <span class="number">0</span>, maxSoFar = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pricesSize; i++) {</span><br><span class="line">        maxCur = maxcmp(<span class="number">0</span>, maxCur + prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        maxSoFar = maxcmp(maxSoFar, maxCur);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"i = %d\t maxCur = %d \t maxSoFar = %d\n"</span>, i, maxCur, maxSoFar);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxSoFar;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome/">验证回文串</a></h2><blockquote>
<p>思路：判断是否是字母和数字，库函数 isalnum; 注意库函数 isalpha 为判断是否为字母。</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">char</span> * s)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="comment">//while (left &lt; right &amp;&amp; !isalpha(s[left])) {</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) {</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//while (left &lt; right &amp;&amp; !isalpha(s[right])) {</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) {</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"left = %d\t right = %d\n"</span>, left, right);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[left]) != <span class="built_in">tolower</span>(s[right])) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a></h2><blockquote>
<p>思路：n ^ n = 0 一个数与自己异或为 0</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        res = res ^ nums[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></h2><blockquote>
<p>思路：快慢双指针</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) {</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142.环形链表 II"></a>142.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II</a></h2><blockquote>
<p>思路：快慢双指针</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    slow = head;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) {</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">entry</span> =</span> head;</span><br><span class="line">            <span class="keyword">while</span> (slow != entry) {</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">                entry = entry-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> entry;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153.寻找旋转排序数组中的最小值"></a>153.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></h2><blockquote>
<p>思路：二分查找</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) {</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[high]) {</span><br><span class="line">            high = mid;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[low];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[(i+<span class="number">1</span>)]) {</span><br><span class="line">            <span class="keyword">return</span> nums[i+<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/?page=1&amp;search=160">相交链表</a></h2><blockquote>
<p>思路：<br>一、<br>二、先统计两个链表结点个数，然后长链表先走个数差位</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur1</span> =</span> headA;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur2</span> =</span> headB;</span><br><span class="line">    <span class="keyword">if</span> (cur1 == <span class="literal">NULL</span> || cur2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1 &amp;&amp; cur2 &amp;&amp; cur1 != cur2) {</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">        cur2 = cur2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cur1 == cur2) {</span><br><span class="line">            <span class="keyword">return</span> cur1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!cur1) {</span><br><span class="line">            cur1 = headB;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!cur2) {</span><br><span class="line">            cur2 = headA;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">多数元素</a></h2><blockquote>
<p>思路：选定一个主元素，计数器</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> majorNum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) {</span><br><span class="line">            majorNum = nums[i];</span><br><span class="line">            count++;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (majorNum == nums[i]) {</span><br><span class="line">            count++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            count--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> majorNum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173.二叉搜索树迭代器"></a>173.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">二叉搜索树迭代器</a></h2><blockquote>
<p>思路：</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span>* res;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">} BSTIterator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTreeSize</span><span class="params">(struct TreeNode* root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getTreeSize(root-&gt;left) + getTreeSize(root-&gt;right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span>* ret, <span class="keyword">int</span>* retSize, struct TreeNode* root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    inorder(ret, retSize, root-&gt;left);</span><br><span class="line">    ret[(*retSize)++] = root-&gt;val;</span><br><span class="line">    inorder(ret, retSize, root-&gt;right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">inorderTraversal</span><span class="params">(<span class="keyword">int</span>* retSize, struct TreeNode* root)</span> </span>{</span><br><span class="line">    *retSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * getTreeSize(root));</span><br><span class="line">    inorder(ret, retSize, root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BSTIterator* <span class="title">bSTIteratorCreate</span><span class="params">(struct TreeNode* root)</span> </span>{</span><br><span class="line">    BSTIterator* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTIterator));</span><br><span class="line">    ret-&gt;res = inorderTraversal(&amp;(ret-&gt;size), root);</span><br><span class="line">    ret-&gt;idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSTIteratorNext</span><span class="params">(BSTIterator* obj)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;res[(obj-&gt;idx)++];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bSTIteratorHasNext</span><span class="params">(BSTIterator* obj)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (obj-&gt;idx &lt; obj-&gt;size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bSTIteratorFree</span><span class="params">(BSTIterator* obj)</span> </span>{</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;res);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189.轮转数组"></a>189.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array/">轮转数组</a></h2><blockquote>
<p>思路：<br>一、每次移动一个数<br>二、先整体翻转，在翻转前k个，最后翻转 numsSize - k个</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveOne</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[numsSize - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numsSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">        nums[i] = nums[i<span class="number">-1</span>]; </span><br><span class="line">    }</span><br><span class="line">    nums[<span class="number">0</span>] = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">        moveOne(nums, numsSize);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) {</span><br><span class="line">        swap(&amp;nums[start], &amp;nums[end]);</span><br><span class="line">        start += <span class="number">1</span>;</span><br><span class="line">        end -= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    k %= numsSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"nums[%d] = %d\t"</span>, i, nums[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"nums[%d] = %d\t"</span>, i, nums[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"nums[%d] = %d\t"</span>, i, nums[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    reverse(nums, k, numsSize - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"nums[%d] = %d\t"</span>, i, nums[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void rotate(int* nums, int numsSize, int k){</span></span><br><span class="line"><span class="comment">     for (int i = 0; i &lt; k; i++) {</span></span><br><span class="line"><span class="comment">        int lastElement = nums[numsSize - 1];</span></span><br><span class="line"><span class="comment">        for (int j = numsSize - 1; j &gt; 0; j--) {</span></span><br><span class="line"><span class="comment">            nums[j] = nums[j - 1];</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        nums[0] = lastElement;</span></span><br><span class="line"><span class="comment">    } </span></span><br><span class="line"><span class="comment">}*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">void rotate(int* nums, int numsSize, int k){</span></span><br><span class="line"><span class="comment">    if (k == numsSize / 2 &amp;&amp; numsSize % 2 != 1) {</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; k; i++) {</span></span><br><span class="line"><span class="comment">            int tmp = nums[i];</span></span><br><span class="line"><span class="comment">            nums[i] = nums[k+i];</span></span><br><span class="line"><span class="comment">            nums[k+i] = tmp;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    int i = 0;</span></span><br><span class="line"><span class="comment">    int tmp = nums[0];</span></span><br><span class="line"><span class="comment">    int p = 0;</span></span><br><span class="line"><span class="comment">    int count = 0;</span></span><br><span class="line"><span class="comment">    do {</span></span><br><span class="line"><span class="comment">        p = (i + k) % numsSize;</span></span><br><span class="line"><span class="comment">        printf("p = %d\n",p);</span></span><br><span class="line"><span class="comment">        int t = nums[p];</span></span><br><span class="line"><span class="comment">        nums[p] = tmp;</span></span><br><span class="line"><span class="comment">        tmp = t;</span></span><br><span class="line"><span class="comment">        i = p;</span></span><br><span class="line"><span class="comment">     } while (i != 0);</span></span><br><span class="line"><span class="comment">} */</span> </span><br></pre></td></tr></tbody></table></figure>

<h2 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190.颠倒二进制位"></a>190.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-bits/submissions/">颠倒二进制位</a></h2><blockquote>
<p>思路：32位，</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">uint32_t</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt) {</span><br><span class="line">        m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        m += (n &amp; <span class="number">0x1</span>);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-1-bits/submissions/">位1的个数</a></h2><blockquote>
<p>思路：n &amp; 0x1</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) {</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">0x1</span>) {</span><br><span class="line">            cnt++;</span><br><span class="line">        }</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201.数字范围按位与"></a>201.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/">数字范围按位与</a></h2><blockquote>
<p>思路：n &amp; (n - 1) 去除n最高位的1</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">        right &amp;= right - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-linked-list-elements/">移除链表元素</a></h2><blockquote>
<p>思路：递归</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">removeElements</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) {</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;val == val) {</span><br><span class="line">        <span class="keyword">return</span> removeElements(head-&gt;next, val);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></h2><blockquote>
<p>思路：</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">res</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre_node</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        pre_node-&gt;next = res;</span><br><span class="line">        res = pre_node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215.数组中的第K个最大元素"></a>215.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></h2><blockquote>
<p>思路：排序，第k个最大</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)b - *(<span class="keyword">int</span> *)a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), Cmp);</span><br><span class="line">    <span class="keyword">return</span> nums[k<span class="number">-1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate/">存在重复元素</a></h2><blockquote>
<p>思路：<br>一、排序，比较前一个数和当前数是否相等<br>二、uthash</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), Cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span> (nums[i<span class="number">-1</span>] == nums[i]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">users</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line">   HASH_FIND_INT(users, nums[i], s);</span><br><span class="line">   <span class="keyword">if</span> (s == <span class="literal">NULL</span>) {</span><br><span class="line">       s = (struct my_struct*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct my_struct));</span><br><span class="line">       s-&gt;id = nums[i];</span><br><span class="line">       HASH_ADD_INT(users, id, s);</span><br><span class="line">   } <span class="keyword">else</span> {</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></h2><blockquote>
<p>思路：判空，交换左右子树，递归调用</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">invertTree</span><span class="params">(struct TreeNode* root)</span></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">tmp</span> =</span> root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line"></span><br><span class="line">    invertTree(root-&gt;left);</span><br><span class="line">    invertTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">invertTree</span><span class="params">(struct TreeNode* root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span> =</span> (struct TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span> =</span> (struct TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    left = invertTree(root-&gt;left);</span><br><span class="line">    right = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;left = right;</span><br><span class="line">    root-&gt;right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231.2的幂"></a>231.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-two/">2的幂</a></h2><blockquote>
<p>思路：</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!n) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">       res = isPowerOfTwo(n/<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="comment">//用位运算来判断有几个1，要是只有一个1那就是2的幂。</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">2147483647</span> || n &lt;= <span class="number">-2147483648</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> nu m =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">0</span> &amp;&amp; n!=<span class="number">0</span>) {</span><br><span class="line">        n &amp;= (n<span class="number">-1</span>);</span><br><span class="line">        num++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (num!=<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/submissions/">回文链表</a></h2><blockquote>
<p>思路；<br>一、通过一个数组记录链表中的元素值，在判断数组是否是回文。<br>二、翻转链表</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nums[MAXSIZE] = {<span class="number">0</span>};</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> head;</span><br><span class="line">    <span class="comment">// 判断条件</span></span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        nums[size++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size = %d\n"</span>, size);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="keyword">if</span> (nums[left] != nums[right]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">reverse</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">res</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre_node</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        pre_node-&gt;next = res;</span><br><span class="line">        res = pre_node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">last</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) {</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">NULL</span>) {</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    last = reverse(slow);</span><br><span class="line">    <span class="keyword">while</span> (last) {</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val != last-&gt;val) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram/submissions/">有效的字母异位词</a></h2><blockquote>
<p>思路：先比较长度，不相等 false，通过表格记录第一个字符串中字符，遍历第二个字符串时表格记录–，最后，判断表格中所有值是否为零</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMSIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="keyword">char</span> * s, <span class="keyword">char</span> * t)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> tLen = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">if</span> (sLen != tLen) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> table[<span class="number">256</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) {</span><br><span class="line">        table[s[i]]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tLen; i++) {</span><br><span class="line">        table[t[i]]--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMSIZE; i++) {</span><br><span class="line">        <span class="keyword">if</span> (table[i] != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268.丢失的数字"></a>268.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/missing-number/">丢失的数字</a></h2><blockquote>
<p>思路：边求和，边减去数组中的数字</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> mNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        mNum += (i + <span class="number">1</span>);</span><br><span class="line">        mNum -= nums[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mNum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278.第一个错误的版本"></a>278.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-bad-version/">第一个错误的版本</a></h2><blockquote>
<p>思路：二分查找</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(mid) &amp;&amp; !isBadVersion(mid<span class="number">-1</span>)) {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (isBadVersion(mid) &amp;&amp; isBadVersion(mid<span class="number">-1</span>)) {</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) {</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(mid)) {</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">移动零</a></h2><blockquote>
<p>思路：不等于零时向数组中添加，等于零时跳过，最后填充0<br>nums[start++] = nums[i]</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) {</span><br><span class="line">            nums[start++] = nums[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; start &lt; numsSize; start++) {</span><br><span class="line">        nums[start] = <span class="number">0</span>;</span><br><span class="line">    }    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="287-寻找重复整数"><a href="#287-寻找重复整数" class="headerlink" title="287.寻找重复整数"></a>287.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">寻找重复整数</a></h2><blockquote>
<p>思路：循环遍历，标记，判断是否标记过，return</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100001</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> table[MAXSIZE] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span> (table[nums[i]] != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            table[nums[i]]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string/">反转字符串</a></h2><blockquote>
<p>思路：双指针，交换</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> sSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> left =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = sSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">        <span class="keyword">char</span> c = s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = c;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367.有效的完全平方数"></a>367.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-perfect-square/">有效的完全平方数</a></h2><blockquote>
<p>思路：for 循环，条件 i * i &lt;= num </p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i * i &lt;= num; i++) {</span><br><span class="line">        <span class="keyword">if</span> (i * i == num) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387.字符串中的第一个唯一字符"></a>387.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">字符串中的第一个唯一字符</a></h2><blockquote>
<p>思路：两次遍历，第一次遍历见字母标记得到统计表格中，第二次遍历找出统计表格中第一个为1字符，返回对应下标。</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMSIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="keyword">char</span> * s)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> table[NUMSIZE] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) {</span><br><span class="line">        table[s[i]]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) {</span><br><span class="line">        <span class="keyword">if</span> (table[s[i]] == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389.找不同"></a>389.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-difference/">找不同</a></h2><blockquote>
<p>思路：字符可以转化为数字，为了防止溢出通过 - ‘a’，求两个字符串的差值，在加上’a’</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="keyword">char</span> * s, <span class="keyword">char</span> * t)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> tLen = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">int</span> nS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) {</span><br><span class="line">        nS += s[i] - <span class="string">'a'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tLen; i++) {</span><br><span class="line">        nT += t[i] - <span class="string">'a'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>)(nT - nS + <span class="string">'a'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">左叶子之和</a></h2><blockquote>
<p>思路：递归：判断左子树是否为叶子结点，是则记录sum，返回 sum + 递归调用左子树 + 递归调用右子树</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode* root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) {</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) {</span><br><span class="line">            sum += root-&gt;left-&gt;val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>  sum + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isleaf</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) {</span><br><span class="line">        <span class="keyword">if</span>(isleaf(root-&gt;left)) {</span><br><span class="line">            <span class="comment">// 此处直接递归，少一层调用</span></span><br><span class="line">            <span class="keyword">return</span> root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442.数组中重复的数据"></a>442.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">数组中重复的数据</a></h2><blockquote>
<p>思路：<br>一、通过表标记数组中出现过的数字，当再次出现时将数字添加到返回数组中。<br>二、</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> table[MAXSIZE] = {<span class="number">0</span>};</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAXSIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span> (table[nums[i]] == <span class="number">1</span>) {</span><br><span class="line">            res[*returnSize] = nums[i];</span><br><span class="line">            (*returnSize)++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            table[nums[i]]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> table[<span class="number">100000</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        table[nums[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (table[nums[i]] == <span class="number">2</span>) {</span><br><span class="line">            res[j++] = nums[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    *returnSize = j;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461.汉明距离"></a>461.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hamming-distance/">汉明距离</a></h2><blockquote>
<p>思路：<br>一、求 x ^ y 中 1 的个数<br>二、比较x，y的每一位 和 1与</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) {</span><br><span class="line">        <span class="keyword">int</span> p = n &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p) {</span><br><span class="line">            res++;</span><br><span class="line">        }</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x || y) {</span><br><span class="line">        <span class="keyword">int</span> nX = x &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">int</span> nY = y &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nX != nY) {</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476.数字的补数"></a>476.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-complement/">数字的补数</a></h2><blockquote>
<p>思路：<br>一、按位与1求与，再取反(!)，然后移位，<br>二、先统计位数，在取位数相同全一数，最后与原数字求异或 ^</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) {</span><br><span class="line">        <span class="keyword">int</span> t = !(num &amp; <span class="number">0x1</span>);</span><br><span class="line">        t &lt;&lt;= count;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"t = %d\n"</span>, t);</span><br><span class="line">        res += t;</span><br><span class="line">        count++;</span><br><span class="line">        num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> totalBits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = num;</span><br><span class="line">    <span class="keyword">while</span> (tmp) {</span><br><span class="line">        totalBits++;</span><br><span class="line">        tmp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> flipNumber = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; totalBits; i++) {</span><br><span class="line">        flipNumber += UINT32_C(<span class="number">1</span>) &lt;&lt; i;</span><br><span class="line">    }</span><br><span class="line">    num = num ^ flipNumber;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="509-斐波那契数列"><a href="#509-斐波那契数列" class="headerlink" title="509.斐波那契数列"></a>509.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fibonacci-number/">斐波那契数列</a></h2><blockquote>
<p>思路：一、递归  二、迭代</p>
</blockquote>
<ul>
<li><p>递归</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>迭代</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>* nums = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    nums[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">        nums[i] = nums[i - <span class="number">1</span>] + nums[i - <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520.检测大写字母"></a>520.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/detect-capital/submissions/">检测大写字母</a></h2><blockquote>
<p>思路：<br>一、先判断第二个字母是否为大写，1.word[1] 大写，从从零开始判断是否全为大写 2.word[1]为小写，从word是否全为小写。<br>二、</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(<span class="keyword">char</span> * word)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(word);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isupper</span>(word[i])) {</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (word[i] != <span class="string">'\0'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isupper</span>(word[i])) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">while</span> (word[i] != <span class="string">'\0'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(word[i])) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(<span class="keyword">char</span> * word)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(word);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">        <span class="comment">// word[0] 每次都需要判断，一个复杂度。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(word[<span class="number">0</span>]) &amp;&amp; <span class="built_in">isupper</span>(word[<span class="number">1</span>])) {</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isupper</span>(word[i])) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(word[i])) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="561-拆分数组I"><a href="#561-拆分数组I" class="headerlink" title="561.拆分数组I"></a>561.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/array-partition-i/">拆分数组I</a></h2><blockquote>
<p>思路：排序，取偶数位求和。</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), Cmp);</span><br><span class="line">    <span class="keyword">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            minSum += nums[i];</span><br><span class="line">        }    </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minSum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树</a></h2><blockquote>
<p>思路：递归，判空，</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">node</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">mergeTrees</span><span class="params">(struct TreeNode* root1, struct TreeNode* root2)</span></span>{</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*  if (root1 == NULL &amp;&amp; root2 == NULL) {</span></span><br><span class="line"><span class="comment">        return NULL;</span></span><br><span class="line"><span class="comment">    } */</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/*  struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));</span></span><br><span class="line"><span class="comment">    root-&gt;val += root1 == NULL ? 0 : root1-&gt;val;</span></span><br><span class="line"><span class="comment">    root-&gt;val += root2 == NULL ? 0 : root2-&gt;val;</span></span><br><span class="line"><span class="comment">    root-&gt;left = NULL;</span></span><br><span class="line"><span class="comment">    root-&gt;right = NULL; */</span></span><br><span class="line">    <span class="keyword">int</span> val = (root1 == <span class="literal">NULL</span> ? <span class="number">0</span> : root1-&gt;val) + (root2 == <span class="literal">NULL</span> ? <span class="number">0</span> : root2-&gt;val);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span>  =</span> newNode(val);</span><br><span class="line">    root-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">    root-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647.回文子串"></a>647.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindromic-substrings/">回文子串</a></h2><blockquote>
<p>思路：左侧判断去重，左右判断相等。</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="keyword">char</span> * s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> res = len; <span class="comment">// 每个字符都是回文</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">        <span class="keyword">int</span> p = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; s[p] == s[i]) { <span class="comment">// 左侧去重</span></span><br><span class="line">            res++;</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> q = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; q &lt; len &amp;&amp; s[p] == s[q]) { <span class="comment">// 判断左右相等</span></span><br><span class="line">            res++;</span><br><span class="line">            p--;</span><br><span class="line">            q++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="keyword">char</span> * s)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">        count += countPalin(s, i, i, len);</span><br><span class="line">        <span class="keyword">if</span> (i != len - <span class="number">1</span>) {</span><br><span class="line">            count += countPalin(s, i, i+<span class="number">1</span>, len);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPalin</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> head, <span class="keyword">int</span> tail, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret = (s[head] == s[tail]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret &amp;&amp; head - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tail + <span class="number">1</span> &lt; len) {</span><br><span class="line">        ret += countPalin(s, head - <span class="number">1</span>, tail + <span class="number">1</span>, len);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674.最长连续递增序列"></a>674.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">最长连续递增序列</a></h2><blockquote>
<p>思路：双循环判断，</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="keyword">while</span> (i &lt; numsSize &amp;&amp; nums[i<span class="number">-1</span>] &lt; nums[i]) {</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        res = res &gt; i - p2 ? res : i - p2;</span><br><span class="line">        p2 = i;</span><br><span class="line"></span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; numsSize) {</span><br><span class="line">        <span class="keyword">int</span> start = i;</span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; numsSize &amp;&amp; nums[start] &lt; nums[start + <span class="number">1</span>]) {</span><br><span class="line">            start++;</span><br><span class="line">        }</span><br><span class="line">        maxLen = maxLen &gt; (start - i + <span class="number">1</span>) ? maxLen : (start - i + <span class="number">1</span>);</span><br><span class="line">        start++;</span><br><span class="line">        i = start;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></h2><blockquote>
<p>思路：递归，注意 判空 root == NULL</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">searchBST</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> val)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; val) {</span><br><span class="line">        <span class="keyword">return</span> searchBST(root-&gt;left, val);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> searchBST(root-&gt;right, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a></h2><blockquote>
<p>思路：递归，递归出口，root == NULL, 新建树结点 malloc</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">insertIntoBST</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> val)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">newNode</span> =</span> (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val) {</span><br><span class="line">        root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val) {</span><br><span class="line">        root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search/">二分查找</a></h2><blockquote>
<p>思路：二分查找，注意 left &lt;= right ，包含等于</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) {</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="709-转换成小写字母"><a href="#709-转换成小写字母" class="headerlink" title="709.转换成小写字母"></a>709.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/to-lower-case/">转换成小写字母</a></h2><blockquote>
<p>思路；库函数 isupper, tolower</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">toLowerCase</span><span class="params">(<span class="keyword">char</span> * s)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(s[i])) {</span><br><span class="line">            s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="771-宝石和石头"><a href="#771-宝石和石头" class="headerlink" title="771.宝石和石头"></a>771.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jewels-and-stones/">宝石和石头</a></h2><blockquote>
<p>思路：表记录stones中每个字符个数，求和jewels字符表中的值</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="keyword">char</span> * jewels, <span class="keyword">char</span> * stones)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> table[<span class="number">256</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(stones);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) {</span><br><span class="line">        table[stones[i]]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> jLen = <span class="built_in">strlen</span>(jewels);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jLen; i++) {</span><br><span class="line">        sum +=  table[jewels[i]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="852-山脉数组的峰顶索引"><a href="#852-山脉数组的峰顶索引" class="headerlink" title="852.山脉数组的峰顶索引"></a>852.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">山脉数组的峰顶索引</a></h2><blockquote>
<p>思路：判断条件，完全</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> arrSize)</span></span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">1</span>, high = arrSize;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) {</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid - <span class="number">1</span>] &lt; arr[mid] &amp;&amp; arr[mid] &gt; arr[mid + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid - <span class="number">1</span>] &lt; arr[mid] &amp;&amp; arr[mid] &lt; arr[mid + <span class="number">1</span>])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876.链表的中间结点"></a>876.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">链表的中间结点</a></h2><blockquote>
<p>思路：快慢指针，第二个指针通过 偶数判断  for循环</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pos1</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pos2</span> =</span> head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; pos1-&gt;next != <span class="literal">NULL</span>; pos1 = pos1-&gt;next, i++) {</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            pos2 = pos2-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pos2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="905-按奇偶排序数组"><a href="#905-按奇偶排序数组" class="headerlink" title="905.按奇偶排序数组"></a>905.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-array-by-parity/">按奇偶排序数组</a></h2><blockquote>
<p>思路: 一、双指针，同917<br>二、判断，前后索引移动，双指针</p>
</blockquote>
<ul>
<li><p>解法一：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">sortArrayByParity</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) {</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[start] % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            start++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (end &gt; start &amp;&amp; nums[end] % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">            end--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[start] % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; nums[end] % <span class="number">2</span> != <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">sortArrayByParity</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize)</span></span>{</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">         <span class="keyword">if</span> (nums[left] % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">if</span> (nums[right] % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">             right--;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> tmp = nums[left];</span><br><span class="line">         nums[left] = nums[right];</span><br><span class="line">         nums[right] = tmp;</span><br><span class="line">         left++;</span><br><span class="line">         right--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>解法二；</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">sortArrayByParity</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            res[j] = nums[i];</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            res[p] = nums[i];</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="917-仅仅反转字母"><a href="#917-仅仅反转字母" class="headerlink" title="917.仅仅反转字母"></a>917.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-only-letters/">仅仅反转字母</a></h2><blockquote>
<p>思路：双指针，库函数 isalpha， continue</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">reverseOnlyLetters</span><span class="params">(<span class="keyword">char</span> * s)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isalpha</span>(s[left])) {</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">         <span class="keyword">if</span> (!<span class="built_in">isalpha</span>(s[right])) {</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//if (isalpha(s[left]) &amp;&amp; isalpha(s[right])) {</span></span><br><span class="line">            <span class="keyword">char</span> c = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = c;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938.二叉搜索树的范围和"></a>938.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-of-bst/">二叉搜索树的范围和</a></h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (low &gt; root-&gt;val) {</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;right, low, high);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (high &lt; root-&gt;val) {</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;left, low, high);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val + rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high) {</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>




<h2 id="965-单值二叉树"><a href="#965-单值二叉树" class="headerlink" title="965.单值二叉树"></a>965.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/univalued-binary-tree/">单值二叉树</a></h2><blockquote>
<p>思路：递归，递归出口：root == NULL</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUnivalTree</span><span class="params">(struct TreeNode* root)</span></span>{</span><br><span class="line">    <span class="comment">// root不判空会报错：</span></span><br><span class="line">    <span class="comment">// member access within null pointer of type 'struct TreeNode'</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 多余</span></span><br><span class="line">   <span class="comment">/*  if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) {</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    } */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left-&gt;val != root-&gt;val) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right-&gt;val != root-&gt;val) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isUnivalTree(root-&gt;left) &amp;&amp; isUnivalTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/submissions/">有序数组的平方</a></h2><blockquote>
<p>思路</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a,  <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">sortedSquares</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* squareNum = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) {</span><br><span class="line">        <span class="comment">//squareNum[i] = nums[i] * nums[i];</span></span><br><span class="line">        squareNum[i] = <span class="built_in">pow</span>(nums[i], <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    qsort(squareNum, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), Cmp);</span><br><span class="line">    <span class="keyword">return</span> squareNum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1089-复写零"><a href="#1089-复写零" class="headerlink" title="1089.复写零"></a>1089.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/duplicate-zeros/">复写零</a></h2><blockquote>
<p>思路：将原数组复制一份，根据复制数组，修改原数组值</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> b[arrSize]; <span class="comment">// = {0};</span></span><br><span class="line">    <span class="built_in">memcpy</span>(b, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * arrSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; arrSize &amp;&amp; j &lt; arrSize; i++) {</span><br><span class="line">        arr[j++] = b[i];</span><br><span class="line">        <span class="keyword">if</span> (j &lt; arrSize &amp;&amp; b[i] == <span class="number">0</span>) {</span><br><span class="line">            arr[j++] = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }W</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> arrSize)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> * nums = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * arrSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) {</span><br><span class="line">        nums[i] = arr[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++, j++) {</span><br><span class="line">        arr[i] = nums[j];</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; arrSize &amp;&amp; nums[j] == <span class="number">0</span>) {</span><br><span class="line">            arr[++i] = <span class="number">0</span>; </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="1184-公交站间的距离"><a href="#1184-公交站间的距离" class="headerlink" title="1184.公交站间的距离"></a>1184.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distance-between-bus-stops/submissions/">公交站间的距离</a></h2><blockquote>
<p>思路: 保证 start 小于 destination， 计算一圈的总长度sum，计算start到destination的距离d，取d与sum-d两者较小值</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distanceBetweenBusStops</span><span class="params">(<span class="keyword">int</span>* distance, <span class="keyword">int</span> distanceSize, <span class="keyword">int</span> start, <span class="keyword">int</span> destination)</span></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (start &gt; destination) {</span><br><span class="line">        <span class="keyword">int</span> tmp = start;</span><br><span class="line">        start = destination;</span><br><span class="line">        destination = tmp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; distanceSize; i++) {</span><br><span class="line">        sum += distance[i];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= start &amp;&amp; i &lt; destination) {</span><br><span class="line">            min += distance[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    min = min &lt; (sum - min) ? min : sum - min;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1189-“气球”-的最大数量"><a href="#1189-“气球”-的最大数量" class="headerlink" title="1189. “气球” 的最大数量"></a>1189.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-balloons/"> “气球” 的最大数量</a></h2><blockquote>
<p>思路：统计字符次数，注意 字符串指针  取值 *p  或者 字符数组 test[i]</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxNumberOfBalloons</span><span class="params">(<span class="keyword">char</span> * text)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="keyword">int</span> table[<span class="number">5</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* p = text;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">'\0'</span>) {</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">'b'</span>) {</span><br><span class="line">            table[<span class="number">0</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">'a'</span>) {</span><br><span class="line">            table[<span class="number">1</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">'l'</span>) {</span><br><span class="line">            table[<span class="number">2</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">'o'</span>) {</span><br><span class="line">            table[<span class="number">3</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">'n'</span>) {</span><br><span class="line">            table[<span class="number">4</span>]++;</span><br><span class="line">        }</span><br><span class="line">        p++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    table[<span class="number">2</span>] /= <span class="number">2</span>;</span><br><span class="line">    table[<span class="number">3</span>] /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        min = min &lt; table[i] ? min : table[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* int maxNumberOfBalloons(char * text){</span></span><br><span class="line"><span class="comment">    int len = strlen(text);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int testNum[5] = {0};</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; len; i++) {</span></span><br><span class="line"><span class="comment">        if (text[i] == 'b') {</span></span><br><span class="line"><span class="comment">            testNum[0]++;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        if (text[i] == 'a') {</span></span><br><span class="line"><span class="comment">            testNum[1]++;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if (text[i] == 'l') {</span></span><br><span class="line"><span class="comment">            testNum[2]++;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if (text[i] == 'o') {</span></span><br><span class="line"><span class="comment">            testNum[3]++;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if (text[i] == 'n') {</span></span><br><span class="line"><span class="comment">            testNum[4]++;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    testNum[2] /= 2;</span></span><br><span class="line"><span class="comment">    testNum[3] /= 2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int res = INT_MAX;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; 5; i++) {</span></span><br><span class="line"><span class="comment">        res = res &lt; testNum[i] ? res : testNum[i];</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    return res;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">} */</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="1207-独一无二的出现次数"><a href="#1207-独一无二的出现次数" class="headerlink" title="1207.独一无二的出现次数"></a>1207.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-number-of-occurrences/">独一无二的出现次数</a></h2><p>解法一</p>
<blockquote>
<p>通过一个表统计每个数字出现的次数，定义另外一个表记录表一中每一项的，如果出现相同数字，则返回false，遍历到最后时返回true</p>
</blockquote>
<details>
<summary>uniqueOccurrences</summary>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> arrSize)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> table[<span class="number">2001</span>] = {<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) {</span><br><span class="line">        table[arr[i] + <span class="number">1000</span>]++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"table[arr[%d] + 1000] = %d\n"</span>, i, table[arr[i] + <span class="number">1000</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> table1[<span class="number">2001</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2001</span>; i++) {</span><br><span class="line">        table1[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (table[i] != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (table1[table[i]] != <span class="number">0</span>) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"table1[table[%d]] = %d\n"</span>, i, table1[table[i]]);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                table1[table[i]]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解法二：</p>
<blockquote>
<p>同解法一</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> arrSize)</span></span>{</span><br><span class="line">   <span class="keyword">int</span> hashTable[<span class="number">2001</span>]={<span class="number">0</span>};<span class="comment">//初始化一张表，下标对应元素值，存储对应元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrSize;i++) {</span><br><span class="line">        hashTable[arr[i]+<span class="number">1000</span>]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">bool</span> visited[<span class="number">1001</span>]={<span class="literal">false</span>};</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2001</span>;i++) {</span><br><span class="line">        <span class="keyword">if</span>(hashTable[i]) { <span class="comment">//如果i在数组中</span></span><br><span class="line">            <span class="keyword">if</span>(visited[hashTable[i]]) { <span class="comment">//如果之前出现过与i相同的重复次数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                visited[hashTable[i]]=<span class="literal">true</span>;<span class="comment">//说明与i相同的重复次数还未出现，设置为已访问过</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">} </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</details>








<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/" rel="tag"># 实用教程</a>
              <a href="/tags/Another-Tag/" rel="tag"># Another Tag</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/27/2022/%E8%AF%BB%E4%B9%A6%E9%9A%8F%E8%AE%B0/" rel="prev" title="读书随记">
      <i class="fa fa-chevron-left"></i> 读书随记
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/01/2022/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" rel="next" title="leetcode刷题笔记">
      leetcode刷题笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text"></span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="nav-text">112. 路径总和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-text">121.买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-text">125.验证回文串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">136.只出现一次的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-text">141.环形链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="nav-text">142.环形链表 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">153.寻找旋转排序数组中的最小值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-text">160.相交链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-text">169.多数元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">173.二叉搜索树迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-text">189.轮转数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D"><span class="nav-text">190.颠倒二进制位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">191.位1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#201-%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="nav-text">201.数字范围按位与</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-text">203.移除链表元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">206.反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-text">215.数组中的第K个最大元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-text">217.存在重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">226.翻转二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#231-2%E7%9A%84%E5%B9%82"><span class="nav-text">231.2的幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-text">234.回文链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-text">242.有效的字母异位词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">268.丢失的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-text">278.第一个错误的版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="nav-text">283.移动零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B4%E6%95%B0"><span class="nav-text">287.寻找重复整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">344.反转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-text">367.有效的完全平方数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6"><span class="nav-text">387.字符串中的第一个唯一字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#389-%E6%89%BE%E4%B8%8D%E5%90%8C"><span class="nav-text">389.找不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="nav-text">404.左叶子之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">442.数组中重复的数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB"><span class="nav-text">461.汉明距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0"><span class="nav-text">476.数字的补数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-text">509.斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#520-%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D"><span class="nav-text">520.检测大写字母</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#561-%E6%8B%86%E5%88%86%E6%95%B0%E7%BB%84I"><span class="nav-text">561.拆分数组I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">617.合并二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">647.回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="nav-text">674.最长连续递增序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="nav-text">700.二叉搜索树中的搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-text">701.二叉搜索树中的插入操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">704.二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#709-%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D"><span class="nav-text">709.转换成小写字母</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#771-%E5%AE%9D%E7%9F%B3%E5%92%8C%E7%9F%B3%E5%A4%B4"><span class="nav-text">771.宝石和石头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#852-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95"><span class="nav-text">852.山脉数组的峰顶索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9"><span class="nav-text">876.链表的中间结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#905-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-text">905.按奇偶排序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#917-%E4%BB%85%E4%BB%85%E5%8F%8D%E8%BD%AC%E5%AD%97%E6%AF%8D"><span class="nav-text">917.仅仅反转字母</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C"><span class="nav-text">938.二叉搜索树的范围和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#965-%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">965.单值二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="nav-text">977.有序数组的平方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1089-%E5%A4%8D%E5%86%99%E9%9B%B6"><span class="nav-text">1089.复写零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1184-%E5%85%AC%E4%BA%A4%E7%AB%99%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="nav-text">1184.公交站间的距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1189-%E2%80%9C%E6%B0%94%E7%90%83%E2%80%9D-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F"><span class="nav-text">1189. “气球” 的最大数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="nav-text">1207.独一无二的出现次数</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">204k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:06</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
